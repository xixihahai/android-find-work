# 并发工具类

## 1. 概述

Java 并发包（java.util.concurrent）提供了丰富的并发工具类，用于解决多线程编程中的同步、协调、原子操作等问题。

### 并发工具类分类

| 类别 | 工具类 | 用途 |
|------|--------|------|
| 同步器 | CountDownLatch、CyclicBarrier、Semaphore | 线程协调 |
| 原子类 | AtomicInteger、AtomicReference、LongAdder | 无锁并发 |
| 并发集合 | ConcurrentHashMap、CopyOnWriteArrayList | 线程安全集合 |
| 线程隔离 | ThreadLocal | 线程本地变量 |
| 锁 | ReentrantLock、ReadWriteLock、StampedLock | 显式锁 |

## 2. 核心原理

### 2.1 CountDownLatch

CountDownLatch 是一个同步辅助类，允许一个或多个线程等待其他线程完成操作。

```java
// 使用场景：主线程等待多个子线程完成
public class CountDownLatchExample {
    
    public void example() throws InterruptedException {
        int threadCount = 5;
        CountDownLatch latch = new CountDownLatch(threadCount);
        
        for (int i = 0; i < threadCount; i++) {
            final int index = i;
            new Thread(() -> {
                try {
                    // 模拟任务执行
                    Thread.sleep(1000);
                    System.out.println("Thread " + index + " completed");
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                } finally {
                    latch.countDown();  // 计数减一
                }
            }).start();
        }
        
        latch.await();  // 等待计数归零
        System.out.println("All threads completed");
    }
    
    // 带超时的等待
    public void exampleWithTimeout() throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(5);
        // ...
        boolean completed = latch.await(10, TimeUnit.SECONDS);
        if (!completed) {
            System.out.println("Timeout!");
        }
    }
}
```

#### CountDownLatch 源码分析

```java
public class CountDownLatch {
    private final Sync sync;
    
    // 基于 AQS 实现
    private static final class Sync extends AbstractQueuedSynchronizer {
        Sync(int count) {
            setState(count);
        }
        
        int getCount() {
            return getState();
        }
        
        // 尝试获取共享锁（state 为 0 时成功）
        protected int tryAcquireShared(int acquires) {
            return (getState() == 0) ? 1 : -1;
        }
        
        // 释放共享锁（state 减一）
        protected boolean tryReleaseShared(int releases) {
            for (;;) {
                int c = getState();
                if (c == 0)
                    return false;
                int nextc = c - 1;
                if (compareAndSetState(c, nextc))
                    return nextc == 0;
            }
        }
    }
    
    public void await() throws InterruptedException {
        sync.acquireSharedInterruptibly(1);
    }
    
    public void countDown() {
        sync.releaseShared(1);
    }
}
```

### 2.2 CyclicBarrier

CyclicBarrier 是一个同步辅助类，允许一组线程互相等待，直到所有线程都到达屏障点。

```java
public class CyclicBarrierExample {
    
    // 使用场景：多线程分段计算，每段完成后汇总
    public void example() {
        int threadCount = 3;
        CyclicBarrier barrier = new CyclicBarrier(threadCount, () -> {
            // 所有线程到达屏障后执行
            System.out.println("All threads reached barrier, merging results...");
        });
        
        for (int i = 0; i < threadCount; i++) {
            final int index = i;
            new Thread(() -> {
                try {
                    // 第一阶段
                    System.out.println("Thread " + index + " phase 1 completed");
                    barrier.await();
                    
                    // 第二阶段
                    System.out.println("Thread " + index + " phase 2 completed");
                    barrier.await();  // 可重复使用
                    
                } catch (InterruptedException | BrokenBarrierException e) {
                    Thread.currentThread().interrupt();
                }
            }).start();
        }
    }
}
```

#### CountDownLatch vs CyclicBarrier

| 特性 | CountDownLatch | CyclicBarrier |
|------|----------------|---------------|
| 重用性 | 一次性 | 可重复使用 |
| 等待方式 | 一个线程等待多个线程 | 多个线程互相等待 |
| 回调 | 无 | 支持屏障动作 |
| 计数方式 | 递减 | 递增到阈值 |

### 2.3 Semaphore

Semaphore 是一个计数信号量，用于控制同时访问特定资源的线程数量。

```java
public class SemaphoreExample {
    
    // 使用场景：限流、资源池
    public void example() {
        // 最多允许 3 个线程同时访问
        Semaphore semaphore = new Semaphore(3);
        
        for (int i = 0; i < 10; i++) {
            final int index = i;
            new Thread(() -> {
                try {
                    semaphore.acquire();  // 获取许可
                    System.out.println("Thread " + index + " acquired permit");
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                } finally {
                    semaphore.release();  // 释放许可
                    System.out.println("Thread " + index + " released permit");
                }
            }).start();
        }
    }
    
    // 公平模式
    public void fairExample() {
        Semaphore semaphore = new Semaphore(3, true);  // 公平模式
        // ...
    }
    
    // 尝试获取
    public void tryAcquireExample() {
        Semaphore semaphore = new Semaphore(3);
        
        if (semaphore.tryAcquire()) {
            try {
                // 获取成功
            } finally {
                semaphore.release();
            }
        } else {
            // 获取失败，执行降级逻辑
        }
    }
}
```

### 2.4 原子类与 CAS

#### AtomicInteger

```java
public class AtomicIntegerExample {
    private AtomicInteger counter = new AtomicInteger(0);
    
    public void increment() {
        counter.incrementAndGet();  // 原子递增
    }
    
    public void add(int delta) {
        counter.addAndGet(delta);  // 原子加法
    }
    
    public void compareAndSet() {
        // CAS 操作：期望值为 0，更新为 1
        boolean success = counter.compareAndSet(0, 1);
    }
    
    public void updateAndGet() {
        // 原子更新
        int result = counter.updateAndGet(x -> x * 2);
    }
    
    public void accumulateAndGet() {
        // 原子累加
        int result = counter.accumulateAndGet(10, Integer::sum);
    }
}
```

#### AtomicInteger 源码分析

```java
public class AtomicInteger extends Number implements java.io.Serializable {
    private static final Unsafe U = Unsafe.getUnsafe();
    private static final long VALUE = U.objectFieldOffset(AtomicInteger.class, "value");
    
    private volatile int value;
    
    public final int incrementAndGet() {
        return U.getAndAddInt(this, VALUE, 1) + 1;
    }
    
    public final boolean compareAndSet(int expectedValue, int newValue) {
        return U.compareAndSetInt(this, VALUE, expectedValue, newValue);
    }
}

// Unsafe.getAndAddInt
public final int getAndAddInt(Object o, long offset, int delta) {
    int v;
    do {
        v = getIntVolatile(o, offset);
    } while (!weakCompareAndSetInt(o, offset, v, v + delta));
    return v;
}
```

#### LongAdder（高并发计数器）

```java
public class LongAdderExample {
    // LongAdder 在高并发下性能优于 AtomicLong
    private LongAdder counter = new LongAdder();
    
    public void increment() {
        counter.increment();
    }
    
    public void add(long delta) {
        counter.add(delta);
    }
    
    public long sum() {
        return counter.sum();  // 获取当前值
    }
    
    public void reset() {
        counter.reset();  // 重置为 0
    }
}
```

#### AtomicLong vs LongAdder

| 特性 | AtomicLong | LongAdder |
|------|------------|-----------|
| 实现 | 单个 volatile 变量 | Cell 数组分散热点 |
| 高并发性能 | CAS 竞争激烈 | 分散竞争，性能更好 |
| 精确性 | 精确 | sum() 可能不精确 |
| 适用场景 | 低并发 | 高并发计数 |

### 2.5 并发集合

#### ConcurrentHashMap

```java
public class ConcurrentHashMapExample {
    private ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();
    
    // 基本操作
    public void basicOperations() {
        map.put("key", 1);
        Integer value = map.get("key");
        map.remove("key");
    }
    
    // 原子操作
    public void atomicOperations() {
        // putIfAbsent：不存在时才放入
        map.putIfAbsent("key", 1);
        
        // computeIfAbsent：不存在时计算并放入
        map.computeIfAbsent("key", k -> expensiveComputation(k));
        
        // computeIfPresent：存在时更新
        map.computeIfPresent("key", (k, v) -> v + 1);
        
        // compute：计算新值
        map.compute("key", (k, v) -> v == null ? 1 : v + 1);
        
        // merge：合并值
        map.merge("key", 1, Integer::sum);
    }
    
    // 批量操作
    public void bulkOperations() {
        // forEach
        map.forEach((k, v) -> System.out.println(k + ": " + v));
        
        // search
        String result = map.search(1, (k, v) -> v > 10 ? k : null);
        
        // reduce
        int sum = map.reduceValues(1, Integer::sum);
    }
    
    private Integer expensiveComputation(String key) {
        return key.length();
    }
}
```

#### ConcurrentHashMap 源码分析（JDK 8+）

```java
// JDK 8 使用 CAS + synchronized 替代分段锁
public class ConcurrentHashMap<K,V> {
    
    // 核心数据结构
    transient volatile Node<K,V>[] table;
    
    // put 操作
    final V putVal(K key, V value, boolean onlyIfAbsent) {
        if (key == null || value == null) throw new NullPointerException();
        int hash = spread(key.hashCode());
        int binCount = 0;
        for (Node<K,V>[] tab = table;;) {
            Node<K,V> f; int n, i, fh;
            if (tab == null || (n = tab.length) == 0)
                tab = initTable();  // 初始化
            else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {
                // CAS 插入头节点
                if (casTabAt(tab, i, null, new Node<K,V>(hash, key, value, null)))
                    break;
            }
            else if ((fh = f.hash) == MOVED)
                tab = helpTransfer(tab, f);  // 帮助扩容
            else {
                V oldVal = null;
                // synchronized 锁住头节点
                synchronized (f) {
                    if (tabAt(tab, i) == f) {
                        if (fh >= 0) {
                            // 链表
                            binCount = 1;
                            for (Node<K,V> e = f;; ++binCount) {
                                K ek;
                                if (e.hash == hash &&
                                    ((ek = e.key) == key ||
                                     (ek != null && key.equals(ek)))) {
                                    oldVal = e.val;
                                    if (!onlyIfAbsent)
                                        e.val = value;
                                    break;
                                }
                                Node<K,V> pred = e;
                                if ((e = e.next) == null) {
                                    pred.next = new Node<K,V>(hash, key, value, null);
                                    break;
                                }
                            }
                        }
                        else if (f instanceof TreeBin) {
                            // 红黑树
                            Node<K,V> p;
                            binCount = 2;
                            if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key, value)) != null) {
                                oldVal = p.val;
                                if (!onlyIfAbsent)
                                    p.val = value;
                            }
                        }
                    }
                }
                if (binCount != 0) {
                    if (binCount >= TREEIFY_THRESHOLD)
                        treeifyBin(tab, i);  // 链表转红黑树
                    if (oldVal != null)
                        return oldVal;
                    break;
                }
            }
        }
        addCount(1L, binCount);
        return null;
    }
}
```

#### CopyOnWriteArrayList

```java
public class CopyOnWriteArrayListExample {
    // 适用于读多写少的场景
    private CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();
    
    public void add(String item) {
        list.add(item);  // 写时复制
    }
    
    public String get(int index) {
        return list.get(index);  // 无锁读取
    }
    
    // 迭代时不会抛出 ConcurrentModificationException
    public void iterate() {
        for (String item : list) {
            System.out.println(item);
            // 迭代期间可以修改 list
        }
    }
}
```

#### CopyOnWriteArrayList 源码分析

```java
public class CopyOnWriteArrayList<E> {
    final transient Object lock = new Object();
    private transient volatile Object[] array;
    
    // 写操作：复制数组
    public boolean add(E e) {
        synchronized (lock) {
            Object[] es = getArray();
            int len = es.length;
            // 复制新数组
            es = Arrays.copyOf(es, len + 1);
            es[len] = e;
            setArray(es);
            return true;
        }
    }
    
    // 读操作：无锁
    public E get(int index) {
        return elementAt(getArray(), index);
    }
    
    // 迭代器：快照
    public Iterator<E> iterator() {
        return new COWIterator<E>(getArray(), 0);
    }
}
```

### 2.6 ThreadLocal

```java
public class ThreadLocalExample {
    
    // 基本使用
    private static ThreadLocal<String> threadLocal = new ThreadLocal<>();
    
    public void basicUsage() {
        threadLocal.set("value");
        String value = threadLocal.get();
        threadLocal.remove();  // 使用完必须移除，防止内存泄漏
    }
    
    // 带初始值
    private static ThreadLocal<SimpleDateFormat> dateFormat = 
        ThreadLocal.withInitial(() -> new SimpleDateFormat("yyyy-MM-dd"));
    
    // InheritableThreadLocal：子线程可继承
    private static InheritableThreadLocal<String> inheritableThreadLocal = 
        new InheritableThreadLocal<>();
    
    public void inheritableExample() {
        inheritableThreadLocal.set("parent value");
        
        new Thread(() -> {
            // 子线程可以获取父线程的值
            String value = inheritableThreadLocal.get();
            System.out.println(value);  // "parent value"
        }).start();
    }
}
```

#### ThreadLocal 源码分析

```java
public class ThreadLocal<T> {
    
    public T get() {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null) {
            ThreadLocalMap.Entry e = map.getEntry(this);
            if (e != null) {
                return (T)e.value;
            }
        }
        return setInitialValue();
    }
    
    public void set(T value) {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null)
            map.set(this, value);
        else
            createMap(t, value);
    }
    
    public void remove() {
        ThreadLocalMap m = getMap(Thread.currentThread());
        if (m != null)
            m.remove(this);
    }
    
    // ThreadLocalMap 是 Thread 的成员变量
    ThreadLocalMap getMap(Thread t) {
        return t.threadLocals;
    }
    
    // Entry 使用弱引用
    static class ThreadLocalMap {
        static class Entry extends WeakReference<ThreadLocal<?>> {
            Object value;
            Entry(ThreadLocal<?> k, Object v) {
                super(k);
                value = v;
            }
        }
    }
}
```

#### ThreadLocal 内存泄漏

```
┌─────────────────────────────────────────────────────────────┐
│                  ThreadLocal 内存泄漏原理                     │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   Thread ──────► ThreadLocalMap ──────► Entry               │
│                                           │                 │
│                                    ┌──────┴──────┐          │
│                                    │             │          │
│                              WeakReference    Value         │
│                                    │             │          │
│                                    ▼             ▼          │
│                              ThreadLocal      Object        │
│                                                             │
│   问题：ThreadLocal 被回收后，Entry 的 key 为 null，          │
│        但 value 仍然被 Entry 强引用，无法回收                  │
│                                                             │
│   解决：使用完后调用 remove()                                 │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 3. 关键源码解析

### 3.1 AQS（AbstractQueuedSynchronizer）

AQS 是 Java 并发包的基础框架，ReentrantLock、Semaphore、CountDownLatch 等都基于 AQS 实现。

```java
public abstract class AbstractQueuedSynchronizer {
    
    // 同步状态
    private volatile int state;
    
    // CLH 队列头尾节点
    private transient volatile Node head;
    private transient volatile Node tail;
    
    // 获取独占锁
    public final void acquire(int arg) {
        if (!tryAcquire(arg) &&
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
    
    // 释放独占锁
    public final boolean release(int arg) {
        if (tryRelease(arg)) {
            Node h = head;
            if (h != null && h.waitStatus != 0)
                unparkSuccessor(h);
            return true;
        }
        return false;
    }
    
    // 获取共享锁
    public final void acquireShared(int arg) {
        if (tryAcquireShared(arg) < 0)
            doAcquireShared(arg);
    }
    
    // 释放共享锁
    public final boolean releaseShared(int arg) {
        if (tryReleaseShared(arg)) {
            doReleaseShared();
            return true;
        }
        return false;
    }
    
    // 子类需要实现的方法
    protected boolean tryAcquire(int arg) { throw new UnsupportedOperationException(); }
    protected boolean tryRelease(int arg) { throw new UnsupportedOperationException(); }
    protected int tryAcquireShared(int arg) { throw new UnsupportedOperationException(); }
    protected boolean tryReleaseShared(int arg) { throw new UnsupportedOperationException(); }
}
```

### 3.2 ReentrantLock 源码

```java
public class ReentrantLock implements Lock {
    private final Sync sync;
    
    // 非公平锁（默认）
    public ReentrantLock() {
        sync = new NonfairSync();
    }
    
    // 公平锁
    public ReentrantLock(boolean fair) {
        sync = fair ? new FairSync() : new NonfairSync();
    }
    
    // 非公平锁实现
    static final class NonfairSync extends Sync {
        final boolean initialTryLock() {
            Thread current = Thread.currentThread();
            // 直接尝试 CAS 获取锁
            if (compareAndSetState(0, 1)) {
                setExclusiveOwnerThread(current);
                return true;
            } else if (getExclusiveOwnerThread() == current) {
                // 重入
                int c = getState() + 1;
                if (c < 0)
                    throw new Error("Maximum lock count exceeded");
                setState(c);
                return true;
            } else
                return false;
        }
    }
    
    // 公平锁实现
    static final class FairSync extends Sync {
        final boolean initialTryLock() {
            Thread current = Thread.currentThread();
            int c = getState();
            if (c == 0) {
                // 检查队列中是否有等待的线程
                if (!hasQueuedThreads() && compareAndSetState(0, 1)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            } else if (getExclusiveOwnerThread() == current) {
                // 重入
                if (++c < 0)
                    throw new Error("Maximum lock count exceeded");
                setState(c);
                return true;
            }
            return false;
        }
    }
}
```

## 4. 实战应用

### 4.1 Android 中的并发工具使用

```kotlin
// 1. 使用 CountDownLatch 等待多个初始化完成
class AppInitializer {
    private val initLatch = CountDownLatch(3)
    
    fun initialize() {
        // 并行初始化
        thread { initDatabase(); initLatch.countDown() }
        thread { initNetwork(); initLatch.countDown() }
        thread { initAnalytics(); initLatch.countDown() }
        
        // 等待所有初始化完成
        initLatch.await(10, TimeUnit.SECONDS)
    }
}

// 2. 使用 Semaphore 限制并发请求数
class NetworkManager {
    private val semaphore = Semaphore(5)  // 最多 5 个并发请求
    
    suspend fun request(url: String): Response {
        semaphore.acquire()
        try {
            return httpClient.get(url)
        } finally {
            semaphore.release()
        }
    }
}

// 3. 使用 ConcurrentHashMap 缓存
class ImageCache {
    private val cache = ConcurrentHashMap<String, Bitmap>()
    
    fun get(key: String): Bitmap? = cache[key]
    
    fun put(key: String, bitmap: Bitmap) {
        cache[key] = bitmap
    }
    
    fun getOrLoad(key: String, loader: () -> Bitmap): Bitmap {
        return cache.computeIfAbsent(key) { loader() }
    }
}

// 4. 使用 ThreadLocal 存储请求上下文
object RequestContext {
    private val context = ThreadLocal<RequestInfo>()
    
    fun set(info: RequestInfo) {
        context.set(info)
    }
    
    fun get(): RequestInfo? = context.get()
    
    fun clear() {
        context.remove()
    }
}

// 5. 使用 AtomicInteger 统计
class RequestCounter {
    private val counter = AtomicInteger(0)
    private val successCounter = AtomicInteger(0)
    private val failureCounter = AtomicInteger(0)
    
    fun onRequest() {
        counter.incrementAndGet()
    }
    
    fun onSuccess() {
        successCounter.incrementAndGet()
    }
    
    fun onFailure() {
        failureCounter.incrementAndGet()
    }
    
    fun getStats(): Stats {
        return Stats(
            total = counter.get(),
            success = successCounter.get(),
            failure = failureCounter.get()
        )
    }
}
```

### 4.2 高并发场景最佳实践

```kotlin
// 1. 限流器
class RateLimiter(
    private val permitsPerSecond: Double
) {
    private val semaphore = Semaphore(1)
    private var lastAcquireTime = System.nanoTime()
    private val intervalNanos = (1_000_000_000 / permitsPerSecond).toLong()
    
    fun acquire() {
        semaphore.acquire()
        try {
            val now = System.nanoTime()
            val waitTime = intervalNanos - (now - lastAcquireTime)
            if (waitTime > 0) {
                Thread.sleep(waitTime / 1_000_000, (waitTime % 1_000_000).toInt())
            }
            lastAcquireTime = System.nanoTime()
        } finally {
            semaphore.release()
        }
    }
}

// 2. 双重检查锁定单例
class Singleton private constructor() {
    companion object {
        @Volatile
        private var instance: Singleton? = null
        
        fun getInstance(): Singleton {
            return instance ?: synchronized(this) {
                instance ?: Singleton().also { instance = it }
            }
        }
    }
}

// 3. 读写锁缓存
class ReadWriteCache<K, V> {
    private val cache = HashMap<K, V>()
    private val lock = ReentrantReadWriteLock()
    
    fun get(key: K): V? {
        lock.readLock().lock()
        try {
            return cache[key]
        } finally {
            lock.readLock().unlock()
        }
    }
    
    fun put(key: K, value: V) {
        lock.writeLock().lock()
        try {
            cache[key] = value
        } finally {
            lock.writeLock().unlock()
        }
    }
}
```

## 5. 常见面试题

### 问题1：CountDownLatch 和 CyclicBarrier 的区别是什么？

**答案要点**：
- **CountDownLatch**：一次性，一个线程等待多个线程完成
- **CyclicBarrier**：可重复使用，多个线程互相等待
- **回调**：CyclicBarrier 支持屏障动作，CountDownLatch 不支持
- **计数**：CountDownLatch 递减，CyclicBarrier 递增到阈值

### 问题2：ConcurrentHashMap 的实现原理是什么？JDK 7 和 JDK 8 有什么区别？

**答案要点**：
- **JDK 7**：分段锁（Segment），每个 Segment 是一个 ReentrantLock
- **JDK 8**：CAS + synchronized，锁粒度更细（锁住单个桶）
- **数据结构**：JDK 8 引入红黑树，链表长度超过 8 转为红黑树
- **并发度**：JDK 8 并发度更高，性能更好

### 问题3：ThreadLocal 的原理是什么？如何避免内存泄漏？

**答案要点**：
- **原理**：每个 Thread 有一个 ThreadLocalMap，key 是 ThreadLocal，value 是值
- **内存泄漏**：Entry 的 key 是弱引用，value 是强引用，ThreadLocal 被回收后 value 无法回收
- **解决**：使用完后调用 remove()，或使用 try-finally 确保清理

### 问题4：AQS 的原理是什么？

**答案要点**：
- **核心**：volatile int state + CLH 队列
- **独占模式**：tryAcquire/tryRelease，如 ReentrantLock
- **共享模式**：tryAcquireShared/tryReleaseShared，如 Semaphore、CountDownLatch
- **CLH 队列**：双向链表，FIFO 等待队列

### 问题5：CAS 的原理是什么？有什么问题？

**答案要点**：
- **原理**：Compare And Swap，比较并交换，CPU 原子指令
- **问题**：
  1. ABA 问题：使用 AtomicStampedReference 解决
  2. 自旋开销：竞争激烈时 CPU 消耗大
  3. 只能保证单个变量原子性

### 问题6：Semaphore 的使用场景有哪些？

**答案要点**：
- **限流**：限制并发请求数
- **资源池**：数据库连接池、线程池
- **生产者消费者**：控制缓冲区大小
- **公平/非公平**：支持公平模式

### 问题7：CopyOnWriteArrayList 的原理是什么？适用什么场景？

**答案要点**：
- **原理**：写时复制，写操作复制新数组，读操作无锁
- **适用场景**：读多写少，如监听器列表、配置列表
- **缺点**：写操作开销大，内存占用高，数据一致性弱

### 问题8：ReentrantLock 和 synchronized 的区别是什么？

**答案要点**：
| 特性 | synchronized | ReentrantLock |
|------|--------------|---------------|
| 实现 | JVM 内置 | Java 代码 |
| 公平性 | 非公平 | 可选公平/非公平 |
| 可中断 | 不可中断 | 可中断 |
| 超时 | 不支持 | 支持 tryLock |
| 条件变量 | 单个 | 多个 Condition |
| 释放 | 自动 | 手动 unlock |

### 问题9：LongAdder 和 AtomicLong 的区别是什么？

**答案要点**：
- **AtomicLong**：单个 volatile 变量，高并发下 CAS 竞争激烈
- **LongAdder**：Cell 数组分散热点，高并发下性能更好
- **精确性**：AtomicLong 精确，LongAdder 的 sum() 可能不精确
- **适用场景**：高并发计数用 LongAdder，需要精确值用 AtomicLong

### 问题10：如何实现一个线程安全的单例？

**答案要点**：
```kotlin
// 1. 双重检查锁定
class Singleton private constructor() {
    companion object {
        @Volatile
        private var instance: Singleton? = null
        
        fun getInstance(): Singleton {
            return instance ?: synchronized(this) {
                instance ?: Singleton().also { instance = it }
            }
        }
    }
}

// 2. 静态内部类
class Singleton private constructor() {
    companion object {
        fun getInstance() = Holder.INSTANCE
    }
    private object Holder {
        val INSTANCE = Singleton()
    }
}

// 3. Kotlin object（推荐）
object Singleton {
    fun doSomething() {}
}
```
