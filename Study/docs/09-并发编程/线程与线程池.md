# 线程与线程池

## 1. 概述

线程是程序执行的最小单位，线程池是管理和复用线程的机制，是 Android 并发编程的基础。

### 为什么需要线程池

| 问题 | 直接创建线程 | 使用线程池 |
|------|-------------|-----------|
| 资源消耗 | 每次创建销毁开销大 | 复用线程，减少开销 |
| 响应速度 | 需要等待线程创建 | 直接使用已有线程 |
| 可管理性 | 无法统一管理 | 统一管理、监控 |
| 线程数量 | 可能无限创建 | 可控制最大数量 |

## 2. 核心原理

### 2.1 线程基础

#### 线程状态

```
┌─────────────────────────────────────────────────────────────┐
│                      线程状态转换图                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   ┌─────────┐   start()   ┌───────────┐                    │
│   │   NEW   │ ──────────► │  RUNNABLE │◄─────────┐         │
│   └─────────┘             └─────┬─────┘          │         │
│                                 │                │         │
│                    ┌────────────┼────────────┐   │         │
│                    │            │            │   │         │
│                    ▼            ▼            ▼   │         │
│              ┌─────────┐  ┌─────────┐  ┌─────────┐         │
│              │ BLOCKED │  │ WAITING │  │ TIMED   │         │
│              │         │  │         │  │ WAITING │         │
│              └────┬────┘  └────┬────┘  └────┬────┘         │
│                   │            │            │              │
│                   └────────────┴────────────┘              │
│                                │                           │
│                                ▼                           │
│                          ┌───────────┐                     │
│                          │TERMINATED │                     │
│                          └───────────┘                     │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

#### 线程创建方式

```kotlin
// 方式1：继承 Thread
class MyThread : Thread() {
    override fun run() {
        println("Thread running: ${currentThread().name}")
    }
}

// 方式2：实现 Runnable
class MyRunnable : Runnable {
    override fun run() {
        println("Runnable running: ${Thread.currentThread().name}")
    }
}

// 方式3：实现 Callable（有返回值）
class MyCallable : Callable<String> {
    override fun call(): String {
        Thread.sleep(1000)
        return "Callable result"
    }
}

// 使用示例
fun main() {
    // Thread
    MyThread().start()
    
    // Runnable
    Thread(MyRunnable()).start()
    
    // Callable + FutureTask
    val futureTask = FutureTask(MyCallable())
    Thread(futureTask).start()
    val result = futureTask.get()  // 阻塞等待结果
}
```

### 2.2 ThreadPoolExecutor 原理

#### 核心参数

```java
public ThreadPoolExecutor(
    int corePoolSize,           // 核心线程数
    int maximumPoolSize,        // 最大线程数
    long keepAliveTime,         // 非核心线程空闲存活时间
    TimeUnit unit,              // 时间单位
    BlockingQueue<Runnable> workQueue,  // 任务队列
    ThreadFactory threadFactory,        // 线程工厂
    RejectedExecutionHandler handler    // 拒绝策略
)
```

| 参数 | 说明 | 建议值 |
|------|------|--------|
| corePoolSize | 核心线程数，即使空闲也不会销毁 | CPU 密集型：N+1，IO 密集型：2N |
| maximumPoolSize | 最大线程数 | 根据业务场景设置 |
| keepAliveTime | 非核心线程空闲存活时间 | 60s |
| workQueue | 任务队列 | LinkedBlockingQueue / ArrayBlockingQueue |
| threadFactory | 线程工厂，用于创建线程 | 自定义命名 |
| handler | 拒绝策略 | CallerRunsPolicy |

#### 工作流程

```
┌─────────────────────────────────────────────────────────────┐
│                   ThreadPoolExecutor 工作流程                 │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   提交任务                                                   │
│      │                                                      │
│      ▼                                                      │
│   ┌─────────────────────────────────────┐                  │
│   │ 当前线程数 < corePoolSize ?          │                  │
│   └──────────────┬──────────────────────┘                  │
│                  │                                          │
│         是       │        否                                │
│         ▼        │        ▼                                │
│   ┌──────────┐   │   ┌─────────────────────────────┐       │
│   │创建核心   │   │   │ 任务队列未满 ?               │       │
│   │线程执行   │   │   └──────────────┬──────────────┘       │
│   └──────────┘   │                  │                      │
│                  │         是       │        否            │
│                  │         ▼        │        ▼            │
│                  │   ┌──────────┐   │   ┌─────────────────┐│
│                  │   │加入队列   │   │   │线程数<最大线程数?││
│                  │   └──────────┘   │   └────────┬────────┘│
│                  │                  │            │         │
│                  │                  │   是       │   否    │
│                  │                  │   ▼        │   ▼    │
│                  │                  │ ┌────────┐ │┌──────┐ │
│                  │                  │ │创建非核│ ││拒绝  │ │
│                  │                  │ │心线程  │ ││策略  │ │
│                  │                  │ └────────┘ │└──────┘ │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 2.3 常用线程池类型

```kotlin
// 1. FixedThreadPool - 固定线程数
val fixedPool = Executors.newFixedThreadPool(4)
// 特点：核心线程数 = 最大线程数，无界队列
// 适用：负载较重的服务器

// 2. CachedThreadPool - 可缓存线程池
val cachedPool = Executors.newCachedThreadPool()
// 特点：核心线程数为0，最大线程数为 Integer.MAX_VALUE，60s 空闲回收
// 适用：大量短期异步任务

// 3. SingleThreadExecutor - 单线程池
val singlePool = Executors.newSingleThreadExecutor()
// 特点：只有一个核心线程，保证任务顺序执行
// 适用：需要保证顺序执行的场景

// 4. ScheduledThreadPool - 定时任务线程池
val scheduledPool = Executors.newScheduledThreadPool(4)
// 特点：支持定时和周期性任务
// 适用：定时任务、周期性任务

// 5. WorkStealingPool (Java 8+) - 工作窃取线程池
val workStealingPool = Executors.newWorkStealingPool()
// 特点：基于 ForkJoinPool，支持工作窃取
// 适用：大量可分解的任务
```

#### 各线程池对比

| 线程池 | 核心线程数 | 最大线程数 | 队列类型 | 适用场景 |
|--------|-----------|-----------|----------|----------|
| FixedThreadPool | n | n | LinkedBlockingQueue | 负载较重 |
| CachedThreadPool | 0 | MAX_VALUE | SynchronousQueue | 短期异步任务 |
| SingleThreadExecutor | 1 | 1 | LinkedBlockingQueue | 顺序执行 |
| ScheduledThreadPool | n | MAX_VALUE | DelayedWorkQueue | 定时任务 |

### 2.4 任务队列类型

```kotlin
// 1. LinkedBlockingQueue - 无界队列
// 特点：容量为 Integer.MAX_VALUE，可能导致 OOM
val linkedQueue = LinkedBlockingQueue<Runnable>()

// 2. ArrayBlockingQueue - 有界队列
// 特点：固定容量，需要设置合理大小
val arrayQueue = ArrayBlockingQueue<Runnable>(100)

// 3. SynchronousQueue - 同步队列
// 特点：不存储元素，直接传递给线程
val syncQueue = SynchronousQueue<Runnable>()

// 4. PriorityBlockingQueue - 优先级队列
// 特点：按优先级排序
val priorityQueue = PriorityBlockingQueue<Runnable>()

// 5. DelayedWorkQueue - 延迟队列
// 特点：用于 ScheduledThreadPool
```

### 2.5 拒绝策略

```kotlin
// 1. AbortPolicy - 抛出异常（默认）
val abortPolicy = ThreadPoolExecutor.AbortPolicy()

// 2. CallerRunsPolicy - 调用者线程执行
val callerRunsPolicy = ThreadPoolExecutor.CallerRunsPolicy()

// 3. DiscardPolicy - 静默丢弃
val discardPolicy = ThreadPoolExecutor.DiscardPolicy()

// 4. DiscardOldestPolicy - 丢弃最老任务
val discardOldestPolicy = ThreadPoolExecutor.DiscardOldestPolicy()

// 5. 自定义拒绝策略
class CustomRejectedHandler : RejectedExecutionHandler {
    override fun rejectedExecution(r: Runnable, executor: ThreadPoolExecutor) {
        // 记录日志
        Log.w("ThreadPool", "Task rejected: $r")
        // 可以选择：
        // 1. 存入数据库，稍后重试
        // 2. 发送到消息队列
        // 3. 降级处理
    }
}
```

## 3. 关键源码解析

### 3.1 ThreadPoolExecutor.execute()

```java
// ThreadPoolExecutor.java
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    
    int c = ctl.get();
    
    // 1. 当前线程数 < 核心线程数，创建核心线程
    if (workerCountOf(c) < corePoolSize) {
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
    
    // 2. 核心线程已满，尝试加入队列
    if (isRunning(c) && workQueue.offer(command)) {
        int recheck = ctl.get();
        // 再次检查状态
        if (!isRunning(recheck) && remove(command))
            reject(command);
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    // 3. 队列已满，尝试创建非核心线程
    else if (!addWorker(command, false))
        // 4. 创建失败，执行拒绝策略
        reject(command);
}
```

### 3.2 addWorker() - 创建工作线程

```java
private boolean addWorker(Runnable firstTask, boolean core) {
    retry:
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);
        
        // 检查线程池状态
        if (rs >= SHUTDOWN &&
            !(rs == SHUTDOWN && firstTask == null && !workQueue.isEmpty()))
            return false;
        
        for (;;) {
            int wc = workerCountOf(c);
            // 检查线程数量限制
            if (wc >= CAPACITY ||
                wc >= (core ? corePoolSize : maximumPoolSize))
                return false;
            // CAS 增加线程数
            if (compareAndIncrementWorkerCount(c))
                break retry;
            c = ctl.get();
            if (runStateOf(c) != rs)
                continue retry;
        }
    }
    
    boolean workerStarted = false;
    boolean workerAdded = false;
    Worker w = null;
    try {
        // 创建 Worker
        w = new Worker(firstTask);
        final Thread t = w.thread;
        if (t != null) {
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                int rs = runStateOf(ctl.get());
                if (rs < SHUTDOWN ||
                    (rs == SHUTDOWN && firstTask == null)) {
                    if (t.isAlive())
                        throw new IllegalThreadStateException();
                    // 添加到 workers 集合
                    workers.add(w);
                    int s = workers.size();
                    if (s > largestPoolSize)
                        largestPoolSize = s;
                    workerAdded = true;
                }
            } finally {
                mainLock.unlock();
            }
            if (workerAdded) {
                // 启动线程
                t.start();
                workerStarted = true;
            }
        }
    } finally {
        if (!workerStarted)
            addWorkerFailed(w);
    }
    return workerStarted;
}
```

### 3.3 Worker 类 - 工作线程

```java
private final class Worker extends AbstractQueuedSynchronizer implements Runnable {
    final Thread thread;
    Runnable firstTask;
    volatile long completedTasks;
    
    Worker(Runnable firstTask) {
        setState(-1);  // 禁止中断直到 runWorker
        this.firstTask = firstTask;
        // 使用线程工厂创建线程
        this.thread = getThreadFactory().newThread(this);
    }
    
    public void run() {
        runWorker(this);
    }
}

final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    Runnable task = w.firstTask;
    w.firstTask = null;
    w.unlock();  // 允许中断
    boolean completedAbruptly = true;
    try {
        // 循环获取任务执行
        while (task != null || (task = getTask()) != null) {
            w.lock();
            // 检查中断状态
            if ((runStateAtLeast(ctl.get(), STOP) ||
                 (Thread.interrupted() && runStateAtLeast(ctl.get(), STOP))) &&
                !wt.isInterrupted())
                wt.interrupt();
            try {
                // 执行前回调
                beforeExecute(wt, task);
                Throwable thrown = null;
                try {
                    // 执行任务
                    task.run();
                } catch (RuntimeException x) {
                    thrown = x; throw x;
                } catch (Error x) {
                    thrown = x; throw x;
                } catch (Throwable x) {
                    thrown = x; throw new Error(x);
                } finally {
                    // 执行后回调
                    afterExecute(task, thrown);
                }
            } finally {
                task = null;
                w.completedTasks++;
                w.unlock();
            }
        }
        completedAbruptly = false;
    } finally {
        // 线程退出处理
        processWorkerExit(w, completedAbruptly);
    }
}
```

### 3.4 getTask() - 获取任务

```java
private Runnable getTask() {
    boolean timedOut = false;
    
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);
        
        // 检查线程池状态
        if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
            decrementWorkerCount();
            return null;
        }
        
        int wc = workerCountOf(c);
        
        // 是否需要超时控制
        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;
        
        // 检查是否需要减少线程
        if ((wc > maximumPoolSize || (timed && timedOut))
            && (wc > 1 || workQueue.isEmpty())) {
            if (compareAndDecrementWorkerCount(c))
                return null;
            continue;
        }
        
        try {
            // 从队列获取任务
            Runnable r = timed ?
                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                workQueue.take();
            if (r != null)
                return r;
            timedOut = true;
        } catch (InterruptedException retry) {
            timedOut = false;
        }
    }
}
```

## 4. 实战应用

### 4.1 Android 最佳实践线程池配置

```kotlin
object AppExecutors {
    
    // CPU 密集型任务线程池
    val cpuExecutor: ExecutorService by lazy {
        val cpuCount = Runtime.getRuntime().availableProcessors()
        ThreadPoolExecutor(
            cpuCount + 1,
            cpuCount + 1,
            0L,
            TimeUnit.MILLISECONDS,
            LinkedBlockingQueue(128),
            NamedThreadFactory("cpu"),
            ThreadPoolExecutor.CallerRunsPolicy()
        )
    }
    
    // IO 密集型任务线程池
    val ioExecutor: ExecutorService by lazy {
        val cpuCount = Runtime.getRuntime().availableProcessors()
        ThreadPoolExecutor(
            cpuCount * 2,
            cpuCount * 2,
            30L,
            TimeUnit.SECONDS,
            LinkedBlockingQueue(256),
            NamedThreadFactory("io"),
            ThreadPoolExecutor.CallerRunsPolicy()
        )
    }
    
    // 单线程池（顺序执行）
    val singleExecutor: ExecutorService by lazy {
        Executors.newSingleThreadExecutor(NamedThreadFactory("single"))
    }
    
    // 定时任务线程池
    val scheduledExecutor: ScheduledExecutorService by lazy {
        Executors.newScheduledThreadPool(2, NamedThreadFactory("scheduled"))
    }
    
    // 自定义线程工厂
    private class NamedThreadFactory(private val prefix: String) : ThreadFactory {
        private val counter = AtomicInteger(0)
        
        override fun newThread(r: Runnable): Thread {
            return Thread(r, "$prefix-${counter.incrementAndGet()}").apply {
                // 设置为守护线程
                isDaemon = true
                // 设置优先级
                priority = Thread.NORM_PRIORITY
            }
        }
    }
}
```

### 4.2 线程池监控

```kotlin
class ThreadPoolMonitor(
    private val executor: ThreadPoolExecutor,
    private val name: String
) {
    
    fun getStats(): ThreadPoolStats {
        return ThreadPoolStats(
            name = name,
            poolSize = executor.poolSize,
            activeCount = executor.activeCount,
            corePoolSize = executor.corePoolSize,
            maximumPoolSize = executor.maximumPoolSize,
            queueSize = executor.queue.size,
            completedTaskCount = executor.completedTaskCount,
            taskCount = executor.taskCount,
            largestPoolSize = executor.largestPoolSize
        )
    }
    
    fun logStats() {
        val stats = getStats()
        Log.d("ThreadPool", """
            [$name] Stats:
            - Pool Size: ${stats.poolSize}/${stats.maximumPoolSize}
            - Active: ${stats.activeCount}
            - Queue: ${stats.queueSize}
            - Completed: ${stats.completedTaskCount}/${stats.taskCount}
        """.trimIndent())
    }
    
    data class ThreadPoolStats(
        val name: String,
        val poolSize: Int,
        val activeCount: Int,
        val corePoolSize: Int,
        val maximumPoolSize: Int,
        val queueSize: Int,
        val completedTaskCount: Long,
        val taskCount: Long,
        val largestPoolSize: Int
    )
}

// 带监控的线程池
class MonitoredThreadPoolExecutor(
    corePoolSize: Int,
    maximumPoolSize: Int,
    keepAliveTime: Long,
    unit: TimeUnit,
    workQueue: BlockingQueue<Runnable>,
    threadFactory: ThreadFactory,
    handler: RejectedExecutionHandler
) : ThreadPoolExecutor(
    corePoolSize, maximumPoolSize, keepAliveTime, unit,
    workQueue, threadFactory, handler
) {
    
    private val taskStartTime = ConcurrentHashMap<Runnable, Long>()
    
    override fun beforeExecute(t: Thread, r: Runnable) {
        super.beforeExecute(t, r)
        taskStartTime[r] = System.currentTimeMillis()
    }
    
    override fun afterExecute(r: Runnable, t: Throwable?) {
        super.afterExecute(r, t)
        val startTime = taskStartTime.remove(r) ?: return
        val duration = System.currentTimeMillis() - startTime
        
        // 记录慢任务
        if (duration > 1000) {
            Log.w("ThreadPool", "Slow task detected: ${duration}ms")
        }
        
        // 记录异常
        t?.let {
            Log.e("ThreadPool", "Task exception", it)
        }
    }
    
    override fun terminated() {
        super.terminated()
        Log.d("ThreadPool", "ThreadPool terminated")
    }
}
```

### 4.3 AsyncTask 原理（已废弃）

```java
// AsyncTask.java (API 30 已废弃)
public abstract class AsyncTask<Params, Progress, Result> {
    
    // 串行执行器
    public static final Executor SERIAL_EXECUTOR = new SerialExecutor();
    
    // 线程池执行器
    public static final Executor THREAD_POOL_EXECUTOR;
    
    static {
        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(
                CORE_POOL_SIZE,      // CPU 核心数 + 1
                MAXIMUM_POOL_SIZE,   // CPU 核心数 * 2 + 1
                KEEP_ALIVE_SECONDS,  // 30 秒
                TimeUnit.SECONDS,
                sPoolWorkQueue,      // LinkedBlockingQueue(128)
                sThreadFactory);
        threadPoolExecutor.allowCoreThreadTimeOut(true);
        THREAD_POOL_EXECUTOR = threadPoolExecutor;
    }
    
    // 串行执行器实现
    private static class SerialExecutor implements Executor {
        final ArrayDeque<Runnable> mTasks = new ArrayDeque<Runnable>();
        Runnable mActive;
        
        public synchronized void execute(final Runnable r) {
            mTasks.offer(new Runnable() {
                public void run() {
                    try {
                        r.run();
                    } finally {
                        scheduleNext();
                    }
                }
            });
            if (mActive == null) {
                scheduleNext();
            }
        }
        
        protected synchronized void scheduleNext() {
            if ((mActive = mTasks.poll()) != null) {
                THREAD_POOL_EXECUTOR.execute(mActive);
            }
        }
    }
    
    // 主线程 Handler
    private static Handler getMainHandler() {
        synchronized (AsyncTask.class) {
            if (sHandler == null) {
                sHandler = new InternalHandler(Looper.getMainLooper());
            }
            return sHandler;
        }
    }
    
    // 执行流程
    public final AsyncTask<Params, Progress, Result> execute(Params... params) {
        return executeOnExecutor(sDefaultExecutor, params);
    }
    
    public final AsyncTask<Params, Progress, Result> executeOnExecutor(
            Executor exec, Params... params) {
        // 状态检查
        if (mStatus != Status.PENDING) {
            switch (mStatus) {
                case RUNNING:
                    throw new IllegalStateException("Cannot execute task: already running.");
                case FINISHED:
                    throw new IllegalStateException("Cannot execute task: already executed.");
            }
        }
        
        mStatus = Status.RUNNING;
        
        // 在主线程执行 onPreExecute
        onPreExecute();
        
        mWorker.mParams = params;
        exec.execute(mFuture);
        
        return this;
    }
}
```

### 4.4 协程替代线程池

```kotlin
// 使用协程替代传统线程池
class CoroutineExecutor {
    
    // IO 调度器（类似 IO 线程池）
    private val ioScope = CoroutineScope(Dispatchers.IO + SupervisorJob())
    
    // CPU 调度器（类似 CPU 线程池）
    private val cpuScope = CoroutineScope(Dispatchers.Default + SupervisorJob())
    
    // 自定义调度器
    private val customDispatcher = Executors.newFixedThreadPool(4).asCoroutineDispatcher()
    private val customScope = CoroutineScope(customDispatcher + SupervisorJob())
    
    // 执行 IO 任务
    fun executeIO(block: suspend () -> Unit): Job {
        return ioScope.launch {
            try {
                block()
            } catch (e: Exception) {
                Log.e("CoroutineExecutor", "IO task error", e)
            }
        }
    }
    
    // 执行 CPU 任务
    fun executeCPU(block: suspend () -> Unit): Job {
        return cpuScope.launch {
            try {
                block()
            } catch (e: Exception) {
                Log.e("CoroutineExecutor", "CPU task error", e)
            }
        }
    }
    
    // 执行带返回值的任务
    suspend fun <T> executeAsync(block: suspend () -> T): T {
        return withContext(Dispatchers.IO) {
            block()
        }
    }
    
    // 并行执行多个任务
    suspend fun <T> executeParallel(tasks: List<suspend () -> T>): List<T> {
        return coroutineScope {
            tasks.map { task ->
                async(Dispatchers.IO) { task() }
            }.awaitAll()
        }
    }
    
    // 关闭
    fun shutdown() {
        ioScope.cancel()
        cpuScope.cancel()
        customScope.cancel()
        customDispatcher.close()
    }
}
```

## 5. 常见面试题

### 问题1：线程池的核心参数有哪些？各自的作用是什么？

**答案要点**：
- **corePoolSize**：核心线程数，即使空闲也不会销毁（除非设置 allowCoreThreadTimeOut）
- **maximumPoolSize**：最大线程数，包括核心线程和非核心线程
- **keepAliveTime**：非核心线程空闲存活时间
- **workQueue**：任务队列，存放等待执行的任务
- **threadFactory**：线程工厂，用于创建线程
- **handler**：拒绝策略，队列满且线程数达到最大时的处理策略

### 问题2：线程池的工作流程是怎样的？

**答案要点**：
1. 提交任务时，如果当前线程数 < corePoolSize，创建核心线程执行
2. 如果核心线程已满，尝试将任务加入队列
3. 如果队列已满，且线程数 < maximumPoolSize，创建非核心线程执行
4. 如果线程数已达到 maximumPoolSize，执行拒绝策略

### 问题3：常用的线程池有哪些？各自的特点和适用场景？

**答案要点**：
- **FixedThreadPool**：固定线程数，适合负载较重的服务器
- **CachedThreadPool**：可缓存，适合大量短期异步任务
- **SingleThreadExecutor**：单线程，适合需要顺序执行的场景
- **ScheduledThreadPool**：支持定时任务，适合周期性任务
- **注意**：Executors 创建的线程池可能导致 OOM，建议手动创建

### 问题4：为什么不建议使用 Executors 创建线程池？

**答案要点**：
- **FixedThreadPool/SingleThreadExecutor**：使用无界队列 LinkedBlockingQueue，可能导致 OOM
- **CachedThreadPool**：最大线程数为 Integer.MAX_VALUE，可能创建大量线程导致 OOM
- **ScheduledThreadPool**：最大线程数为 Integer.MAX_VALUE
- **建议**：手动创建 ThreadPoolExecutor，设置合理的参数

### 问题5：线程池的拒绝策略有哪些？

**答案要点**：
- **AbortPolicy**：抛出 RejectedExecutionException（默认）
- **CallerRunsPolicy**：调用者线程执行任务
- **DiscardPolicy**：静默丢弃任务
- **DiscardOldestPolicy**：丢弃队列中最老的任务
- **自定义策略**：实现 RejectedExecutionHandler 接口

### 问题6：如何合理配置线程池参数？

**答案要点**：
- **CPU 密集型**：corePoolSize = CPU 核心数 + 1
- **IO 密集型**：corePoolSize = CPU 核心数 * 2
- **混合型**：根据 IO 等待时间和 CPU 计算时间的比例调整
- **队列大小**：根据任务数量和内存限制设置
- **拒绝策略**：根据业务需求选择，推荐 CallerRunsPolicy

### 问题7：线程池中的线程是如何复用的？

**答案要点**：
- Worker 线程在 runWorker() 方法中循环执行
- 通过 getTask() 从队列获取任务
- 如果获取到任务，执行任务；否则根据配置决定是否退出
- 核心线程默认不会退出，非核心线程超时后退出

### 问题8：AsyncTask 的原理是什么？为什么被废弃？

**答案要点**：
- **原理**：内部使用线程池 + Handler 实现
- **执行流程**：onPreExecute(主线程) → doInBackground(线程池) → onPostExecute(主线程)
- **废弃原因**：
  1. 容易导致内存泄漏（持有 Activity 引用）
  2. 生命周期管理困难
  3. 串行执行效率低
  4. 协程是更好的替代方案

### 问题9：如何监控线程池的运行状态？

**答案要点**：
- 使用 ThreadPoolExecutor 的方法获取状态：
  - getPoolSize()：当前线程数
  - getActiveCount()：活跃线程数
  - getQueue().size()：队列大小
  - getCompletedTaskCount()：已完成任务数
- 重写 beforeExecute/afterExecute 监控任务执行
- 重写 terminated 监控线程池关闭

### 问题10：线程池如何实现优雅关闭？

**答案要点**：
```kotlin
fun shutdownGracefully(executor: ExecutorService, timeout: Long = 60) {
    // 1. 停止接收新任务
    executor.shutdown()
    
    try {
        // 2. 等待已提交任务完成
        if (!executor.awaitTermination(timeout, TimeUnit.SECONDS)) {
            // 3. 超时后强制关闭
            executor.shutdownNow()
            // 4. 再次等待
            if (!executor.awaitTermination(timeout, TimeUnit.SECONDS)) {
                Log.e("ThreadPool", "Pool did not terminate")
            }
        }
    } catch (e: InterruptedException) {
        // 5. 被中断时强制关闭
        executor.shutdownNow()
        Thread.currentThread().interrupt()
    }
}
```
