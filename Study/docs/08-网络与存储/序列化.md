# 序列化

## 1. 概述

序列化（Serialization）是将对象转换为可存储或可传输格式的过程，反序列化（Deserialization）则是将存储或传输的数据还原为对象的过程。在 Android 开发中，序列化主要用于以下场景：

- **进程间通信（IPC）**：通过 Intent、Binder 传递对象
- **数据持久化**：将对象保存到文件或数据库
- **网络传输**：将对象转换为 JSON/Protobuf 等格式进行网络请求
- **Activity/Fragment 状态保存**：在配置变更时保存和恢复数据

Android 中常用的序列化方案包括：

| 方案 | 特点 | 适用场景 |
|------|------|----------|
| Serializable | Java 原生，使用简单，性能较差 | 数据持久化、网络传输 |
| Parcelable | Android 专属，性能优秀 | IPC、Intent 传递 |
| JSON | 可读性好，跨平台 | 网络传输、配置文件 |
| Protocol Buffers | 高效紧凑，跨平台 | 高性能网络传输、数据存储 |

## 2. 核心原理

### 2.1 Serializable 原理

#### 2.1.1 基本概念

`Serializable` 是 Java 提供的序列化接口，是一个标记接口（Marker Interface），不包含任何方法。实现该接口的类可以被 `ObjectOutputStream` 序列化。

```
┌─────────────────────────────────────────────────────────────┐
│                  Serializable 序列化流程                     │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   Java 对象                    字节流                        │
│  ┌─────────┐                 ┌─────────┐                   │
│  │  User   │  ──────────►   │ 0x AC ED │                   │
│  │ - name  │  ObjectOutput  │ 00 05 ...│                   │
│  │ - age   │  Stream        │ (二进制) │                   │
│  └─────────┘                 └─────────┘                   │
│                                                             │
│       ▲                           │                         │
│       │      ObjectInput          │                         │
│       └───────Stream──────────────┘                         │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

#### 2.1.2 序列化过程详解

```
┌─────────────────────────────────────────────────────────────┐
│              Serializable 序列化详细流程                     │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. 检查是否实现 Serializable 接口                          │
│     ↓                                                       │
│  2. 检查是否有 writeObject 方法（自定义序列化）              │
│     ↓                                                       │
│  3. 写入类描述信息（类名、serialVersionUID、字段信息）       │
│     ↓                                                       │
│  4. 递归写入父类信息（如果父类也实现 Serializable）          │
│     ↓                                                       │
│  5. 写入对象字段值                                          │
│     ├── 基本类型：直接写入                                  │
│     └── 引用类型：递归序列化                                │
│     ↓                                                       │
│  6. 处理循环引用（使用引用表）                              │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

#### 2.1.3 serialVersionUID 的作用

```
┌─────────────────────────────────────────────────────────────┐
│                serialVersionUID 版本控制                     │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  序列化时:                                                  │
│  ┌─────────────┐                                           │
│  │ User v1.0   │  serialVersionUID = 1L                    │
│  │ - name      │  ──────► 保存到文件                       │
│  │ - age       │                                           │
│  └─────────────┘                                           │
│                                                             │
│  反序列化时:                                                │
│  ┌─────────────┐                                           │
│  │ User v2.0   │  serialVersionUID = 1L  ✓ 成功           │
│  │ - name      │  serialVersionUID = 2L  ✗ 失败           │
│  │ - age       │  (InvalidClassException)                  │
│  │ - email     │                                           │
│  └─────────────┘                                           │
│                                                             │
│  如果不显式指定 serialVersionUID:                           │
│  - JVM 会根据类结构自动生成                                 │
│  - 类结构变化会导致 UID 变化，反序列化失败                  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

#### 2.1.4 transient 关键字

使用 `transient` 修饰的字段不会被序列化：

```java
public class User implements Serializable {
    private String name;
    private transient String password;  // 不会被序列化
}
```

### 2.2 Parcelable 原理

#### 2.2.1 基本概念

`Parcelable` 是 Android 专门为 IPC 设计的序列化接口，通过 `Parcel` 容器进行数据传输。相比 `Serializable`，它避免了反射，性能更优。

```
┌─────────────────────────────────────────────────────────────┐
│                  Parcelable 序列化流程                       │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   Java 对象                    Parcel 容器                   │
│  ┌─────────┐                 ┌─────────────────┐            │
│  │  User   │  writeToParcel │ ┌───┬───┬───┐   │            │
│  │ - name  │  ────────────► │ │int│str│...│   │            │
│  │ - age   │                │ └───┴───┴───┘   │            │
│  └─────────┘                │   连续内存块     │            │
│                             └─────────────────┘            │
│       ▲                           │                         │
│       │      createFromParcel     │                         │
│       └───────────────────────────┘                         │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

#### 2.2.2 Parcel 内存结构

```
┌─────────────────────────────────────────────────────────────┐
│                    Parcel 内存布局                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌──────────────────────────────────────────────────────┐  │
│  │                    Native 层内存                      │  │
│  │  ┌────┬────┬────┬────┬────┬────┬────┬────┬────┐     │  │
│  │  │ 4B │ 4B │ 8B │ 4B │ nB │ 4B │ nB │ ...│    │     │  │
│  │  │int │int │long│len │str │len │str │    │    │     │  │
│  │  └────┴────┴────┴────┴────┴────┴────┴────┴────┘     │  │
│  │    ↑                                                  │  │
│  │  mData (数据指针)                                     │  │
│  │                                                       │  │
│  │  mDataPos: 当前读写位置                               │  │
│  │  mDataSize: 已使用大小                                │  │
│  │  mDataCapacity: 总容量                                │  │
│  └──────────────────────────────────────────────────────┘  │
│                                                             │
│  特点:                                                      │
│  - 数据连续存储，无需额外的类型信息                         │
│  - 读写顺序必须一致                                         │
│  - 使用 Native 内存，效率高                                 │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 2.3 Serializable vs Parcelable 对比

```
┌─────────────────────────────────────────────────────────────────────────┐
│                  Serializable vs Parcelable 详细对比                     │
├─────────────────────────────────────────────────────────────────────────┤
│  特性              │  Serializable          │  Parcelable              │
├─────────────────────────────────────────────────────────────────────────┤
│  来源              │  Java 标准库            │  Android SDK             │
├─────────────────────────────────────────────────────────────────────────┤
│  实现复杂度        │  简单（标记接口）        │  复杂（需实现方法）       │
├─────────────────────────────────────────────────────────────────────────┤
│  序列化方式        │  反射                   │  直接写入内存             │
├─────────────────────────────────────────────────────────────────────────┤
│  性能              │  较慢（反射+大量临时对象）│  快（无反射，内存操作）   │
├─────────────────────────────────────────────────────────────────────────┤
│  内存开销          │  大（产生大量临时对象）   │  小（直接内存操作）       │
├─────────────────────────────────────────────────────────────────────────┤
│  适用场景          │  持久化存储、网络传输    │  IPC、Intent 传递         │
├─────────────────────────────────────────────────────────────────────────┤
│  跨平台            │  支持                   │  不支持（Android 专属）   │
├─────────────────────────────────────────────────────────────────────────┤
│  版本兼容          │  serialVersionUID       │  需手动处理               │
└─────────────────────────────────────────────────────────────────────────┘
```

#### 性能对比测试数据

```
┌─────────────────────────────────────────────────────────────┐
│              序列化性能对比（10000次操作）                    │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  Serializable:                                              │
│  ├── 序列化耗时:   ~1200ms                                  │
│  ├── 反序列化耗时: ~1100ms                                  │
│  └── 内存分配:     ~15MB (大量临时对象)                     │
│                                                             │
│  Parcelable:                                                │
│  ├── 序列化耗时:   ~50ms                                    │
│  ├── 反序列化耗时: ~30ms                                    │
│  └── 内存分配:     ~0.5MB                                   │
│                                                             │
│  性能差距: Parcelable 约快 20-30 倍                         │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 2.4 JSON 解析库原理

#### 2.4.1 Gson 原理

```
┌─────────────────────────────────────────────────────────────┐
│                      Gson 工作原理                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  序列化流程:                                                │
│  ┌─────────┐    反射获取字段    ┌─────────────┐            │
│  │  User   │  ───────────────► │ TypeAdapter │            │
│  │ object  │                   │  (类型适配器) │            │
│  └─────────┘                   └──────┬──────┘            │
│                                       │                     │
│                                       ▼                     │
│                               ┌─────────────┐              │
│                               │ JsonWriter  │              │
│                               │ (流式写入)   │              │
│                               └──────┬──────┘              │
│                                       │                     │
│                                       ▼                     │
│                               ┌─────────────┐              │
│                               │ JSON String │              │
│                               └─────────────┘              │
│                                                             │
│  核心组件:                                                  │
│  - TypeAdapter: 类型适配器，负责具体类型的序列化/反序列化    │
│  - TypeAdapterFactory: 创建 TypeAdapter 的工厂             │
│  - ReflectiveTypeAdapterFactory: 基于反射的默认实现        │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

#### 2.4.2 Moshi 原理

```
┌─────────────────────────────────────────────────────────────┐
│                      Moshi 工作原理                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  两种模式:                                                  │
│                                                             │
│  1. 反射模式 (moshi-kotlin-reflect):                        │
│     - 运行时反射，类似 Gson                                 │
│     - 支持 Kotlin 特性（默认值、空安全）                    │
│                                                             │
│  2. 代码生成模式 (moshi-kotlin-codegen):                    │
│     - 编译时生成 JsonAdapter                                │
│     - 无反射，性能更好                                      │
│     - 使用 @JsonClass(generateAdapter = true) 注解         │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │  @JsonClass(generateAdapter = true)                 │   │
│  │  data class User(val name: String, val age: Int)    │   │
│  │                      │                              │   │
│  │                      ▼ 编译时生成                    │   │
│  │  class UserJsonAdapter : JsonAdapter<User>() {      │   │
│  │      override fun fromJson(reader: JsonReader)      │   │
│  │      override fun toJson(writer: JsonWriter, value) │   │
│  │  }                                                  │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

#### 2.4.3 kotlinx.serialization 原理

```
┌─────────────────────────────────────────────────────────────┐
│               kotlinx.serialization 工作原理                 │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  编译器插件 + 运行时库:                                      │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │  @Serializable                                      │   │
│  │  data class User(val name: String, val age: Int)    │   │
│  │                      │                              │   │
│  │                      ▼ Kotlin 编译器插件            │   │
│  │  // 自动生成 serializer                             │   │
│  │  companion object {                                 │   │
│  │      fun serializer(): KSerializer<User>            │   │
│  │  }                                                  │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  特点:                                                      │
│  - 编译时生成，无反射                                       │
│  - Kotlin 官方支持，与语言深度集成                          │
│  - 支持多种格式（JSON、Protobuf、CBOR 等）                  │
│  - 支持多平台（JVM、JS、Native）                            │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

#### 2.4.4 JSON 解析库对比

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                         JSON 解析库详细对比                                      │
├─────────────────────────────────────────────────────────────────────────────────┤
│  特性          │  Gson           │  Moshi          │  kotlinx.serialization    │
├─────────────────────────────────────────────────────────────────────────────────┤
│  开发者        │  Google         │  Square         │  JetBrains                │
├─────────────────────────────────────────────────────────────────────────────────┤
│  实现方式      │  反射           │  反射/代码生成   │  编译器插件               │
├─────────────────────────────────────────────────────────────────────────────────┤
│  Kotlin 支持   │  一般           │  良好           │  原生支持                 │
├─────────────────────────────────────────────────────────────────────────────────┤
│  空安全        │  不支持         │  支持           │  原生支持                 │
├─────────────────────────────────────────────────────────────────────────────────┤
│  默认值        │  不支持         │  支持           │  原生支持                 │
├─────────────────────────────────────────────────────────────────────────────────┤
│  性能          │  较慢           │  中等/快        │  快                       │
├─────────────────────────────────────────────────────────────────────────────────┤
│  包大小        │  ~250KB         │  ~150KB         │  ~300KB                   │
├─────────────────────────────────────────────────────────────────────────────────┤
│  多平台        │  JVM            │  JVM            │  JVM/JS/Native            │
├─────────────────────────────────────────────────────────────────────────────────┤
│  学习成本      │  低             │  中             │  中                       │
├─────────────────────────────────────────────────────────────────────────────────┤
│  推荐场景      │  老项目维护     │  新项目         │  Kotlin 优先项目          │
└─────────────────────────────────────────────────────────────────────────────────┘
```

### 2.5 Protocol Buffers 原理

#### 2.5.1 基本概念

Protocol Buffers（简称 Protobuf）是 Google 开发的高效数据序列化协议，具有体积小、速度快、跨平台的特点。

```
┌─────────────────────────────────────────────────────────────┐
│                  Protocol Buffers 工作流程                   │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. 定义 .proto 文件                                        │
│     ┌─────────────────────────────────────┐                │
│     │  message User {                     │                │
│     │      string name = 1;               │                │
│     │      int32 age = 2;                 │                │
│     │  }                                  │                │
│     └─────────────────────────────────────┘                │
│                      │                                      │
│                      ▼ protoc 编译器                        │
│  2. 生成代码                                                │
│     ┌─────────────────────────────────────┐                │
│     │  // Java/Kotlin 代码                │                │
│     │  class User {                       │                │
│     │      fun getName(): String          │                │
│     │      fun getAge(): Int              │                │
│     │      fun toByteArray(): ByteArray   │                │
│     │      fun parseFrom(bytes): User     │                │
│     │  }                                  │                │
│     └─────────────────────────────────────┘                │
│                      │                                      │
│  3. 序列化/反序列化                                         │
│     ┌─────────────────────────────────────┐                │
│     │  User → [0A 05 4A 6F 68 6E 10 1E]  │                │
│     │         (紧凑的二进制格式)           │                │
│     └─────────────────────────────────────┘                │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

#### 2.5.2 编码原理

```
┌─────────────────────────────────────────────────────────────┐
│                  Protobuf 编码格式                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  Wire Type (线类型):                                        │
│  ┌────────┬────────────────────────────────────────────┐   │
│  │ 类型   │ 含义                                       │   │
│  ├────────┼────────────────────────────────────────────┤   │
│  │   0    │ Varint (int32, int64, bool, enum)         │   │
│  │   1    │ 64-bit (fixed64, double)                  │   │
│  │   2    │ Length-delimited (string, bytes, message) │   │
│  │   5    │ 32-bit (fixed32, float)                   │   │
│  └────────┴────────────────────────────────────────────┘   │
│                                                             │
│  Tag 编码: (field_number << 3) | wire_type                 │
│                                                             │
│  示例: message User { string name = 1; int32 age = 2; }    │
│                                                             │
│  User("John", 30) 编码结果:                                 │
│  ┌────┬────┬────┬────┬────┬────┬────┬────┐                │
│  │ 0A │ 04 │ 4A │ 6F │ 68 │ 6E │ 10 │ 1E │                │
│  └────┴────┴────┴────┴────┴────┴────┴────┘                │
│    │    │    └────────┬───────┘    │    │                  │
│    │    │         "John"           │    │                  │
│    │    └── 长度=4                 │    └── 30 (Varint)   │
│    └── Tag: field=1, type=2       └── Tag: field=2, type=0│
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

#### 2.5.3 Varint 编码

```
┌─────────────────────────────────────────────────────────────┐
│                    Varint 变长编码                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  原理: 每个字节的最高位(MSB)表示是否还有后续字节             │
│        MSB=1: 后面还有字节                                  │
│        MSB=0: 这是最后一个字节                              │
│                                                             │
│  示例: 编码数字 300                                         │
│                                                             │
│  300 的二进制: 100101100                                    │
│                                                             │
│  分组 (每组7位):                                            │
│  ┌─────────┬─────────┐                                     │
│  │ 0000010 │ 0101100 │                                     │
│  └─────────┴─────────┘                                     │
│       ↓         ↓                                           │
│  ┌─────────┬─────────┐                                     │
│  │10101100 │00000010 │  (小端序，低位在前)                  │
│  │   AC    │   02    │                                     │
│  └─────────┴─────────┘                                     │
│    ↑              ↑                                         │
│   MSB=1         MSB=0                                       │
│   (还有)        (结束)                                      │
│                                                             │
│  优点: 小数字占用更少字节                                   │
│  - 1-127: 1字节                                            │
│  - 128-16383: 2字节                                        │
│  - 16384-2097151: 3字节                                    │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 3. 关键源码解析

### 3.1 Serializable 源码分析

```java
/**
 * ObjectOutputStream 序列化核心代码
 * 源码位置: java/io/ObjectOutputStream.java
 */
public class ObjectOutputStream extends OutputStream {
    
    /**
     * 写入对象的核心方法
     */
    public final void writeObject(Object obj) throws IOException {
        // 检查是否启用覆盖
        if (enableOverride) {
            writeObjectOverride(obj);
            return;
        }
        try {
            // 调用内部写入方法
            writeObject0(obj, false);
        } catch (IOException ex) {
            // ...
        }
    }
    
    /**
     * 内部写入对象方法
     */
    private void writeObject0(Object obj, boolean unshared) throws IOException {
        // 1. 处理 null
        if (obj == null) {
            writeNull();
            return;
        }
        
        // 2. 检查是否已经写入过（处理循环引用）
        Object orig = obj;
        Class<?> cl = obj.getClass();
        ObjectStreamClass desc = ObjectStreamClass.lookup(cl, true);
        
        // 3. 检查是否实现 Serializable
        if (!desc.isSerializable()) {
            throw new NotSerializableException(cl.getName());
        }
        
        // 4. 根据类型选择写入方式
        if (obj instanceof String) {
            writeString((String) obj, unshared);
        } else if (cl.isArray()) {
            writeArray(obj, desc, unshared);
        } else if (obj instanceof Enum) {
            writeEnum((Enum<?>) obj, desc, unshared);
        } else if (obj instanceof Serializable) {
            // 5. 写入普通对象
            writeOrdinaryObject(obj, desc, unshared);
        } else {
            throw new NotSerializableException(cl.getName());
        }
    }
    
    /**
     * 写入普通对象
     */
    private void writeOrdinaryObject(Object obj, ObjectStreamClass desc, 
            boolean unshared) throws IOException {
        // 写入类型标记
        bout.writeByte(TC_OBJECT);
        // 写入类描述信息
        writeClassDesc(desc, false);
        
        // 检查是否有自定义 writeObject 方法
        if (desc.hasWriteObjectMethod()) {
            // 调用自定义序列化方法
            desc.invokeWriteObject(obj, this);
        } else {
            // 使用默认序列化
            defaultWriteFields(obj, desc);
        }
    }
    
    /**
     * 默认字段写入 - 使用反射获取字段值
     */
    private void defaultWriteFields(Object obj, ObjectStreamClass desc) 
            throws IOException {
        // 获取所有需要序列化的字段
        ObjectStreamField[] fields = desc.getFields(false);
        
        for (ObjectStreamField f : fields) {
            // 通过反射获取字段值
            Field field = f.getField();
            Object value = field.get(obj);  // 反射调用
            
            // 根据类型写入
            if (f.isPrimitive()) {
                // 基本类型直接写入
                writePrimitiveData(value, f.getTypeCode());
            } else {
                // 引用类型递归序列化
                writeObject0(value, false);
            }
        }
    }
}
```

### 3.2 Parcelable 源码分析

```java
/**
 * Parcel 核心源码分析
 * 源码位置: frameworks/base/core/java/android/os/Parcel.java
 */
public final class Parcel {
    
    // Native 层指针
    private long mNativePtr;
    
    /**
     * 写入 String
     * 直接调用 Native 方法，无反射
     */
    public final void writeString(String val) {
        // 调用 Native 方法写入
        nativeWriteString(mNativePtr, val);
    }
    
    /**
     * 写入 int
     */
    public final void writeInt(int val) {
        nativeWriteInt(mNativePtr, val);
    }
    
    /**
     * 写入 Parcelable 对象
     */
    public final void writeParcelable(Parcelable p, int parcelableFlags) {
        if (p == null) {
            writeString(null);
            return;
        }
        // 写入类名（用于反序列化时创建对象）
        writeParcelableCreator(p);
        // 调用对象的 writeToParcel 方法
        p.writeToParcel(this, parcelableFlags);
    }
    
    /**
     * 读取 Parcelable 对象
     */
    public final <T extends Parcelable> T readParcelable(ClassLoader loader) {
        // 读取类名
        Parcelable.Creator<?> creator = readParcelableCreator(loader);
        if (creator == null) {
            return null;
        }
        // 调用 CREATOR.createFromParcel 创建对象
        return (T) creator.createFromParcel(this);
    }
}

/**
 * Native 层 Parcel 实现
 * 源码位置: frameworks/native/libs/binder/Parcel.cpp
 */
// C++ 代码
status_t Parcel::writeString16(const String16& str) {
    // 写入字符串长度
    status_t err = writeInt32(str.size());
    if (err == NO_ERROR) {
        // 写入字符串内容（直接内存拷贝）
        err = write(str.string(), str.size() * sizeof(char16_t));
    }
    return err;
}

status_t Parcel::writeInt32(int32_t val) {
    // 确保有足够空间
    if ((mDataPos + sizeof(val)) <= mDataCapacity) {
        // 直接写入内存
        *reinterpret_cast<int32_t*>(mData + mDataPos) = val;
        mDataPos += sizeof(val);
        return NO_ERROR;
    }
    // 扩容后重试
    return growData(sizeof(val));
}
```

### 3.3 Parcelable 实现示例

```kotlin
/**
 * Parcelable 完整实现示例
 * 展示手动实现和 @Parcelize 注解两种方式
 */

// 方式一：手动实现 Parcelable
class User : Parcelable {
    var name: String = ""
    var age: Int = 0
    var address: Address? = null  // 嵌套 Parcelable
    var tags: List<String> = emptyList()  // 集合类型
    
    // 默认构造函数
    constructor()
    
    // 从 Parcel 读取数据的构造函数
    // 注意：读取顺序必须与 writeToParcel 写入顺序一致
    constructor(parcel: Parcel) {
        name = parcel.readString() ?: ""
        age = parcel.readInt()
        address = parcel.readParcelable(Address::class.java.classLoader)
        tags = parcel.createStringArrayList() ?: emptyList()
    }
    
    // 将对象写入 Parcel
    override fun writeToParcel(parcel: Parcel, flags: Int) {
        parcel.writeString(name)
        parcel.writeInt(age)
        parcel.writeParcelable(address, flags)
        parcel.writeStringList(tags)
    }
    
    // 描述内容，通常返回 0
    // 如果包含文件描述符，返回 CONTENTS_FILE_DESCRIPTOR
    override fun describeContents(): Int = 0
    
    // CREATOR 是必须的，用于反序列化
    companion object CREATOR : Parcelable.Creator<User> {
        // 从 Parcel 创建对象
        override fun createFromParcel(parcel: Parcel): User {
            return User(parcel)
        }
        
        // 创建对象数组
        override fun newArray(size: Int): Array<User?> {
            return arrayOfNulls(size)
        }
    }
}

// 方式二：使用 @Parcelize 注解（推荐）
// 需要添加 kotlin-parcelize 插件
@Parcelize
data class UserParcelize(
    val name: String,
    val age: Int,
    val address: Address?,
    val tags: List<String>
) : Parcelable

// 嵌套的 Parcelable 类
@Parcelize
data class Address(
    val city: String,
    val street: String
) : Parcelable
```

### 3.4 Gson 源码分析

```java
/**
 * Gson 核心源码分析
 * 源码位置: com/google/gson/Gson.java
 */
public final class Gson {
    
    // TypeAdapter 工厂列表
    private final List<TypeAdapterFactory> factories;
    // TypeAdapter 缓存
    private final Map<TypeToken<?>, TypeAdapter<?>> typeTokenCache;
    
    /**
     * 序列化对象为 JSON 字符串
     */
    public String toJson(Object src) {
        if (src == null) {
            return toJson(JsonNull.INSTANCE);
        }
        return toJson(src, src.getClass());
    }
    
    public String toJson(Object src, Type typeOfSrc) {
        StringWriter writer = new StringWriter();
        toJson(src, typeOfSrc, writer);
        return writer.toString();
    }
    
    /**
     * 获取 TypeAdapter
     * 这是 Gson 的核心机制
     */
    public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {
        // 1. 先从缓存获取
        TypeAdapter<?> cached = typeTokenCache.get(type);
        if (cached != null) {
            return (TypeAdapter<T>) cached;
        }
        
        // 2. 遍历工厂列表创建 TypeAdapter
        for (TypeAdapterFactory factory : factories) {
            TypeAdapter<T> candidate = factory.create(this, type);
            if (candidate != null) {
                // 缓存并返回
                typeTokenCache.put(type, candidate);
                return candidate;
            }
        }
        
        throw new IllegalArgumentException("Cannot serialize " + type);
    }
}

/**
 * ReflectiveTypeAdapterFactory - 基于反射的 TypeAdapter 工厂
 * 这是 Gson 性能较慢的主要原因
 */
public final class ReflectiveTypeAdapterFactory implements TypeAdapterFactory {
    
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
        Class<? super T> raw = type.getRawType();
        
        // 获取所有字段
        Map<String, BoundField> boundFields = getBoundFields(gson, type, raw);
        
        return new Adapter<T>(constructor, boundFields);
    }
    
    /**
     * 获取绑定字段 - 使用反射
     */
    private Map<String, BoundField> getBoundFields(Gson gson, TypeToken<?> type, 
            Class<?> raw) {
        Map<String, BoundField> result = new LinkedHashMap<>();
        
        // 遍历类及其父类的所有字段
        while (raw != Object.class) {
            Field[] fields = raw.getDeclaredFields();
            
            for (Field field : fields) {
                // 跳过 transient 和 static 字段
                if (Modifier.isTransient(field.getModifiers()) ||
                    Modifier.isStatic(field.getModifiers())) {
                    continue;
                }
                
                // 设置可访问（反射的关键）
                field.setAccessible(true);
                
                // 创建 BoundField
                BoundField boundField = createBoundField(gson, field, 
                        getFieldName(field), TypeToken.get(field.getGenericType()));
                result.put(boundField.name, boundField);
            }
            
            raw = raw.getSuperclass();
        }
        
        return result;
    }
    
    /**
     * 反射适配器 - 读写都使用反射
     */
    private static final class Adapter<T> extends TypeAdapter<T> {
        private final ObjectConstructor<T> constructor;
        private final Map<String, BoundField> boundFields;
        
        @Override
        public void write(JsonWriter out, T value) throws IOException {
            out.beginObject();
            for (BoundField boundField : boundFields.values()) {
                out.name(boundField.name);
                // 通过反射获取字段值
                boundField.write(out, value);
            }
            out.endObject();
        }
        
        @Override
        public T read(JsonReader in) throws IOException {
            // 通过反射创建对象
            T instance = constructor.construct();
            
            in.beginObject();
            while (in.hasNext()) {
                String name = in.nextName();
                BoundField field = boundFields.get(name);
                if (field != null) {
                    // 通过反射设置字段值
                    field.read(in, instance);
                }
            }
            in.endObject();
            
            return instance;
        }
    }
}
```

### 3.5 kotlinx.serialization 源码分析

```kotlin
/**
 * kotlinx.serialization 核心原理
 * 编译器插件自动生成 serializer
 */

// 原始代码
@Serializable
data class User(val name: String, val age: Int)

// 编译器生成的代码（简化版）
@Serializable
data class User(val name: String, val age: Int) {
    
    // 自动生成的伴生对象
    companion object {
        // 返回序列化器
        fun serializer(): KSerializer<User> = UserSerializer
    }
    
    // 自动生成的序列化器
    private object UserSerializer : KSerializer<User> {
        
        // 序列化描述符
        override val descriptor: SerialDescriptor = buildClassSerialDescriptor("User") {
            element<String>("name")
            element<Int>("age")
        }
        
        // 序列化方法
        override fun serialize(encoder: Encoder, value: User) {
            encoder.encodeStructure(descriptor) {
                encodeStringElement(descriptor, 0, value.name)
                encodeIntElement(descriptor, 1, value.age)
            }
        }
        
        // 反序列化方法
        override fun deserialize(decoder: Decoder): User {
            return decoder.decodeStructure(descriptor) {
                var name = ""
                var age = 0
                
                while (true) {
                    when (val index = decodeElementIndex(descriptor)) {
                        0 -> name = decodeStringElement(descriptor, 0)
                        1 -> age = decodeIntElement(descriptor, 1)
                        CompositeDecoder.DECODE_DONE -> break
                    }
                }
                
                User(name, age)
            }
        }
    }
}

/**
 * 使用示例
 */
fun main() {
    val user = User("John", 30)
    
    // 序列化
    val json = Json.encodeToString(user)
    // 输出: {"name":"John","age":30}
    
    // 反序列化
    val decoded = Json.decodeFromString<User>(json)
}
```

### 3.6 Protocol Buffers 生成代码分析

```java
/**
 * Protobuf 生成的 Java 代码分析
 * 
 * .proto 文件:
 * message User {
 *     string name = 1;
 *     int32 age = 2;
 * }
 */
public final class User extends GeneratedMessageV3 {
    
    // 字段编号常量
    public static final int NAME_FIELD_NUMBER = 1;
    public static final int AGE_FIELD_NUMBER = 2;
    
    // 字段存储
    private volatile Object name_;
    private int age_;
    
    // Getter 方法
    public String getName() {
        Object ref = name_;
        if (ref instanceof String) {
            return (String) ref;
        } else {
            ByteString bs = (ByteString) ref;
            String s = bs.toStringUtf8();
            name_ = s;
            return s;
        }
    }
    
    public int getAge() {
        return age_;
    }
    
    /**
     * 序列化到字节数组
     */
    @Override
    public void writeTo(CodedOutputStream output) throws IOException {
        // 写入 name 字段
        if (!getNameBytes().isEmpty()) {
            // Tag = (1 << 3) | 2 = 0x0A
            output.writeString(NAME_FIELD_NUMBER, getName());
        }
        // 写入 age 字段
        if (age_ != 0) {
            // Tag = (2 << 3) | 0 = 0x10
            output.writeInt32(AGE_FIELD_NUMBER, age_);
        }
    }
    
    /**
     * 计算序列化大小
     */
    @Override
    public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;
        
        size = 0;
        if (!getNameBytes().isEmpty()) {
            size += CodedOutputStream.computeStringSize(NAME_FIELD_NUMBER, getName());
        }
        if (age_ != 0) {
            size += CodedOutputStream.computeInt32Size(AGE_FIELD_NUMBER, age_);
        }
        memoizedSize = size;
        return size;
    }
    
    /**
     * 从字节数组解析
     */
    public static User parseFrom(byte[] data) throws InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
    }
    
    /**
     * Builder 模式构建对象
     */
    public static final class Builder extends GeneratedMessageV3.Builder<Builder> {
        private Object name_ = "";
        private int age_;
        
        public Builder setName(String value) {
            name_ = value;
            return this;
        }
        
        public Builder setAge(int value) {
            age_ = value;
            return this;
        }
        
        public User build() {
            return new User(this);
        }
    }
}
```

## 4. 实战应用

### 4.1 Intent 传递对象最佳实践

```kotlin
/**
 * Intent 传递对象的几种方式对比
 */

// 1. 使用 Parcelable（推荐用于 IPC）
@Parcelize
data class User(val name: String, val age: Int) : Parcelable

// 传递
val intent = Intent(this, DetailActivity::class.java).apply {
    putExtra("user", user)
}
startActivity(intent)

// 接收
val user = intent.getParcelableExtra<User>("user")

// 2. 使用 Serializable（简单但性能差）
data class UserSerializable(val name: String, val age: Int) : Serializable

// 传递
intent.putExtra("user", userSerializable)

// 接收
val user = intent.getSerializableExtra("user") as? UserSerializable

// 3. 使用 Bundle（适合多个参数）
val bundle = Bundle().apply {
    putString("name", "John")
    putInt("age", 30)
}
intent.putExtras(bundle)

// 4. 使用 JSON 字符串（跨进程兼容性好）
val json = Gson().toJson(user)
intent.putExtra("user_json", json)

// 接收
val json = intent.getStringExtra("user_json")
val user = Gson().fromJson(json, User::class.java)
```

### 4.2 网络请求序列化最佳实践

```kotlin
/**
 * Retrofit + kotlinx.serialization 配置
 */

// 1. 添加依赖
// implementation("com.jakewharton.retrofit:retrofit2-kotlinx-serialization-converter:1.0.0")
// implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.6.0")

// 2. 定义数据类
@Serializable
data class ApiResponse<T>(
    val code: Int,
    val message: String,
    val data: T?
)

@Serializable
data class UserResponse(
    val id: Long,
    val name: String,
    val email: String,
    @SerialName("created_at")  // 字段名映射
    val createdAt: String,
    val avatar: String? = null  // 可空字段带默认值
)

// 3. 配置 Retrofit
val json = Json {
    ignoreUnknownKeys = true  // 忽略未知字段
    coerceInputValues = true  // null 转为默认值
    isLenient = true          // 宽松解析
}

val retrofit = Retrofit.Builder()
    .baseUrl("https://api.example.com/")
    .addConverterFactory(json.asConverterFactory("application/json".toMediaType()))
    .build()

// 4. 定义 API 接口
interface UserApi {
    @GET("users/{id}")
    suspend fun getUser(@Path("id") id: Long): ApiResponse<UserResponse>
    
    @POST("users")
    suspend fun createUser(@Body user: UserRequest): ApiResponse<UserResponse>
}

/**
 * Retrofit + Moshi 配置
 */

// 1. 定义数据类
@JsonClass(generateAdapter = true)  // 编译时生成适配器
data class UserMoshi(
    val id: Long,
    val name: String,
    @Json(name = "created_at")
    val createdAt: String
)

// 2. 配置 Moshi
val moshi = Moshi.Builder()
    .addLast(KotlinJsonAdapterFactory())  // 反射模式
    // 或使用代码生成模式（推荐）
    .build()

val retrofit = Retrofit.Builder()
    .baseUrl("https://api.example.com/")
    .addConverterFactory(MoshiConverterFactory.create(moshi))
    .build()
```

### 4.3 数据持久化序列化

```kotlin
/**
 * MMKV + Protobuf 高性能存储
 */

// 1. 定义 .proto 文件
// user.proto
// syntax = "proto3";
// message UserProto {
//     string name = 1;
//     int32 age = 2;
//     repeated string tags = 3;
// }

// 2. 存储和读取
class UserStorage(private val mmkv: MMKV) {
    
    fun saveUser(user: UserProto) {
        // Protobuf 序列化为字节数组
        val bytes = user.toByteArray()
        mmkv.encode("user", bytes)
    }
    
    fun getUser(): UserProto? {
        val bytes = mmkv.decodeBytes("user") ?: return null
        return try {
            UserProto.parseFrom(bytes)
        } catch (e: InvalidProtocolBufferException) {
            null
        }
    }
}

/**
 * DataStore + kotlinx.serialization
 */

// 1. 定义数据类
@Serializable
data class UserPreferences(
    val theme: String = "light",
    val language: String = "zh",
    val notificationEnabled: Boolean = true
)

// 2. 创建 Serializer
object UserPreferencesSerializer : Serializer<UserPreferences> {
    override val defaultValue: UserPreferences = UserPreferences()
    
    override suspend fun readFrom(input: InputStream): UserPreferences {
        return try {
            Json.decodeFromString(
                UserPreferences.serializer(),
                input.readBytes().decodeToString()
            )
        } catch (e: SerializationException) {
            defaultValue
        }
    }
    
    override suspend fun writeTo(t: UserPreferences, output: OutputStream) {
        output.write(
            Json.encodeToString(UserPreferences.serializer(), t).encodeToByteArray()
        )
    }
}

// 3. 创建 DataStore
val Context.userPreferencesDataStore: DataStore<UserPreferences> by dataStore(
    fileName = "user_preferences.json",
    serializer = UserPreferencesSerializer
)

// 4. 使用
class SettingsRepository(private val dataStore: DataStore<UserPreferences>) {
    
    val userPreferences: Flow<UserPreferences> = dataStore.data
    
    suspend fun updateTheme(theme: String) {
        dataStore.updateData { preferences ->
            preferences.copy(theme = theme)
        }
    }
}
```

### 4.4 Bundle 大小限制与解决方案

```kotlin
/**
 * Bundle/Intent 传递数据大小限制
 * 
 * Binder 事务缓冲区大小限制：约 1MB（所有进程共享）
 * 单个事务建议不超过：500KB
 */

// ❌ 错误示例：传递大数据
val largeList = List(10000) { User("User$it", it) }
intent.putParcelableArrayListExtra("users", ArrayList(largeList))
// 可能导致 TransactionTooLargeException

// ✅ 解决方案 1：使用 ViewModel 共享数据
class SharedViewModel : ViewModel() {
    val users = MutableLiveData<List<User>>()
}

// Activity A
sharedViewModel.users.value = largeList
// Activity B
sharedViewModel.users.observe(this) { users ->
    // 使用数据
}

// ✅ 解决方案 2：使用文件缓存
class DataCache(private val context: Context) {
    private val cacheDir = context.cacheDir
    
    fun saveData(key: String, data: List<User>) {
        val file = File(cacheDir, "$key.json")
        file.writeText(Json.encodeToString(data))
    }
    
    fun loadData(key: String): List<User>? {
        val file = File(cacheDir, "$key.json")
        if (!file.exists()) return null
        return Json.decodeFromString(file.readText())
    }
}

// 传递时只传递 key
intent.putExtra("data_key", "users_cache_key")

// ✅ 解决方案 3：使用 ContentProvider
// 适合跨进程大数据传递

// ✅ 解决方案 4：分页加载
// 只传递必要的 ID，按需加载详情
```

### 4.5 序列化性能优化

```kotlin
/**
 * 序列化性能优化技巧
 */

// 1. Gson 性能优化 - 使用 TypeAdapter
class UserTypeAdapter : TypeAdapter<User>() {
    override fun write(out: JsonWriter, value: User?) {
        if (value == null) {
            out.nullValue()
            return
        }
        out.beginObject()
        out.name("name").value(value.name)
        out.name("age").value(value.age)
        out.endObject()
    }
    
    override fun read(`in`: JsonReader): User {
        var name = ""
        var age = 0
        
        `in`.beginObject()
        while (`in`.hasNext()) {
            when (`in`.nextName()) {
                "name" -> name = `in`.nextString()
                "age" -> age = `in`.nextInt()
                else -> `in`.skipValue()
            }
        }
        `in`.endObject()
        
        return User(name, age)
    }
}

// 注册 TypeAdapter
val gson = GsonBuilder()
    .registerTypeAdapter(User::class.java, UserTypeAdapter())
    .create()

// 2. 复用 Gson 实例
object GsonProvider {
    val gson: Gson by lazy {
        GsonBuilder()
            .setDateFormat("yyyy-MM-dd HH:mm:ss")
            .create()
    }
}

// 3. Parcelable 优化 - 使用 @Parcelize
// 避免手动实现，减少出错可能

// 4. 大数据序列化 - 使用流式处理
fun parseJsonStream(inputStream: InputStream): List<User> {
    val users = mutableListOf<User>()
    JsonReader(InputStreamReader(inputStream)).use { reader ->
        reader.beginArray()
        while (reader.hasNext()) {
            users.add(gson.fromJson(reader, User::class.java))
        }
        reader.endArray()
    }
    return users
}

// 5. 选择合适的序列化方案
// - IPC 传递：Parcelable
// - 网络请求：kotlinx.serialization / Moshi
// - 高性能存储：Protocol Buffers
// - 配置文件：JSON
```

## 5. 常见面试题

### 问题1：Serializable 和 Parcelable 的区别？为什么 Parcelable 性能更好？

**答案要点**：

| 对比项 | Serializable | Parcelable |
|--------|--------------|------------|
| 来源 | Java 标准库 | Android SDK |
| 实现方式 | 反射 | 直接内存读写 |
| 性能 | 慢（约慢 10-20 倍） | 快 |
| 内存开销 | 大（产生大量临时对象） | 小 |
| 使用场景 | 持久化、网络传输 | IPC、Intent 传递 |

**Parcelable 性能更好的原因**：
1. **无反射**：Parcelable 直接调用 `writeToParcel` 和 `createFromParcel` 方法，无需反射获取字段
2. **内存操作**：Parcel 在 Native 层直接操作连续内存，效率高
3. **无临时对象**：Serializable 序列化过程会产生大量临时对象，触发 GC
4. **无类型信息**：Parcelable 不需要存储类型信息，数据更紧凑

**使用建议**：
- Android IPC 场景优先使用 Parcelable
- 需要持久化或跨平台时使用 Serializable 或 JSON
- 使用 `@Parcelize` 注解简化 Parcelable 实现

---

### 问题2：serialVersionUID 的作用是什么？不设置会有什么问题？

**答案要点**：

**作用**：
- `serialVersionUID` 是序列化版本号，用于验证序列化对象和对应类的版本一致性
- 反序列化时，JVM 会比较字节流中的 `serialVersionUID` 与本地类的 `serialVersionUID`
- 如果不一致，会抛出 `InvalidClassException`

**不设置的问题**：
- JVM 会根据类结构（字段、方法等）自动生成 `serialVersionUID`
- 类结构任何变化（如添加字段）都会导致 `serialVersionUID` 变化
- 之前序列化的数据将无法反序列化

**最佳实践**：
```java
public class User implements Serializable {
    // 显式声明，保证版本兼容
    private static final long serialVersionUID = 1L;
    
    private String name;
    private int age;
    // 新增字段不影响旧数据反序列化
    private String email;
}
```

---

### 问题3：Parcelable 的 CREATOR 是什么？为什么需要它？

**答案要点**：

**CREATOR 的作用**：
- `CREATOR` 是 `Parcelable.Creator<T>` 接口的实现
- 用于从 `Parcel` 中反序列化创建对象
- 是 Parcelable 机制的核心组件

**为什么需要 CREATOR**：
1. **工厂模式**：Parcelable 使用工厂模式创建对象，而不是反射
2. **性能考虑**：避免反射调用构造函数，提高性能
3. **类型安全**：编译时确定类型，避免运行时类型转换错误

**CREATOR 的两个方法**：
```kotlin
companion object CREATOR : Parcelable.Creator<User> {
    // 从 Parcel 创建单个对象
    override fun createFromParcel(parcel: Parcel): User {
        return User(parcel)
    }
    
    // 创建对象数组（用于传递数组时）
    override fun newArray(size: Int): Array<User?> {
        return arrayOfNulls(size)
    }
}
```

**系统如何找到 CREATOR**：
- 通过反射获取类的 `CREATOR` 静态字段
- 这是 Parcelable 中唯一使用反射的地方

---

### 问题4：Gson、Moshi、kotlinx.serialization 如何选择？

**答案要点**：

| 库 | 优点 | 缺点 | 适用场景 |
|----|------|------|----------|
| **Gson** | 使用简单、文档丰富、社区成熟 | 性能较差、不支持 Kotlin 特性 | 老项目维护 |
| **Moshi** | 性能好、支持 Kotlin、代码生成 | 学习成本稍高 | 新项目、Kotlin 项目 |
| **kotlinx.serialization** | 官方支持、多平台、编译时生成 | 需要编译器插件 | Kotlin 优先项目、KMM |

**选择建议**：
1. **新 Kotlin 项目**：优先选择 `kotlinx.serialization` 或 `Moshi`
2. **需要多平台支持**：选择 `kotlinx.serialization`
3. **老项目迁移**：可以继续使用 Gson，或逐步迁移到 Moshi
4. **性能敏感场景**：使用代码生成模式（Moshi codegen 或 kotlinx.serialization）

**Kotlin 特性支持对比**：
```kotlin
// Gson 的问题
data class User(val name: String, val age: Int = 18)
// Gson 反序列化时会忽略默认值，age 可能为 0

// Moshi 和 kotlinx.serialization 正确处理默认值
// 如果 JSON 中没有 age 字段，会使用默认值 18
```

---

### 问题5：Protocol Buffers 相比 JSON 有什么优势？什么场景下使用？

**答案要点**：

**Protobuf 优势**：
1. **体积小**：二进制格式，比 JSON 小 3-10 倍
2. **速度快**：序列化/反序列化速度快 20-100 倍
3. **类型安全**：强类型，编译时检查
4. **向后兼容**：字段编号机制支持版本演进
5. **跨平台**：支持多种语言

**Protobuf 劣势**：
1. **可读性差**：二进制格式，不便于调试
2. **需要编译**：需要 protoc 编译器生成代码
3. **学习成本**：需要学习 .proto 语法

**适用场景**：
- 高性能 RPC 通信（gRPC）
- 大数据量传输
- 移动端与服务端通信（节省流量）
- 数据存储（如 MMKV）

**不适用场景**：
- 需要人工阅读的配置文件
- 简单的 REST API
- 快速原型开发

---

### 问题6：Intent 传递数据有大小限制吗？如何解决大数据传递问题？

**答案要点**：

**大小限制**：
- Binder 事务缓冲区大小约 **1MB**（所有进程共享）
- 单个事务建议不超过 **500KB**
- 超过限制会抛出 `TransactionTooLargeException`

**解决方案**：

1. **使用 ViewModel 共享数据**（同进程）
```kotlin
class SharedViewModel : ViewModel() {
    val largeData = MutableLiveData<List<Data>>()
}
```

2. **使用文件缓存**
```kotlin
// 写入缓存
File(cacheDir, "data.json").writeText(json)
// 只传递文件路径
intent.putExtra("file_path", filePath)
```

3. **使用 ContentProvider**（跨进程）

4. **分页加载**：只传递 ID，按需加载详情

5. **使用 EventBus/LiveData**（同进程）

6. **使用数据库**：存入数据库，传递 ID

---

### 问题7：如何自定义 Gson 的序列化/反序列化行为？

**答案要点**：

**方式一：使用 @SerializedName 注解**
```kotlin
data class User(
    @SerializedName("user_name")
    val name: String,
    @SerializedName("user_age")
    val age: Int
)
```

**方式二：自定义 TypeAdapter**
```kotlin
class DateTypeAdapter : TypeAdapter<Date>() {
    private val format = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())
    
    override fun write(out: JsonWriter, value: Date?) {
        out.value(value?.let { format.format(it) })
    }
    
    override fun read(`in`: JsonReader): Date? {
        return try {
            format.parse(`in`.nextString())
        } catch (e: Exception) {
            null
        }
    }
}

val gson = GsonBuilder()
    .registerTypeAdapter(Date::class.java, DateTypeAdapter())
    .create()
```

**方式三：使用 JsonSerializer/JsonDeserializer**
```kotlin
class UserSerializer : JsonSerializer<User> {
    override fun serialize(src: User, typeOfSrc: Type, 
            context: JsonSerializationContext): JsonElement {
        return JsonObject().apply {
            addProperty("n", src.name)  // 自定义字段名
            addProperty("a", src.age)
        }
    }
}
```

**方式四：使用 ExclusionStrategy 排除字段**
```kotlin
val gson = GsonBuilder()
    .setExclusionStrategies(object : ExclusionStrategy {
        override fun shouldSkipField(f: FieldAttributes): Boolean {
            return f.getAnnotation(Exclude::class.java) != null
        }
        override fun shouldSkipClass(clazz: Class<*>): Boolean = false
    })
    .create()
```

---

### 问题8：Parcelable 中 describeContents() 方法的作用是什么？

**答案要点**：

**作用**：
- 描述 Parcelable 对象的特殊内容类型
- 通常返回 0，表示没有特殊内容

**返回值**：
- `0`：没有特殊内容（最常见）
- `CONTENTS_FILE_DESCRIPTOR`：包含文件描述符

**什么时候返回 CONTENTS_FILE_DESCRIPTOR**：
```kotlin
class FileWrapper(val fd: ParcelFileDescriptor) : Parcelable {
    override fun describeContents(): Int {
        // 包含文件描述符时返回此值
        return Parcelable.CONTENTS_FILE_DESCRIPTOR
    }
    
    override fun writeToParcel(parcel: Parcel, flags: Int) {
        parcel.writeParcelable(fd, flags)
    }
}
```

**实际意义**：
- 系统根据此值决定如何处理 Parcelable 对象
- 包含文件描述符的对象需要特殊处理（如跨进程传递时）

---

### 问题9：kotlinx.serialization 如何处理多态类型？

**答案要点**：

```kotlin
// 使用 @Polymorphic 和 @SerialName 处理多态

@Serializable
sealed class Animal {
    abstract val name: String
}

@Serializable
@SerialName("dog")
data class Dog(override val name: String, val breed: String) : Animal()

@Serializable
@SerialName("cat")
data class Cat(override val name: String, val color: String) : Animal()

// 配置多态序列化
val json = Json {
    serializersModule = SerializersModule {
        polymorphic(Animal::class) {
            subclass(Dog::class)
            subclass(Cat::class)
        }
    }
}

// 使用
val animals: List<Animal> = listOf(
    Dog("Buddy", "Golden Retriever"),
    Cat("Whiskers", "Orange")
)

val jsonString = json.encodeToString(animals)
// [{"type":"dog","name":"Buddy","breed":"Golden Retriever"},
//  {"type":"cat","name":"Whiskers","color":"Orange"}]

val decoded = json.decodeFromString<List<Animal>>(jsonString)
```

---

### 问题10：如何优化大量数据的序列化性能？

**答案要点**：

1. **选择合适的序列化方案**
   - IPC：Parcelable
   - 网络：Protocol Buffers > kotlinx.serialization > Moshi > Gson
   - 存储：Protocol Buffers + MMKV

2. **使用代码生成而非反射**
   - Moshi：使用 `@JsonClass(generateAdapter = true)`
   - kotlinx.serialization：使用 `@Serializable`

3. **流式处理大数据**
```kotlin
// 使用 JsonReader 流式解析
JsonReader(inputStream.reader()).use { reader ->
    reader.beginArray()
    while (reader.hasNext()) {
        // 逐个处理，避免一次性加载全部数据
    }
    reader.endArray()
}
```

4. **复用对象**
```kotlin
// 复用 Gson 实例
object GsonHolder {
    val gson: Gson = GsonBuilder().create()
}

// 复用 Parcel
val parcel = Parcel.obtain()
try {
    // 使用 parcel
} finally {
    parcel.recycle()  // 回收复用
}
```

5. **减少序列化数据量**
   - 使用 `@Transient` 排除不必要的字段
   - 压缩数据后再传输
   - 分页加载，按需获取

6. **异步序列化**
```kotlin
withContext(Dispatchers.IO) {
    val json = Json.encodeToString(largeData)
}
```
