# Android 网络原理与优化

## 1. 概述

网络通信是移动应用的核心能力之一，也是 Android 高级开发面试的高频考点。本文将从网络协议原理、主流网络框架源码分析、网络优化策略等方面全面讲解 Android 网络开发的核心知识点。

### 1.1 网络知识体系

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        Android 网络知识体系                              │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  协议层:                                                                │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  • HTTP/HTTPS 协议原理                                          │   │
│  │  • TCP/IP 协议栈                                                │   │
│  │  • TLS/SSL 安全传输                                             │   │
│  │  • HTTP/2、HTTP/3 新特性                                        │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  框架层:                                                                │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  • OkHttp: 底层网络请求框架                                     │   │
│  │  • Retrofit: 声明式 API 封装                                    │   │
│  │  • Volley: Google 官方轻量级框架                                │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  优化层:                                                                │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  • DNS 优化                                                     │   │
│  │  • 连接优化                                                     │   │
│  │  • 数据优化                                                     │   │
│  │  • 弱网优化                                                     │   │
│  │  • 网络监控                                                     │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 1.2 面试重点分布

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        大厂面试重点分布                                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  字节跳动:                                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  • OkHttp 拦截器链原理 (必问)                                   │   │
│  │  • 连接池复用机制                                               │   │
│  │  • HTTPS 握手过程                                               │   │
│  │  • 网络优化实战经验                                             │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  美团:                                                                  │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  • Retrofit 动态代理原理                                        │   │
│  │  • 网络请求的完整流程                                           │   │
│  │  • 弱网环境优化策略                                             │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  快手:                                                                  │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  • TCP 三次握手/四次挥手                                        │   │
│  │  • HTTP/2 多路复用                                              │   │
│  │  • 大文件上传/下载优化                                          │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```


## 2. 核心原理

### 2.1 HTTP/HTTPS 协议原理

#### 2.1.1 HTTP 协议基础

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        HTTP 协议结构                                     │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  请求报文结构:                                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  请求行:    GET /api/user HTTP/1.1                              │   │
│  │  ─────────────────────────────────────────────────────────────  │   │
│  │  请求头:    Host: api.example.com                               │   │
│  │            Content-Type: application/json                       │   │
│  │            Authorization: Bearer xxx                            │   │
│  │            Accept-Encoding: gzip, deflate                       │   │
│  │  ─────────────────────────────────────────────────────────────  │   │
│  │  空行:      \r\n                                                │   │
│  │  ─────────────────────────────────────────────────────────────  │   │
│  │  请求体:    {"name": "test"}                                    │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  响应报文结构:                                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  状态行:    HTTP/1.1 200 OK                                     │   │
│  │  ─────────────────────────────────────────────────────────────  │   │
│  │  响应头:    Content-Type: application/json                      │   │
│  │            Content-Length: 1234                                 │   │
│  │            Cache-Control: max-age=3600                          │   │
│  │  ─────────────────────────────────────────────────────────────  │   │
│  │  空行:      \r\n                                                │   │
│  │  ─────────────────────────────────────────────────────────────  │   │
│  │  响应体:    {"code": 0, "data": {...}}                          │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

#### 2.1.2 HTTP 版本演进

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        HTTP 版本对比                                     │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  HTTP/1.0:                                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  • 每次请求都需要建立新的 TCP 连接                              │   │
│  │  • 无法复用连接，性能较差                                       │   │
│  │  • 不支持 Host 头，无法实现虚拟主机                             │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  HTTP/1.1:                                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  • 默认开启 Keep-Alive，支持连接复用                            │   │
│  │  • 支持管道化 (Pipelining)，但存在队头阻塞问题                  │   │
│  │  • 支持 Host 头，实现虚拟主机                                   │   │
│  │  • 支持断点续传 (Range 头)                                      │   │
│  │  • 支持分块传输 (Chunked Transfer)                              │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  HTTP/2:                                                                │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  • 二进制分帧层，更高效的数据传输                               │   │
│  │  • 多路复用，解决队头阻塞问题                                   │   │
│  │  • 头部压缩 (HPACK)                                             │   │
│  │  • 服务器推送 (Server Push)                                     │   │
│  │  • 请求优先级                                                   │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  HTTP/3 (QUIC):                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  • 基于 UDP 协议                                                │   │
│  │  • 0-RTT 连接建立                                               │   │
│  │  • 解决 TCP 层的队头阻塞                                        │   │
│  │  • 连接迁移 (Connection Migration)                              │   │
│  │  • 内置 TLS 1.3                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

#### 2.1.3 HTTPS 原理

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        HTTPS = HTTP + TLS/SSL                            │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  HTTPS 安全特性:                                                        │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  1. 机密性: 数据加密传输，防止窃听                              │   │
│  │  2. 完整性: 数据校验，防止篡改                                  │   │
│  │  3. 身份认证: 证书验证，防止中间人攻击                          │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  加密方式:                                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  对称加密 (数据传输):                                           │   │
│  │  ┌───────────────────────────────────────────────────────────┐ │   │
│  │  │  • AES-128-GCM / AES-256-GCM                              │ │   │
│  │  │  • 加密解密使用相同密钥                                   │ │   │
│  │  │  • 速度快，适合大量数据加密                               │ │   │
│  │  └───────────────────────────────────────────────────────────┘ │   │
│  │                                                                 │   │
│  │  非对称加密 (密钥交换):                                         │   │
│  │  ┌───────────────────────────────────────────────────────────┐ │   │
│  │  │  • RSA / ECDHE                                            │ │   │
│  │  │  • 公钥加密，私钥解密                                     │ │   │
│  │  │  • 用于安全交换对称密钥                                   │ │   │
│  │  └───────────────────────────────────────────────────────────┘ │   │
│  │                                                                 │   │
│  │  摘要算法 (完整性校验):                                         │   │
│  │  ┌───────────────────────────────────────────────────────────┐ │   │
│  │  │  • SHA-256 / SHA-384                                      │ │   │
│  │  │  • 生成数据指纹，验证数据完整性                           │ │   │
│  │  └───────────────────────────────────────────────────────────┘ │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.2 TCP 三次握手与四次挥手

#### 2.2.1 TCP 三次握手

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        TCP 三次握手流程                                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│     客户端                                              服务端          │
│        │                                                  │             │
│        │  ① SYN=1, seq=x (客户端初始序列号)               │             │
│        │ ─────────────────────────────────────────────────>│             │
│        │                                                  │             │
│  [SYN_SENT]                                         [SYN_RCVD]          │
│        │                                                  │             │
│        │  ② SYN=1, ACK=1, seq=y, ack=x+1                  │             │
│        │ <─────────────────────────────────────────────────│             │
│        │                                                  │             │
│        │  ③ ACK=1, seq=x+1, ack=y+1                       │             │
│        │ ─────────────────────────────────────────────────>│             │
│        │                                                  │             │
│  [ESTABLISHED]                                     [ESTABLISHED]        │
│        │                                                  │             │
│        │  ← 开始数据传输 →                                │             │
│        │                                                  │             │
└─────────────────────────────────────────────────────────────────────────┘

三次握手的目的:
┌─────────────────────────────────────────────────────────────────────────┐
│  1. 确认双方的发送和接收能力                                            │
│     - 第一次握手: 服务端确认客户端发送能力正常                          │
│     - 第二次握手: 客户端确认服务端发送和接收能力正常                    │
│     - 第三次握手: 服务端确认客户端接收能力正常                          │
│                                                                         │
│  2. 同步初始序列号 (ISN)                                                │
│     - 双方交换各自的初始序列号                                          │
│     - 用于后续数据传输的可靠性保证                                      │
│                                                                         │
│  3. 防止历史连接的初始化                                                │
│     - 避免旧的重复连接请求造成混乱                                      │
└─────────────────────────────────────────────────────────────────────────┘
```

#### 2.2.2 TCP 四次挥手

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        TCP 四次挥手流程                                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│     客户端                                              服务端          │
│        │                                                  │             │
│  [ESTABLISHED]                                     [ESTABLISHED]        │
│        │                                                  │             │
│        │  ① FIN=1, seq=u (客户端请求关闭)                 │             │
│        │ ─────────────────────────────────────────────────>│             │
│        │                                                  │             │
│  [FIN_WAIT_1]                                       [CLOSE_WAIT]        │
│        │                                                  │             │
│        │  ② ACK=1, seq=v, ack=u+1                         │             │
│        │ <─────────────────────────────────────────────────│             │
│        │                                                  │             │
│  [FIN_WAIT_2]                                       [CLOSE_WAIT]        │
│        │                                                  │             │
│        │         (服务端可能还有数据要发送)               │             │
│        │                                                  │             │
│        │  ③ FIN=1, ACK=1, seq=w, ack=u+1                  │             │
│        │ <─────────────────────────────────────────────────│             │
│        │                                                  │             │
│  [TIME_WAIT]                                        [LAST_ACK]          │
│        │                                                  │             │
│        │  ④ ACK=1, seq=u+1, ack=w+1                       │             │
│        │ ─────────────────────────────────────────────────>│             │
│        │                                                  │             │
│  [TIME_WAIT]                                         [CLOSED]           │
│        │                                                  │             │
│        │  等待 2MSL (Maximum Segment Lifetime)            │             │
│        │                                                  │             │
│   [CLOSED]                                                              │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘

四次挥手的原因:
┌─────────────────────────────────────────────────────────────────────────┐
│  为什么是四次而不是三次?                                                │
│  ─────────────────────────────────────────────────────────────────────  │
│  • TCP 是全双工通信，双方都可以独立发送数据                             │
│  • 客户端发送 FIN 只表示客户端不再发送数据                              │
│  • 服务端可能还有数据要发送，不能立即关闭                               │
│  • 服务端需要先 ACK 客户端的 FIN，然后发送完数据后再发送自己的 FIN      │
│                                                                         │
│  TIME_WAIT 状态的作用:                                                  │
│  ─────────────────────────────────────────────────────────────────────  │
│  • 确保最后一个 ACK 能够到达服务端                                      │
│  • 等待网络中残留的数据包消失，避免影响新连接                           │
│  • 等待时间: 2MSL (通常为 60 秒)                                        │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.3 TLS 握手过程

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        TLS 1.2 握手流程                                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│     客户端                                              服务端          │
│        │                                                  │             │
│        │  ① ClientHello                                   │             │
│        │    - 支持的 TLS 版本                             │             │
│        │    - 支持的加密套件列表                          │             │
│        │    - 客户端随机数 (Client Random)                │             │
│        │ ─────────────────────────────────────────────────>│             │
│        │                                                  │             │
│        │  ② ServerHello                                   │             │
│        │    - 选定的 TLS 版本                             │             │
│        │    - 选定的加密套件                              │             │
│        │    - 服务端随机数 (Server Random)                │             │
│        │ <─────────────────────────────────────────────────│             │
│        │                                                  │             │
│        │  ③ Certificate (服务端证书)                      │             │
│        │ <─────────────────────────────────────────────────│             │
│        │                                                  │             │
│        │  ④ ServerKeyExchange (可选，ECDHE 需要)          │             │
│        │ <─────────────────────────────────────────────────│             │
│        │                                                  │             │
│        │  ⑤ ServerHelloDone                               │             │
│        │ <─────────────────────────────────────────────────│             │
│        │                                                  │             │
│        │  ⑥ ClientKeyExchange                             │             │
│        │    - 预主密钥 (Pre-Master Secret)                │             │
│        │ ─────────────────────────────────────────────────>│             │
│        │                                                  │             │
│        │  ⑦ ChangeCipherSpec                              │             │
│        │    - 通知开始使用加密通信                        │             │
│        │ ─────────────────────────────────────────────────>│             │
│        │                                                  │             │
│        │  ⑧ Finished (加密的握手摘要)                     │             │
│        │ ─────────────────────────────────────────────────>│             │
│        │                                                  │             │
│        │  ⑨ ChangeCipherSpec                              │             │
│        │ <─────────────────────────────────────────────────│             │
│        │                                                  │             │
│        │  ⑩ Finished                                      │             │
│        │ <─────────────────────────────────────────────────│             │
│        │                                                  │             │
│        │  ← 开始加密数据传输 →                            │             │
│        │                                                  │             │
└─────────────────────────────────────────────────────────────────────────┘

密钥生成过程:
┌─────────────────────────────────────────────────────────────────────────┐
│                                                                         │
│  Master Secret = PRF(Pre-Master Secret,                                 │
│                      "master secret",                                   │
│                      Client Random + Server Random)                     │
│                                                                         │
│  会话密钥 = PRF(Master Secret,                                          │
│                 "key expansion",                                        │
│                 Server Random + Client Random)                          │
│                                                                         │
│  生成的密钥包括:                                                        │
│  • client_write_MAC_key: 客户端 MAC 密钥                                │
│  • server_write_MAC_key: 服务端 MAC 密钥                                │
│  • client_write_key: 客户端加密密钥                                     │
│  • server_write_key: 服务端加密密钥                                     │
│  • client_write_IV: 客户端初始化向量                                    │
│  • server_write_IV: 服务端初始化向量                                    │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        TLS 1.3 握手流程 (简化)                           │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  TLS 1.3 优化:                                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  • 握手只需 1-RTT (首次) 或 0-RTT (恢复)                        │   │
│  │  • 移除不安全的加密算法 (RSA 密钥交换、RC4、SHA-1 等)           │   │
│  │  • 所有握手消息在 ServerHello 后都加密                          │   │
│  │  • 简化密钥交换，只支持 ECDHE 和 DHE                            │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│     客户端                                              服务端          │
│        │                                                  │             │
│        │  ① ClientHello + KeyShare                        │             │
│        │ ─────────────────────────────────────────────────>│             │
│        │                                                  │             │
│        │  ② ServerHello + KeyShare                        │             │
│        │    + EncryptedExtensions                         │             │
│        │    + Certificate                                 │             │
│        │    + CertificateVerify                           │             │
│        │    + Finished                                    │             │
│        │ <─────────────────────────────────────────────────│             │
│        │                                                  │             │
│        │  ③ Finished                                      │             │
│        │ ─────────────────────────────────────────────────>│             │
│        │                                                  │             │
│        │  ← 开始加密数据传输 (1-RTT) →                    │             │
│        │                                                  │             │
└─────────────────────────────────────────────────────────────────────────┘
```


## 3. 关键源码解析

### 3.1 OkHttp 源码分析

#### 3.1.1 OkHttp 整体架构

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        OkHttp 整体架构                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                      OkHttpClient                               │   │
│  │  ┌───────────────────────────────────────────────────────────┐ │   │
│  │  │  • Dispatcher: 请求调度器                                 │ │   │
│  │  │  • ConnectionPool: 连接池                                 │ │   │
│  │  │  • Interceptors: 拦截器列表                               │ │   │
│  │  │  • Cache: 缓存                                            │ │   │
│  │  │  • CookieJar: Cookie 管理                                 │ │   │
│  │  │  • Dns: DNS 解析                                          │ │   │
│  │  │  • SocketFactory: Socket 工厂                             │ │   │
│  │  │  • SSLSocketFactory: SSL Socket 工厂                      │ │   │
│  │  └───────────────────────────────────────────────────────────┘ │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                              │                                          │
│                              ↓                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                        Request                                  │   │
│  │  ┌───────────────────────────────────────────────────────────┐ │   │
│  │  │  • url: 请求 URL                                          │ │   │
│  │  │  • method: 请求方法                                       │ │   │
│  │  │  • headers: 请求头                                        │ │   │
│  │  │  • body: 请求体                                           │ │   │
│  │  └───────────────────────────────────────────────────────────┘ │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                              │                                          │
│                              ↓                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                    RealCall / AsyncCall                         │   │
│  │  ┌───────────────────────────────────────────────────────────┐ │   │
│  │  │  • execute(): 同步执行                                    │ │   │
│  │  │  • enqueue(): 异步执行                                    │ │   │
│  │  │  • getResponseWithInterceptorChain(): 拦截器链执行        │ │   │
│  │  └───────────────────────────────────────────────────────────┘ │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                              │                                          │
│                              ↓                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                    Interceptor Chain                            │   │
│  │  ┌───────────────────────────────────────────────────────────┐ │   │
│  │  │  1. 应用拦截器 (Application Interceptors)                 │ │   │
│  │  │  2. RetryAndFollowUpInterceptor (重试和重定向)            │ │   │
│  │  │  3. BridgeInterceptor (桥接)                              │ │   │
│  │  │  4. CacheInterceptor (缓存)                               │ │   │
│  │  │  5. ConnectInterceptor (连接)                             │ │   │
│  │  │  6. 网络拦截器 (Network Interceptors)                     │ │   │
│  │  │  7. CallServerInterceptor (请求服务器)                    │ │   │
│  │  └───────────────────────────────────────────────────────────┘ │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                              │                                          │
│                              ↓                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                        Response                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

#### 3.1.2 拦截器链核心源码

```kotlin
/**
 * RealCall.getResponseWithInterceptorChain()
 * 拦截器链的核心实现 - 责任链模式
 * 源码位置: okhttp3/internal/http/RealInterceptorChain.kt
 */
@Throws(IOException::class)
internal fun getResponseWithInterceptorChain(): Response {
    // 构建完整的拦截器列表
    val interceptors = mutableListOf<Interceptor>()
    
    // 1. 添加应用拦截器 (用户自定义，最先执行)
    interceptors += client.interceptors
    
    // 2. 添加核心拦截器
    interceptors += RetryAndFollowUpInterceptor(client)  // 重试和重定向
    interceptors += BridgeInterceptor(client.cookieJar)  // 桥接处理
    interceptors += CacheInterceptor(client.cache)       // 缓存处理
    interceptors += ConnectInterceptor                   // 建立连接
    
    // 3. 添加网络拦截器 (只在真正网络请求时执行)
    if (!forWebSocket) {
        interceptors += client.networkInterceptors
    }
    
    // 4. 添加最终的请求拦截器
    interceptors += CallServerInterceptor(forWebSocket)
    
    // 5. 创建拦截器链
    val chain = RealInterceptorChain(
        call = this,
        interceptors = interceptors,
        index = 0,                    // 从第一个拦截器开始
        exchange = null,
        request = originalRequest,
        connectTimeoutMillis = client.connectTimeoutMillis,
        readTimeoutMillis = client.readTimeoutMillis,
        writeTimeoutMillis = client.writeTimeoutMillis
    )
    
    var calledNoMoreExchanges = false
    try {
        // 6. 开始执行拦截器链
        val response = chain.proceed(originalRequest)
        
        if (isCanceled()) {
            response.closeQuietly()
            throw IOException("Canceled")
        }
        
        return response
    } catch (e: IOException) {
        calledNoMoreExchanges = true
        throw noMoreExchanges(e) as Throwable
    } finally {
        if (!calledNoMoreExchanges) {
            noMoreExchanges(null)
        }
    }
}

/**
 * RealInterceptorChain.proceed()
 * 拦截器链的执行逻辑
 */
@Throws(IOException::class)
override fun proceed(request: Request): Response {
    // 检查是否还有拦截器
    check(index < interceptors.size)
    
    calls++
    
    // 如果已经有 Exchange，检查请求 URL 是否匹配
    if (exchange != null) {
        check(exchange.finder.sameHostAndPort(request.url)) {
            "network interceptor ${interceptors[index - 1]} must retain the same host and port"
        }
        check(calls == 1) {
            "network interceptor ${interceptors[index - 1]} must call proceed() exactly once"
        }
    }
    
    // 创建下一个拦截器链节点 (index + 1)
    val next = copy(index = index + 1, request = request)
    
    // 获取当前拦截器
    val interceptor = interceptors[index]
    
    // 执行当前拦截器，传入下一个链节点
    // 拦截器内部会调用 chain.proceed() 继续执行下一个拦截器
    @Suppress("USELESS_ELVIS")
    val response = interceptor.intercept(next) ?: throw NullPointerException(
        "interceptor $interceptor returned null"
    )
    
    // 检查响应体
    if (exchange != null) {
        check(index + 1 >= interceptors.size || next.calls == 1) {
            "network interceptor $interceptor must call proceed() exactly once"
        }
    }
    
    check(response.body != null) { "interceptor $interceptor returned a response with no body" }
    
    return response
}
```

#### 3.1.3 各拦截器详解

```kotlin
/**
 * 1. RetryAndFollowUpInterceptor - 重试和重定向拦截器
 * 负责失败重试和处理重定向
 */
class RetryAndFollowUpInterceptor(private val client: OkHttpClient) : Interceptor {
    
    companion object {
        private const val MAX_FOLLOW_UPS = 20  // 最大重定向次数
    }
    
    @Throws(IOException::class)
    override fun intercept(chain: Interceptor.Chain): Response {
        val realChain = chain as RealInterceptorChain
        var request = chain.request
        val call = realChain.call
        var followUpCount = 0
        var priorResponse: Response? = null
        var newExchangeFinder = true
        var recoveredFailures = listOf<IOException>()
        
        while (true) {
            // 准备连接
            call.enterNetworkInterceptorExchange(request, newExchangeFinder)
            
            var response: Response
            var closeActiveExchange = true
            try {
                if (call.isCanceled()) {
                    throw IOException("Canceled")
                }
                
                try {
                    // 执行下一个拦截器
                    response = realChain.proceed(request)
                    newExchangeFinder = true
                } catch (e: RouteException) {
                    // 路由异常，尝试恢复
                    if (!recover(e.lastConnectException, call, request, requestSendStarted = false)) {
                        throw e.firstConnectException.withSuppressed(recoveredFailures)
                    }
                    recoveredFailures += e.firstConnectException
                    newExchangeFinder = false
                    continue  // 重试
                } catch (e: IOException) {
                    // IO 异常，尝试恢复
                    if (!recover(e, call, request, requestSendStarted = e !is ConnectionShutdownException)) {
                        throw e.withSuppressed(recoveredFailures)
                    }
                    recoveredFailures += e
                    newExchangeFinder = false
                    continue  // 重试
                }
                
                // 构建响应
                if (priorResponse != null) {
                    response = response.newBuilder()
                        .priorResponse(priorResponse.newBuilder().body(null).build())
                        .build()
                }
                
                val exchange = call.interceptorScopedExchange
                
                // 检查是否需要重定向
                val followUp = followUpRequest(response, exchange)
                
                if (followUp == null) {
                    // 不需要重定向，返回响应
                    if (exchange != null && exchange.isDuplex) {
                        call.timeoutEarlyExit()
                    }
                    closeActiveExchange = false
                    return response
                }
                
                // 检查重定向次数
                if (++followUpCount > MAX_FOLLOW_UPS) {
                    throw ProtocolException("Too many follow-up requests: $followUpCount")
                }
                
                // 准备重定向请求
                request = followUp
                priorResponse = response
                
            } finally {
                call.exitNetworkInterceptorExchange(closeActiveExchange)
            }
        }
    }
    
    /**
     * 判断是否可以恢复
     */
    private fun recover(
        e: IOException,
        call: RealCall,
        userRequest: Request,
        requestSendStarted: Boolean
    ): Boolean {
        // 客户端配置不允许重试
        if (!client.retryOnConnectionFailure) return false
        
        // 请求体只能发送一次
        if (requestSendStarted && requestIsOneShot(e, userRequest)) return false
        
        // 致命异常不重试
        if (!isRecoverable(e, requestSendStarted)) return false
        
        // 没有更多路由可尝试
        if (!call.retryAfterFailure()) return false
        
        return true
    }
}

/**
 * 2. BridgeInterceptor - 桥接拦截器
 * 负责添加请求头、处理 Gzip 压缩等
 */
class BridgeInterceptor(private val cookieJar: CookieJar) : Interceptor {
    
    @Throws(IOException::class)
    override fun intercept(chain: Interceptor.Chain): Response {
        val userRequest = chain.request()
        val requestBuilder = userRequest.newBuilder()
        
        val body = userRequest.body
        
        // 添加 Content-Type
        if (body != null) {
            val contentType = body.contentType()
            if (contentType != null) {
                requestBuilder.header("Content-Type", contentType.toString())
            }
            
            // 添加 Content-Length 或 Transfer-Encoding
            val contentLength = body.contentLength()
            if (contentLength != -1L) {
                requestBuilder.header("Content-Length", contentLength.toString())
                requestBuilder.removeHeader("Transfer-Encoding")
            } else {
                requestBuilder.header("Transfer-Encoding", "chunked")
                requestBuilder.removeHeader("Content-Length")
            }
        }
        
        // 添加 Host
        if (userRequest.header("Host") == null) {
            requestBuilder.header("Host", userRequest.url.toHostHeader())
        }
        
        // 添加 Connection: Keep-Alive
        if (userRequest.header("Connection") == null) {
            requestBuilder.header("Connection", "Keep-Alive")
        }
        
        // 添加 Accept-Encoding: gzip (如果用户没有指定)
        var transparentGzip = false
        if (userRequest.header("Accept-Encoding") == null && 
            userRequest.header("Range") == null) {
            transparentGzip = true
            requestBuilder.header("Accept-Encoding", "gzip")
        }
        
        // 添加 Cookie
        val cookies = cookieJar.loadForRequest(userRequest.url)
        if (cookies.isNotEmpty()) {
            requestBuilder.header("Cookie", cookieHeader(cookies))
        }
        
        // 添加 User-Agent
        if (userRequest.header("User-Agent") == null) {
            requestBuilder.header("User-Agent", userAgent)
        }
        
        // 执行请求
        val networkResponse = chain.proceed(requestBuilder.build())
        
        // 保存 Cookie
        cookieJar.receiveHeaders(userRequest.url, networkResponse.headers)
        
        // 构建响应
        val responseBuilder = networkResponse.newBuilder()
            .request(userRequest)
        
        // 处理 Gzip 解压
        if (transparentGzip &&
            "gzip".equals(networkResponse.header("Content-Encoding"), ignoreCase = true) &&
            networkResponse.promisesBody()) {
            val responseBody = networkResponse.body
            if (responseBody != null) {
                val gzipSource = GzipSource(responseBody.source())
                val strippedHeaders = networkResponse.headers.newBuilder()
                    .removeAll("Content-Encoding")
                    .removeAll("Content-Length")
                    .build()
                responseBuilder.headers(strippedHeaders)
                val contentType = networkResponse.header("Content-Type")
                responseBuilder.body(RealResponseBody(contentType, -1L, gzipSource.buffer()))
            }
        }
        
        return responseBuilder.build()
    }
}

/**
 * 3. CacheInterceptor - 缓存拦截器
 * 负责缓存的读取和写入
 */
class CacheInterceptor(internal val cache: Cache?) : Interceptor {
    
    @Throws(IOException::class)
    override fun intercept(chain: Interceptor.Chain): Response {
        val call = chain.call()
        
        // 尝试从缓存获取响应
        val cacheCandidate = cache?.get(chain.request())
        
        val now = System.currentTimeMillis()
        
        // 缓存策略：决定使用缓存还是网络
        val strategy = CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()
        val networkRequest = strategy.networkRequest  // 网络请求 (null 表示不需要网络)
        val cacheResponse = strategy.cacheResponse    // 缓存响应 (null 表示缓存不可用)
        
        cache?.trackResponse(strategy)
        
        val listener = (call as? RealCall)?.eventListener ?: EventListener.NONE
        
        // 缓存不可用，关闭缓存候选
        if (cacheCandidate != null && cacheResponse == null) {
            cacheCandidate.body?.closeQuietly()
        }
        
        // 不需要网络且没有缓存，返回 504
        if (networkRequest == null && cacheResponse == null) {
            return Response.Builder()
                .request(chain.request())
                .protocol(Protocol.HTTP_1_1)
                .code(HTTP_GATEWAY_TIMEOUT)
                .message("Unsatisfiable Request (only-if-cached)")
                .body(EMPTY_RESPONSE)
                .sentRequestAtMillis(-1L)
                .receivedResponseAtMillis(System.currentTimeMillis())
                .build().also {
                    listener.satisfactionFailure(call, it)
                }
        }
        
        // 不需要网络，直接返回缓存
        if (networkRequest == null) {
            return cacheResponse!!.newBuilder()
                .cacheResponse(stripBody(cacheResponse))
                .build().also {
                    listener.cacheHit(call, it)
                }
        }
        
        // 需要网络请求
        if (cacheResponse != null) {
            listener.cacheConditionalHit(call, cacheResponse)
        } else if (cache != null) {
            listener.cacheMiss(call)
        }
        
        var networkResponse: Response? = null
        try {
            // 执行网络请求
            networkResponse = chain.proceed(networkRequest)
        } finally {
            if (networkResponse == null && cacheCandidate != null) {
                cacheCandidate.body?.closeQuietly()
            }
        }
        
        // 有缓存，检查是否 304 Not Modified
        if (cacheResponse != null) {
            if (networkResponse?.code == HTTP_NOT_MODIFIED) {
                // 304，使用缓存
                val response = cacheResponse.newBuilder()
                    .headers(combine(cacheResponse.headers, networkResponse.headers))
                    .sentRequestAtMillis(networkResponse.sentRequestAtMillis)
                    .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis)
                    .cacheResponse(stripBody(cacheResponse))
                    .networkResponse(stripBody(networkResponse))
                    .build()
                
                networkResponse.body!!.close()
                
                // 更新缓存
                cache!!.trackConditionalCacheHit()
                cache.update(cacheResponse, response)
                return response.also {
                    listener.cacheHit(call, it)
                }
            } else {
                cacheResponse.body?.closeQuietly()
            }
        }
        
        // 使用网络响应
        val response = networkResponse!!.newBuilder()
            .cacheResponse(stripBody(cacheResponse))
            .networkResponse(stripBody(networkResponse))
            .build()
        
        // 写入缓存
        if (cache != null) {
            if (response.promisesBody() && CacheStrategy.isCacheable(response, networkRequest)) {
                val cacheRequest = cache.put(response)
                return cacheWritingResponse(cacheRequest, response).also {
                    if (cacheResponse != null) {
                        listener.cacheMiss(call)
                    }
                }
            }
            
            // 不可缓存的请求方法，移除缓存
            if (HttpMethod.invalidatesCache(networkRequest.method)) {
                try {
                    cache.remove(networkRequest)
                } catch (_: IOException) {
                }
            }
        }
        
        return response
    }
}
```


```kotlin
/**
 * 4. ConnectInterceptor - 连接拦截器
 * 负责建立与服务器的连接
 */
object ConnectInterceptor : Interceptor {
    
    @Throws(IOException::class)
    override fun intercept(chain: Interceptor.Chain): Response {
        val realChain = chain as RealInterceptorChain
        
        // 获取或创建 Exchange (封装了连接和编解码器)
        val exchange = realChain.call.initExchange(chain)
        
        // 创建新的拦截器链，包含 Exchange
        val connectedChain = realChain.copy(exchange = exchange)
        
        // 继续执行下一个拦截器
        return connectedChain.proceed(chain.request)
    }
}

/**
 * 5. CallServerInterceptor - 请求服务器拦截器
 * 负责真正的网络 I/O 操作
 */
class CallServerInterceptor(private val forWebSocket: Boolean) : Interceptor {
    
    @Throws(IOException::class)
    override fun intercept(chain: Interceptor.Chain): Response {
        val realChain = chain as RealInterceptorChain
        val exchange = realChain.exchange!!
        val request = realChain.request
        val requestBody = request.body
        
        var invokeStartEvent = true
        var responseBuilder: Response.Builder? = null
        
        // 写入请求头
        exchange.writeRequestHeaders(request)
        
        // 处理请求体
        if (HttpMethod.permitsRequestBody(request.method) && requestBody != null) {
            // 如果有 Expect: 100-continue，先等待服务器响应
            if ("100-continue".equals(request.header("Expect"), ignoreCase = true)) {
                exchange.flushRequest()
                responseBuilder = exchange.readResponseHeaders(expectContinue = true)
                exchange.responseHeadersStart()
                invokeStartEvent = false
            }
            
            if (responseBuilder == null) {
                // 写入请求体
                if (requestBody.isDuplex()) {
                    // 双工模式
                    exchange.flushRequest()
                    val bufferedRequestBody = exchange.createRequestBody(request, true).buffer()
                    requestBody.writeTo(bufferedRequestBody)
                } else {
                    // 普通模式
                    val bufferedRequestBody = exchange.createRequestBody(request, false).buffer()
                    requestBody.writeTo(bufferedRequestBody)
                    bufferedRequestBody.close()
                }
            } else {
                // 服务器拒绝请求体
                exchange.noRequestBody()
                if (!exchange.connection.isMultiplexed) {
                    exchange.noNewExchangesOnConnection()
                }
            }
        } else {
            exchange.noRequestBody()
        }
        
        // 完成请求
        if (requestBody == null || !requestBody.isDuplex()) {
            exchange.finishRequest()
        }
        
        // 读取响应头
        if (responseBuilder == null) {
            responseBuilder = exchange.readResponseHeaders(expectContinue = false)!!
            if (invokeStartEvent) {
                exchange.responseHeadersStart()
                invokeStartEvent = false
            }
        }
        
        // 构建响应
        var response = responseBuilder
            .request(request)
            .handshake(exchange.connection.handshake())
            .sentRequestAtMillis(exchange.sentRequestAtMillis)
            .receivedResponseAtMillis(System.currentTimeMillis())
            .build()
        
        var code = response.code
        
        // 处理 100 Continue
        if (code == 100) {
            responseBuilder = exchange.readResponseHeaders(expectContinue = false)!!
            if (invokeStartEvent) {
                exchange.responseHeadersStart()
            }
            response = responseBuilder
                .request(request)
                .handshake(exchange.connection.handshake())
                .sentRequestAtMillis(exchange.sentRequestAtMillis)
                .receivedResponseAtMillis(System.currentTimeMillis())
                .build()
            code = response.code
        }
        
        exchange.responseHeadersEnd(response)
        
        // 读取响应体
        response = if (forWebSocket && code == 101) {
            response.newBuilder()
                .body(EMPTY_RESPONSE)
                .build()
        } else {
            response.newBuilder()
                .body(exchange.openResponseBody(response))
                .build()
        }
        
        // 处理 Connection: close
        if ("close".equals(response.request.header("Connection"), ignoreCase = true) ||
            "close".equals(response.header("Connection"), ignoreCase = true)) {
            exchange.noNewExchangesOnConnection()
        }
        
        // 检查响应体
        if ((code == 204 || code == 205) && response.body?.contentLength() ?: -1L > 0L) {
            throw ProtocolException(
                "HTTP $code had non-zero Content-Length: ${response.body?.contentLength()}"
            )
        }
        
        return response
    }
}
```

#### 3.1.4 连接池源码分析

```kotlin
/**
 * ConnectionPool - 连接池
 * 负责管理和复用 HTTP 连接
 * 源码位置: okhttp3/ConnectionPool.kt
 */
class ConnectionPool internal constructor(
    internal val delegate: RealConnectionPool
) {
    constructor(
        maxIdleConnections: Int = 5,           // 最大空闲连接数
        keepAliveDuration: Long = 5,           // 保活时间
        timeUnit: TimeUnit = TimeUnit.MINUTES  // 时间单位
    ) : this(RealConnectionPool(
        taskRunner = TaskRunner.INSTANCE,
        maxIdleConnections = maxIdleConnections,
        keepAliveDuration = keepAliveDuration,
        timeUnit = timeUnit
    ))
    
    /** 当前空闲连接数 */
    fun idleConnectionCount(): Int = delegate.idleConnectionCount()
    
    /** 当前总连接数 */
    fun connectionCount(): Int = delegate.connectionCount()
    
    /** 清除所有空闲连接 */
    fun evictAll() {
        delegate.evictAll()
    }
}

/**
 * RealConnectionPool - 连接池的真正实现
 */
class RealConnectionPool(
    taskRunner: TaskRunner,
    private val maxIdleConnections: Int,
    keepAliveDuration: Long,
    timeUnit: TimeUnit
) {
    // 保活时间 (纳秒)
    private val keepAliveDurationNs: Long = timeUnit.toNanos(keepAliveDuration)
    
    // 清理任务
    private val cleanupQueue: TaskQueue = taskRunner.newQueue()
    private val cleanupTask = object : Task("$okHttpName ConnectionPool") {
        override fun runOnce() = cleanup(System.nanoTime())
    }
    
    // 连接列表 (使用 ConcurrentLinkedQueue 保证线程安全)
    private val connections = ConcurrentLinkedQueue<RealConnection>()
    
    /**
     * 尝试获取一个可复用的连接
     */
    fun callAcquirePooledConnection(
        address: Address,
        call: RealCall,
        routes: List<Route>?,
        requireMultiplexed: Boolean
    ): Boolean {
        // 遍历连接池中的连接
        for (connection in connections) {
            synchronized(connection) {
                // 检查是否需要多路复用
                if (requireMultiplexed && !connection.isMultiplexed) return@synchronized
                
                // 检查连接是否可用于该地址
                if (!connection.isEligible(address, routes)) return@synchronized
                
                // 获取连接
                call.acquireConnectionNoEvents(connection)
                return true
            }
        }
        return false
    }
    
    /**
     * 将连接放入连接池
     */
    fun put(connection: RealConnection) {
        connection.assertThreadHoldsLock()
        
        connections.add(connection)
        
        // 启动清理任务
        cleanupQueue.schedule(cleanupTask, 0L)
    }
    
    /**
     * 连接变为空闲时调用
     */
    fun connectionBecameIdle(connection: RealConnection): Boolean {
        connection.assertThreadHoldsLock()
        
        // 如果连接不可保活或超过最大空闲连接数，移除连接
        return if (connection.noNewExchanges || maxIdleConnections == 0) {
            connection.noNewExchanges = true
            connections.remove(connection)
            true
        } else {
            // 启动清理任务
            cleanupQueue.schedule(cleanupTask, 0L)
            false
        }
    }
    
    /**
     * 清理过期连接
     * 返回下次清理的等待时间
     */
    fun cleanup(now: Long): Long {
        var inUseConnectionCount = 0      // 使用中的连接数
        var idleConnectionCount = 0       // 空闲连接数
        var longestIdleConnection: RealConnection? = null  // 最长空闲连接
        var longestIdleDurationNs = Long.MIN_VALUE         // 最长空闲时间
        
        // 遍历所有连接
        for (connection in connections) {
            synchronized(connection) {
                // 统计连接状态
                if (pruneAndGetAllocationCount(connection, now) > 0) {
                    inUseConnectionCount++
                } else {
                    idleConnectionCount++
                    
                    // 找出空闲时间最长的连接
                    val idleDurationNs = now - connection.idleAtNs
                    if (idleDurationNs > longestIdleDurationNs) {
                        longestIdleDurationNs = idleDurationNs
                        longestIdleConnection = connection
                    }
                }
            }
        }
        
        when {
            // 空闲时间超过保活时间，或空闲连接数超过最大值
            longestIdleDurationNs >= this.keepAliveDurationNs ||
            idleConnectionCount > this.maxIdleConnections -> {
                // 移除最长空闲连接
                val connection = longestIdleConnection!!
                synchronized(connection) {
                    if (connection.calls.isNotEmpty()) return 0L
                    if (connection.idleAtNs + longestIdleDurationNs != now) return 0L
                    connection.noNewExchanges = true
                    connections.remove(longestIdleConnection)
                }
                
                connection.socket().closeQuietly()
                
                // 立即再次清理
                return 0L
            }
            
            // 有空闲连接，等待到期后清理
            idleConnectionCount > 0 -> {
                return keepAliveDurationNs - longestIdleDurationNs
            }
            
            // 有使用中的连接，等待保活时间后清理
            inUseConnectionCount > 0 -> {
                return keepAliveDurationNs
            }
            
            // 没有连接，不需要清理
            else -> {
                return -1
            }
        }
    }
}
```


```
┌─────────────────────────────────────────────────────────────────────────┐
│                        连接池工作流程                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  请求到来                                                               │
│      │                                                                  │
│      ↓                                                                  │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  1. 查找可复用连接                                              │   │
│  │     - 遍历连接池                                                │   │
│  │     - 检查 Address 是否匹配 (host, port, proxy, ssl)            │   │
│  │     - 检查连接是否健康                                          │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│      │                                                                  │
│      ├── 找到可复用连接 ──→ 直接使用                                   │
│      │                                                                  │
│      ↓ 没有可复用连接                                                   │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  2. 创建新连接                                                  │   │
│  │     - DNS 解析                                                  │   │
│  │     - TCP 三次握手                                              │   │
│  │     - TLS 握手 (HTTPS)                                          │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│      │                                                                  │
│      ↓                                                                  │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  3. 执行请求                                                    │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│      │                                                                  │
│      ↓                                                                  │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  4. 请求完成，连接放回连接池                                    │   │
│  │     - 标记为空闲                                                │   │
│  │     - 启动清理任务                                              │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│      │                                                                  │
│      ↓                                                                  │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  5. 清理任务                                                    │   │
│  │     - 检查空闲连接数是否超过 maxIdleConnections (默认 5)        │   │
│  │     - 检查空闲时间是否超过 keepAliveDuration (默认 5 分钟)      │   │
│  │     - 移除过期连接                                              │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Retrofit 源码分析

#### 3.2.1 Retrofit 整体架构

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        Retrofit 整体架构                                 │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                        Retrofit                                 │   │
│  │  ┌───────────────────────────────────────────────────────────┐ │   │
│  │  │  • baseUrl: 基础 URL                                      │ │   │
│  │  │  • callFactory: OkHttpClient                              │ │   │
│  │  │  • converterFactories: 数据转换器工厂列表                 │ │   │
│  │  │  • callAdapterFactories: Call 适配器工厂列表              │ │   │
│  │  │  • callbackExecutor: 回调执行器                           │ │   │
│  │  └───────────────────────────────────────────────────────────┘ │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                              │                                          │
│                              │ create(ApiService::class.java)           │
│                              ↓                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                    动态代理 (Proxy)                             │   │
│  │  ┌───────────────────────────────────────────────────────────┐ │   │
│  │  │  • 拦截接口方法调用                                       │ │   │
│  │  │  • 解析方法注解 (@GET, @POST, @Query 等)                  │ │   │
│  │  │  • 创建 ServiceMethod                                     │ │   │
│  │  └───────────────────────────────────────────────────────────┘ │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                              │                                          │
│                              ↓                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                    ServiceMethod                                │   │
│  │  ┌───────────────────────────────────────────────────────────┐ │   │
│  │  │  • RequestFactory: 构建 OkHttp Request                    │ │   │
│  │  │  • CallAdapter: 适配返回类型 (Call, Observable, Flow)     │ │   │
│  │  │  • ResponseConverter: 转换响应数据                        │ │   │
│  │  └───────────────────────────────────────────────────────────┘ │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                              │                                          │
│                              ↓                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                    OkHttpCall                                   │   │
│  │  ┌───────────────────────────────────────────────────────────┐ │   │
│  │  │  • 封装 OkHttp 的 Call                                    │ │   │
│  │  │  • 执行网络请求                                           │ │   │
│  │  │  • 转换响应数据                                           │ │   │
│  │  └───────────────────────────────────────────────────────────┘ │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

#### 3.2.2 动态代理核心源码

```kotlin
/**
 * Retrofit.create() - 创建 API 接口的动态代理
 * 这是 Retrofit 的核心方法
 */
@Suppress("UNCHECKED_CAST")
fun <T> create(service: Class<T>): T {
    // 1. 验证接口
    validateServiceInterface(service)
    
    // 2. 创建动态代理
    return Proxy.newProxyInstance(
        service.classLoader,
        arrayOf<Class<*>>(service),
        object : InvocationHandler {
            private val platform = Platform.get()
            private val emptyArgs = arrayOfNulls<Any>(0)
            
            @Throws(Throwable::class)
            override fun invoke(proxy: Any, method: Method, args: Array<Any>?): Any? {
                // 3. 如果是 Object 的方法，直接调用
                if (method.declaringClass == Any::class.java) {
                    return method.invoke(this, *(args ?: emptyArgs))
                }
                
                val arguments = args ?: emptyArgs
                
                // 4. 如果是接口的默认方法 (Java 8+)
                return if (platform.isDefaultMethod(method)) {
                    platform.invokeDefaultMethod(method, service, proxy, *arguments)
                } else {
                    // 5. 加载 ServiceMethod 并执行
                    loadServiceMethod(method).invoke(arguments)
                }
            }
        }
    ) as T
}

/**
 * 验证服务接口
 */
private fun validateServiceInterface(service: Class<*>) {
    // 必须是接口
    if (!service.isInterface) {
        throw IllegalArgumentException("API declarations must be interfaces.")
    }
    
    // 不能有泛型参数
    if (service.typeParameters.isNotEmpty()) {
        throw IllegalArgumentException(
            "Type parameters are unsupported on ${service.name}"
        )
    }
    
    // 检查父接口
    val check = ArrayDeque<Class<*>>()
    check.add(service)
    while (check.isNotEmpty()) {
        val candidate = check.removeFirst()
        if (candidate.typeParameters.isNotEmpty()) {
            val message = StringBuilder("Type parameters are unsupported on ")
                .append(candidate.name)
            if (candidate != service) {
                message.append(" which is an interface of ").append(service.name)
            }
            throw IllegalArgumentException(message.toString())
        }
        check.addAll(candidate.interfaces)
    }
    
    // 预加载所有方法 (可选，提前验证)
    if (validateEagerly) {
        for (method in service.declaredMethods) {
            if (!platform.isDefaultMethod(method) && 
                !Modifier.isStatic(method.modifiers) &&
                !method.isSynthetic) {
                loadServiceMethod(method)
            }
        }
    }
}

/**
 * 加载 ServiceMethod (带缓存)
 */
fun loadServiceMethod(method: Method): ServiceMethod<*> {
    // 先从缓存获取
    var result = serviceMethodCache[method]
    if (result != null) return result
    
    // 加锁创建
    synchronized(serviceMethodCache) {
        result = serviceMethodCache[method]
        if (result == null) {
            // 解析方法注解，创建 ServiceMethod
            result = ServiceMethod.parseAnnotations<Any>(this, method)
            serviceMethodCache[method] = result
        }
    }
    return result!!
}
```

#### 3.2.3 ServiceMethod 解析源码

```kotlin
/**
 * ServiceMethod - 封装 API 方法的所有信息
 */
abstract class ServiceMethod<T> {
    
    abstract fun invoke(args: Array<Any?>): T
    
    companion object {
        /**
         * 解析方法注解，创建 ServiceMethod
         */
        fun <T> parseAnnotations(retrofit: Retrofit, method: Method): ServiceMethod<T> {
            // 1. 创建 RequestFactory (解析请求相关注解)
            val requestFactory = RequestFactory.parseAnnotations(retrofit, method)
            
            // 2. 获取返回类型
            val returnType = method.genericReturnType
            if (Utils.hasUnresolvableType(returnType)) {
                throw methodError(method, 
                    "Method return type must not include a type variable or wildcard: %s", 
                    returnType)
            }
            if (returnType === Void.TYPE) {
                throw methodError(method, "Service methods cannot return void.")
            }
            
            // 3. 创建 HttpServiceMethod
            return HttpServiceMethod.parseAnnotations<Any, T>(retrofit, method, requestFactory)
        }
    }
}

/**
 * HttpServiceMethod - HTTP 请求的 ServiceMethod 实现
 */
internal abstract class HttpServiceMethod<ResponseT, ReturnT>(
    private val requestFactory: RequestFactory,
    private val callFactory: okhttp3.Call.Factory,
    private val responseConverter: Converter<ResponseBody, ResponseT>
) : ServiceMethod<ReturnT>() {
    
    override fun invoke(args: Array<Any?>): ReturnT {
        // 创建 OkHttpCall
        val call = OkHttpCall(requestFactory, args, callFactory, responseConverter)
        // 适配返回类型
        return adapt(call, args)
    }
    
    protected abstract fun adapt(call: Call<ResponseT>, args: Array<Any?>): ReturnT
    
    companion object {
        fun <ResponseT, ReturnT> parseAnnotations(
            retrofit: Retrofit,
            method: Method,
            requestFactory: RequestFactory
        ): HttpServiceMethod<ResponseT, ReturnT> {
            
            val isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction
            var continuationWantsResponse = false
            var continuationBodyNullable = false
            
            val annotations = method.annotations
            val adapterType: Type
            
            if (isKotlinSuspendFunction) {
                // Kotlin 挂起函数处理
                val parameterTypes = method.genericParameterTypes
                val responseType = Utils.getParameterLowerBound(
                    0, 
                    parameterTypes[parameterTypes.size - 1] as ParameterizedType
                )
                
                // 检查是否返回 Response<T>
                if (getRawType(responseType) == Response::class.java && 
                    responseType is ParameterizedType) {
                    responseType = Utils.getParameterUpperBound(0, responseType)
                    continuationWantsResponse = true
                }
                
                adapterType = ParameterizedTypeImpl(null, Call::class.java, responseType)
                annotations = SkipCallbackExecutorImpl.ensurePresent(annotations)
            } else {
                adapterType = method.genericReturnType
            }
            
            // 获取 CallAdapter
            val callAdapter = createCallAdapter<ResponseT, ReturnT>(
                retrofit, method, adapterType, annotations
            )
            
            val responseType = callAdapter.responseType()
            
            // 获取 ResponseConverter
            val responseConverter = createResponseConverter<ResponseT>(
                retrofit, method, responseType
            )
            
            val callFactory = retrofit.callFactory
            
            // 根据是否是挂起函数返回不同的实现
            return if (!isKotlinSuspendFunction) {
                CallAdapted(requestFactory, callFactory, responseConverter, callAdapter)
            } else if (continuationWantsResponse) {
                SuspendForResponse(requestFactory, callFactory, responseConverter, callAdapter)
            } else {
                SuspendForBody(requestFactory, callFactory, responseConverter, callAdapter, 
                    continuationBodyNullable)
            }
        }
    }
    
    /**
     * 普通方法的实现
     */
    internal class CallAdapted<ResponseT, ReturnT>(
        requestFactory: RequestFactory,
        callFactory: okhttp3.Call.Factory,
        responseConverter: Converter<ResponseBody, ResponseT>,
        private val callAdapter: CallAdapter<ResponseT, ReturnT>
    ) : HttpServiceMethod<ResponseT, ReturnT>(requestFactory, callFactory, responseConverter) {
        
        override fun adapt(call: Call<ResponseT>, args: Array<Any?>): ReturnT {
            return callAdapter.adapt(call)
        }
    }
    
    /**
     * Kotlin 挂起函数的实现 (返回 Response)
     */
    internal class SuspendForResponse<ResponseT, ReturnT>(
        requestFactory: RequestFactory,
        callFactory: okhttp3.Call.Factory,
        responseConverter: Converter<ResponseBody, ResponseT>,
        private val callAdapter: CallAdapter<ResponseT, ReturnT>
    ) : HttpServiceMethod<ResponseT, ReturnT>(requestFactory, callFactory, responseConverter) {
        
        override fun adapt(call: Call<ResponseT>, args: Array<Any?>): ReturnT {
            call as Call<ResponseT>
            val continuation = args.last() as Continuation<Response<ResponseT>>
            
            return try {
                // 使用协程执行请求
                KotlinExtensions.awaitResponse(call, continuation)
            } catch (e: Exception) {
                KotlinExtensions.suspendAndThrow(e, continuation)
            } as ReturnT
        }
    }
}
```


#### 3.2.4 RequestFactory 解析源码

```kotlin
/**
 * RequestFactory - 解析方法注解，构建 OkHttp Request
 */
internal class RequestFactory private constructor(
    val method: Method,
    val baseUrl: HttpUrl,
    val httpMethod: String,
    val relativeUrl: String?,
    val headers: Headers?,
    val contentType: MediaType?,
    val hasBody: Boolean,
    val isFormEncoded: Boolean,
    val isMultipart: Boolean,
    val parameterHandlers: Array<ParameterHandler<*>>,
    val isKotlinSuspendFunction: Boolean
) {
    
    /**
     * 创建 OkHttp Request
     */
    fun create(args: Array<Any?>): okhttp3.Request {
        val requestBuilder = RequestBuilder(
            httpMethod, baseUrl, relativeUrl, headers, contentType, 
            hasBody, isFormEncoded, isMultipart
        )
        
        // 处理参数
        val argumentCount = args.size
        val handlers = parameterHandlers
        
        for (i in 0 until argumentCount) {
            handlers[i].apply(requestBuilder, args[i])
        }
        
        return requestBuilder.get().tag(Invocation::class.java, 
            Invocation.of(method, args.toList())).build()
    }
    
    companion object {
        /**
         * 解析方法注解
         */
        fun parseAnnotations(retrofit: Retrofit, method: Method): RequestFactory {
            return Builder(retrofit, method).build()
        }
    }
    
    /**
     * Builder - 解析注解的构建器
     */
    internal class Builder(
        private val retrofit: Retrofit,
        private val method: Method
    ) {
        private val methodAnnotations: Array<Annotation> = method.annotations
        private val parameterTypes: Array<Type> = method.genericParameterTypes
        private val parameterAnnotationsArray: Array<Array<Annotation>> = 
            method.parameterAnnotations
        
        private var httpMethod: String? = null
        private var hasBody = false
        private var relativeUrl: String? = null
        private var headers: Headers? = null
        private var contentType: MediaType? = null
        private var isFormEncoded = false
        private var isMultipart = false
        private var parameterHandlers: Array<ParameterHandler<*>>? = null
        private var isKotlinSuspendFunction = false
        
        fun build(): RequestFactory {
            // 1. 解析方法注解 (@GET, @POST, @Headers 等)
            for (annotation in methodAnnotations) {
                parseMethodAnnotation(annotation)
            }
            
            // 验证 HTTP 方法
            if (httpMethod == null) {
                throw methodError(method, "HTTP method annotation is required (e.g., @GET, @POST, etc.).")
            }
            
            // 2. 解析参数注解 (@Path, @Query, @Body 等)
            val parameterCount = parameterAnnotationsArray.size
            parameterHandlers = arrayOfNulls<ParameterHandler<*>>(parameterCount)
            
            for (i in 0 until parameterCount) {
                parameterHandlers!![i] = parseParameter(i, parameterTypes[i], 
                    parameterAnnotationsArray[i], i == parameterCount - 1)
            }
            
            return RequestFactory(
                method, retrofit.baseUrl, httpMethod!!, relativeUrl, headers,
                contentType, hasBody, isFormEncoded, isMultipart,
                parameterHandlers!!, isKotlinSuspendFunction
            )
        }
        
        /**
         * 解析方法注解
         */
        private fun parseMethodAnnotation(annotation: Annotation) {
            when (annotation) {
                is DELETE -> parseHttpMethodAndPath("DELETE", annotation.value, false)
                is GET -> parseHttpMethodAndPath("GET", annotation.value, false)
                is HEAD -> parseHttpMethodAndPath("HEAD", annotation.value, false)
                is PATCH -> parseHttpMethodAndPath("PATCH", annotation.value, true)
                is POST -> parseHttpMethodAndPath("POST", annotation.value, true)
                is PUT -> parseHttpMethodAndPath("PUT", annotation.value, true)
                is OPTIONS -> parseHttpMethodAndPath("OPTIONS", annotation.value, false)
                is HTTP -> {
                    parseHttpMethodAndPath(annotation.method, annotation.path, annotation.hasBody)
                }
                is retrofit2.http.Headers -> {
                    // 解析 @Headers 注解
                    val headersToParse = annotation.value
                    if (headersToParse.isEmpty()) {
                        throw methodError(method, "@Headers annotation is empty.")
                    }
                    headers = parseHeaders(headersToParse)
                }
                is Multipart -> {
                    isMultipart = true
                }
                is FormUrlEncoded -> {
                    isFormEncoded = true
                }
            }
        }
        
        /**
         * 解析参数注解
         */
        private fun parseParameter(
            index: Int,
            type: Type,
            annotations: Array<Annotation>,
            allowContinuation: Boolean
        ): ParameterHandler<*> {
            var result: ParameterHandler<*>? = null
            
            for (annotation in annotations) {
                val handler = parseParameterAnnotation(index, type, annotations, annotation)
                
                if (handler == null) continue
                
                if (result != null) {
                    throw parameterError(method, index,
                        "Multiple Retrofit annotations found, only one allowed.")
                }
                
                result = handler
            }
            
            // 检查是否是 Kotlin 挂起函数的 Continuation 参数
            if (result == null) {
                if (allowContinuation) {
                    try {
                        if (Utils.getRawType(type) == Continuation::class.java) {
                            isKotlinSuspendFunction = true
                            return ParameterHandler.Skip
                        }
                    } catch (ignored: NoClassDefFoundError) {
                    }
                }
                throw parameterError(method, index, "No Retrofit annotation found.")
            }
            
            return result
        }
        
        /**
         * 解析单个参数注解
         */
        private fun parseParameterAnnotation(
            index: Int,
            type: Type,
            annotations: Array<Annotation>,
            annotation: Annotation
        ): ParameterHandler<*>? {
            return when (annotation) {
                is Url -> {
                    // @Url 注解
                    ParameterHandler.RelativeUrl(method, index)
                }
                is Path -> {
                    // @Path 注解
                    val name = annotation.value
                    val encoded = annotation.encoded
                    val converter = retrofit.stringConverter<Any>(type, annotations)
                    ParameterHandler.Path(method, index, name, converter, encoded)
                }
                is Query -> {
                    // @Query 注解
                    val name = annotation.value
                    val encoded = annotation.encoded
                    val converter = retrofit.stringConverter<Any>(type, annotations)
                    ParameterHandler.Query(name, converter, encoded)
                }
                is QueryMap -> {
                    // @QueryMap 注解
                    val rawType = Utils.getRawType(type)
                    val encoded = annotation.encoded
                    val converter = retrofit.stringConverter<Any>(type, annotations)
                    ParameterHandler.QueryMap(method, index, converter, encoded)
                }
                is Header -> {
                    // @Header 注解
                    val name = annotation.value
                    val converter = retrofit.stringConverter<Any>(type, annotations)
                    ParameterHandler.Header(name, converter)
                }
                is HeaderMap -> {
                    // @HeaderMap 注解
                    val converter = retrofit.stringConverter<Any>(type, annotations)
                    ParameterHandler.HeaderMap(method, index, converter)
                }
                is Field -> {
                    // @Field 注解 (表单字段)
                    val name = annotation.value
                    val encoded = annotation.encoded
                    val converter = retrofit.stringConverter<Any>(type, annotations)
                    ParameterHandler.Field(name, converter, encoded)
                }
                is FieldMap -> {
                    // @FieldMap 注解
                    val converter = retrofit.stringConverter<Any>(type, annotations)
                    ParameterHandler.FieldMap(method, index, converter, annotation.encoded)
                }
                is Part -> {
                    // @Part 注解 (Multipart)
                    val partName = annotation.value
                    val encoding = annotation.encoding
                    ParameterHandler.Part(method, index, partName, encoding)
                }
                is Body -> {
                    // @Body 注解
                    val converter = retrofit.requestBodyConverter<Any>(type, annotations, 
                        methodAnnotations)
                    ParameterHandler.Body(method, index, converter)
                }
                else -> null
            }
        }
    }
}
```

#### 3.2.5 Converter 和 CallAdapter

```kotlin
/**
 * Converter - 数据转换器接口
 * 负责请求体和响应体的序列化/反序列化
 */
interface Converter<F, T> {
    @Throws(IOException::class)
    fun convert(value: F): T?
    
    /**
     * Converter 工厂
     */
    abstract class Factory {
        /**
         * 创建响应体转换器
         * ResponseBody -> T
         */
        open fun responseBodyConverter(
            type: Type,
            annotations: Array<Annotation>,
            retrofit: Retrofit
        ): Converter<ResponseBody, *>? = null
        
        /**
         * 创建请求体转换器
         * T -> RequestBody
         */
        open fun requestBodyConverter(
            type: Type,
            parameterAnnotations: Array<Annotation>,
            methodAnnotations: Array<Annotation>,
            retrofit: Retrofit
        ): Converter<*, RequestBody>? = null
        
        /**
         * 创建字符串转换器
         * T -> String (用于 @Query, @Path 等)
         */
        open fun stringConverter(
            type: Type,
            annotations: Array<Annotation>,
            retrofit: Retrofit
        ): Converter<*, String>? = null
    }
}

/**
 * GsonConverterFactory - Gson 转换器工厂示例
 */
class GsonConverterFactory private constructor(
    private val gson: Gson
) : Converter.Factory() {
    
    override fun responseBodyConverter(
        type: Type,
        annotations: Array<Annotation>,
        retrofit: Retrofit
    ): Converter<ResponseBody, *> {
        val adapter = gson.getAdapter(TypeToken.get(type))
        return GsonResponseBodyConverter(gson, adapter)
    }
    
    override fun requestBodyConverter(
        type: Type,
        parameterAnnotations: Array<Annotation>,
        methodAnnotations: Array<Annotation>,
        retrofit: Retrofit
    ): Converter<*, RequestBody> {
        val adapter = gson.getAdapter(TypeToken.get(type))
        return GsonRequestBodyConverter(gson, adapter)
    }
    
    companion object {
        @JvmStatic
        fun create(): GsonConverterFactory = create(Gson())
        
        @JvmStatic
        fun create(gson: Gson): GsonConverterFactory = GsonConverterFactory(gson)
    }
}

/**
 * CallAdapter - Call 适配器接口
 * 负责将 Call<T> 适配为其他类型 (如 Observable, Flow)
 */
interface CallAdapter<R, T> {
    /**
     * 返回响应类型
     */
    fun responseType(): Type
    
    /**
     * 适配 Call
     */
    fun adapt(call: Call<R>): T
    
    /**
     * CallAdapter 工厂
     */
    abstract class Factory {
        /**
         * 创建 CallAdapter
         */
        abstract fun get(
            returnType: Type,
            annotations: Array<Annotation>,
            retrofit: Retrofit
        ): CallAdapter<*, *>?
    }
}

/**
 * RxJava3CallAdapterFactory - RxJava3 适配器工厂示例
 */
class RxJava3CallAdapterFactory private constructor(
    private val scheduler: Scheduler?,
    private val isAsync: Boolean
) : CallAdapter.Factory() {
    
    override fun get(
        returnType: Type,
        annotations: Array<Annotation>,
        retrofit: Retrofit
    ): CallAdapter<*, *>? {
        val rawType = getRawType(returnType)
        
        // 检查返回类型
        val isObservable = rawType == Observable::class.java
        val isSingle = rawType == Single::class.java
        val isMaybe = rawType == Maybe::class.java
        val isFlowable = rawType == Flowable::class.java
        val isCompletable = rawType == Completable::class.java
        
        if (!isObservable && !isSingle && !isMaybe && !isFlowable && !isCompletable) {
            return null
        }
        
        // 获取响应类型
        val responseType = if (isCompletable) {
            Void::class.java
        } else {
            getParameterUpperBound(0, returnType as ParameterizedType)
        }
        
        return RxJava3CallAdapter(responseType, scheduler, isAsync, 
            isObservable, isSingle, isMaybe, isFlowable, isCompletable)
    }
    
    companion object {
        @JvmStatic
        fun create(): RxJava3CallAdapterFactory = RxJava3CallAdapterFactory(null, false)
        
        @JvmStatic
        fun createWithScheduler(scheduler: Scheduler): RxJava3CallAdapterFactory =
            RxJava3CallAdapterFactory(scheduler, false)
    }
}
```


## 4. 实战应用

### 4.1 网络优化策略

#### 4.1.1 DNS 优化

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        DNS 优化策略                                      │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  DNS 解析问题:                                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  • 解析耗时: 通常 100-500ms，弱网环境可能更长                   │   │
│  │  • DNS 劫持: 运营商可能劫持 DNS 返回错误 IP                     │   │
│  │  • DNS 污染: 返回被污染的 IP 地址                               │   │
│  │  • 解析失败: 网络不稳定时可能解析失败                           │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  优化方案:                                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  1. HTTPDNS: 使用 HTTP 协议进行 DNS 解析，绕过运营商            │   │
│  │  2. DNS 预解析: 提前解析常用域名                                │   │
│  │  3. DNS 缓存: 缓存解析结果，减少重复解析                        │   │
│  │  4. IP 直连: 直接使用 IP 地址，跳过 DNS 解析                    │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

```kotlin
/**
 * 自定义 DNS 实现 - HTTPDNS
 */
class HttpDns : Dns {
    
    // DNS 缓存
    private val dnsCache = ConcurrentHashMap<String, List<InetAddress>>()
    
    // 缓存过期时间 (5 分钟)
    private val cacheExpireTime = 5 * 60 * 1000L
    
    // 缓存时间戳
    private val cacheTimestamps = ConcurrentHashMap<String, Long>()
    
    override fun lookup(hostname: String): List<InetAddress> {
        // 1. 检查缓存
        val cached = getFromCache(hostname)
        if (cached != null) {
            return cached
        }
        
        // 2. 尝试 HTTPDNS 解析
        try {
            val ips = resolveByHttpDns(hostname)
            if (ips.isNotEmpty()) {
                // 缓存结果
                putToCache(hostname, ips)
                return ips
            }
        } catch (e: Exception) {
            Log.w(TAG, "HTTPDNS resolve failed: ${e.message}")
        }
        
        // 3. 降级到系统 DNS
        return Dns.SYSTEM.lookup(hostname)
    }
    
    /**
     * 通过 HTTPDNS 服务解析域名
     */
    private fun resolveByHttpDns(hostname: String): List<InetAddress> {
        // 调用 HTTPDNS 服务 (如阿里云、腾讯云 HTTPDNS)
        val url = "https://httpdns.example.com/resolve?host=$hostname"
        
        val request = Request.Builder()
            .url(url)
            .build()
        
        // 使用独立的 OkHttpClient，避免循环依赖
        val response = httpDnsClient.newCall(request).execute()
        
        if (response.isSuccessful) {
            val json = response.body?.string()
            // 解析返回的 IP 列表
            val ips = parseIpList(json)
            return ips.map { InetAddress.getByName(it) }
        }
        
        return emptyList()
    }
    
    /**
     * 从缓存获取
     */
    private fun getFromCache(hostname: String): List<InetAddress>? {
        val timestamp = cacheTimestamps[hostname] ?: return null
        
        // 检查是否过期
        if (System.currentTimeMillis() - timestamp > cacheExpireTime) {
            dnsCache.remove(hostname)
            cacheTimestamps.remove(hostname)
            return null
        }
        
        return dnsCache[hostname]
    }
    
    /**
     * 放入缓存
     */
    private fun putToCache(hostname: String, ips: List<InetAddress>) {
        dnsCache[hostname] = ips
        cacheTimestamps[hostname] = System.currentTimeMillis()
    }
    
    /**
     * DNS 预解析
     */
    fun preResolve(hostnames: List<String>) {
        hostnames.forEach { hostname ->
            GlobalScope.launch(Dispatchers.IO) {
                try {
                    lookup(hostname)
                } catch (e: Exception) {
                    Log.w(TAG, "Pre-resolve failed for $hostname: ${e.message}")
                }
            }
        }
    }
    
    companion object {
        private const val TAG = "HttpDns"
        
        // 用于 HTTPDNS 请求的独立 Client
        private val httpDnsClient = OkHttpClient.Builder()
            .connectTimeout(3, TimeUnit.SECONDS)
            .readTimeout(3, TimeUnit.SECONDS)
            .dns(Dns.SYSTEM)  // 使用系统 DNS
            .build()
    }
}

/**
 * 使用自定义 DNS
 */
val okHttpClient = OkHttpClient.Builder()
    .dns(HttpDns())
    .build()
```

#### 4.1.2 连接优化

```kotlin
/**
 * 连接优化配置
 */
val okHttpClient = OkHttpClient.Builder()
    // 1. 连接池配置
    .connectionPool(ConnectionPool(
        maxIdleConnections = 10,      // 最大空闲连接数
        keepAliveDuration = 5,        // 保活时间
        timeUnit = TimeUnit.MINUTES
    ))
    
    // 2. 超时配置
    .connectTimeout(10, TimeUnit.SECONDS)   // 连接超时
    .readTimeout(30, TimeUnit.SECONDS)      // 读取超时
    .writeTimeout(30, TimeUnit.SECONDS)     // 写入超时
    
    // 3. 启用 HTTP/2
    .protocols(listOf(Protocol.HTTP_2, Protocol.HTTP_1_1))
    
    // 4. 连接失败重试
    .retryOnConnectionFailure(true)
    
    .build()

/**
 * 连接预热 - 提前建立连接
 */
class ConnectionWarmer(private val client: OkHttpClient) {
    
    /**
     * 预热指定 URL 的连接
     */
    fun warmUp(urls: List<String>) {
        urls.forEach { url ->
            GlobalScope.launch(Dispatchers.IO) {
                try {
                    // 发送 HEAD 请求建立连接
                    val request = Request.Builder()
                        .url(url)
                        .head()
                        .build()
                    
                    client.newCall(request).execute().close()
                    Log.d(TAG, "Connection warmed up for: $url")
                } catch (e: Exception) {
                    Log.w(TAG, "Warm up failed for $url: ${e.message}")
                }
            }
        }
    }
    
    companion object {
        private const val TAG = "ConnectionWarmer"
    }
}
```

#### 4.1.3 数据压缩优化

```kotlin
/**
 * 请求数据压缩拦截器
 */
class GzipRequestInterceptor : Interceptor {
    
    @Throws(IOException::class)
    override fun intercept(chain: Interceptor.Chain): Response {
        val originalRequest = chain.request()
        
        // 检查是否有请求体
        val body = originalRequest.body ?: return chain.proceed(originalRequest)
        
        // 检查是否已经压缩
        if (originalRequest.header("Content-Encoding") != null) {
            return chain.proceed(originalRequest)
        }
        
        // 压缩请求体
        val compressedRequest = originalRequest.newBuilder()
            .header("Content-Encoding", "gzip")
            .method(originalRequest.method, gzip(body))
            .build()
        
        return chain.proceed(compressedRequest)
    }
    
    private fun gzip(body: RequestBody): RequestBody {
        return object : RequestBody() {
            override fun contentType(): MediaType? = body.contentType()
            
            override fun contentLength(): Long = -1  // 压缩后长度未知
            
            @Throws(IOException::class)
            override fun writeTo(sink: BufferedSink) {
                val gzipSink = GzipSink(sink).buffer()
                body.writeTo(gzipSink)
                gzipSink.close()
            }
        }
    }
}

/**
 * 数据优化建议
 */
/*
 * 1. 使用 Protocol Buffers 替代 JSON
 *    - 体积更小 (通常减少 30-50%)
 *    - 解析更快
 *    
 * 2. 图片优化
 *    - 使用 WebP 格式
 *    - 根据屏幕尺寸请求合适大小的图片
 *    - 使用渐进式加载
 *    
 * 3. 增量更新
 *    - 只传输变化的数据
 *    - 使用 ETag/Last-Modified 进行条件请求
 *    
 * 4. 数据缓存
 *    - 合理设置 Cache-Control
 *    - 使用本地缓存减少网络请求
 */
```

#### 4.1.4 弱网优化

```kotlin
/**
 * 弱网优化策略
 */
class WeakNetworkOptimizer(private val context: Context) {
    
    /**
     * 获取当前网络质量
     */
    fun getNetworkQuality(): NetworkQuality {
        val connectivityManager = context.getSystemService(Context.CONNECTIVITY_SERVICE) 
            as ConnectivityManager
        
        val network = connectivityManager.activeNetwork ?: return NetworkQuality.OFFLINE
        val capabilities = connectivityManager.getNetworkCapabilities(network) 
            ?: return NetworkQuality.OFFLINE
        
        // 获取下行带宽 (Kbps)
        val downstreamBandwidth = capabilities.linkDownstreamBandwidthKbps
        
        return when {
            downstreamBandwidth >= 10000 -> NetworkQuality.EXCELLENT  // >= 10 Mbps
            downstreamBandwidth >= 2000 -> NetworkQuality.GOOD        // >= 2 Mbps
            downstreamBandwidth >= 500 -> NetworkQuality.MODERATE     // >= 500 Kbps
            downstreamBandwidth > 0 -> NetworkQuality.POOR            // > 0
            else -> NetworkQuality.OFFLINE
        }
    }
    
    /**
     * 根据网络质量调整请求策略
     */
    fun getOptimizedClient(baseClient: OkHttpClient): OkHttpClient {
        val quality = getNetworkQuality()
        
        return when (quality) {
            NetworkQuality.EXCELLENT, NetworkQuality.GOOD -> {
                // 网络良好，使用默认配置
                baseClient
            }
            NetworkQuality.MODERATE -> {
                // 网络一般，增加超时时间
                baseClient.newBuilder()
                    .connectTimeout(15, TimeUnit.SECONDS)
                    .readTimeout(45, TimeUnit.SECONDS)
                    .build()
            }
            NetworkQuality.POOR -> {
                // 弱网环境，大幅增加超时，启用更激进的重试
                baseClient.newBuilder()
                    .connectTimeout(30, TimeUnit.SECONDS)
                    .readTimeout(60, TimeUnit.SECONDS)
                    .addInterceptor(WeakNetworkRetryInterceptor(maxRetries = 3))
                    .build()
            }
            NetworkQuality.OFFLINE -> {
                // 离线，直接使用缓存
                baseClient.newBuilder()
                    .addInterceptor(ForceCacheInterceptor())
                    .build()
            }
        }
    }
    
    enum class NetworkQuality {
        EXCELLENT, GOOD, MODERATE, POOR, OFFLINE
    }
}

/**
 * 弱网重试拦截器
 */
class WeakNetworkRetryInterceptor(
    private val maxRetries: Int = 3,
    private val retryDelayMs: Long = 1000
) : Interceptor {
    
    @Throws(IOException::class)
    override fun intercept(chain: Interceptor.Chain): Response {
        val request = chain.request()
        var lastException: IOException? = null
        
        repeat(maxRetries) { attempt ->
            try {
                return chain.proceed(request)
            } catch (e: IOException) {
                lastException = e
                Log.w(TAG, "Request failed, attempt ${attempt + 1}/$maxRetries: ${e.message}")
                
                // 等待后重试
                if (attempt < maxRetries - 1) {
                    Thread.sleep(retryDelayMs * (attempt + 1))  // 指数退避
                }
            }
        }
        
        throw lastException!!
    }
    
    companion object {
        private const val TAG = "WeakNetworkRetry"
    }
}

/**
 * 强制使用缓存拦截器
 */
class ForceCacheInterceptor : Interceptor {
    
    @Throws(IOException::class)
    override fun intercept(chain: Interceptor.Chain): Response {
        val request = chain.request().newBuilder()
            .cacheControl(CacheControl.FORCE_CACHE)
            .build()
        
        return chain.proceed(request)
    }
}
```


### 4.2 网络监控

```kotlin
/**
 * 网络监控 - 使用 OkHttp EventListener
 */
class NetworkMonitorEventListener : EventListener() {
    
    private var callStartTime: Long = 0
    private var dnsStartTime: Long = 0
    private var connectStartTime: Long = 0
    private var secureConnectStartTime: Long = 0
    private var requestStartTime: Long = 0
    private var responseStartTime: Long = 0
    
    // 监控数据
    private val metrics = NetworkMetrics()
    
    override fun callStart(call: Call) {
        callStartTime = System.currentTimeMillis()
        metrics.url = call.request().url.toString()
        metrics.method = call.request().method
    }
    
    override fun dnsStart(call: Call, domainName: String) {
        dnsStartTime = System.currentTimeMillis()
    }
    
    override fun dnsEnd(call: Call, domainName: String, inetAddressList: List<InetAddress>) {
        metrics.dnsTime = System.currentTimeMillis() - dnsStartTime
    }
    
    override fun connectStart(call: Call, inetSocketAddress: InetSocketAddress, proxy: Proxy) {
        connectStartTime = System.currentTimeMillis()
    }
    
    override fun connectEnd(
        call: Call,
        inetSocketAddress: InetSocketAddress,
        proxy: Proxy,
        protocol: Protocol?
    ) {
        metrics.connectTime = System.currentTimeMillis() - connectStartTime
        metrics.protocol = protocol?.toString()
    }
    
    override fun secureConnectStart(call: Call) {
        secureConnectStartTime = System.currentTimeMillis()
    }
    
    override fun secureConnectEnd(call: Call, handshake: Handshake?) {
        metrics.sslTime = System.currentTimeMillis() - secureConnectStartTime
    }
    
    override fun requestHeadersStart(call: Call) {
        requestStartTime = System.currentTimeMillis()
    }
    
    override fun requestBodyEnd(call: Call, byteCount: Long) {
        metrics.requestSize = byteCount
    }
    
    override fun responseHeadersStart(call: Call) {
        responseStartTime = System.currentTimeMillis()
        metrics.requestTime = responseStartTime - requestStartTime
    }
    
    override fun responseBodyEnd(call: Call, byteCount: Long) {
        metrics.responseTime = System.currentTimeMillis() - responseStartTime
        metrics.responseSize = byteCount
    }
    
    override fun callEnd(call: Call) {
        metrics.totalTime = System.currentTimeMillis() - callStartTime
        metrics.success = true
        
        // 上报监控数据
        reportMetrics(metrics)
    }
    
    override fun callFailed(call: Call, ioe: IOException) {
        metrics.totalTime = System.currentTimeMillis() - callStartTime
        metrics.success = false
        metrics.errorMessage = ioe.message
        
        // 上报监控数据
        reportMetrics(metrics)
    }
    
    private fun reportMetrics(metrics: NetworkMetrics) {
        Log.d(TAG, """
            Network Metrics:
            URL: ${metrics.url}
            Method: ${metrics.method}
            Protocol: ${metrics.protocol}
            DNS Time: ${metrics.dnsTime}ms
            Connect Time: ${metrics.connectTime}ms
            SSL Time: ${metrics.sslTime}ms
            Request Time: ${metrics.requestTime}ms
            Response Time: ${metrics.responseTime}ms
            Total Time: ${metrics.totalTime}ms
            Request Size: ${metrics.requestSize} bytes
            Response Size: ${metrics.responseSize} bytes
            Success: ${metrics.success}
            Error: ${metrics.errorMessage}
        """.trimIndent())
        
        // 上报到监控平台
        NetworkMonitor.report(metrics)
    }
    
    companion object {
        private const val TAG = "NetworkMonitor"
        
        /**
         * 创建 EventListener 工厂
         */
        val FACTORY = object : EventListener.Factory {
            override fun create(call: Call): EventListener {
                return NetworkMonitorEventListener()
            }
        }
    }
}

/**
 * 网络监控数据
 */
data class NetworkMetrics(
    var url: String = "",
    var method: String = "",
    var protocol: String? = null,
    var dnsTime: Long = 0,
    var connectTime: Long = 0,
    var sslTime: Long = 0,
    var requestTime: Long = 0,
    var responseTime: Long = 0,
    var totalTime: Long = 0,
    var requestSize: Long = 0,
    var responseSize: Long = 0,
    var success: Boolean = false,
    var errorMessage: String? = null
)

/**
 * 网络监控管理器
 */
object NetworkMonitor {
    
    private val metricsBuffer = mutableListOf<NetworkMetrics>()
    private const val BUFFER_SIZE = 100
    
    /**
     * 上报监控数据
     */
    @Synchronized
    fun report(metrics: NetworkMetrics) {
        metricsBuffer.add(metrics)
        
        // 批量上报
        if (metricsBuffer.size >= BUFFER_SIZE) {
            flush()
        }
    }
    
    /**
     * 立即上报所有数据
     */
    @Synchronized
    fun flush() {
        if (metricsBuffer.isEmpty()) return
        
        val data = metricsBuffer.toList()
        metricsBuffer.clear()
        
        // 异步上报到服务器
        GlobalScope.launch(Dispatchers.IO) {
            try {
                uploadMetrics(data)
            } catch (e: Exception) {
                Log.e(TAG, "Upload metrics failed: ${e.message}")
            }
        }
    }
    
    private suspend fun uploadMetrics(data: List<NetworkMetrics>) {
        // 上报到监控平台
        // ...
    }
    
    private const val TAG = "NetworkMonitor"
}

/**
 * 使用网络监控
 */
val okHttpClient = OkHttpClient.Builder()
    .eventListenerFactory(NetworkMonitorEventListener.FACTORY)
    .build()
```

### 4.3 最佳实践配置

```kotlin
/**
 * OkHttp 最佳实践配置
 */
object NetworkClient {
    
    // 缓存目录和大小
    private const val CACHE_SIZE = 50L * 1024 * 1024  // 50 MB
    
    /**
     * 创建 OkHttpClient
     */
    fun create(context: Context): OkHttpClient {
        // 缓存
        val cache = Cache(
            directory = File(context.cacheDir, "http_cache"),
            maxSize = CACHE_SIZE
        )
        
        return OkHttpClient.Builder()
            // 超时配置
            .connectTimeout(10, TimeUnit.SECONDS)
            .readTimeout(30, TimeUnit.SECONDS)
            .writeTimeout(30, TimeUnit.SECONDS)
            
            // 连接池
            .connectionPool(ConnectionPool(10, 5, TimeUnit.MINUTES))
            
            // 缓存
            .cache(cache)
            
            // 协议
            .protocols(listOf(Protocol.HTTP_2, Protocol.HTTP_1_1))
            
            // 自定义 DNS
            .dns(HttpDns())
            
            // 重试
            .retryOnConnectionFailure(true)
            
            // 拦截器
            .addInterceptor(LoggingInterceptor())           // 日志
            .addInterceptor(HeaderInterceptor())            // 公共请求头
            .addNetworkInterceptor(CacheInterceptor())      // 缓存控制
            
            // 网络监控
            .eventListenerFactory(NetworkMonitorEventListener.FACTORY)
            
            // SSL 配置 (如需要)
            // .sslSocketFactory(sslSocketFactory, trustManager)
            // .hostnameVerifier(hostnameVerifier)
            
            .build()
    }
    
    /**
     * 创建 Retrofit
     */
    fun createRetrofit(context: Context, baseUrl: String): Retrofit {
        return Retrofit.Builder()
            .baseUrl(baseUrl)
            .client(create(context))
            .addConverterFactory(GsonConverterFactory.create())
            .addCallAdapterFactory(RxJava3CallAdapterFactory.create())
            .build()
    }
}

/**
 * 日志拦截器
 */
class LoggingInterceptor : Interceptor {
    
    @Throws(IOException::class)
    override fun intercept(chain: Interceptor.Chain): Response {
        val request = chain.request()
        
        val startTime = System.nanoTime()
        Log.d(TAG, "Sending request: ${request.url}")
        
        val response = chain.proceed(request)
        
        val duration = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime)
        Log.d(TAG, "Received response for ${request.url} in ${duration}ms")
        
        return response
    }
    
    companion object {
        private const val TAG = "OkHttp"
    }
}

/**
 * 公共请求头拦截器
 */
class HeaderInterceptor : Interceptor {
    
    @Throws(IOException::class)
    override fun intercept(chain: Interceptor.Chain): Response {
        val request = chain.request().newBuilder()
            .header("User-Agent", "MyApp/1.0.0 Android/${Build.VERSION.SDK_INT}")
            .header("Accept", "application/json")
            .header("Accept-Language", Locale.getDefault().language)
            .header("X-Device-Id", getDeviceId())
            .header("X-App-Version", BuildConfig.VERSION_NAME)
            .build()
        
        return chain.proceed(request)
    }
    
    private fun getDeviceId(): String {
        // 获取设备 ID
        return "device_id"
    }
}
```


## 5. 常见面试题

### 5.1 网络协议相关

#### 问题1：HTTP 和 HTTPS 的区别是什么？HTTPS 是如何保证安全的？

**答案要点：**

```
HTTP vs HTTPS 区别:
┌─────────────────────────────────────────────────────────────────────────┐
│  特性          │  HTTP                    │  HTTPS                     │
├─────────────────────────────────────────────────────────────────────────┤
│  端口          │  80                      │  443                       │
│  安全性        │  明文传输，不安全        │  加密传输，安全            │
│  证书          │  不需要                  │  需要 CA 证书              │
│  性能          │  较快                    │  略慢 (TLS 握手开销)       │
│  SEO           │  不利于 SEO              │  有利于 SEO                │
└─────────────────────────────────────────────────────────────────────────┘

HTTPS 安全保证机制:
1. 机密性: 使用对称加密 (AES) 加密数据，防止窃听
2. 完整性: 使用 MAC (消息认证码) 验证数据完整性，防止篡改
3. 身份认证: 使用数字证书验证服务器身份，防止中间人攻击

TLS 握手过程:
1. 客户端发送 ClientHello (支持的加密套件、随机数)
2. 服务端返回 ServerHello (选定的加密套件、随机数) + 证书
3. 客户端验证证书，生成预主密钥，用服务端公钥加密发送
4. 双方根据随机数和预主密钥生成会话密钥
5. 使用会话密钥进行对称加密通信
```

#### 问题2：TCP 三次握手和四次挥手的过程？为什么是三次和四次？

**答案要点：**

```
三次握手:
1. 客户端 → 服务端: SYN=1, seq=x (请求建立连接)
2. 服务端 → 客户端: SYN=1, ACK=1, seq=y, ack=x+1 (同意连接)
3. 客户端 → 服务端: ACK=1, seq=x+1, ack=y+1 (确认)

为什么是三次:
• 确认双方的发送和接收能力都正常
• 同步双方的初始序列号
• 防止历史连接的初始化 (两次握手无法防止)

四次挥手:
1. 客户端 → 服务端: FIN=1, seq=u (请求关闭)
2. 服务端 → 客户端: ACK=1, ack=u+1 (确认收到)
3. 服务端 → 客户端: FIN=1, seq=w (服务端也请求关闭)
4. 客户端 → 服务端: ACK=1, ack=w+1 (确认)

为什么是四次:
• TCP 是全双工通信，双方可以独立关闭
• 客户端发送 FIN 只表示不再发送数据，但可以接收
• 服务端可能还有数据要发送，不能立即关闭
• 需要分别关闭两个方向的连接

TIME_WAIT 状态:
• 等待 2MSL (约 60 秒)
• 确保最后一个 ACK 能到达服务端
• 等待网络中残留的数据包消失
```

#### 问题3：HTTP/2 相比 HTTP/1.1 有哪些改进？

**答案要点：**

```
HTTP/2 主要改进:

1. 二进制分帧层
   • HTTP/1.1 是文本协议，HTTP/2 是二进制协议
   • 更高效的解析和传输

2. 多路复用 (Multiplexing)
   • 单个 TCP 连接上可以并行多个请求/响应
   • 解决了 HTTP/1.1 的队头阻塞问题
   • 不再需要多个 TCP 连接

3. 头部压缩 (HPACK)
   • 使用静态表和动态表压缩头部
   • 减少重复头部的传输

4. 服务器推送 (Server Push)
   • 服务器可以主动推送资源
   • 减少客户端请求次数

5. 请求优先级
   • 客户端可以指定请求优先级
   • 服务器可以优先处理重要请求

6. 流量控制
   • 基于流的流量控制
   • 防止接收方被压垮

Android 中启用 HTTP/2:
OkHttpClient.Builder()
    .protocols(listOf(Protocol.HTTP_2, Protocol.HTTP_1_1))
    .build()
```

### 5.2 OkHttp 相关

#### 问题4：OkHttp 的拦截器链是如何工作的？应用拦截器和网络拦截器有什么区别？

**答案要点：**

```
拦截器链工作原理 (责任链模式):

1. 拦截器顺序:
   应用拦截器 → RetryAndFollowUpInterceptor → BridgeInterceptor 
   → CacheInterceptor → ConnectInterceptor → 网络拦截器 
   → CallServerInterceptor

2. 执行流程:
   • 每个拦截器调用 chain.proceed(request) 传递给下一个
   • 请求从上往下传递，响应从下往上返回
   • 拦截器可以修改请求和响应

应用拦截器 vs 网络拦截器:
┌─────────────────────────────────────────────────────────────────────────┐
│  特性              │  应用拦截器           │  网络拦截器              │
├─────────────────────────────────────────────────────────────────────────┤
│  位置              │  最先执行             │  ConnectInterceptor 之后 │
│  调用次数          │  只调用一次           │  重定向时会多次调用      │
│  缓存响应          │  能看到               │  看不到 (被缓存拦截)     │
│  网络请求          │  看不到真实网络请求   │  能看到真实网络请求      │
│  重试/重定向       │  看不到中间过程       │  能看到每次请求          │
│  使用场景          │  日志、公共参数       │  网络层监控、修改请求头  │
└─────────────────────────────────────────────────────────────────────────┘

代码示例:
// 应用拦截器
client.addInterceptor(LoggingInterceptor())

// 网络拦截器
client.addNetworkInterceptor(NetworkMonitorInterceptor())
```

#### 问题5：OkHttp 的连接池是如何工作的？如何复用连接？

**答案要点：**

```
连接池工作原理:

1. 连接池配置:
   ConnectionPool(
       maxIdleConnections = 5,    // 最大空闲连接数
       keepAliveDuration = 5,     // 保活时间 (分钟)
       timeUnit = TimeUnit.MINUTES
   )

2. 连接复用条件:
   • 相同的 Address (host, port, proxy, ssl 配置)
   • 连接健康 (未关闭、未超时)
   • HTTP/2 连接可以多路复用

3. 连接获取流程:
   a. 先从连接池查找可复用连接
   b. 找到则直接使用
   c. 找不到则创建新连接
   d. 请求完成后，连接放回连接池

4. 连接清理:
   • 后台线程定期清理
   • 清理空闲时间超过 keepAliveDuration 的连接
   • 清理超过 maxIdleConnections 的连接

5. 连接复用的好处:
   • 减少 TCP 三次握手开销
   • 减少 TLS 握手开销
   • 减少慢启动影响
   • 提高请求速度

源码关键类:
• ConnectionPool: 连接池
• RealConnectionPool: 真正的实现
• RealConnection: 真实连接
• Exchange: 请求/响应交换
```

#### 问题6：OkHttp 的缓存机制是如何实现的？

**答案要点：**

```
OkHttp 缓存机制:

1. 缓存配置:
   val cache = Cache(
       directory = File(cacheDir, "http_cache"),
       maxSize = 50 * 1024 * 1024  // 50 MB
   )
   OkHttpClient.Builder().cache(cache).build()

2. 缓存策略 (CacheStrategy):
   • 根据请求头和响应头决定使用缓存还是网络
   • Cache-Control: max-age, no-cache, no-store, only-if-cached
   • ETag / If-None-Match: 条件请求
   • Last-Modified / If-Modified-Since: 条件请求

3. 缓存流程:
   a. CacheInterceptor 检查是否有缓存
   b. 根据缓存策略决定:
      - 只用缓存: 直接返回缓存
      - 只用网络: 发起网络请求
      - 条件请求: 带 If-None-Match/If-Modified-Since 请求
   c. 304 响应: 使用缓存，更新头部
   d. 200 响应: 使用网络响应，更新缓存

4. 缓存存储:
   • 使用 DiskLruCache 存储
   • 每个缓存条目包含: 请求 URL、响应头、响应体
   • 使用 URL 的 MD5 作为 key

5. 强制使用缓存:
   val request = Request.Builder()
       .cacheControl(CacheControl.FORCE_CACHE)
       .url(url)
       .build()

6. 强制使用网络:
   val request = Request.Builder()
       .cacheControl(CacheControl.FORCE_NETWORK)
       .url(url)
       .build()
```

### 5.3 Retrofit 相关

#### 问题7：Retrofit 是如何通过动态代理实现接口调用的？

**答案要点：**

```
Retrofit 动态代理原理:

1. 创建代理对象:
   val api = retrofit.create(ApiService::class.java)
   
   // 内部使用 Proxy.newProxyInstance()
   Proxy.newProxyInstance(
       service.classLoader,
       arrayOf(service),
       InvocationHandler { proxy, method, args ->
           // 拦截方法调用
           loadServiceMethod(method).invoke(args)
       }
   )

2. 方法调用流程:
   a. 调用接口方法 (如 api.getUser(id))
   b. InvocationHandler.invoke() 被调用
   c. 加载/创建 ServiceMethod (带缓存)
   d. ServiceMethod 解析方法注解 (@GET, @Query 等)
   e. 创建 OkHttpCall
   f. 通过 CallAdapter 适配返回类型
   g. 执行网络请求

3. ServiceMethod 解析:
   • RequestFactory: 解析请求相关注解，构建 Request
   • CallAdapter: 适配返回类型 (Call, Observable, Flow)
   • Converter: 转换请求体和响应体

4. 注解解析示例:
   @GET("users/{id}")
   suspend fun getUser(@Path("id") id: String): User
   
   解析结果:
   • httpMethod = "GET"
   • relativeUrl = "users/{id}"
   • parameterHandlers = [Path("id")]
   • isKotlinSuspendFunction = true

5. 缓存机制:
   • ServiceMethod 会被缓存到 Map 中
   • 避免重复解析注解
   • 提高性能
```

#### 问题8：Retrofit 的 Converter 和 CallAdapter 分别是什么作用？

**答案要点：**

```
Converter (数据转换器):

1. 作用:
   • 请求体转换: 将对象转换为 RequestBody
   • 响应体转换: 将 ResponseBody 转换为对象
   • 字符串转换: 用于 @Query, @Path 等参数

2. 常用 Converter:
   • GsonConverterFactory: JSON ↔ 对象
   • MoshiConverterFactory: JSON ↔ 对象 (Kotlin 友好)
   • ScalarsConverterFactory: 基本类型
   • ProtobufConverterFactory: Protocol Buffers

3. 使用:
   Retrofit.Builder()
       .addConverterFactory(GsonConverterFactory.create())
       .build()

CallAdapter (调用适配器):

1. 作用:
   • 将 Call<T> 适配为其他类型
   • 支持不同的异步编程模型

2. 常用 CallAdapter:
   • 默认: Call<T>
   • RxJava3CallAdapterFactory: Observable, Single, Flowable
   • CoroutineCallAdapterFactory: suspend 函数 (内置)

3. 使用:
   Retrofit.Builder()
       .addCallAdapterFactory(RxJava3CallAdapterFactory.create())
       .build()

4. 返回类型示例:
   // 默认 Call
   fun getUser(): Call<User>
   
   // RxJava
   fun getUser(): Observable<User>
   fun getUser(): Single<User>
   
   // Kotlin 协程 (内置支持)
   suspend fun getUser(): User
   suspend fun getUser(): Response<User>

5. 查找顺序:
   • 按添加顺序查找
   • 第一个能处理该返回类型的 Factory 生效
```

### 5.4 网络优化相关

#### 问题9：如何进行网络优化？有哪些常见的优化手段？

**答案要点：**

```
网络优化策略:

1. DNS 优化:
   • HTTPDNS: 绕过运营商 DNS，防止劫持
   • DNS 预解析: 提前解析常用域名
   • DNS 缓存: 缓存解析结果
   • IP 直连: 跳过 DNS 解析 (需处理证书验证)

2. 连接优化:
   • 连接复用: 使用 Keep-Alive 和连接池
   • 连接预热: 提前建立连接
   • HTTP/2: 多路复用，减少连接数
   • 合理的超时配置

3. 数据优化:
   • 数据压缩: Gzip 压缩请求和响应
   • 协议优化: 使用 Protocol Buffers 替代 JSON
   • 增量更新: 只传输变化的数据
   • 图片优化: WebP 格式、按需加载

4. 缓存优化:
   • HTTP 缓存: 合理设置 Cache-Control
   • 本地缓存: 减少重复请求
   • 预加载: 提前加载可能需要的数据

5. 弱网优化:
   • 网络质量检测
   • 动态调整超时时间
   • 请求重试策略
   • 离线缓存支持

6. 请求优化:
   • 请求合并: 减少请求次数
   • 请求优先级: 重要请求优先
   • 取消无用请求: 页面退出时取消

7. 监控:
   • 网络耗时监控
   • 成功率监控
   • 错误类型统计
```

#### 问题10：弱网环境下如何保证用户体验？

**答案要点：**

```
弱网优化策略:

1. 网络质量检测:
   • 使用 ConnectivityManager 获取网络信息
   • 根据带宽判断网络质量
   • 动态调整请求策略

2. 超时策略:
   • 弱网环境增加超时时间
   • 分级超时: 连接超时 < 读取超时
   • 避免过早超时导致请求失败

3. 重试策略:
   • 指数退避重试
   • 限制最大重试次数
   • 区分可重试和不可重试错误

4. 缓存策略:
   • 优先使用缓存
   • 离线模式支持
   • 缓存过期策略放宽

5. 请求优化:
   • 减少请求数据量
   • 压缩请求和响应
   • 取消非必要请求

6. UI 优化:
   • 显示加载进度
   • 提供取消选项
   • 友好的错误提示
   • 支持手动重试

7. 降级策略:
   • 图片降级: 加载低质量图片
   • 功能降级: 关闭非核心功能
   • 数据降级: 只加载必要数据

代码示例:
class WeakNetworkOptimizer {
    fun getOptimizedClient(quality: NetworkQuality): OkHttpClient {
        return when (quality) {
            NetworkQuality.POOR -> client.newBuilder()
                .connectTimeout(30, TimeUnit.SECONDS)
                .readTimeout(60, TimeUnit.SECONDS)
                .addInterceptor(RetryInterceptor(maxRetries = 3))
                .build()
            // ...
        }
    }
}
```

### 5.5 综合问题

#### 问题11：一个 HTTPS 请求的完整过程是怎样的？

**答案要点：**

```
HTTPS 请求完整流程:

1. DNS 解析 (如果没有缓存):
   • 查询本地 DNS 缓存
   • 向 DNS 服务器查询域名对应的 IP
   • 耗时: 通常 50-200ms

2. TCP 三次握手:
   • SYN → SYN+ACK → ACK
   • 建立 TCP 连接
   • 耗时: 1 RTT

3. TLS 握手:
   • ClientHello: 发送支持的加密套件
   • ServerHello: 返回选定的加密套件 + 证书
   • 客户端验证证书
   • 密钥交换，生成会话密钥
   • 耗时: TLS 1.2 需要 2 RTT，TLS 1.3 需要 1 RTT

4. 发送 HTTP 请求:
   • 使用会话密钥加密请求数据
   • 发送请求行、请求头、请求体

5. 服务器处理:
   • 解密请求
   • 处理业务逻辑
   • 生成响应

6. 接收 HTTP 响应:
   • 接收加密的响应数据
   • 使用会话密钥解密
   • 解析响应头、响应体

7. 连接复用或关闭:
   • Keep-Alive: 连接放入连接池
   • Connection: close: 四次挥手关闭连接

OkHttp 中的对应:
• DNS 解析: Dns 接口
• TCP 连接: ConnectInterceptor
• TLS 握手: SSLSocketFactory
• 请求/响应: CallServerInterceptor
• 连接复用: ConnectionPool
```

#### 问题12：如何设计一个网络请求框架？需要考虑哪些方面？

**答案要点：**

```
网络框架设计要点:

1. 分层架构:
   ┌─────────────────────────────────────────┐
   │  API 层: 声明式接口定义                 │
   ├─────────────────────────────────────────┤
   │  适配层: CallAdapter, Converter         │
   ├─────────────────────────────────────────┤
   │  拦截层: 拦截器链                       │
   ├─────────────────────────────────────────┤
   │  连接层: 连接池、连接复用               │
   ├─────────────────────────────────────────┤
   │  传输层: Socket、TLS                    │
   └─────────────────────────────────────────┘

2. 核心功能:
   • 请求构建: URL、方法、头部、请求体
   • 响应解析: 状态码、头部、响应体
   • 同步/异步: 支持两种调用方式
   • 取消机制: 支持取消请求

3. 扩展机制:
   • 拦截器: 支持自定义拦截器
   • 转换器: 支持自定义数据转换
   • 适配器: 支持不同返回类型

4. 性能优化:
   • 连接池: 复用 TCP 连接
   • 缓存: HTTP 缓存支持
   • 压缩: Gzip 压缩
   • HTTP/2: 多路复用

5. 可靠性:
   • 重试机制: 失败自动重试
   • 超时控制: 连接、读取、写入超时
   • 错误处理: 统一的错误处理

6. 安全性:
   • HTTPS: TLS 加密
   • 证书验证: 证书校验
   • 证书锁定: Certificate Pinning

7. 监控:
   • 耗时统计: 各阶段耗时
   • 成功率: 请求成功率
   • 错误统计: 错误类型分布

8. 易用性:
   • 简洁的 API
   • 链式调用
   • 注解支持
   • 协程支持
```

---

## 总结

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        网络知识点总结                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  协议层:                                                                │
│  • HTTP/HTTPS 原理、版本演进                                            │
│  • TCP 三次握手、四次挥手                                               │
│  • TLS 握手过程、加密机制                                               │
│                                                                         │
│  OkHttp 核心:                                                           │
│  • 拦截器链 (责任链模式)                                                │
│  • 连接池 (连接复用)                                                    │
│  • 缓存机制 (DiskLruCache)                                              │
│  • 各拦截器职责                                                         │
│                                                                         │
│  Retrofit 核心:                                                         │
│  • 动态代理原理                                                         │
│  • 注解解析 (RequestFactory)                                            │
│  • Converter 和 CallAdapter                                             │
│  • 协程支持                                                             │
│                                                                         │
│  网络优化:                                                              │
│  • DNS 优化 (HTTPDNS、预解析、缓存)                                     │
│  • 连接优化 (连接池、HTTP/2、预热)                                      │
│  • 数据优化 (压缩、Protocol Buffers)                                    │
│  • 弱网优化 (重试、超时、缓存)                                          │
│  • 网络监控 (EventListener)                                             │
│                                                                         │
│  面试重点:                                                              │
│  • OkHttp 拦截器链原理 (必问)                                           │
│  • Retrofit 动态代理原理 (必问)                                         │
│  • HTTPS 握手过程                                                       │
│  • 网络优化实战经验                                                     │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

*文档版本: v1.0*  
*更新时间: 2024-01*  
*目标版本: Android W*
