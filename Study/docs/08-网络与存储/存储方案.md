# 存储方案

## 1. 概述

Android 提供了多种数据存储方案，每种方案都有其适用场景和特点。作为高级开发者，需要深入理解各种存储方案的原理、优缺点，以及在实际项目中如何选择和优化。

### 存储方案对比

| 存储方案 | 数据类型 | 数据量 | 性能 | 跨进程 | 适用场景 |
|---------|---------|-------|------|-------|---------|
| SharedPreferences | 键值对 | 小 | 一般 | 不支持 | 配置项、简单设置 |
| MMKV | 键值对 | 中 | 高 | 支持 | 高频读写、跨进程 |
| DataStore | 键值对/Proto | 小-中 | 高 | 不支持 | 替代 SP、类型安全 |
| SQLite/Room | 结构化数据 | 大 | 中 | 支持 | 复杂查询、关系数据 |
| 文件存储 | 任意 | 大 | 取决于实现 | 支持 | 大文件、二进制数据 |

### 存储位置分类

```
/data/data/<package>/
├── shared_prefs/          # SharedPreferences
├── databases/             # SQLite 数据库
├── files/                 # 内部文件存储
├── cache/                 # 内部缓存
└── no_backup/             # 不备份的文件

/storage/emulated/0/Android/data/<package>/
├── files/                 # 外部文件存储
└── cache/                 # 外部缓存

/storage/emulated/0/
├── Documents/             # 公共文档目录
├── Pictures/              # 公共图片目录
├── Downloads/             # 公共下载目录
└── ...                    # 其他公共目录
```

---

## 2. 核心原理


### 2.1 SharedPreferences 原理与问题

#### 2.1.1 SharedPreferences 工作原理

SharedPreferences 是 Android 提供的轻量级键值对存储方案，底层使用 XML 文件存储数据。

```
SharedPreferences 架构
┌─────────────────────────────────────────────────────────────┐
│                    Application                               │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────┐    ┌─────────────────────────────────┐ │
│  │ SharedPreferences│    │      SharedPreferencesImpl      │ │
│  │   (Interface)    │◄───│  ┌─────────────────────────────┐│ │
│  └─────────────────┘    │  │   mMap (内存缓存)            ││ │
│                         │  │   HashMap<String, Object>    ││ │
│                         │  └─────────────────────────────┘│ │
│                         │  ┌─────────────────────────────┐│ │
│                         │  │   mFile (XML 文件)          ││ │
│                         │  │   /data/data/pkg/shared_prefs││ │
│                         │  └─────────────────────────────┘│ │
│                         └─────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────┤
│                      Editor                                  │
│  ┌─────────────────────────────────────────────────────────┐│
│  │  mModified (修改缓存)                                    ││
│  │  commit() - 同步写入                                     ││
│  │  apply() - 异步写入                                      ││
│  └─────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────┘
```

#### 2.1.2 SP 初始化流程

```java
// ContextImpl.java
@Override
public SharedPreferences getSharedPreferences(String name, int mode) {
    // 1. 检查是否已缓存
    File file;
    synchronized (ContextImpl.class) {
        if (mSharedPrefsPaths == null) {
            mSharedPrefsPaths = new ArrayMap<>();
        }
        file = mSharedPrefsPaths.get(name);
        if (file == null) {
            // 2. 创建文件路径
            file = getSharedPreferencesPath(name);
            mSharedPrefsPaths.put(name, file);
        }
    }
    return getSharedPreferences(file, mode);
}

@Override
public SharedPreferences getSharedPreferences(File file, int mode) {
    SharedPreferencesImpl sp;
    synchronized (ContextImpl.class) {
        // 3. 从缓存获取或创建新实例
        final ArrayMap<File, SharedPreferencesImpl> cache = getSharedPreferencesCacheLocked();
        sp = cache.get(file);
        if (sp == null) {
            // 4. 创建 SharedPreferencesImpl 实例
            sp = new SharedPreferencesImpl(file, mode);
            cache.put(file, sp);
            return sp;
        }
    }
    // 5. 等待 SP 加载完成（可能阻塞）
    sp.startReloadIfChangedUnexpectedly();
    return sp;
}
```

#### 2.1.3 SP 数据加载

```java
// SharedPreferencesImpl.java
SharedPreferencesImpl(File file, int mode) {
    mFile = file;
    mBackupFile = makeBackupFile(file);
    mMode = mode;
    mLoaded = false;
    mMap = null;
    // 异步加载数据
    startLoadFromDisk();
}

private void startLoadFromDisk() {
    synchronized (mLock) {
        mLoaded = false;
    }
    // 在子线程加载
    new Thread("SharedPreferencesImpl-load") {
        public void run() {
            loadFromDisk();
        }
    }.start();
}

private void loadFromDisk() {
    synchronized (mLock) {
        if (mLoaded) {
            return;
        }
        // 备份文件恢复
        if (mBackupFile.exists()) {
            mFile.delete();
            mBackupFile.renameTo(mFile);
        }
    }
    
    Map<String, Object> map = null;
    StructStat stat = null;
    try {
        stat = Os.stat(mFile.getPath());
        if (mFile.canRead()) {
            BufferedInputStream str = null;
            try {
                str = new BufferedInputStream(new FileInputStream(mFile), 16 * 1024);
                // 解析 XML 文件到 Map
                map = (Map<String, Object>) XmlUtils.readMapXml(str);
            } finally {
                IoUtils.closeQuietly(str);
            }
        }
    } catch (Exception e) {
        Log.w(TAG, "Cannot read " + mFile.getAbsolutePath(), e);
    }
    
    synchronized (mLock) {
        mLoaded = true;
        mMap = map != null ? map : new HashMap<>();
        // 唤醒等待的线程
        mLock.notifyAll();
    }
}
```

#### 2.1.4 SP 的 ANR 问题

**问题1：首次获取 SP 时阻塞主线程**

```java
// SharedPreferencesImpl.java
@Override
public String getString(String key, @Nullable String defValue) {
    synchronized (mLock) {
        // 等待加载完成，可能阻塞主线程！
        awaitLoadedLocked();
        String v = (String)mMap.get(key);
        return v != null ? v : defValue;
    }
}

private void awaitLoadedLocked() {
    while (!mLoaded) {
        try {
            // 阻塞等待
            mLock.wait();
        } catch (InterruptedException unused) {
        }
    }
}
```

**问题2：apply() 在 Activity 停止时可能阻塞**

```java
// SharedPreferencesImpl.java
@Override
public void apply() {
    final MemoryCommitResult mcr = commitToMemory();
    final Runnable awaitCommit = new Runnable() {
        @Override
        public void run() {
            try {
                // 等待写入完成
                mcr.writtenToDiskLatch.await();
            } catch (InterruptedException ignored) {
            }
        }
    };
    // 添加到等待队列
    QueuedWork.addFinisher(awaitCommit);
    
    Runnable postWriteRunnable = new Runnable() {
        @Override
        public void run() {
            awaitCommit.run();
            QueuedWork.removeFinisher(awaitCommit);
        }
    };
    // 异步写入
    SharedPreferencesImpl.this.enqueueDiskWrite(mcr, postWriteRunnable);
}
```

```java
// QueuedWork.java - Activity 停止时会等待所有 apply 完成
public static void waitToFinish() {
    // 在 ActivityThread.handleStopActivity 中调用
    // 会阻塞主线程直到所有 apply 完成
    try {
        while (true) {
            Runnable finisher;
            synchronized (sLock) {
                finisher = sFinishers.poll();
            }
            if (finisher == null) {
                break;
            }
            // 等待每个 apply 完成
            finisher.run();
        }
    } finally {
        sCanDelay = true;
    }
}
```

**问题3：commit() 同步写入阻塞主线程**

```java
// SharedPreferencesImpl.java
@Override
public boolean commit() {
    MemoryCommitResult mcr = commitToMemory();
    // 同步写入磁盘
    SharedPreferencesImpl.this.enqueueDiskWrite(mcr, null);
    try {
        // 等待写入完成
        mcr.writtenToDiskLatch.await();
    } catch (InterruptedException e) {
        return false;
    }
    return mcr.writeToDiskResult;
}
```

#### 2.1.5 SP 数据丢失问题

**数据丢失场景分析：**

```
数据丢失流程
┌─────────────────────────────────────────────────────────────┐
│  1. 正常写入流程                                             │
│  ┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐  │
│  │ 原文件   │───►│ 备份文件 │───►│ 写新文件 │───►│ 删除备份 │  │
│  │ data.xml │    │ data.bak │    │ data.xml │    │         │  │
│  └─────────┘    └─────────┘    └─────────┘    └─────────┘  │
├─────────────────────────────────────────────────────────────┤
│  2. 异常场景：写入过程中进程被杀                              │
│  ┌─────────┐    ┌─────────┐    ┌─────────┐                  │
│  │ 原文件   │───►│ 备份文件 │───►│ 写入中断 │  ← 进程被杀     │
│  │ data.xml │    │ data.bak │    │ data.xml │                │
│  └─────────┘    └─────────┘    └─────────┘                  │
│                                     │                        │
│                                     ▼                        │
│                              数据不完整/损坏                  │
├─────────────────────────────────────────────────────────────┤
│  3. 恢复机制：下次启动时从备份恢复                            │
│  ┌─────────┐    ┌─────────┐                                  │
│  │ 备份文件 │───►│ 恢复数据 │  ← 但可能丢失最后一次写入        │
│  │ data.bak │    │ data.xml │                                │
│  └─────────┘    └─────────┘                                  │
└─────────────────────────────────────────────────────────────┘
```

```java
// SharedPreferencesImpl.java - 写入磁盘
private void writeToFile(MemoryCommitResult mcr, boolean isFromSyncCommit) {
    // 1. 创建备份文件
    if (mFile.exists()) {
        if (!mBackupFile.exists()) {
            if (!mFile.renameTo(mBackupFile)) {
                Log.e(TAG, "Couldn't rename file " + mFile + " to backup file " + mBackupFile);
                mcr.setDiskWriteResult(false, false);
                return;
            }
        } else {
            mFile.delete();
        }
    }
    
    try {
        // 2. 写入新文件
        FileOutputStream str = createFileOutputStream(mFile);
        if (str == null) {
            mcr.setDiskWriteResult(false, false);
            return;
        }
        // 写入 XML 数据
        XmlUtils.writeMapXml(mcr.mapToWriteToDisk, str);
        // 同步到磁盘
        FileUtils.sync(str);
        str.close();
        
        // 3. 删除备份文件
        mBackupFile.delete();
        mcr.setDiskWriteResult(true, true);
    } catch (Exception e) {
        // 写入失败，保留备份文件用于恢复
        if (mFile.exists()) {
            if (!mFile.delete()) {
                Log.e(TAG, "Couldn't clean up partially-written file " + mFile);
            }
        }
        mcr.setDiskWriteResult(false, false);
    }
}
```

#### 2.1.6 SP 最佳实践

```kotlin
/**
 * SharedPreferences 最佳实践封装
 */
object SPHelper {
    private const val SP_NAME = "app_config"
    
    private val sp: SharedPreferences by lazy {
        // 在子线程初始化，避免阻塞主线程
        App.context.getSharedPreferences(SP_NAME, Context.MODE_PRIVATE)
    }
    
    // 预加载 SP，在 Application 中调用
    fun preload() {
        GlobalScope.launch(Dispatchers.IO) {
            sp.all // 触发加载
        }
    }
    
    // 使用 apply 而非 commit
    fun putString(key: String, value: String) {
        sp.edit().putString(key, value).apply()
    }
    
    // 批量写入
    fun putBatch(vararg pairs: Pair<String, Any>) {
        sp.edit().apply {
            pairs.forEach { (key, value) ->
                when (value) {
                    is String -> putString(key, value)
                    is Int -> putInt(key, value)
                    is Boolean -> putBoolean(key, value)
                    is Long -> putLong(key, value)
                    is Float -> putFloat(key, value)
                }
            }
        }.apply()
    }
    
    // 避免存储大数据
    fun getString(key: String, default: String = ""): String {
        return sp.getString(key, default) ?: default
    }
}
```


### 2.2 MMKV 原理

MMKV 是腾讯开源的高性能键值存储框架，基于 mmap 内存映射和 Protocol Buffers 编码。

#### 2.2.1 MMKV 整体架构

```
MMKV 架构
┌─────────────────────────────────────────────────────────────┐
│                      Application                             │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────────┐│
│  │                    MMKV API                              ││
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────────┐  ││
│  │  │ encode/decode│  │ Multi-Process│  │ Encryption     │  ││
│  │  └─────────────┘  └─────────────┘  └─────────────────┘  ││
│  └─────────────────────────────────────────────────────────┘│
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────────┐│
│  │                  Core Layer                              ││
│  │  ┌─────────────────┐  ┌─────────────────────────────┐   ││
│  │  │ Protocol Buffers │  │      Memory Map (mmap)      │   ││
│  │  │   编码/解码       │  │  ┌─────────────────────┐   │   ││
│  │  │                   │  │  │   虚拟内存空间       │   │   ││
│  │  │  ┌─────────────┐ │  │  │         ↕           │   │   ││
│  │  │  │ Key-Value   │ │  │  │   物理内存页         │   │   ││
│  │  │  │ 二进制编码   │ │  │  │         ↕           │   │   ││
│  │  │  └─────────────┘ │  │  │   磁盘文件           │   │   ││
│  │  └─────────────────┘  │  └─────────────────────┘   │   ││
│  │                        └─────────────────────────────┘   ││
│  └─────────────────────────────────────────────────────────┘│
├─────────────────────────────────────────────────────────────┤
│                      File System                             │
│  ┌─────────────────────────────────────────────────────────┐│
│  │  /data/data/<package>/files/mmkv/                        ││
│  │  ├── mmkv.default           # 默认存储文件               ││
│  │  ├── mmkv.default.crc       # CRC 校验文件               ││
│  │  └── <custom_id>            # 自定义存储文件             ││
│  └─────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────┘
```

#### 2.2.2 mmap 内存映射原理

```
mmap 工作原理
┌─────────────────────────────────────────────────────────────┐
│                    进程虚拟地址空间                          │
│  ┌─────────────────────────────────────────────────────────┐│
│  │  0x00000000                                              ││
│  │  ├── 代码段                                              ││
│  │  ├── 数据段                                              ││
│  │  ├── 堆                                                  ││
│  │  ├── ...                                                 ││
│  │  ├── mmap 映射区域 ◄─────────────────────────────────┐  ││
│  │  │   ┌─────────────────────────────────────────────┐ │  ││
│  │  │   │  虚拟地址: 0x7f000000 - 0x7f001000          │ │  ││
│  │  │   │  映射文件: mmkv.default                     │ │  ││
│  │  │   │  映射大小: 4KB (一个页)                     │ │  ││
│  │  │   └─────────────────────────────────────────────┘ │  ││
│  │  ├── 栈                                              │  ││
│  │  └── 0xFFFFFFFF                                      │  ││
│  └──────────────────────────────────────────────────────│──┘│
│                                                         │    │
│                         页表映射                         │    │
│                            │                            │    │
│                            ▼                            │    │
│  ┌─────────────────────────────────────────────────────┐│    │
│  │                    物理内存                          ││    │
│  │  ┌─────────────────────────────────────────────────┐││    │
│  │  │  物理页框: 0x12345000                           │││    │
│  │  │  内容: MMKV 数据                                │││    │
│  │  └─────────────────────────────────────────────────┘││    │
│  └─────────────────────────────────────────────────────┘│    │
│                            │                            │    │
│                            ▼                            │    │
│  ┌─────────────────────────────────────────────────────┐│    │
│  │                    磁盘文件                          ││    │
│  │  ┌─────────────────────────────────────────────────┐││    │
│  │  │  /data/data/pkg/files/mmkv/mmkv.default        │◄┘    │
│  │  │  文件内容与物理内存同步                         ││      │
│  │  └─────────────────────────────────────────────────┘│      │
│  └─────────────────────────────────────────────────────┘      │
└─────────────────────────────────────────────────────────────┘

mmap vs 传统 IO 对比
┌─────────────────────────────────────────────────────────────┐
│  传统 IO (read/write)                                        │
│  ┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐  │
│  │ 用户空间 │───►│ 内核缓冲 │───►│ 页缓存   │───►│ 磁盘     │  │
│  │ Buffer  │    │ Buffer  │    │ Page    │    │ File    │  │
│  └─────────┘    └─────────┘    └─────────┘    └─────────┘  │
│       │              │              │              │        │
│       └──────────────┴──────────────┴──────────────┘        │
│                    需要多次数据拷贝                          │
├─────────────────────────────────────────────────────────────┤
│  mmap 内存映射                                               │
│  ┌─────────┐                   ┌─────────┐    ┌─────────┐  │
│  │ 用户空间 │◄─────────────────►│ 页缓存   │◄──►│ 磁盘     │  │
│  │ 直接访问 │   (页表映射)       │ Page    │    │ File    │  │
│  └─────────┘                   └─────────┘    └─────────┘  │
│       │                             │              │        │
│       └─────────────────────────────┴──────────────┘        │
│                    减少数据拷贝，直接操作                     │
└─────────────────────────────────────────────────────────────┘
```

#### 2.2.3 mmap 核心代码

```cpp
// MMKV.cpp - mmap 映射
bool MMKV::loadFromFile() {
    // 1. 打开文件
    m_fd = open(m_path.c_str(), O_RDWR | O_CREAT, S_IRWXU);
    if (m_fd < 0) {
        return false;
    }
    
    // 2. 获取文件大小
    struct stat st;
    if (fstat(m_fd, &st) != 0) {
        return false;
    }
    m_size = static_cast<size_t>(st.st_size);
    
    // 3. 文件大小对齐到页大小
    if (m_size < DEFAULT_MMAP_SIZE || (m_size % DEFAULT_MMAP_SIZE != 0)) {
        size_t roundSize = ((m_size / DEFAULT_MMAP_SIZE) + 1) * DEFAULT_MMAP_SIZE;
        // 扩展文件大小
        if (ftruncate(m_fd, roundSize) != 0) {
            return false;
        }
        m_size = roundSize;
    }
    
    // 4. mmap 映射
    m_ptr = (char *) mmap(nullptr,           // 让系统选择映射地址
                          m_size,             // 映射大小
                          PROT_READ | PROT_WRITE,  // 可读可写
                          MAP_SHARED,         // 共享映射，修改会同步到文件
                          m_fd,               // 文件描述符
                          0);                 // 文件偏移
    
    if (m_ptr == MAP_FAILED) {
        return false;
    }
    
    // 5. 读取数据
    readDataFromFile();
    return true;
}

// 写入数据
bool MMKV::append(const MMBuffer &data) {
    size_t size = data.length();
    
    // 检查是否需要扩容
    if (m_actualSize + size > m_size) {
        // 扩容
        size_t newSize = m_size * 2;
        while (newSize < m_actualSize + size) {
            newSize *= 2;
        }
        
        // 重新映射
        if (!expandFile(newSize)) {
            return false;
        }
    }
    
    // 直接写入内存（mmap 区域）
    memcpy(m_ptr + m_actualSize, data.getPtr(), size);
    m_actualSize += size;
    
    return true;
}

// 扩容
bool MMKV::expandFile(size_t newSize) {
    // 1. 解除旧映射
    if (munmap(m_ptr, m_size) != 0) {
        return false;
    }
    
    // 2. 扩展文件
    if (ftruncate(m_fd, newSize) != 0) {
        return false;
    }
    
    // 3. 重新映射
    m_ptr = (char *) mmap(nullptr, newSize, PROT_READ | PROT_WRITE, MAP_SHARED, m_fd, 0);
    if (m_ptr == MAP_FAILED) {
        return false;
    }
    
    m_size = newSize;
    return true;
}
```

#### 2.2.4 Protocol Buffers 编码

```
Protocol Buffers 编码格式
┌─────────────────────────────────────────────────────────────┐
│  Key-Value 编码结构                                          │
│  ┌─────────────────────────────────────────────────────────┐│
│  │  ┌──────────┬──────────┬──────────┬──────────┐          ││
│  │  │ Key 长度  │ Key 内容  │ Value长度 │ Value内容│          ││
│  │  │ (Varint) │ (bytes)  │ (Varint) │ (bytes) │          ││
│  │  └──────────┴──────────┴──────────┴──────────┘          ││
│  └─────────────────────────────────────────────────────────┘│
├─────────────────────────────────────────────────────────────┤
│  Varint 变长编码（节省空间）                                  │
│  ┌─────────────────────────────────────────────────────────┐│
│  │  数值 300 的编码：                                        ││
│  │  300 = 0b100101100                                       ││
│  │  分组: 0b10 | 0b0101100                                  ││
│  │  编码: 0b10101100 0b00000010 (2 字节)                    ││
│  │                                                          ││
│  │  最高位 1 表示后续还有字节                                ││
│  │  最高位 0 表示这是最后一个字节                            ││
│  └─────────────────────────────────────────────────────────┘│
├─────────────────────────────────────────────────────────────┤
│  MMKV 文件格式                                               │
│  ┌─────────────────────────────────────────────────────────┐│
│  │  ┌──────────┬──────────────────────────────────────────┐││
│  │  │ 数据长度  │              Key-Value 数据              │││
│  │  │ (4 bytes)│  ┌────────┬────────┬────────┬────────┐  │││
│  │  │          │  │ KV1    │ KV2    │ KV3    │ ...    │  │││
│  │  │          │  └────────┴────────┴────────┴────────┘  │││
│  │  └──────────┴──────────────────────────────────────────┘││
│  └─────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────┘
```

```cpp
// CodedOutputData.cpp - Varint 编码
void CodedOutputData::writeRawVarint32(int32_t value) {
    while (true) {
        if ((value & ~0x7F) == 0) {
            // 最后一个字节
            m_ptr[m_position++] = static_cast<uint8_t>(value);
            return;
        } else {
            // 还有后续字节，设置最高位为 1
            m_ptr[m_position++] = static_cast<uint8_t>((value & 0x7F) | 0x80);
            value = static_cast<uint32_t>(value) >> 7;
        }
    }
}

// 写入 Key-Value
void MMKV::setDataForKey(MMBuffer &&data, const string &key) {
    // 1. 计算编码后的大小
    size_t keyLength = key.length();
    size_t size = keyLength + pbRawVarint32Size((int32_t) keyLength);
    size += data.length() + pbRawVarint32Size((int32_t) data.length());
    
    // 2. 编码并写入
    MMBuffer keyData(size);
    CodedOutputData output(keyData.getPtr(), size);
    
    // 写入 key
    output.writeRawVarint32((int32_t) keyLength);
    output.writeRawData(key.data(), keyLength);
    
    // 写入 value
    output.writeRawVarint32((int32_t) data.length());
    output.writeRawData(data.getPtr(), data.length());
    
    // 3. 追加到文件
    append(keyData);
    
    // 4. 更新内存缓存
    m_dic[key] = std::move(data);
}
```

#### 2.2.5 MMKV 增量更新与重整

```
MMKV 增量更新机制
┌─────────────────────────────────────────────────────────────┐
│  初始状态                                                    │
│  ┌─────────────────────────────────────────────────────────┐│
│  │  [key1=v1] [key2=v2] [key3=v3]                          ││
│  └─────────────────────────────────────────────────────────┘│
├─────────────────────────────────────────────────────────────┤
│  更新 key1 的值（追加写入）                                   │
│  ┌─────────────────────────────────────────────────────────┐│
│  │  [key1=v1] [key2=v2] [key3=v3] [key1=v1_new]            ││
│  │     ↑                              ↑                     ││
│  │   旧值（无效）                    新值（有效）             ││
│  └─────────────────────────────────────────────────────────┘│
├─────────────────────────────────────────────────────────────┤
│  多次更新后（文件膨胀）                                       │
│  ┌─────────────────────────────────────────────────────────┐│
│  │  [key1=v1] [key2=v2] [key3=v3] [key1=v1_new] [key2=v2_new]│
│  │  [key1=v1_new2] [key3=v3_new] ...                        ││
│  │                                                          ││
│  │  有效数据占比下降，需要重整                               ││
│  └─────────────────────────────────────────────────────────┘│
├─────────────────────────────────────────────────────────────┤
│  重整后（Full Write Back）                                   │
│  ┌─────────────────────────────────────────────────────────┐│
│  │  [key1=v1_new2] [key2=v2_new] [key3=v3_new]             ││
│  │                                                          ││
│  │  只保留最新值，文件大小减小                               ││
│  └─────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────┘
```

```cpp
// MMKV.cpp - 重整逻辑
void MMKV::fullWriteback() {
    // 1. 计算所有有效数据的大小
    size_t allSize = 0;
    for (auto &itr : m_dic) {
        allSize += itr.first.length() + pbRawVarint32Size((int32_t) itr.first.length());
        allSize += itr.second.length() + pbRawVarint32Size((int32_t) itr.second.length());
    }
    
    // 2. 创建新的缓冲区
    MMBuffer newData(allSize);
    CodedOutputData output(newData.getPtr(), allSize);
    
    // 3. 写入所有有效数据
    for (auto &itr : m_dic) {
        // 写入 key
        output.writeRawVarint32((int32_t) itr.first.length());
        output.writeRawData(itr.first.data(), itr.first.length());
        // 写入 value
        output.writeRawVarint32((int32_t) itr.second.length());
        output.writeRawData(itr.second.getPtr(), itr.second.length());
    }
    
    // 4. 重写文件
    memcpy(m_ptr + Fixed32Size, newData.getPtr(), allSize);
    m_actualSize = allSize;
    
    // 5. 更新文件头的数据长度
    memcpy(m_ptr, &m_actualSize, Fixed32Size);
}
```

#### 2.2.6 MMKV 跨进程支持

```cpp
// MMKV.cpp - 跨进程同步
void MMKV::checkLoadData() {
    if (m_isInterProcess) {
        // 跨进程模式，需要检查文件是否被其他进程修改
        MMKVMetaInfo metaInfo;
        metaInfo.read(m_metaFile.getMemory());
        
        if (m_metaInfo.m_sequence != metaInfo.m_sequence) {
            // 序列号不同，说明其他进程修改了数据
            // 需要重新加载
            clearMemoryCache();
            loadFromFile();
            m_metaInfo = metaInfo;
        }
    }
}

// 文件锁
void MMKV::lock() {
    if (m_isInterProcess) {
        // 使用文件锁实现跨进程同步
        flock(m_fd, LOCK_EX);
    }
}

void MMKV::unlock() {
    if (m_isInterProcess) {
        flock(m_fd, LOCK_UN);
    }
}
```

#### 2.2.7 MMKV 使用示例

```kotlin
/**
 * MMKV 使用封装
 */
object MMKVHelper {
    
    private lateinit var defaultMMKV: MMKV
    
    // 初始化
    fun init(context: Context) {
        val rootDir = MMKV.initialize(context)
        Log.d("MMKV", "MMKV root: $rootDir")
        
        defaultMMKV = MMKV.defaultMMKV()
    }
    
    // 获取指定 ID 的 MMKV 实例
    fun getMMKV(
        mmapID: String,
        mode: Int = MMKV.SINGLE_PROCESS_MODE,
        cryptKey: String? = null
    ): MMKV {
        return MMKV.mmkvWithID(mmapID, mode, cryptKey)
    }
    
    // 跨进程 MMKV
    fun getMultiProcessMMKV(mmapID: String): MMKV {
        return MMKV.mmkvWithID(mmapID, MMKV.MULTI_PROCESS_MODE)
    }
    
    // 基本读写操作
    fun putString(key: String, value: String) {
        defaultMMKV.encode(key, value)
    }
    
    fun getString(key: String, default: String = ""): String {
        return defaultMMKV.decodeString(key, default) ?: default
    }
    
    fun putInt(key: String, value: Int) {
        defaultMMKV.encode(key, value)
    }
    
    fun getInt(key: String, default: Int = 0): Int {
        return defaultMMKV.decodeInt(key, default)
    }
    
    fun putBoolean(key: String, value: Boolean) {
        defaultMMKV.encode(key, value)
    }
    
    fun getBoolean(key: String, default: Boolean = false): Boolean {
        return defaultMMKV.decodeBool(key, default)
    }
    
    // 存储 Parcelable 对象
    fun <T : Parcelable> putParcelable(key: String, value: T) {
        defaultMMKV.encode(key, value)
    }
    
    fun <T : Parcelable> getParcelable(key: String, clazz: Class<T>): T? {
        return defaultMMKV.decodeParcelable(key, clazz)
    }
    
    // 从 SharedPreferences 迁移
    fun importFromSP(sp: SharedPreferences) {
        defaultMMKV.importFromSharedPreferences(sp)
        sp.edit().clear().apply()
    }
    
    // 清除数据
    fun remove(key: String) {
        defaultMMKV.removeValueForKey(key)
    }
    
    fun clear() {
        defaultMMKV.clearAll()
    }
    
    // 获取所有 key
    fun allKeys(): Array<String>? {
        return defaultMMKV.allKeys()
    }
}
```


### 2.3 DataStore

DataStore 是 Google 推出的新一代数据存储方案，用于替代 SharedPreferences。

#### 2.3.1 DataStore 架构

```
DataStore 架构
┌─────────────────────────────────────────────────────────────┐
│                      Application                             │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────────┐│
│  │                    DataStore API                         ││
│  │  ┌─────────────────────┐  ┌─────────────────────────┐   ││
│  │  │ Preferences DataStore│  │    Proto DataStore      │   ││
│  │  │   (键值对存储)        │  │   (类型安全存储)         │   ││
│  │  └─────────────────────┘  └─────────────────────────┘   ││
│  └─────────────────────────────────────────────────────────┘│
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────────┐│
│  │                    Core Layer                            ││
│  │  ┌─────────────────┐  ┌─────────────────────────────┐   ││
│  │  │  Kotlin Flow    │  │      Kotlin Coroutines      │   ││
│  │  │  (响应式数据流)  │  │      (异步操作)              │   ││
│  │  └─────────────────┘  └─────────────────────────────┘   ││
│  │  ┌─────────────────────────────────────────────────────┐││
│  │  │              Atomic File Operations                  │││
│  │  │  (原子文件操作，避免数据损坏)                         │││
│  │  └─────────────────────────────────────────────────────┘││
│  └─────────────────────────────────────────────────────────┘│
├─────────────────────────────────────────────────────────────┤
│                      File System                             │
│  ┌─────────────────────────────────────────────────────────┐│
│  │  /data/data/<package>/files/datastore/                   ││
│  │  ├── settings.preferences_pb    # Preferences DataStore  ││
│  │  └── user_prefs.pb              # Proto DataStore        ││
│  └─────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────┘
```

#### 2.3.2 DataStore vs SharedPreferences

| 特性 | SharedPreferences | DataStore |
|-----|------------------|-----------|
| 异步 API | 部分（apply） | 完全异步 |
| 线程安全 | 需要注意 | 完全线程安全 |
| 类型安全 | 否 | Proto DataStore 支持 |
| 错误处理 | 无 | 支持 Flow 异常处理 |
| 数据一致性 | 可能丢失 | 原子操作保证 |
| 阻塞主线程 | 可能 | 不会 |

#### 2.3.3 Preferences DataStore 使用

```kotlin
// 1. 创建 DataStore
val Context.dataStore: DataStore<Preferences> by preferencesDataStore(
    name = "settings"
)

// 2. 定义 Key
object PreferencesKeys {
    val USER_NAME = stringPreferencesKey("user_name")
    val USER_AGE = intPreferencesKey("user_age")
    val IS_LOGGED_IN = booleanPreferencesKey("is_logged_in")
    val THEME_MODE = stringPreferencesKey("theme_mode")
}

// 3. 读取数据
class SettingsRepository(private val dataStore: DataStore<Preferences>) {
    
    // 读取单个值
    val userName: Flow<String> = dataStore.data
        .catch { exception ->
            if (exception is IOException) {
                emit(emptyPreferences())
            } else {
                throw exception
            }
        }
        .map { preferences ->
            preferences[PreferencesKeys.USER_NAME] ?: ""
        }
    
    // 读取多个值
    val userSettings: Flow<UserSettings> = dataStore.data
        .catch { exception ->
            if (exception is IOException) {
                emit(emptyPreferences())
            } else {
                throw exception
            }
        }
        .map { preferences ->
            UserSettings(
                userName = preferences[PreferencesKeys.USER_NAME] ?: "",
                userAge = preferences[PreferencesKeys.USER_AGE] ?: 0,
                isLoggedIn = preferences[PreferencesKeys.IS_LOGGED_IN] ?: false,
                themeMode = preferences[PreferencesKeys.THEME_MODE] ?: "system"
            )
        }
    
    // 写入数据
    suspend fun updateUserName(name: String) {
        dataStore.edit { preferences ->
            preferences[PreferencesKeys.USER_NAME] = name
        }
    }
    
    // 批量写入
    suspend fun updateUserSettings(settings: UserSettings) {
        dataStore.edit { preferences ->
            preferences[PreferencesKeys.USER_NAME] = settings.userName
            preferences[PreferencesKeys.USER_AGE] = settings.userAge
            preferences[PreferencesKeys.IS_LOGGED_IN] = settings.isLoggedIn
            preferences[PreferencesKeys.THEME_MODE] = settings.themeMode
        }
    }
    
    // 清除数据
    suspend fun clearAll() {
        dataStore.edit { preferences ->
            preferences.clear()
        }
    }
}

data class UserSettings(
    val userName: String,
    val userAge: Int,
    val isLoggedIn: Boolean,
    val themeMode: String
)
```

#### 2.3.4 Proto DataStore 使用

```protobuf
// user_prefs.proto
syntax = "proto3";

option java_package = "com.example.app";
option java_multiple_files = true;

message UserPreferences {
    string user_name = 1;
    int32 user_age = 2;
    bool is_logged_in = 3;
    ThemeMode theme_mode = 4;
    
    enum ThemeMode {
        SYSTEM = 0;
        LIGHT = 1;
        DARK = 2;
    }
}
```

```kotlin
// 1. 创建 Serializer
object UserPreferencesSerializer : Serializer<UserPreferences> {
    override val defaultValue: UserPreferences = UserPreferences.getDefaultInstance()
    
    override suspend fun readFrom(input: InputStream): UserPreferences {
        try {
            return UserPreferences.parseFrom(input)
        } catch (exception: InvalidProtocolBufferException) {
            throw CorruptionException("Cannot read proto.", exception)
        }
    }
    
    override suspend fun writeTo(t: UserPreferences, output: OutputStream) {
        t.writeTo(output)
    }
}

// 2. 创建 DataStore
val Context.userPrefsDataStore: DataStore<UserPreferences> by dataStore(
    fileName = "user_prefs.pb",
    serializer = UserPreferencesSerializer
)

// 3. 使用
class UserPrefsRepository(private val dataStore: DataStore<UserPreferences>) {
    
    val userPreferences: Flow<UserPreferences> = dataStore.data
        .catch { exception ->
            if (exception is IOException) {
                emit(UserPreferences.getDefaultInstance())
            } else {
                throw exception
            }
        }
    
    suspend fun updateUserName(name: String) {
        dataStore.updateData { currentPrefs ->
            currentPrefs.toBuilder()
                .setUserName(name)
                .build()
        }
    }
    
    suspend fun updateThemeMode(mode: UserPreferences.ThemeMode) {
        dataStore.updateData { currentPrefs ->
            currentPrefs.toBuilder()
                .setThemeMode(mode)
                .build()
        }
    }
    
    suspend fun login(userName: String, age: Int) {
        dataStore.updateData { currentPrefs ->
            currentPrefs.toBuilder()
                .setUserName(userName)
                .setUserAge(age)
                .setIsLoggedIn(true)
                .build()
        }
    }
}
```

#### 2.3.5 DataStore 核心源码分析

```kotlin
// SingleProcessDataStore.kt - 核心实现
internal class SingleProcessDataStore<T>(
    private val produceFile: () -> File,
    private val serializer: Serializer<T>,
    private val corruptionHandler: ReplaceFileCorruptionHandler<T>?,
    private val initTasksList: List<suspend (api: InitializerApi<T>) -> Unit>,
    private val scope: CoroutineScope
) : DataStore<T> {
    
    // 数据流
    override val data: Flow<T> = flow {
        // 确保初始化完成
        val currentState = downstreamFlow.first()
        
        // 发射当前值
        emit(currentState.value)
        
        // 收集后续更新
        emitAll(downstreamFlow.map { it.value })
    }
    
    // 更新数据
    override suspend fun updateData(transform: suspend (t: T) -> T): T {
        val ack = CompletableDeferred<T>()
        val msg = Message.Update(transform, ack)
        
        // 发送更新消息到 actor
        actor.send(msg)
        
        // 等待更新完成
        return ack.await()
    }
    
    // Actor 处理消息
    private val actor = scope.actor<Message<T>>(
        capacity = Channel.UNLIMITED
    ) {
        for (msg in channel) {
            when (msg) {
                is Message.Read -> handleRead(msg)
                is Message.Update -> handleUpdate(msg)
            }
        }
    }
    
    // 处理更新
    private suspend fun handleUpdate(update: Message.Update<T>) {
        try {
            // 1. 读取当前数据
            val currentData = readData()
            
            // 2. 应用转换
            val newData = update.transform(currentData)
            
            // 3. 写入文件（原子操作）
            writeData(newData)
            
            // 4. 更新内存状态
            downstreamFlow.value = Data(newData)
            
            // 5. 完成
            update.ack.complete(newData)
        } catch (e: Exception) {
            update.ack.completeExceptionally(e)
        }
    }
    
    // 原子写入
    private suspend fun writeData(data: T) {
        val file = produceFile()
        val scratchFile = File(file.absolutePath + ".tmp")
        
        try {
            // 写入临时文件
            scratchFile.outputStream().use { stream ->
                serializer.writeTo(data, stream)
                stream.fd.sync()  // 确保数据写入磁盘
            }
            
            // 原子重命名
            if (!scratchFile.renameTo(file)) {
                throw IOException("Unable to rename $scratchFile to $file")
            }
        } catch (e: Exception) {
            scratchFile.delete()
            throw e
        }
    }
}
```

### 2.4 SQLite 基础与优化

#### 2.4.1 SQLite 架构

```
SQLite 架构
┌─────────────────────────────────────────────────────────────┐
│                      Application                             │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────────┐│
│  │                    SQLite API                            ││
│  │  ┌─────────────────┐  ┌─────────────────────────────┐   ││
│  │  │ SQLiteOpenHelper│  │    SQLiteDatabase           │   ││
│  │  └─────────────────┘  └─────────────────────────────┘   ││
│  └─────────────────────────────────────────────────────────┘│
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────────┐│
│  │                    SQLite Core                           ││
│  │  ┌─────────────────────────────────────────────────────┐││
│  │  │                SQL Compiler                          │││
│  │  │  ┌─────────┐  ┌─────────┐  ┌─────────┐             │││
│  │  │  │ Tokenizer│─►│ Parser  │─►│Code Gen │             │││
│  │  │  └─────────┘  └─────────┘  └─────────┘             │││
│  │  └─────────────────────────────────────────────────────┘││
│  │  ┌─────────────────────────────────────────────────────┐││
│  │  │              Virtual Machine (VDBE)                  │││
│  │  │  执行字节码，操作 B-Tree                              │││
│  │  └─────────────────────────────────────────────────────┘││
│  │  ┌─────────────────────────────────────────────────────┐││
│  │  │                B-Tree Module                         │││
│  │  │  ┌─────────────────────────────────────────────────┐│││
│  │  │  │  表数据: B+Tree (rowid 为 key)                   ││││
│  │  │  │  索引数据: B-Tree (索引列为 key)                 ││││
│  │  │  └─────────────────────────────────────────────────┘│││
│  │  └─────────────────────────────────────────────────────┘││
│  │  ┌─────────────────────────────────────────────────────┐││
│  │  │                  Pager Module                        │││
│  │  │  页面缓存、事务管理、日志                             │││
│  │  └─────────────────────────────────────────────────────┘││
│  │  ┌─────────────────────────────────────────────────────┐││
│  │  │                    OS Layer                          │││
│  │  │  文件 I/O、锁、内存分配                               │││
│  │  └─────────────────────────────────────────────────────┘││
│  └─────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────┘
```

#### 2.4.2 SQLiteOpenHelper 使用

```kotlin
class AppDatabaseHelper(
    context: Context,
    name: String = DATABASE_NAME,
    version: Int = DATABASE_VERSION
) : SQLiteOpenHelper(context, name, null, version) {
    
    companion object {
        private const val DATABASE_NAME = "app.db"
        private const val DATABASE_VERSION = 1
        
        // 表名
        const val TABLE_USER = "user"
        
        // 列名
        const val COLUMN_ID = "id"
        const val COLUMN_NAME = "name"
        const val COLUMN_AGE = "age"
        const val COLUMN_EMAIL = "email"
        const val COLUMN_CREATED_AT = "created_at"
    }
    
    override fun onCreate(db: SQLiteDatabase) {
        // 创建表
        val createUserTable = """
            CREATE TABLE $TABLE_USER (
                $COLUMN_ID INTEGER PRIMARY KEY AUTOINCREMENT,
                $COLUMN_NAME TEXT NOT NULL,
                $COLUMN_AGE INTEGER DEFAULT 0,
                $COLUMN_EMAIL TEXT UNIQUE,
                $COLUMN_CREATED_AT INTEGER DEFAULT (strftime('%s', 'now'))
            )
        """.trimIndent()
        
        db.execSQL(createUserTable)
        
        // 创建索引
        db.execSQL("CREATE INDEX idx_user_name ON $TABLE_USER($COLUMN_NAME)")
        db.execSQL("CREATE INDEX idx_user_email ON $TABLE_USER($COLUMN_EMAIL)")
    }
    
    override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) {
        // 版本升级
        if (oldVersion < 2) {
            // 添加新列
            db.execSQL("ALTER TABLE $TABLE_USER ADD COLUMN avatar TEXT")
        }
        if (oldVersion < 3) {
            // 创建新表
            db.execSQL("CREATE TABLE IF NOT EXISTS settings (...)")
        }
    }
    
    override fun onConfigure(db: SQLiteDatabase) {
        super.onConfigure(db)
        // 启用外键约束
        db.setForeignKeyConstraintsEnabled(true)
        // 启用 WAL 模式
        db.enableWriteAheadLogging()
    }
}
```

#### 2.4.3 SQLite 优化策略

```kotlin
/**
 * SQLite 优化工具类
 */
object SQLiteOptimizer {
    
    /**
     * 1. 使用事务批量操作
     */
    fun batchInsert(db: SQLiteDatabase, users: List<User>) {
        db.beginTransaction()
        try {
            val stmt = db.compileStatement(
                "INSERT INTO user (name, age, email) VALUES (?, ?, ?)"
            )
            
            users.forEach { user ->
                stmt.clearBindings()
                stmt.bindString(1, user.name)
                stmt.bindLong(2, user.age.toLong())
                stmt.bindString(3, user.email)
                stmt.executeInsert()
            }
            
            db.setTransactionSuccessful()
        } finally {
            db.endTransaction()
        }
    }
    
    /**
     * 2. 使用预编译语句
     */
    fun insertWithStatement(db: SQLiteDatabase, user: User): Long {
        val stmt = db.compileStatement(
            "INSERT INTO user (name, age, email) VALUES (?, ?, ?)"
        )
        stmt.bindString(1, user.name)
        stmt.bindLong(2, user.age.toLong())
        stmt.bindString(3, user.email)
        return stmt.executeInsert()
    }
    
    /**
     * 3. 索引优化
     */
    fun createOptimalIndexes(db: SQLiteDatabase) {
        // 单列索引 - 用于等值查询
        db.execSQL("CREATE INDEX IF NOT EXISTS idx_user_email ON user(email)")
        
        // 复合索引 - 用于多条件查询（注意列顺序）
        db.execSQL("CREATE INDEX IF NOT EXISTS idx_user_name_age ON user(name, age)")
        
        // 覆盖索引 - 避免回表查询
        db.execSQL("CREATE INDEX IF NOT EXISTS idx_user_covering ON user(name, age, email)")
    }
    
    /**
     * 4. 查询优化
     */
    fun optimizedQuery(db: SQLiteDatabase, name: String, minAge: Int): Cursor {
        // 使用参数化查询，避免 SQL 注入
        return db.rawQuery(
            """
            SELECT id, name, age, email 
            FROM user 
            WHERE name = ? AND age >= ?
            ORDER BY age DESC
            LIMIT 100
            """.trimIndent(),
            arrayOf(name, minAge.toString())
        )
    }
    
    /**
     * 5. 分析查询计划
     */
    fun explainQuery(db: SQLiteDatabase, sql: String) {
        val cursor = db.rawQuery("EXPLAIN QUERY PLAN $sql", null)
        cursor.use {
            while (it.moveToNext()) {
                val detail = it.getString(it.getColumnIndexOrThrow("detail"))
                Log.d("SQLite", "Query Plan: $detail")
            }
        }
    }
    
    /**
     * 6. WAL 模式配置
     */
    fun enableWAL(db: SQLiteDatabase) {
        // WAL (Write-Ahead Logging) 模式
        // 优点：读写并发、写入性能提升
        // 缺点：占用更多磁盘空间
        db.enableWriteAheadLogging()
        
        // 设置 WAL 检查点大小
        db.rawQuery("PRAGMA wal_autocheckpoint=1000", null).close()
    }
    
    /**
     * 7. 内存优化
     */
    fun configureMemory(db: SQLiteDatabase) {
        // 设置页面缓存大小（单位：页，默认页大小 4KB）
        db.rawQuery("PRAGMA cache_size=2000", null).close()  // 8MB 缓存
        
        // 设置临时存储位置
        db.rawQuery("PRAGMA temp_store=MEMORY", null).close()
    }
    
    /**
     * 8. 数据库维护
     */
    fun maintenance(db: SQLiteDatabase) {
        // 分析表统计信息（优化查询计划）
        db.execSQL("ANALYZE")
        
        // 整理数据库（回收空间）
        db.execSQL("VACUUM")
        
        // 完整性检查
        val cursor = db.rawQuery("PRAGMA integrity_check", null)
        cursor.use {
            if (it.moveToFirst()) {
                val result = it.getString(0)
                if (result != "ok") {
                    Log.e("SQLite", "Database integrity check failed: $result")
                }
            }
        }
    }
}
```

#### 2.4.4 SQLite 事务与锁

```
SQLite 锁机制
┌─────────────────────────────────────────────────────────────┐
│  锁状态转换                                                  │
│                                                              │
│  UNLOCKED ──► SHARED ──► RESERVED ──► PENDING ──► EXCLUSIVE │
│      │           │           │           │           │       │
│      │           │           │           │           │       │
│      ▼           ▼           ▼           ▼           ▼       │
│   无锁状态    读锁状态    准备写入    等待写入    独占写入    │
│   (初始)     (可并发)    (单个)     (阻塞读)    (独占)      │
│                                                              │
├─────────────────────────────────────────────────────────────┤
│  WAL 模式下的并发                                            │
│  ┌─────────────────────────────────────────────────────────┐│
│  │  Reader 1 ──► 读取 WAL 快照 1                            ││
│  │  Reader 2 ──► 读取 WAL 快照 1                            ││
│  │  Writer   ──► 写入 WAL 文件 ──► 检查点 ──► 合并到主文件  ││
│  │                                                          ││
│  │  读写可以并发进行！                                       ││
│  └─────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────┘
```


### 2.5 Room 数据库

Room 是 Google 推出的 SQLite 抽象层，提供编译时验证和便捷的 API。

#### 2.5.1 Room 架构

```
Room 架构
┌─────────────────────────────────────────────────────────────┐
│                      Application                             │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────────┐│
│  │                    Room API                              ││
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────────┐  ││
│  │  │  @Entity    │  │    @Dao     │  │   @Database     │  ││
│  │  │  (数据表)    │  │  (数据访问)  │  │   (数据库)      │  ││
│  │  └─────────────┘  └─────────────┘  └─────────────────┘  ││
│  └─────────────────────────────────────────────────────────┘│
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────────┐│
│  │              Room Compiler (APT)                         ││
│  │  ┌─────────────────────────────────────────────────────┐││
│  │  │  编译时生成：                                         │││
│  │  │  - AppDatabase_Impl                                  │││
│  │  │  - UserDao_Impl                                      │││
│  │  │  - SQL 语句验证                                       │││
│  │  └─────────────────────────────────────────────────────┘││
│  └─────────────────────────────────────────────────────────┘│
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────────┐│
│  │                    SQLite                                ││
│  └─────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────┘
```

#### 2.5.2 Room 基本使用

```kotlin
// 1. Entity 定义
@Entity(
    tableName = "users",
    indices = [
        Index(value = ["email"], unique = true),
        Index(value = ["name", "age"])
    ]
)
data class User(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0,
    
    @ColumnInfo(name = "name")
    val name: String,
    
    @ColumnInfo(name = "age")
    val age: Int,
    
    @ColumnInfo(name = "email")
    val email: String?,
    
    @ColumnInfo(name = "created_at", defaultValue = "CURRENT_TIMESTAMP")
    val createdAt: Long = System.currentTimeMillis()
)

// 2. Dao 定义
@Dao
interface UserDao {
    
    // 查询所有用户
    @Query("SELECT * FROM users ORDER BY created_at DESC")
    fun getAllUsers(): Flow<List<User>>
    
    // 根据 ID 查询
    @Query("SELECT * FROM users WHERE id = :userId")
    suspend fun getUserById(userId: Long): User?
    
    // 根据条件查询
    @Query("SELECT * FROM users WHERE age >= :minAge AND age <= :maxAge")
    fun getUsersByAgeRange(minAge: Int, maxAge: Int): Flow<List<User>>
    
    // 模糊查询
    @Query("SELECT * FROM users WHERE name LIKE '%' || :keyword || '%'")
    suspend fun searchUsers(keyword: String): List<User>
    
    // 分页查询
    @Query("SELECT * FROM users ORDER BY id DESC LIMIT :limit OFFSET :offset")
    suspend fun getUsersPaged(limit: Int, offset: Int): List<User>
    
    // 插入
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(user: User): Long
    
    // 批量插入
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertAll(users: List<User>): List<Long>
    
    // 更新
    @Update
    suspend fun update(user: User): Int
    
    // 删除
    @Delete
    suspend fun delete(user: User): Int
    
    // 根据 ID 删除
    @Query("DELETE FROM users WHERE id = :userId")
    suspend fun deleteById(userId: Long): Int
    
    // 清空表
    @Query("DELETE FROM users")
    suspend fun deleteAll()
    
    // 事务操作
    @Transaction
    suspend fun updateUserWithLog(user: User, log: OperationLog) {
        update(user)
        insertLog(log)
    }
    
    @Insert
    suspend fun insertLog(log: OperationLog)
}

// 3. Database 定义
@Database(
    entities = [User::class, OperationLog::class],
    version = 1,
    exportSchema = true
)
@TypeConverters(Converters::class)
abstract class AppDatabase : RoomDatabase() {
    
    abstract fun userDao(): UserDao
    
    companion object {
        @Volatile
        private var INSTANCE: AppDatabase? = null
        
        fun getInstance(context: Context): AppDatabase {
            return INSTANCE ?: synchronized(this) {
                INSTANCE ?: buildDatabase(context).also { INSTANCE = it }
            }
        }
        
        private fun buildDatabase(context: Context): AppDatabase {
            return Room.databaseBuilder(
                context.applicationContext,
                AppDatabase::class.java,
                "app_database.db"
            )
            .addCallback(object : RoomDatabase.Callback() {
                override fun onCreate(db: SupportSQLiteDatabase) {
                    super.onCreate(db)
                    // 数据库首次创建时的回调
                }
            })
            .addMigrations(MIGRATION_1_2, MIGRATION_2_3)
            .setJournalMode(JournalMode.WRITE_AHEAD_LOGGING)
            .build()
        }
        
        // 数据库迁移
        private val MIGRATION_1_2 = object : Migration(1, 2) {
            override fun migrate(database: SupportSQLiteDatabase) {
                database.execSQL("ALTER TABLE users ADD COLUMN avatar TEXT")
            }
        }
        
        private val MIGRATION_2_3 = object : Migration(2, 3) {
            override fun migrate(database: SupportSQLiteDatabase) {
                database.execSQL("""
                    CREATE TABLE IF NOT EXISTS settings (
                        id INTEGER PRIMARY KEY NOT NULL,
                        key TEXT NOT NULL,
                        value TEXT
                    )
                """)
            }
        }
    }
}

// 4. 类型转换器
class Converters {
    @TypeConverter
    fun fromTimestamp(value: Long?): Date? {
        return value?.let { Date(it) }
    }
    
    @TypeConverter
    fun dateToTimestamp(date: Date?): Long? {
        return date?.time
    }
    
    @TypeConverter
    fun fromStringList(value: List<String>?): String? {
        return value?.joinToString(",")
    }
    
    @TypeConverter
    fun toStringList(value: String?): List<String>? {
        return value?.split(",")
    }
}
```

#### 2.5.3 Room 高级用法

```kotlin
// 1. 关联查询
@Entity(tableName = "posts")
data class Post(
    @PrimaryKey(autoGenerate = true) val postId: Long = 0,
    val userId: Long,
    val title: String,
    val content: String
)

// 一对多关系
data class UserWithPosts(
    @Embedded val user: User,
    @Relation(
        parentColumn = "id",
        entityColumn = "userId"
    )
    val posts: List<Post>
)

@Dao
interface UserDao {
    @Transaction
    @Query("SELECT * FROM users WHERE id = :userId")
    suspend fun getUserWithPosts(userId: Long): UserWithPosts?
    
    @Transaction
    @Query("SELECT * FROM users")
    fun getAllUsersWithPosts(): Flow<List<UserWithPosts>>
}

// 2. 多对多关系
@Entity(tableName = "tags")
data class Tag(
    @PrimaryKey(autoGenerate = true) val tagId: Long = 0,
    val name: String
)

@Entity(
    tableName = "post_tag_cross_ref",
    primaryKeys = ["postId", "tagId"]
)
data class PostTagCrossRef(
    val postId: Long,
    val tagId: Long
)

data class PostWithTags(
    @Embedded val post: Post,
    @Relation(
        parentColumn = "postId",
        entityColumn = "tagId",
        associateBy = Junction(PostTagCrossRef::class)
    )
    val tags: List<Tag>
)

// 3. 原始查询
@Dao
interface RawQueryDao {
    @RawQuery(observedEntities = [User::class])
    fun getUsers(query: SupportSQLiteQuery): Flow<List<User>>
}

// 使用
val query = SimpleSQLiteQuery(
    "SELECT * FROM users WHERE age > ? ORDER BY name",
    arrayOf(18)
)
rawQueryDao.getUsers(query)

// 4. 与 Paging 3 集成
@Dao
interface UserDao {
    @Query("SELECT * FROM users ORDER BY id DESC")
    fun getUsersPagingSource(): PagingSource<Int, User>
}

// ViewModel 中使用
val usersPager = Pager(
    config = PagingConfig(
        pageSize = 20,
        enablePlaceholders = false
    ),
    pagingSourceFactory = { userDao.getUsersPagingSource() }
).flow.cachedIn(viewModelScope)
```


### 2.6 Scoped Storage（分区存储）

Android 10 引入分区存储，Android 11 强制执行，限制应用对外部存储的访问。

#### 2.6.1 分区存储架构

```
分区存储架构
┌─────────────────────────────────────────────────────────────┐
│                    外部存储 (/storage/emulated/0/)           │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────────┐│
│  │              应用专属目录（无需权限）                      ││
│  │  /storage/emulated/0/Android/data/<package>/            ││
│  │  ├── files/          # getExternalFilesDir()            ││
│  │  └── cache/          # getExternalCacheDir()            ││
│  └─────────────────────────────────────────────────────────┘│
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────────┐│
│  │              共享存储（需要权限/SAF）                      ││
│  │  ┌─────────────────────────────────────────────────────┐││
│  │  │  媒体文件（MediaStore API）                          │││
│  │  │  ├── Images/      # MediaStore.Images               │││
│  │  │  ├── Video/       # MediaStore.Video                │││
│  │  │  ├── Audio/       # MediaStore.Audio                │││
│  │  │  └── Downloads/   # MediaStore.Downloads            │││
│  │  └─────────────────────────────────────────────────────┘││
│  │  ┌─────────────────────────────────────────────────────┐││
│  │  │  其他文件（Storage Access Framework）                │││
│  │  │  ├── Documents/                                     │││
│  │  │  └── 任意目录（用户授权）                             │││
│  │  └─────────────────────────────────────────────────────┘││
│  └─────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────┘

权限变化
┌─────────────────────────────────────────────────────────────┐
│  Android 版本    │  权限要求                                 │
├─────────────────────────────────────────────────────────────┤
│  Android 9-     │  READ/WRITE_EXTERNAL_STORAGE              │
│  Android 10     │  requestLegacyExternalStorage=true 可绕过 │
│  Android 11+    │  强制分区存储，需使用 MediaStore/SAF       │
│  Android 13+    │  细分媒体权限：                            │
│                 │  READ_MEDIA_IMAGES                        │
│                 │  READ_MEDIA_VIDEO                         │
│                 │  READ_MEDIA_AUDIO                         │
│  Android 14+    │  READ_MEDIA_VISUAL_USER_SELECTED          │
│                 │  （部分照片访问权限）                       │
└─────────────────────────────────────────────────────────────┘
```

#### 2.6.2 MediaStore API 使用

```kotlin
/**
 * MediaStore 操作工具类
 */
object MediaStoreHelper {
    
    /**
     * 保存图片到相册
     */
    suspend fun saveImageToGallery(
        context: Context,
        bitmap: Bitmap,
        displayName: String,
        mimeType: String = "image/jpeg"
    ): Uri? = withContext(Dispatchers.IO) {
        val contentValues = ContentValues().apply {
            put(MediaStore.Images.Media.DISPLAY_NAME, displayName)
            put(MediaStore.Images.Media.MIME_TYPE, mimeType)
            put(MediaStore.Images.Media.DATE_ADDED, System.currentTimeMillis() / 1000)
            put(MediaStore.Images.Media.DATE_MODIFIED, System.currentTimeMillis() / 1000)
            
            // Android 10+ 需要设置 RELATIVE_PATH
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                put(MediaStore.Images.Media.RELATIVE_PATH, Environment.DIRECTORY_PICTURES)
                put(MediaStore.Images.Media.IS_PENDING, 1)
            }
        }
        
        val resolver = context.contentResolver
        val uri = resolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, contentValues)
        
        uri?.let {
            try {
                resolver.openOutputStream(it)?.use { outputStream ->
                    val format = if (mimeType == "image/png") {
                        Bitmap.CompressFormat.PNG
                    } else {
                        Bitmap.CompressFormat.JPEG
                    }
                    bitmap.compress(format, 90, outputStream)
                }
                
                // Android 10+ 完成写入后清除 IS_PENDING
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                    contentValues.clear()
                    contentValues.put(MediaStore.Images.Media.IS_PENDING, 0)
                    resolver.update(it, contentValues, null, null)
                }
                
                it
            } catch (e: Exception) {
                resolver.delete(it, null, null)
                null
            }
        }
    }
    
    /**
     * 查询图片
     */
    suspend fun queryImages(
        context: Context,
        selection: String? = null,
        selectionArgs: Array<String>? = null,
        sortOrder: String = "${MediaStore.Images.Media.DATE_MODIFIED} DESC",
        limit: Int = 100
    ): List<MediaItem> = withContext(Dispatchers.IO) {
        val images = mutableListOf<MediaItem>()
        
        val projection = arrayOf(
            MediaStore.Images.Media._ID,
            MediaStore.Images.Media.DISPLAY_NAME,
            MediaStore.Images.Media.SIZE,
            MediaStore.Images.Media.MIME_TYPE,
            MediaStore.Images.Media.DATE_MODIFIED,
            MediaStore.Images.Media.WIDTH,
            MediaStore.Images.Media.HEIGHT
        )
        
        val queryUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI.buildUpon()
            .appendQueryParameter("limit", limit.toString())
            .build()
        
        context.contentResolver.query(
            queryUri,
            projection,
            selection,
            selectionArgs,
            sortOrder
        )?.use { cursor ->
            val idColumn = cursor.getColumnIndexOrThrow(MediaStore.Images.Media._ID)
            val nameColumn = cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DISPLAY_NAME)
            val sizeColumn = cursor.getColumnIndexOrThrow(MediaStore.Images.Media.SIZE)
            val mimeColumn = cursor.getColumnIndexOrThrow(MediaStore.Images.Media.MIME_TYPE)
            val dateColumn = cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATE_MODIFIED)
            
            while (cursor.moveToNext()) {
                val id = cursor.getLong(idColumn)
                val contentUri = ContentUris.withAppendedId(
                    MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
                    id
                )
                
                images.add(
                    MediaItem(
                        id = id,
                        uri = contentUri,
                        displayName = cursor.getString(nameColumn),
                        size = cursor.getLong(sizeColumn),
                        mimeType = cursor.getString(mimeColumn),
                        dateModified = cursor.getLong(dateColumn)
                    )
                )
            }
        }
        
        images
    }
    
    /**
     * 删除媒体文件
     */
    suspend fun deleteMedia(context: Context, uri: Uri): Boolean = withContext(Dispatchers.IO) {
        try {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
                // Android 11+ 需要用户确认
                val pendingIntent = MediaStore.createDeleteRequest(
                    context.contentResolver,
                    listOf(uri)
                )
                // 需要在 Activity 中启动
                // startIntentSenderForResult(pendingIntent.intentSender, ...)
                false
            } else {
                context.contentResolver.delete(uri, null, null) > 0
            }
        } catch (e: Exception) {
            false
        }
    }
}

data class MediaItem(
    val id: Long,
    val uri: Uri,
    val displayName: String,
    val size: Long,
    val mimeType: String,
    val dateModified: Long
)
```

#### 2.6.3 Storage Access Framework (SAF)

```kotlin
/**
 * SAF 文件选择器
 */
class FilePickerHelper(private val activity: ComponentActivity) {
    
    // 选择单个文件
    private val pickFileLauncher = activity.registerForActivityResult(
        ActivityResultContracts.OpenDocument()
    ) { uri ->
        uri?.let { onFilePicked(it) }
    }
    
    // 选择多个文件
    private val pickMultipleFilesLauncher = activity.registerForActivityResult(
        ActivityResultContracts.OpenMultipleDocuments()
    ) { uris ->
        onMultipleFilesPicked(uris)
    }
    
    // 创建文件
    private val createFileLauncher = activity.registerForActivityResult(
        ActivityResultContracts.CreateDocument("application/pdf")
    ) { uri ->
        uri?.let { onFileCreated(it) }
    }
    
    // 选择目录
    private val pickDirectoryLauncher = activity.registerForActivityResult(
        ActivityResultContracts.OpenDocumentTree()
    ) { uri ->
        uri?.let { onDirectoryPicked(it) }
    }
    
    fun pickFile(mimeTypes: Array<String> = arrayOf("*/*")) {
        pickFileLauncher.launch(mimeTypes)
    }
    
    fun pickMultipleFiles(mimeTypes: Array<String> = arrayOf("*/*")) {
        pickMultipleFilesLauncher.launch(mimeTypes)
    }
    
    fun createFile(fileName: String) {
        createFileLauncher.launch(fileName)
    }
    
    fun pickDirectory() {
        pickDirectoryLauncher.launch(null)
    }
    
    private fun onFilePicked(uri: Uri) {
        // 获取持久化权限
        activity.contentResolver.takePersistableUriPermission(
            uri,
            Intent.FLAG_GRANT_READ_URI_PERMISSION or Intent.FLAG_GRANT_WRITE_URI_PERMISSION
        )
        
        // 读取文件
        activity.contentResolver.openInputStream(uri)?.use { inputStream ->
            // 处理文件内容
        }
    }
    
    private fun onMultipleFilesPicked(uris: List<Uri>) {
        uris.forEach { uri ->
            activity.contentResolver.takePersistableUriPermission(
                uri,
                Intent.FLAG_GRANT_READ_URI_PERMISSION
            )
        }
    }
    
    private fun onFileCreated(uri: Uri) {
        activity.contentResolver.openOutputStream(uri)?.use { outputStream ->
            // 写入文件内容
        }
    }
    
    private fun onDirectoryPicked(uri: Uri) {
        // 获取目录的持久化权限
        activity.contentResolver.takePersistableUriPermission(
            uri,
            Intent.FLAG_GRANT_READ_URI_PERMISSION or Intent.FLAG_GRANT_WRITE_URI_PERMISSION
        )
        
        // 使用 DocumentFile 操作目录
        val documentFile = DocumentFile.fromTreeUri(activity, uri)
        documentFile?.listFiles()?.forEach { file ->
            Log.d("SAF", "File: ${file.name}, isDirectory: ${file.isDirectory}")
        }
    }
}
```


### 2.7 文件存储最佳实践

#### 2.7.1 存储位置选择

```kotlin
/**
 * 文件存储工具类
 */
object FileStorageHelper {
    
    /**
     * 获取内部存储目录
     * 路径: /data/data/<package>/files/
     * 特点: 应用私有，卸载时删除，无需权限
     */
    fun getInternalFilesDir(context: Context, type: String? = null): File {
        return context.filesDir.let { dir ->
            if (type != null) File(dir, type).also { it.mkdirs() } else dir
        }
    }
    
    /**
     * 获取内部缓存目录
     * 路径: /data/data/<package>/cache/
     * 特点: 系统可能在存储空间不足时清理
     */
    fun getInternalCacheDir(context: Context): File {
        return context.cacheDir
    }
    
    /**
     * 获取外部应用专属目录
     * 路径: /storage/emulated/0/Android/data/<package>/files/
     * 特点: 无需权限，卸载时删除
     */
    fun getExternalFilesDir(context: Context, type: String? = null): File? {
        return context.getExternalFilesDir(type)
    }
    
    /**
     * 获取外部缓存目录
     * 路径: /storage/emulated/0/Android/data/<package>/cache/
     */
    fun getExternalCacheDir(context: Context): File? {
        return context.externalCacheDir
    }
    
    /**
     * 存储位置选择建议
     */
    fun recommendStorageLocation(
        context: Context,
        fileType: FileType,
        fileSize: Long,
        needShare: Boolean
    ): File? {
        return when {
            // 敏感数据 -> 内部存储
            fileType == FileType.SENSITIVE -> getInternalFilesDir(context, "secure")
            
            // 需要分享的媒体文件 -> MediaStore
            needShare && fileType in listOf(FileType.IMAGE, FileType.VIDEO, FileType.AUDIO) -> {
                // 使用 MediaStore API
                null
            }
            
            // 大文件 -> 外部应用专属目录
            fileSize > 10 * 1024 * 1024 -> getExternalFilesDir(context, fileType.dirName)
            
            // 临时文件 -> 缓存目录
            fileType == FileType.TEMP -> getExternalCacheDir(context) ?: getInternalCacheDir(context)
            
            // 默认 -> 内部存储
            else -> getInternalFilesDir(context, fileType.dirName)
        }
    }
    
    enum class FileType(val dirName: String) {
        IMAGE("images"),
        VIDEO("videos"),
        AUDIO("audio"),
        DOCUMENT("documents"),
        TEMP("temp"),
        SENSITIVE("secure"),
        DATABASE("databases"),
        LOG("logs")
    }
}
```

#### 2.7.2 文件操作封装

```kotlin
/**
 * 文件操作工具类
 */
object FileUtils {
    
    /**
     * 安全写入文件（原子操作）
     */
    suspend fun writeFileAtomically(
        file: File,
        content: ByteArray
    ): Boolean = withContext(Dispatchers.IO) {
        val tempFile = File(file.parent, "${file.name}.tmp")
        
        try {
            // 1. 写入临时文件
            tempFile.outputStream().use { output ->
                output.write(content)
                output.fd.sync()  // 确保数据写入磁盘
            }
            
            // 2. 原子重命名
            if (tempFile.renameTo(file)) {
                true
            } else {
                // 重命名失败，尝试复制
                tempFile.copyTo(file, overwrite = true)
                tempFile.delete()
                true
            }
        } catch (e: Exception) {
            tempFile.delete()
            false
        }
    }
    
    /**
     * 安全读取文件
     */
    suspend fun readFile(file: File): ByteArray? = withContext(Dispatchers.IO) {
        try {
            if (file.exists() && file.canRead()) {
                file.readBytes()
            } else {
                null
            }
        } catch (e: Exception) {
            null
        }
    }
    
    /**
     * 复制文件（带进度回调）
     */
    suspend fun copyFile(
        source: File,
        dest: File,
        onProgress: ((Long, Long) -> Unit)? = null
    ): Boolean = withContext(Dispatchers.IO) {
        try {
            val totalSize = source.length()
            var copiedSize = 0L
            
            source.inputStream().use { input ->
                dest.outputStream().use { output ->
                    val buffer = ByteArray(8192)
                    var bytesRead: Int
                    
                    while (input.read(buffer).also { bytesRead = it } != -1) {
                        output.write(buffer, 0, bytesRead)
                        copiedSize += bytesRead
                        onProgress?.invoke(copiedSize, totalSize)
                    }
                    
                    output.fd.sync()
                }
            }
            true
        } catch (e: Exception) {
            dest.delete()
            false
        }
    }
    
    /**
     * 删除目录（递归）
     */
    fun deleteDirectory(dir: File): Boolean {
        if (dir.isDirectory) {
            dir.listFiles()?.forEach { child ->
                deleteDirectory(child)
            }
        }
        return dir.delete()
    }
    
    /**
     * 获取目录大小
     */
    fun getDirectorySize(dir: File): Long {
        var size = 0L
        if (dir.isDirectory) {
            dir.listFiles()?.forEach { file ->
                size += if (file.isDirectory) {
                    getDirectorySize(file)
                } else {
                    file.length()
                }
            }
        } else {
            size = dir.length()
        }
        return size
    }
    
    /**
     * 清理过期缓存
     */
    fun cleanExpiredCache(cacheDir: File, maxAge: Long = 7 * 24 * 60 * 60 * 1000L) {
        val now = System.currentTimeMillis()
        cacheDir.listFiles()?.forEach { file ->
            if (now - file.lastModified() > maxAge) {
                if (file.isDirectory) {
                    deleteDirectory(file)
                } else {
                    file.delete()
                }
            }
        }
    }
    
    /**
     * 限制缓存大小
     */
    fun limitCacheSize(cacheDir: File, maxSize: Long) {
        val currentSize = getDirectorySize(cacheDir)
        if (currentSize <= maxSize) return
        
        // 按修改时间排序，删除最旧的文件
        val files = cacheDir.listFiles()
            ?.filter { it.isFile }
            ?.sortedBy { it.lastModified() }
            ?: return
        
        var freedSize = 0L
        val targetFreeSize = currentSize - maxSize
        
        for (file in files) {
            if (freedSize >= targetFreeSize) break
            freedSize += file.length()
            file.delete()
        }
    }
}
```

---

## 3. 关键源码解析

### 3.1 MMKV 核心源码

```cpp
// MMKV.cpp - 核心数据结构
class MMKV {
private:
    // 文件路径
    string m_path;
    // 文件描述符
    int m_fd;
    // mmap 映射地址
    char *m_ptr;
    // 映射大小
    size_t m_size;
    // 实际数据大小
    size_t m_actualSize;
    // 内存缓存
    unordered_map<string, MMBuffer> m_dic;
    // 是否跨进程
    bool m_isInterProcess;
    // 文件锁
    FileLock *m_fileLock;
    // CRC 校验
    uint32_t m_crcDigest;
    
public:
    // 获取实例
    static MMKV *mmkvWithID(const string &mmapID, int mode, string *cryptKey);
    
    // 编码数据
    bool set(bool value, const string &key);
    bool set(int32_t value, const string &key);
    bool set(const string &value, const string &key);
    bool set(const MMBuffer &value, const string &key);
    
    // 解码数据
    bool getBool(const string &key, bool defaultValue = false);
    int32_t getInt32(const string &key, int32_t defaultValue = 0);
    string getString(const string &key, const string &defaultValue = "");
    MMBuffer getBytes(const string &key);
    
    // 删除数据
    void removeValueForKey(const string &key);
    void removeValuesForKeys(const vector<string> &keys);
    
    // 同步
    void sync(SyncFlag flag);
    
    // 重整
    void trim();
    void clearAll();
};

// 写入数据的核心实现
bool MMKV::setDataForKey(MMBuffer &&data, const string &key) {
    if (data.length() == 0 || key.empty()) {
        return false;
    }
    
    // 1. 加锁（跨进程模式）
    SCOPED_LOCK(m_lock);
    
    // 2. 检查是否需要从文件重新加载
    checkLoadData();
    
    // 3. 计算编码后的大小
    auto keyData = MMBuffer((void *) key.data(), key.length(), MMBufferNoCopy);
    size_t size = keyData.length() + pbRawVarint32Size((int32_t) keyData.length());
    size += data.length() + pbRawVarint32Size((int32_t) data.length());
    
    // 4. 检查是否需要扩容或重整
    bool hasEnoughSize = ensureMemorySize(size);
    if (!hasEnoughSize || m_needFullWriteback) {
        // 需要重整
        fullWriteback();
    }
    
    // 5. 追加写入
    if (hasEnoughSize) {
        // 编码 key-value
        MMBuffer keyValue(size);
        CodedOutputData output(keyValue.getPtr(), size);
        output.writeData(keyData);
        output.writeData(data);
        
        // 写入 mmap 区域
        memcpy(m_ptr + Fixed32Size + m_actualSize, keyValue.getPtr(), size);
        m_actualSize += size;
        
        // 更新文件头
        memcpy(m_ptr, &m_actualSize, Fixed32Size);
    }
    
    // 6. 更新内存缓存
    m_dic[key] = std::move(data);
    
    return true;
}
```

### 3.2 Room 生成代码分析

```java
// Room 编译器生成的 DAO 实现
public final class UserDao_Impl implements UserDao {
    private final RoomDatabase __db;
    private final EntityInsertionAdapter<User> __insertionAdapterOfUser;
    private final EntityDeletionOrUpdateAdapter<User> __deletionAdapterOfUser;
    private final EntityDeletionOrUpdateAdapter<User> __updateAdapterOfUser;
    
    public UserDao_Impl(RoomDatabase __db) {
        this.__db = __db;
        
        // 插入适配器
        this.__insertionAdapterOfUser = new EntityInsertionAdapter<User>(__db) {
            @Override
            public String createQuery() {
                return "INSERT OR REPLACE INTO `users` (`id`,`name`,`age`,`email`,`created_at`) "
                    + "VALUES (nullif(?, 0),?,?,?,?)";
            }
            
            @Override
            public void bind(SupportSQLiteStatement stmt, User value) {
                stmt.bindLong(1, value.getId());
                stmt.bindString(2, value.getName());
                stmt.bindLong(3, value.getAge());
                if (value.getEmail() == null) {
                    stmt.bindNull(4);
                } else {
                    stmt.bindString(4, value.getEmail());
                }
                stmt.bindLong(5, value.getCreatedAt());
            }
        };
    }
    
    @Override
    public Object insert(final User user, final Continuation<? super Long> continuation) {
        return CoroutinesRoom.execute(__db, true, new Callable<Long>() {
            @Override
            public Long call() throws Exception {
                __db.beginTransaction();
                try {
                    long _result = __insertionAdapterOfUser.insertAndReturnId(user);
                    __db.setTransactionSuccessful();
                    return _result;
                } finally {
                    __db.endTransaction();
                }
            }
        }, continuation);
    }
    
    @Override
    public Flow<List<User>> getAllUsers() {
        final String _sql = "SELECT * FROM users ORDER BY created_at DESC";
        final RoomSQLiteQuery _statement = RoomSQLiteQuery.acquire(_sql, 0);
        
        return CoroutinesRoom.createFlow(__db, false, new String[]{"users"}, new Callable<List<User>>() {
            @Override
            public List<User> call() throws Exception {
                final Cursor _cursor = DBUtil.query(__db, _statement, false, null);
                try {
                    final int _cursorIndexOfId = CursorUtil.getColumnIndexOrThrow(_cursor, "id");
                    final int _cursorIndexOfName = CursorUtil.getColumnIndexOrThrow(_cursor, "name");
                    final int _cursorIndexOfAge = CursorUtil.getColumnIndexOrThrow(_cursor, "age");
                    final int _cursorIndexOfEmail = CursorUtil.getColumnIndexOrThrow(_cursor, "email");
                    final int _cursorIndexOfCreatedAt = CursorUtil.getColumnIndexOrThrow(_cursor, "created_at");
                    
                    final List<User> _result = new ArrayList<User>(_cursor.getCount());
                    while (_cursor.moveToNext()) {
                        final User _item;
                        final long _tmpId = _cursor.getLong(_cursorIndexOfId);
                        final String _tmpName = _cursor.getString(_cursorIndexOfName);
                        final int _tmpAge = _cursor.getInt(_cursorIndexOfAge);
                        final String _tmpEmail = _cursor.isNull(_cursorIndexOfEmail) ? null : _cursor.getString(_cursorIndexOfEmail);
                        final long _tmpCreatedAt = _cursor.getLong(_cursorIndexOfCreatedAt);
                        _item = new User(_tmpId, _tmpName, _tmpAge, _tmpEmail, _tmpCreatedAt);
                        _result.add(_item);
                    }
                    return _result;
                } finally {
                    _cursor.close();
                }
            }
        });
    }
}
```


---

## 4. 实战应用

### 4.1 存储方案选型指南

```
存储方案选型决策树
┌─────────────────────────────────────────────────────────────┐
│                      数据类型判断                            │
│                           │                                  │
│              ┌────────────┼────────────┐                    │
│              ▼            ▼            ▼                    │
│         键值对数据    结构化数据     文件数据                │
│              │            │            │                    │
│              ▼            ▼            ▼                    │
│    ┌─────────────┐  ┌─────────┐  ┌─────────────┐           │
│    │ 数据量/频率  │  │ SQLite  │  │ 文件存储     │           │
│    └─────────────┘  │  Room   │  └─────────────┘           │
│         │           └─────────┘       │                     │
│    ┌────┴────┐                   ┌────┴────┐               │
│    ▼         ▼                   ▼         ▼               │
│  小量/低频  大量/高频          媒体文件   其他文件           │
│    │         │                   │         │               │
│    ▼         ▼                   ▼         ▼               │
│ DataStore   MMKV            MediaStore    SAF              │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 4.2 多存储方案组合使用

```kotlin
/**
 * 统一存储管理器
 */
class StorageManager private constructor(private val context: Context) {
    
    companion object {
        @Volatile
        private var instance: StorageManager? = null
        
        fun getInstance(context: Context): StorageManager {
            return instance ?: synchronized(this) {
                instance ?: StorageManager(context.applicationContext).also { instance = it }
            }
        }
    }
    
    // MMKV - 高频键值对存储
    private val mmkv: MMKV by lazy {
        MMKV.initialize(context)
        MMKV.defaultMMKV()
    }
    
    // DataStore - 配置存储
    private val Context.settingsDataStore by preferencesDataStore(name = "settings")
    private val settingsDataStore get() = context.settingsDataStore
    
    // Room - 结构化数据
    private val database: AppDatabase by lazy {
        AppDatabase.getInstance(context)
    }
    
    // ==================== MMKV 操作 ====================
    
    fun putHighFrequencyData(key: String, value: String) {
        mmkv.encode(key, value)
    }
    
    fun getHighFrequencyData(key: String, default: String = ""): String {
        return mmkv.decodeString(key, default) ?: default
    }
    
    // ==================== DataStore 操作 ====================
    
    val settings: Flow<AppSettings> = settingsDataStore.data
        .catch { emit(emptyPreferences()) }
        .map { prefs ->
            AppSettings(
                theme = prefs[PreferencesKeys.THEME] ?: "system",
                language = prefs[PreferencesKeys.LANGUAGE] ?: "zh",
                notificationEnabled = prefs[PreferencesKeys.NOTIFICATION] ?: true
            )
        }
    
    suspend fun updateTheme(theme: String) {
        settingsDataStore.edit { prefs ->
            prefs[PreferencesKeys.THEME] = theme
        }
    }
    
    // ==================== Room 操作 ====================
    
    fun getAllUsers(): Flow<List<User>> = database.userDao().getAllUsers()
    
    suspend fun insertUser(user: User): Long = database.userDao().insert(user)
    
    suspend fun deleteUser(user: User) = database.userDao().delete(user)
    
    // ==================== 文件操作 ====================
    
    suspend fun saveFile(fileName: String, content: ByteArray): Boolean {
        val file = File(context.filesDir, fileName)
        return FileUtils.writeFileAtomically(file, content)
    }
    
    suspend fun readFile(fileName: String): ByteArray? {
        val file = File(context.filesDir, fileName)
        return FileUtils.readFile(file)
    }
    
    // ==================== 缓存管理 ====================
    
    fun clearAllCache() {
        // 清理文件缓存
        context.cacheDir.deleteRecursively()
        context.externalCacheDir?.deleteRecursively()
        
        // 清理 MMKV 缓存数据
        mmkv.clearAll()
    }
    
    fun getCacheSize(): Long {
        var size = FileUtils.getDirectorySize(context.cacheDir)
        context.externalCacheDir?.let {
            size += FileUtils.getDirectorySize(it)
        }
        return size
    }
    
    private object PreferencesKeys {
        val THEME = stringPreferencesKey("theme")
        val LANGUAGE = stringPreferencesKey("language")
        val NOTIFICATION = booleanPreferencesKey("notification")
    }
}

data class AppSettings(
    val theme: String,
    val language: String,
    val notificationEnabled: Boolean
)
```

### 4.3 数据迁移方案

```kotlin
/**
 * 从 SharedPreferences 迁移到 MMKV/DataStore
 */
object DataMigrationHelper {
    
    private const val MIGRATION_COMPLETED_KEY = "migration_completed"
    
    /**
     * SP 迁移到 MMKV
     */
    fun migrateSpToMmkv(context: Context, spName: String) {
        val mmkv = MMKV.defaultMMKV()
        
        // 检查是否已迁移
        if (mmkv.decodeBool(MIGRATION_COMPLETED_KEY, false)) {
            return
        }
        
        val sp = context.getSharedPreferences(spName, Context.MODE_PRIVATE)
        
        // 导入数据
        mmkv.importFromSharedPreferences(sp)
        
        // 清除原 SP 数据
        sp.edit().clear().apply()
        
        // 标记迁移完成
        mmkv.encode(MIGRATION_COMPLETED_KEY, true)
        
        Log.d("Migration", "SP to MMKV migration completed")
    }
    
    /**
     * SP 迁移到 DataStore
     */
    suspend fun migrateSpToDataStore(
        context: Context,
        spName: String,
        dataStore: DataStore<Preferences>
    ) {
        val sp = context.getSharedPreferences(spName, Context.MODE_PRIVATE)
        
        dataStore.edit { prefs ->
            // 检查是否已迁移
            if (prefs[booleanPreferencesKey(MIGRATION_COMPLETED_KEY)] == true) {
                return@edit
            }
            
            // 迁移数据
            sp.all.forEach { (key, value) ->
                when (value) {
                    is String -> prefs[stringPreferencesKey(key)] = value
                    is Int -> prefs[intPreferencesKey(key)] = value
                    is Boolean -> prefs[booleanPreferencesKey(key)] = value
                    is Long -> prefs[longPreferencesKey(key)] = value
                    is Float -> prefs[floatPreferencesKey(key)] = value
                    is Set<*> -> {
                        @Suppress("UNCHECKED_CAST")
                        prefs[stringSetPreferencesKey(key)] = value as Set<String>
                    }
                }
            }
            
            // 标记迁移完成
            prefs[booleanPreferencesKey(MIGRATION_COMPLETED_KEY)] = true
        }
        
        // 清除原 SP 数据
        sp.edit().clear().apply()
        
        Log.d("Migration", "SP to DataStore migration completed")
    }
    
    /**
     * Room 数据库迁移
     */
    fun createRoomMigration(
        startVersion: Int,
        endVersion: Int,
        migrate: (SupportSQLiteDatabase) -> Unit
    ): Migration {
        return object : Migration(startVersion, endVersion) {
            override fun migrate(database: SupportSQLiteDatabase) {
                migrate(database)
            }
        }
    }
}
```

---

## 5. 常见面试题

### 问题1：SharedPreferences 为什么会导致 ANR？如何解决？

**答案要点：**

1. **ANR 原因分析：**
   - **首次获取阻塞**：`getSharedPreferences()` 会在子线程加载 XML 文件，但 `getString()` 等读取方法会调用 `awaitLoadedLocked()` 阻塞等待加载完成
   - **apply() 阻塞**：`apply()` 虽然是异步写入，但会将写入任务添加到 `QueuedWork`，在 `Activity.onStop()` 时会调用 `QueuedWork.waitToFinish()` 等待所有 apply 完成
   - **commit() 同步写入**：`commit()` 是同步操作，直接在调用线程写入磁盘

2. **解决方案：**
   ```kotlin
   // 1. 提前预加载
   class App : Application() {
       override fun onCreate() {
           GlobalScope.launch(Dispatchers.IO) {
               getSharedPreferences("config", MODE_PRIVATE).all
           }
       }
   }
   
   // 2. 使用 MMKV 替代
   MMKV.initialize(context)
   val mmkv = MMKV.defaultMMKV()
   
   // 3. 使用 DataStore
   val dataStore by preferencesDataStore(name = "settings")
   ```

---

### 问题2：MMKV 为什么比 SharedPreferences 快？原理是什么？

**答案要点：**

1. **mmap 内存映射**：
   - SP 使用传统 IO：用户空间 → 内核缓冲 → 页缓存 → 磁盘（多次拷贝）
   - MMKV 使用 mmap：直接将文件映射到进程虚拟内存，读写操作直接操作内存，由操作系统负责同步到磁盘
   - 减少了数据拷贝次数，提升读写性能

2. **Protocol Buffers 编码**：
   - SP 使用 XML 格式，解析开销大
   - MMKV 使用 PB 编码，二进制格式，编解码效率高
   - Varint 变长编码节省空间

3. **增量更新**：
   - SP 每次写入都是全量写入整个 XML 文件
   - MMKV 采用追加写入，只写入变更的 key-value
   - 定期重整（Full Write Back）清理无效数据

4. **跨进程支持**：
   - 使用文件锁实现跨进程同步
   - 通过序列号检测文件变更，按需重新加载

---

### 问题3：DataStore 相比 SharedPreferences 有什么优势？

**答案要点：**

| 特性 | SharedPreferences | DataStore |
|-----|------------------|-----------|
| API 类型 | 同步/部分异步 | 完全异步（Flow + Coroutines） |
| 线程安全 | 需要注意 | 完全线程安全 |
| 类型安全 | 否 | Proto DataStore 支持 |
| 错误处理 | 无 | 支持 Flow 异常处理 |
| 数据一致性 | 可能丢失 | 原子操作保证 |
| 阻塞主线程 | 可能 | 不会 |

```kotlin
// DataStore 使用示例
val userName: Flow<String> = dataStore.data
    .catch { exception ->
        if (exception is IOException) {
            emit(emptyPreferences())
        } else {
            throw exception
        }
    }
    .map { preferences ->
        preferences[USER_NAME_KEY] ?: ""
    }
```

---

### 问题4：Room 数据库如何进行版本迁移？

**答案要点：**

```kotlin
// 1. 定义迁移
val MIGRATION_1_2 = object : Migration(1, 2) {
    override fun migrate(database: SupportSQLiteDatabase) {
        // 添加新列
        database.execSQL("ALTER TABLE users ADD COLUMN avatar TEXT")
    }
}

val MIGRATION_2_3 = object : Migration(2, 3) {
    override fun migrate(database: SupportSQLiteDatabase) {
        // 创建新表
        database.execSQL("""
            CREATE TABLE IF NOT EXISTS posts (
                id INTEGER PRIMARY KEY NOT NULL,
                user_id INTEGER NOT NULL,
                title TEXT NOT NULL,
                FOREIGN KEY (user_id) REFERENCES users(id)
            )
        """)
    }
}

// 2. 应用迁移
Room.databaseBuilder(context, AppDatabase::class.java, "app.db")
    .addMigrations(MIGRATION_1_2, MIGRATION_2_3)
    .build()

// 3. 自动迁移（Room 2.4+）
@Database(
    version = 3,
    autoMigrations = [
        AutoMigration(from = 1, to = 2),
        AutoMigration(from = 2, to = 3, spec = Migration2To3::class)
    ]
)
abstract class AppDatabase : RoomDatabase()

@RenameColumn(tableName = "users", fromColumnName = "name", toColumnName = "user_name")
class Migration2To3 : AutoMigrationSpec
```

---

### 问题5：Android 分区存储（Scoped Storage）是什么？如何适配？

**答案要点：**

1. **分区存储概念**：
   - Android 10 引入，Android 11 强制执行
   - 限制应用对外部存储的直接访问
   - 应用只能访问自己的专属目录和通过 MediaStore/SAF 访问的文件

2. **存储区域划分**：
   - **应用专属目录**：无需权限，卸载时删除
   - **共享存储**：需要权限或用户授权
     - 媒体文件：通过 MediaStore API 访问
     - 其他文件：通过 SAF 访问

3. **适配方案**：
   ```kotlin
   // 1. 应用专属目录（无需权限）
   context.getExternalFilesDir(Environment.DIRECTORY_PICTURES)
   
   // 2. MediaStore 保存图片
   val contentValues = ContentValues().apply {
       put(MediaStore.Images.Media.DISPLAY_NAME, "image.jpg")
       put(MediaStore.Images.Media.MIME_TYPE, "image/jpeg")
       if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
           put(MediaStore.Images.Media.RELATIVE_PATH, Environment.DIRECTORY_PICTURES)
       }
   }
   val uri = contentResolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, contentValues)
   
   // 3. SAF 选择文件
   val intent = Intent(Intent.ACTION_OPEN_DOCUMENT).apply {
       addCategory(Intent.CATEGORY_OPENABLE)
       type = "*/*"
   }
   startActivityForResult(intent, REQUEST_CODE)
   ```

---

### 问题6：SQLite 如何优化查询性能？

**答案要点：**

1. **索引优化**：
   ```sql
   -- 单列索引
   CREATE INDEX idx_user_email ON users(email);
   
   -- 复合索引（注意列顺序，遵循最左前缀原则）
   CREATE INDEX idx_user_name_age ON users(name, age);
   
   -- 覆盖索引（避免回表）
   CREATE INDEX idx_user_covering ON users(name, age, email);
   ```

2. **查询优化**：
   ```kotlin
   // 使用参数化查询
   db.rawQuery("SELECT * FROM users WHERE age > ?", arrayOf("18"))
   
   // 只查询需要的列
   db.query("users", arrayOf("id", "name"), "age > ?", arrayOf("18"), null, null, null)
   
   // 使用 LIMIT 限制结果集
   db.rawQuery("SELECT * FROM users LIMIT 100", null)
   ```

3. **事务优化**：
   ```kotlin
   db.beginTransaction()
   try {
       // 批量操作
       users.forEach { user -> insertUser(user) }
       db.setTransactionSuccessful()
   } finally {
       db.endTransaction()
   }
   ```

4. **WAL 模式**：
   ```kotlin
   db.enableWriteAheadLogging()  // 提升并发性能
   ```

---

### 问题7：如何设计一个高性能的本地缓存系统？

**答案要点：**

```kotlin
/**
 * 多级缓存系统
 */
class CacheManager(context: Context) {
    
    // L1: 内存缓存（LruCache）
    private val memoryCache = object : LruCache<String, Any>(
        (Runtime.getRuntime().maxMemory() / 8).toInt()
    ) {
        override fun sizeOf(key: String, value: Any): Int {
            return when (value) {
                is Bitmap -> value.byteCount
                is String -> value.length
                else -> 1
            }
        }
    }
    
    // L2: 磁盘缓存（MMKV）
    private val diskCache = MMKV.mmkvWithID("cache", MMKV.SINGLE_PROCESS_MODE)
    
    // L3: 数据库缓存（Room）
    private val database = AppDatabase.getInstance(context)
    
    suspend fun <T> get(
        key: String,
        type: Class<T>,
        loader: suspend () -> T
    ): T {
        // 1. 检查内存缓存
        memoryCache.get(key)?.let {
            @Suppress("UNCHECKED_CAST")
            return it as T
        }
        
        // 2. 检查磁盘缓存
        diskCache.decodeString(key)?.let { json ->
            val value = Gson().fromJson(json, type)
            memoryCache.put(key, value as Any)
            return value
        }
        
        // 3. 加载数据
        val value = loader()
        
        // 4. 写入缓存
        memoryCache.put(key, value as Any)
        diskCache.encode(key, Gson().toJson(value))
        
        return value
    }
    
    fun invalidate(key: String) {
        memoryCache.remove(key)
        diskCache.removeValueForKey(key)
    }
    
    fun clear() {
        memoryCache.evictAll()
        diskCache.clearAll()
    }
}
```

---

### 问题8：MMKV 的增量更新和重整机制是什么？

**答案要点：**

1. **增量更新**：
   - 每次写入数据时，不是覆盖原有数据，而是追加到文件末尾
   - 同一个 key 可能存在多个值，读取时以最后一个为准
   - 优点：写入速度快，避免全量写入

2. **重整（Full Write Back）**：
   - 当文件中无效数据过多时，触发重整
   - 将内存中的有效数据全部重新写入文件
   - 清理无效数据，减小文件大小

3. **触发条件**：
   - 文件空间不足时
   - 无效数据占比过高时
   - 手动调用 `trim()` 方法

```cpp
// 重整核心逻辑
void MMKV::fullWriteback() {
    // 1. 计算有效数据大小
    size_t allSize = 0;
    for (auto &itr : m_dic) {
        allSize += itr.first.length() + itr.second.length() + overhead;
    }
    
    // 2. 创建新缓冲区，写入所有有效数据
    MMBuffer newData(allSize);
    for (auto &itr : m_dic) {
        // 编码并写入
    }
    
    // 3. 覆盖原文件
    memcpy(m_ptr, newData.getPtr(), allSize);
    m_actualSize = allSize;
}
```

---

## 总结

### 存储方案选择建议

| 场景 | 推荐方案 | 原因 |
|-----|---------|------|
| 简单配置项 | DataStore | 类型安全、异步 API |
| 高频读写 | MMKV | 性能最优 |
| 跨进程数据 | MMKV | 原生支持跨进程 |
| 结构化数据 | Room | 编译时验证、关系查询 |
| 大文件 | 文件存储 | 直接操作文件系统 |
| 媒体文件 | MediaStore | 分区存储要求 |

### 面试重点

1. **SP 问题**：ANR 原因（awaitLoadedLocked、QueuedWork.waitToFinish）、数据丢失
2. **MMKV 原理**：mmap 内存映射、Protocol Buffers 编码、增量更新
3. **DataStore**：与 SP 对比、Flow API、原子操作
4. **Room**：编译时验证、DAO 生成代码、数据库迁移
5. **分区存储**：MediaStore API、SAF、权限变化

---

*文档版本: v1.0*  
*更新时间: 2025-01*  
*适用版本: Android W*
