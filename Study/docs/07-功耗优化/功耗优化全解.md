# Android 功耗优化全解

## 1. 概述

功耗优化是 Android 应用开发中至关重要的一环，尤其对于 OPPO、vivo 等手机厂商来说更是面试重点。良好的功耗表现不仅能提升用户体验，还能延长设备续航时间，是衡量应用质量的重要指标。

### 1.1 功耗优化的重要性

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        功耗优化的价值                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  用户体验影响:                                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  • 电量消耗过快是用户卸载应用的主要原因之一                     │   │
│  │  • 后台耗电会导致用户投诉和差评                                 │   │
│  │  • 发热问题直接影响用户使用体验                                 │   │
│  │  • Google Play 将功耗作为应用质量评估指标                       │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  厂商关注点 (OPPO/vivo 特别重视):                                       │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  • 后台功耗管控是系统优化重点                                   │   │
│  │  • 应用功耗排行直接影响用户感知                                 │   │
│  │  • 高功耗应用可能被系统限制或杀死                               │   │
│  │  • 功耗优化能力是高级开发者必备技能                             │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 1.2 功耗消耗来源

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        主要功耗来源                                      │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  硬件模块功耗占比 (典型值):                                             │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  屏幕显示:     ~40-50%  (最大功耗来源)                          │   │
│  │  CPU 计算:     ~15-25%                                          │   │
│  │  网络通信:     ~10-20%  (WiFi < 4G < 5G)                        │   │
│  │  GPS 定位:     ~5-15%   (高精度定位功耗极高)                    │   │
│  │  传感器:       ~2-5%                                            │   │
│  │  音频播放:     ~2-5%                                            │   │
│  │  蓝牙/NFC:     ~1-3%                                            │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 1.3 功耗优化目标

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        功耗优化目标                                      │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  前台优化目标:                                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  • 减少不必要的 CPU 计算                                        │   │
│  │  • 优化渲染效率，减少过度绘制                                   │   │
│  │  • 合理使用传感器和定位服务                                     │   │
│  │  • 优化网络请求频率和数据量                                     │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  后台优化目标 (重点):                                                   │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  • 最小化后台唤醒次数                                           │   │
│  │  • 合理使用 WakeLock                                            │   │
│  │  • 批量处理后台任务                                             │   │
│  │  • 遵循系统省电策略 (Doze/App Standby)                          │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 2. 核心原理

### 2.1 Android 电量管理机制

```
┌─────────────────────────────────────────────────────────────────────────┐
│                   Android 电量管理架构                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                    应用层 (Application)                         │   │
│  │  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐            │   │
│  │  │ App 1   │  │ App 2   │  │ App 3   │  │ App N   │            │   │
│  │  └────┬────┘  └────┬────┘  └────┬────┘  └────┬────┘            │   │
│  └───────┼────────────┼────────────┼────────────┼──────────────────┘   │
│          │            │            │            │                       │
│          ↓            ↓            ↓            ↓                       │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                  Framework 层                                   │   │
│  │  ┌──────────────────────────────────────────────────────────┐  │   │
│  │  │              PowerManagerService                         │  │   │
│  │  │  • WakeLock 管理                                         │  │   │
│  │  │  • 屏幕状态管理                                          │  │   │
│  │  │  • 休眠策略控制                                          │  │   │
│  │  └──────────────────────────────────────────────────────────┘  │   │
│  │  ┌──────────────────────────────────────────────────────────┐  │   │
│  │  │              BatteryStatsService                         │  │   │
│  │  │  • 电量统计                                              │  │   │
│  │  │  • 功耗归因                                              │  │   │
│  │  │  • 唤醒统计                                              │  │   │
│  │  └──────────────────────────────────────────────────────────┘  │   │
│  │  ┌──────────────────────────────────────────────────────────┐  │   │
│  │  │              DeviceIdleController                        │  │   │
│  │  │  • Doze 模式控制                                         │  │   │
│  │  │  • App Standby 管理                                      │  │   │
│  │  │  • 白名单管理                                            │  │   │
│  │  └──────────────────────────────────────────────────────────┘  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                              │                                          │
│                              ↓                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                    HAL 层                                       │   │
│  │  ┌──────────────────────────────────────────────────────────┐  │   │
│  │  │              Power HAL                                   │  │   │
│  │  │  • CPU 频率控制                                          │  │   │
│  │  │  • 休眠/唤醒控制                                         │  │   │
│  │  │  • 电源状态管理                                          │  │   │
│  │  └──────────────────────────────────────────────────────────┘  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                              │                                          │
│                              ↓                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                    Kernel 层                                    │   │
│  │  ┌──────────────────────────────────────────────────────────┐  │   │
│  │  │  • wakelock 驱动                                         │  │   │
│  │  │  • CPU 调频驱动 (cpufreq)                                │  │   │
│  │  │  • 电源管理驱动                                          │  │   │
│  │  └──────────────────────────────────────────────────────────┘  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.2 Doze 模式详解

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      Doze 模式工作原理                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  触发条件:                                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  • 设备未充电                                                   │   │
│  │  • 屏幕关闭                                                     │   │
│  │  • 设备静止不动 (Android 7.0+ 可在移动时进入轻度 Doze)          │   │
│  │  • 持续一段时间 (约 30 分钟)                                    │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  Doze 状态机:                                                           │
│                                                                         │
│  ┌──────────┐    屏幕关闭     ┌──────────┐    静止检测    ┌──────────┐ │
│  │  ACTIVE  │ ──────────────→ │ INACTIVE │ ──────────────→ │  IDLE_   │ │
│  │  (活跃)  │                 │ (非活跃) │                 │ PENDING  │ │
│  └──────────┘                 └──────────┘                 └────┬─────┘ │
│       ↑                            ↑                            │       │
│       │                            │                            ↓       │
│       │                            │                      ┌──────────┐ │
│       │                            │                      │  SENSING │ │
│       │                            │                      │ (传感器) │ │
│       │                            │                      └────┬─────┘ │
│       │                            │                            │       │
│       │                            │                            ↓       │
│       │                            │                      ┌──────────┐ │
│       │                            │                      │ LOCATING │ │
│       │                            │                      │  (定位)  │ │
│       │                            │                      └────┬─────┘ │
│       │                            │                            │       │
│       │                            │                            ↓       │
│       │                            │                      ┌──────────┐ │
│       │                            │    维护窗口          │   IDLE   │ │
│       │                            │ ←─────────────────── │  (空闲)  │ │
│       │                            │                      └────┬─────┘ │
│       │                            │                            │       │
│       │                            │                            ↓       │
│       │                            │                      ┌──────────┐ │
│       │                            │                      │  IDLE_   │ │
│       │                            └───────────────────── │MAINTENANCE│ │
│       │                                 屏幕点亮          │ (维护)   │ │
│       │                                                   └──────────┘ │
│       │                                                                 │
│       └─────────────────────────────────────────────────────────────────┘
│                              屏幕点亮/充电/移动                          │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      Doze 模式限制                                       │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  在 Doze 模式下，系统会限制以下行为:                                    │
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  网络访问:     暂停，仅在维护窗口期间允许                       │   │
│  │  WakeLock:     忽略，系统不响应 WakeLock 请求                   │   │
│  │  AlarmManager: 延迟到维护窗口 (setExactAndAllowWhileIdle 除外)  │   │
│  │  WiFi 扫描:    暂停                                             │   │
│  │  JobScheduler: 延迟到维护窗口                                   │   │
│  │  同步适配器:   延迟到维护窗口                                   │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  维护窗口 (Maintenance Window):                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  • 系统定期退出 Doze 模式，进入短暂的维护窗口                   │   │
│  │  • 维护窗口期间，应用可以执行被延迟的任务                       │   │
│  │  • 维护窗口间隔会随时间增加 (1h → 2h → 4h → 6h)                 │   │
│  │  • 维护窗口持续时间约 30 秒到几分钟                             │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.3 App Standby 详解

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      App Standby 工作原理                                │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  App Standby Buckets (Android 9.0+):                                    │
│                                                                         │
│  ┌────────────┬──────────────┬──────────────────────────────────────┐  │
│  │   Bucket   │   触发条件   │            限制程度                  │  │
│  ├────────────┼──────────────┼──────────────────────────────────────┤  │
│  │   Active   │ 正在使用     │ 无限制                               │  │
│  │   (活跃)   │ 前台可见     │ Jobs/Alarms/网络 正常执行            │  │
│  ├────────────┼──────────────┼──────────────────────────────────────┤  │
│  │  Working   │ 经常使用     │ 轻度限制                             │  │
│  │   Set      │ 最近几小时   │ Jobs 延迟最多 2 小时                 │  │
│  │ (工作集)   │ 内使用过     │ Alarms 延迟最多 6 分钟               │  │
│  ├────────────┼──────────────┼──────────────────────────────────────┤  │
│  │  Frequent  │ 定期使用     │ 中度限制                             │  │
│  │   (频繁)   │ 但非每天     │ Jobs 延迟最多 8 小时                 │  │
│  │            │              │ Alarms 延迟最多 30 分钟              │  │
│  ├────────────┼──────────────┼──────────────────────────────────────┤  │
│  │   Rare     │ 很少使用     │ 严格限制                             │  │
│  │   (稀有)   │              │ Jobs 延迟最多 24 小时                │  │
│  │            │              │ Alarms 延迟最多 2 小时               │  │
│  │            │              │ 网络访问受限                         │  │
│  ├────────────┼──────────────┼──────────────────────────────────────┤  │
│  │ Restricted │ 几乎不使用   │ 最严格限制 (Android 12+)             │  │
│  │  (受限)    │ 或消耗过多   │ Jobs 每天最多运行 1 次               │  │
│  │            │ 系统资源     │ Alarms 每天最多触发 1 次             │  │
│  │            │              │ 无法使用前台服务                     │  │
│  └────────────┴──────────────┴──────────────────────────────────────┘  │
│                                                                         │
│  Bucket 切换规则:                                                       │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  • 用户主动使用应用 → 立即提升到 Active                         │   │
│  │  • 收到高优先级 FCM 消息 → 临时提升到 Active                    │   │
│  │  • 应用长时间未使用 → 逐步降级                                  │   │
│  │  • 系统会根据使用模式预测用户行为                               │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.4 WakeLock 机制

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      WakeLock 类型与使用                                 │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  WakeLock 类型:                                                         │
│                                                                         │
│  ┌────────────────────┬────────────┬────────────┬────────────────────┐ │
│  │      类型          │    CPU     │    屏幕    │       键盘         │ │
│  ├────────────────────┼────────────┼────────────┼────────────────────┤ │
│  │ PARTIAL_WAKE_LOCK  │    开启    │    关闭    │       关闭         │ │
│  │ (最常用)           │            │            │                    │ │
│  ├────────────────────┼────────────┼────────────┼────────────────────┤ │
│  │ SCREEN_DIM_WAKE_   │    开启    │   变暗     │       关闭         │ │
│  │ LOCK (已废弃)      │            │            │                    │ │
│  ├────────────────────┼────────────┼────────────┼────────────────────┤ │
│  │ SCREEN_BRIGHT_     │    开启    │   全亮     │       关闭         │ │
│  │ WAKE_LOCK (已废弃) │            │            │                    │ │
│  ├────────────────────┼────────────┼────────────┼────────────────────┤ │
│  │ FULL_WAKE_LOCK     │    开启    │   全亮     │       全亮         │ │
│  │ (已废弃)           │            │            │                    │ │
│  └────────────────────┴────────────┴────────────┴────────────────────┘ │
│                                                                         │
│  注意: 除 PARTIAL_WAKE_LOCK 外，其他类型已废弃                          │
│        屏幕保持请使用 FLAG_KEEP_SCREEN_ON                               │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 3. 关键源码解析

### 3.1 PowerManagerService 核心源码

```java
/**
 * PowerManagerService - 电源管理服务
 * 源码位置: frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java
 */
public final class PowerManagerService extends SystemService
        implements Watchdog.Monitor {
    
    // WakeLock 相关常量
    private static final int WAKE_LOCK_CPU = 1 << 0;
    private static final int WAKE_LOCK_SCREEN_BRIGHT = 1 << 1;
    private static final int WAKE_LOCK_SCREEN_DIM = 1 << 2;
    private static final int WAKE_LOCK_BUTTON_BRIGHT = 1 << 3;
    private static final int WAKE_LOCK_PROXIMITY_SCREEN_OFF = 1 << 4;
    private static final int WAKE_LOCK_STAY_AWAKE = 1 << 5;
    private static final int WAKE_LOCK_DOZE = 1 << 6;
    private static final int WAKE_LOCK_DRAW = 1 << 7;
    
    // WakeLock 列表
    private final ArrayList<WakeLock> mWakeLocks = new ArrayList<>();
    
    /**
     * 获取 WakeLock
     * 应用调用 PowerManager.newWakeLock() 最终会调用到这里
     */
    private void acquireWakeLockInternal(IBinder lock, int displayId, int flags, 
            String tag, String packageName, WorkSource ws, String historyTag,
            int uid, int pid) {
        synchronized (mLock) {
            // 1. 查找是否已存在相同的 WakeLock
            int index = findWakeLockIndexLocked(lock);
            WakeLock wakeLock;
            
            if (index >= 0) {
                // 2. 已存在，更新 WakeLock
                wakeLock = mWakeLocks.get(index);
                if (!wakeLock.hasSameProperties(flags, tag, ws, uid, pid)) {
                    // 属性变化，需要更新
                    notifyWakeLockChangingLocked(wakeLock, flags, tag, packageName,
                            uid, pid, ws, historyTag);
                    wakeLock.updateProperties(flags, tag, packageName, ws, 
                            historyTag, uid, pid);
                }
            } else {
                // 3. 创建新的 WakeLock
                UidState state = mUidState.get(uid);
                if (state == null) {
                    state = new UidState(uid);
                    state.mProcState = ActivityManager.PROCESS_STATE_NONEXISTENT;
                    mUidState.put(uid, state);
                }
                
                wakeLock = new WakeLock(lock, displayId, flags, tag, packageName,
                        ws, historyTag, uid, pid, state);
                
                // 4. 添加到列表
                mWakeLocks.add(wakeLock);
                
                // 5. 设置 Binder 死亡监听
                // 当持有 WakeLock 的进程死亡时自动释放
                try {
                    lock.linkToDeath(wakeLock, 0);
                } catch (RemoteException ex) {
                    throw new IllegalArgumentException("Wake lock is already dead.");
                }
                
                // 6. 通知 WakeLock 获取
                notifyWakeLockAcquiredLocked(wakeLock);
            }
            
            // 7. 更新电源状态
            updatePowerStateLocked();
        }
    }
    
    /**
     * 释放 WakeLock
     */
    private void releaseWakeLockInternal(IBinder lock, int flags) {
        synchronized (mLock) {
            int index = findWakeLockIndexLocked(lock);
            if (index < 0) {
                return;
            }
            
            WakeLock wakeLock = mWakeLocks.get(index);
            
            // 1. 移除死亡监听
            wakeLock.mLock.unlinkToDeath(wakeLock, 0);
            
            // 2. 从列表移除
            mWakeLocks.remove(index);
            
            // 3. 通知 WakeLock 释放
            notifyWakeLockReleasedLocked(wakeLock);
            
            // 4. 更新电源状态
            updatePowerStateLocked();
        }
    }
    
    /**
     * 更新电源状态 - 核心方法
     * 根据当前所有 WakeLock 和系统状态决定设备电源状态
     */
    private void updatePowerStateLocked() {
        // 1. 计算当前需要的唤醒锁级别
        int wakelockSummary = 0;
        for (int i = 0; i < mWakeLocks.size(); i++) {
            WakeLock wakeLock = mWakeLocks.get(i);
            wakelockSummary |= getWakeLockSummaryFlags(wakeLock);
        }
        
        // 2. 根据唤醒锁级别决定电源状态
        if ((wakelockSummary & WAKE_LOCK_CPU) != 0) {
            // 需要保持 CPU 运行
            setWakefulnessLocked(WAKEFULNESS_AWAKE, 0);
        }
        
        // 3. 更新屏幕状态
        updateScreenStateLocked(wakelockSummary);
        
        // 4. 更新休眠状态
        updateSuspendBlockerLocked();
    }
}
```

### 3.2 DeviceIdleController (Doze) 源码分析

```java
/**
 * DeviceIdleController - Doze 模式控制器
 * 源码位置: frameworks/base/apex/jobscheduler/service/java/com/android/server/DeviceIdleController.java
 */
public class DeviceIdleController extends SystemService
        implements AnyMotionDetector.DeviceIdleCallback {
    
    // Doze 状态常量
    public static final int STATE_ACTIVE = 0;           // 活跃状态
    public static final int STATE_INACTIVE = 1;         // 非活跃状态
    public static final int STATE_IDLE_PENDING = 2;     // 等待进入空闲
    public static final int STATE_SENSING = 3;          // 传感器检测
    public static final int STATE_LOCATING = 4;         // 定位中
    public static final int STATE_IDLE = 5;             // 空闲状态 (Doze)
    public static final int STATE_IDLE_MAINTENANCE = 6; // 维护窗口
    
    // 当前状态
    private int mState = STATE_ACTIVE;
    
    // 轻度 Doze 状态 (Android 7.0+)
    public static final int LIGHT_STATE_ACTIVE = 0;
    public static final int LIGHT_STATE_INACTIVE = 1;
    public static final int LIGHT_STATE_IDLE = 4;
    public static final int LIGHT_STATE_WAITING_FOR_NETWORK = 5;
    public static final int LIGHT_STATE_IDLE_MAINTENANCE = 6;
    public static final int LIGHT_STATE_OVERRIDE = 7;
    
    private int mLightState = LIGHT_STATE_ACTIVE;
    
    /**
     * 状态切换处理
     */
    void stepIdleStateLocked(String reason) {
        final long now = SystemClock.elapsedRealtime();
        
        switch (mState) {
            case STATE_INACTIVE:
                // 从非活跃状态开始检测
                mState = STATE_IDLE_PENDING;
                // 设置下次检查时间
                scheduleAlarmLocked(mInactiveTimeout, false);
                break;
                
            case STATE_IDLE_PENDING:
                // 开始传感器检测
                mState = STATE_SENSING;
                // 启动运动检测
                mAnyMotionDetector.checkForAnyMotion();
                break;
                
            case STATE_SENSING:
                // 传感器检测完成，开始定位
                mState = STATE_LOCATING;
                // 请求位置更新
                requestLocationLocked();
                break;
                
            case STATE_LOCATING:
                // 定位完成，进入 Doze 模式
                mState = STATE_IDLE;
                // 通知系统进入 Doze
                mLocalPowerManager.setDeviceIdleMode(true);
                // 设置维护窗口时间
                scheduleAlarmLocked(mNextIdleDelay, true);
                break;
                
            case STATE_IDLE:
                // 进入维护窗口
                mState = STATE_IDLE_MAINTENANCE;
                // 通知系统退出 Doze (临时)
                mLocalPowerManager.setDeviceIdleMode(false);
                // 设置维护窗口结束时间
                scheduleAlarmLocked(mNextIdlePendingDelay, false);
                break;
                
            case STATE_IDLE_MAINTENANCE:
                // 维护窗口结束，重新进入 Doze
                mState = STATE_IDLE;
                mLocalPowerManager.setDeviceIdleMode(true);
                // 增加下次维护窗口间隔
                mNextIdleDelay = Math.min(mNextIdleDelay * 2, mMaxIdleTimeout);
                scheduleAlarmLocked(mNextIdleDelay, true);
                break;
        }
    }
    
    /**
     * 退出 Doze 模式
     */
    void exitIdleLocked(String reason) {
        if (mState != STATE_ACTIVE) {
            mState = STATE_ACTIVE;
            mLightState = LIGHT_STATE_ACTIVE;
            
            // 通知系统退出 Doze
            mLocalPowerManager.setDeviceIdleMode(false);
            mLocalPowerManager.setLightDeviceIdleMode(false);
            
            // 取消所有定时器
            cancelAlarmLocked();
            
            // 停止运动检测
            mAnyMotionDetector.stop();
        }
    }
    
    /**
     * 检查应用是否在 Doze 白名单中
     */
    public boolean isAppOnWhitelistInternal(int uid) {
        synchronized (this) {
            return Arrays.binarySearch(mPowerSaveWhitelistAllAppIdArray, 
                    UserHandle.getAppId(uid)) >= 0;
        }
    }
}
```

### 3.3 JobScheduler 源码分析

```java
/**
 * JobSchedulerService - 任务调度服务
 * 源码位置: frameworks/base/apex/jobscheduler/service/java/com/android/server/job/JobSchedulerService.java
 */
public class JobSchedulerService extends com.android.server.SystemService
        implements StateChangedListener, JobCompletedListener {
    
    // 任务约束类型
    public static final int CONSTRAINT_CHARGING = 1 << 0;        // 充电中
    public static final int CONSTRAINT_BATTERY_NOT_LOW = 1 << 1; // 电量不低
    public static final int CONSTRAINT_STORAGE_NOT_LOW = 1 << 2; // 存储不低
    public static final int CONSTRAINT_TIMING_DELAY = 1 << 3;    // 延迟执行
    public static final int CONSTRAINT_DEADLINE = 1 << 4;        // 截止时间
    public static final int CONSTRAINT_IDLE = 1 << 5;            // 设备空闲
    public static final int CONSTRAINT_CONNECTIVITY = 1 << 6;    // 网络连接
    public static final int CONSTRAINT_CONTENT_TRIGGER = 1 << 7; // 内容变化触发
    
    /**
     * 调度任务
     */
    public int scheduleAsPackage(JobInfo job, JobWorkItem work, int uId,
            String packageName, int userId, String tag) {
        
        // 1. 验证任务参数
        if (!validateJob(job, uId, packageName)) {
            return JobScheduler.RESULT_FAILURE;
        }
        
        // 2. 创建 JobStatus
        JobStatus jobStatus = JobStatus.createFromJobInfo(job, uId, packageName, 
                userId, tag);
        
        synchronized (mLock) {
            // 3. 检查是否已存在相同任务
            JobStatus existingJob = mJobs.getJobByUidAndJobId(uId, job.getId());
            if (existingJob != null) {
                // 取消旧任务
                cancelJobImplLocked(existingJob, null, 
                        JobParameters.STOP_REASON_CANCELLED_BY_APP);
            }
            
            // 4. 添加到任务列表
            mJobs.add(jobStatus);
            
            // 5. 检查约束条件
            updateConstraintsLocked(jobStatus);
            
            // 6. 尝试立即执行
            maybeRunPendingJobsLocked();
        }
        
        return JobScheduler.RESULT_SUCCESS;
    }
    
    /**
     * 检查任务是否满足执行条件
     */
    private boolean isReadyToBeExecutedLocked(JobStatus job) {
        // 1. 检查所有约束是否满足
        if (!job.isConstraintsSatisfied()) {
            return false;
        }
        
        // 2. 检查 App Standby Bucket 限制
        if (!isWithinQuotaLocked(job)) {
            return false;
        }
        
        // 3. 检查 Doze 模式限制
        if (mDeviceIdleMode && !job.canRunInDoze()) {
            return false;
        }
        
        // 4. 检查电池优化限制
        if (mBatterySaverMode && !job.canRunInBatterySaver()) {
            return false;
        }
        
        return true;
    }
    
    /**
     * 执行待处理的任务
     */
    private void maybeRunPendingJobsLocked() {
        // 获取所有待执行的任务
        List<JobStatus> pendingJobs = mPendingJobs;
        
        for (JobStatus job : pendingJobs) {
            if (isReadyToBeExecutedLocked(job)) {
                // 分配执行上下文
                JobServiceContext context = getAvailableContext();
                if (context != null) {
                    // 执行任务
                    context.executeRunnableJob(job);
                }
            }
        }
    }
}

/**
 * JobInfo.Builder - 任务构建器
 * 源码位置: frameworks/base/core/java/android/app/job/JobInfo.java
 */
public static final class Builder {
    private int mJobId;
    private ComponentName mJobService;
    private int mConstraintFlags;
    private long mMinLatencyMillis;
    private long mMaxExecutionDelayMillis;
    private boolean mIsPersisted;
    private NetworkRequest mNetworkRequest;
    
    /**
     * 设置网络约束
     */
    public Builder setRequiredNetworkType(@NetworkType int networkType) {
        if (networkType == NETWORK_TYPE_NONE) {
            mNetworkRequest = null;
        } else {
            // 构建网络请求
            NetworkRequest.Builder builder = new NetworkRequest.Builder();
            builder.addCapability(NET_CAPABILITY_INTERNET);
            
            if (networkType == NETWORK_TYPE_UNMETERED) {
                builder.addCapability(NET_CAPABILITY_NOT_METERED);
            } else if (networkType == NETWORK_TYPE_NOT_ROAMING) {
                builder.addCapability(NET_CAPABILITY_NOT_ROAMING);
            }
            
            mNetworkRequest = builder.build();
        }
        return this;
    }
    
    /**
     * 设置充电约束
     */
    public Builder setRequiresCharging(boolean requiresCharging) {
        if (requiresCharging) {
            mConstraintFlags |= CONSTRAINT_FLAG_CHARGING;
        } else {
            mConstraintFlags &= ~CONSTRAINT_FLAG_CHARGING;
        }
        return this;
    }
    
    /**
     * 设置设备空闲约束
     */
    public Builder setRequiresDeviceIdle(boolean requiresDeviceIdle) {
        if (requiresDeviceIdle) {
            mConstraintFlags |= CONSTRAINT_FLAG_DEVICE_IDLE;
        } else {
            mConstraintFlags &= ~CONSTRAINT_FLAG_DEVICE_IDLE;
        }
        return this;
    }
    
    /**
     * 设置周期性执行
     * 注意: 最小周期为 15 分钟
     */
    public Builder setPeriodic(long intervalMillis) {
        return setPeriodic(intervalMillis, intervalMillis);
    }
    
    public Builder setPeriodic(long intervalMillis, long flexMillis) {
        // 最小周期限制
        final long minPeriod = MIN_PERIOD_MILLIS; // 15 分钟
        final long minFlex = MIN_FLEX_MILLIS;     // 5 分钟
        
        if (intervalMillis < minPeriod) {
            intervalMillis = minPeriod;
        }
        if (flexMillis < minFlex) {
            flexMillis = minFlex;
        }
        
        mIntervalMillis = intervalMillis;
        mFlexMillis = flexMillis;
        return this;
    }
}
```

### 3.4 WorkManager 源码分析

```java
/**
 * WorkManager - 后台任务管理器
 * 源码位置: androidx.work:work-runtime
 */
public abstract class WorkManager {
    
    /**
     * 获取 WorkManager 实例
     */
    public static WorkManager getInstance(@NonNull Context context) {
        return WorkManagerImpl.getInstance(context);
    }
    
    /**
     * 入队一次性任务
     */
    public abstract Operation enqueue(@NonNull WorkRequest workRequest);
    
    /**
     * 入队唯一任务
     * 保证同一时间只有一个同名任务在执行
     */
    public abstract Operation enqueueUniqueWork(
            @NonNull String uniqueWorkName,
            @NonNull ExistingWorkPolicy existingWorkPolicy,
            @NonNull OneTimeWorkRequest work);
    
    /**
     * 入队周期性唯一任务
     */
    public abstract Operation enqueueUniquePeriodicWork(
            @NonNull String uniqueWorkName,
            @NonNull ExistingPeriodicWorkPolicy existingPeriodicWorkPolicy,
            @NonNull PeriodicWorkRequest periodicWork);
}

/**
 * WorkManagerImpl - WorkManager 实现类
 */
public class WorkManagerImpl extends WorkManager {
    
    private final WorkDatabase mWorkDatabase;
    private final Scheduler[] mSchedulers;
    private final Processor mProcessor;
    
    /**
     * 入队任务
     */
    @Override
    public Operation enqueue(@NonNull WorkRequest workRequest) {
        return new WorkContinuationImpl(this, workRequest).enqueue();
    }
    
    /**
     * 调度任务
     */
    public void scheduleWorkInBackground(@NonNull String workSpecId) {
        mWorkTaskExecutor.executeOnBackgroundThread(() -> {
            // 1. 从数据库获取任务信息
            WorkSpec workSpec = mWorkDatabase.workSpecDao().getWorkSpec(workSpecId);
            
            if (workSpec == null) {
                return;
            }
            
            // 2. 选择合适的调度器
            for (Scheduler scheduler : mSchedulers) {
                if (scheduler.hasLimitedSchedulingSlots()) {
                    // 使用 JobScheduler
                    scheduler.schedule(workSpec);
                    break;
                }
            }
        });
    }
}

/**
 * SystemJobScheduler - 使用 JobScheduler 调度
 */
public class SystemJobScheduler implements Scheduler {
    
    @Override
    public void schedule(@NonNull WorkSpec... workSpecs) {
        for (WorkSpec workSpec : workSpecs) {
            // 1. 构建 JobInfo
            JobInfo.Builder builder = new JobInfo.Builder(
                    workSpec.getJobId(),
                    new ComponentName(mContext, SystemJobService.class));
            
            // 2. 设置约束条件
            Constraints constraints = workSpec.constraints;
            
            // 网络约束
            if (constraints.getRequiredNetworkType() != NetworkType.NOT_REQUIRED) {
                builder.setRequiredNetworkType(
                        convertNetworkType(constraints.getRequiredNetworkType()));
            }
            
            // 充电约束
            if (constraints.requiresCharging()) {
                builder.setRequiresCharging(true);
            }
            
            // 设备空闲约束
            if (constraints.requiresDeviceIdle()) {
                builder.setRequiresDeviceIdle(true);
            }
            
            // 电量约束
            if (constraints.requiresBatteryNotLow()) {
                builder.setRequiresBatteryNotLow(true);
            }
            
            // 3. 设置延迟和截止时间
            if (workSpec.initialDelay > 0) {
                builder.setMinimumLatency(workSpec.initialDelay);
            }
            
            // 4. 设置重试策略
            if (workSpec.backoffPolicy == BackoffPolicy.LINEAR) {
                builder.setBackoffCriteria(
                        workSpec.backoffDelayDuration,
                        JobInfo.BACKOFF_POLICY_LINEAR);
            } else {
                builder.setBackoffCriteria(
                        workSpec.backoffDelayDuration,
                        JobInfo.BACKOFF_POLICY_EXPONENTIAL);
            }
            
            // 5. 调度任务
            JobScheduler jobScheduler = mContext.getSystemService(JobScheduler.class);
            jobScheduler.schedule(builder.build());
        }
    }
}

/**
 * Worker - 任务执行基类
 */
public abstract class Worker extends ListenableWorker {
    
    /**
     * 执行任务 (在后台线程)
     */
    @WorkerThread
    public abstract @NonNull Result doWork();
    
    @Override
    public final @NonNull ListenableFuture<Result> startWork() {
        return CallbackToFutureAdapter.getFuture(completer -> {
            // 在后台线程执行
            mBackgroundExecutor.execute(() -> {
                try {
                    Result result = doWork();
                    completer.set(result);
                } catch (Throwable throwable) {
                    completer.setException(throwable);
                }
            });
            return "Worker.startWork";
        });
    }
}

/**
 * CoroutineWorker - 协程版本的 Worker
 */
public abstract class CoroutineWorker(
    appContext: Context,
    params: WorkerParameters
) : ListenableWorker(appContext, params) {
    
    /**
     * 挂起函数执行任务
     */
    abstract suspend fun doWork(): Result
    
    override fun startWork(): ListenableFuture<Result> {
        return future {
            withContext(coroutineContext) {
                doWork()
            }
        }
    }
}
```

### 3.5 AlarmManager 源码分析

```java
/**
 * AlarmManagerService - 闹钟管理服务
 * 源码位置: frameworks/base/apex/jobscheduler/service/java/com/android/server/alarm/AlarmManagerService.java
 */
public class AlarmManagerService extends SystemService {
    
    // 闹钟类型
    public static final int RTC_WAKEUP = 0;      // 实时时钟，唤醒设备
    public static final int RTC = 1;              // 实时时钟，不唤醒
    public static final int ELAPSED_REALTIME_WAKEUP = 2; // 开机时间，唤醒设备
    public static final int ELAPSED_REALTIME = 3; // 开机时间，不唤醒
    
    /**
     * 设置闹钟
     */
    void setImpl(int type, long triggerAtTime, long windowLength, long interval,
            PendingIntent operation, IAlarmListener directReceiver,
            String listenerTag, int flags, WorkSource workSource,
            AlarmManager.AlarmClockInfo alarmClock, int callingUid,
            String callingPackage) {
        
        // 1. 检查权限和参数
        if (operation == null && directReceiver == null) {
            return;
        }
        
        // 2. 检查 Doze 模式限制
        // 在 Doze 模式下，普通闘钟会被延迟
        if (mDeviceIdleMode) {
            // 检查是否允许在 Doze 模式下执行
            if ((flags & AlarmManager.FLAG_ALLOW_WHILE_IDLE) == 0) {
                // 延迟到维护窗口
                triggerAtTime = adjustTriggerTimeForDoze(triggerAtTime);
            }
        }
        
        // 3. 检查 App Standby Bucket 限制
        int standbyBucket = mUsageStatsManagerInternal
                .getAppStandbyBucket(callingPackage, callingUid);
        
        if (standbyBucket != UsageStatsManager.STANDBY_BUCKET_ACTIVE) {
            // 根据 Bucket 调整触发时间
            triggerAtTime = adjustTriggerTimeForBucket(triggerAtTime, standbyBucket);
        }
        
        // 4. 创建 Alarm 对象
        Alarm alarm = new Alarm(type, triggerAtTime, windowLength, interval,
                operation, directReceiver, listenerTag, workSource,
                flags, alarmClock, callingUid, callingPackage);
        
        // 5. 添加到闹钟列表
        synchronized (mLock) {
            setImplLocked(alarm);
        }
    }
    
    /**
     * 批量处理闹钟 (省电优化)
     * 将相近时间的闹钟合并到同一批次执行
     */
    private void setImplLocked(Alarm alarm) {
        // 1. 查找合适的批次
        int whichBatch = findBatchLocked(alarm);
        
        if (whichBatch < 0) {
            // 2. 创建新批次
            Batch batch = new Batch(alarm);
            addBatchLocked(mAlarmBatches, batch);
        } else {
            // 3. 添加到现有批次
            Batch batch = mAlarmBatches.get(whichBatch);
            if (batch.add(alarm)) {
                // 批次时间可能需要调整
                mAlarmBatches.remove(whichBatch);
                addBatchLocked(mAlarmBatches, batch);
            }
        }
        
        // 4. 重新计算下次唤醒时间
        rescheduleKernelAlarmsLocked();
    }
    
    /**
     * setExactAndAllowWhileIdle 的限制
     * 防止应用滥用此 API
     */
    private long getMinimumAllowedWhileIdleDelayLocked(int uid) {
        // 默认最小间隔: 9 分钟
        // 如果应用频繁使用，间隔会增加
        final long minDelay = mConstants.ALLOW_WHILE_IDLE_SHORT_TIME;
        
        // 检查应用最近的使用频率
        long lastTime = mLastAllowWhileIdleDispatch.get(uid, 0);
        long elapsed = SystemClock.elapsedRealtime() - lastTime;
        
        if (elapsed < minDelay) {
            // 强制延迟
            return minDelay - elapsed;
        }
        
        return 0;
    }
}
```

---

## 4. 实战应用

### 4.1 Battery Historian 使用

```
┌─────────────────────────────────────────────────────────────────────────┐
│                   Battery Historian 使用指南                             │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  1. 安装 Battery Historian:                                             │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  # 方式1: Docker 安装 (推荐)                                    │   │
│  │  docker run -p 9999:9999 gcr.io/android-battery-historian/stable│   │
│  │                                                                 │   │
│  │  # 方式2: 源码编译                                              │   │
│  │  go get -d -u github.com/nicholasf/battery-historian/...        │   │
│  │  cd $GOPATH/src/github.com/nicholasf/battery-historian          │   │
│  │  go run setup.go                                                │   │
│  │  go run cmd/battery-historian/battery-historian.go              │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  2. 收集电量数据:                                                       │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  # 重置电量统计                                                 │   │
│  │  adb shell dumpsys batterystats --reset                         │   │
│  │                                                                 │   │
│  │  # 断开 USB (使用 WiFi adb 或等待测试完成后再连接)              │   │
│  │  # 进行测试操作...                                              │   │
│  │                                                                 │   │
│  │  # 导出电量数据                                                 │   │
│  │  adb bugreport bugreport.zip                                    │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  3. 分析数据:                                                           │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  • 打开 http://localhost:9999                                   │   │
│  │  • 上传 bugreport.zip 文件                                      │   │
│  │  • 查看各项指标                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

```
┌─────────────────────────────────────────────────────────────────────────┐
│                   Battery Historian 关键指标                             │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  重点关注指标:                                                          │
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  Wakelock:                                                      │   │
│  │  • 查看应用持有 WakeLock 的时长                                 │   │
│  │  • 识别长时间持有的 WakeLock                                    │   │
│  │  • 检查 WakeLock 是否正确释放                                   │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  JobScheduler:                                                  │   │
│  │  • 查看 Job 执行频率和时长                                      │   │
│  │  • 检查 Job 是否在合适的时机执行                                │   │
│  │  • 识别过于频繁的 Job                                           │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  Network:                                                       │   │
│  │  • 查看网络请求频率                                             │   │
│  │  • 检查是否有不必要的后台网络请求                               │   │
│  │  • 分析网络请求的时机                                           │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  GPS:                                                           │   │
│  │  • 查看 GPS 使用时长                                            │   │
│  │  • 检查是否有不必要的高精度定位                                 │   │
│  │  • 分析定位请求频率                                             │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  Alarm:                                                         │   │
│  │  • 查看闹钟触发频率                                             │   │
│  │  • 检查是否有过于频繁的闹钟                                     │   │
│  │  • 分析闹钟唤醒设备的次数                                       │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 4.2 WakeLock 使用规范

```kotlin
/**
 * WakeLock 正确使用示例
 */
class WakeLockManager(private val context: Context) {
    
    private val powerManager = context.getSystemService(Context.POWER_SERVICE) as PowerManager
    private var wakeLock: PowerManager.WakeLock? = null
    
    /**
     * 获取 WakeLock
     * 注意: 必须在 finally 中释放，或使用超时机制
     */
    fun acquireWakeLock(timeout: Long = 10 * 60 * 1000L) { // 默认 10 分钟超时
        wakeLock = powerManager.newWakeLock(
            PowerManager.PARTIAL_WAKE_LOCK,
            "MyApp:MyWakeLockTag"  // Tag 格式: 包名:标签名
        ).apply {
            // 设置引用计数为 false，避免多次 acquire 导致无法释放
            setReferenceCounted(false)
            // 使用超时机制，防止忘记释放
            acquire(timeout)
        }
    }
    
    /**
     * 释放 WakeLock
     */
    fun releaseWakeLock() {
        wakeLock?.let {
            if (it.isHeld) {
                it.release()
            }
        }
        wakeLock = null
    }
    
    /**
     * 安全执行任务 (推荐方式)
     */
    inline fun <T> withWakeLock(timeout: Long = 60_000L, block: () -> T): T {
        val wl = powerManager.newWakeLock(
            PowerManager.PARTIAL_WAKE_LOCK,
            "MyApp:TaskWakeLock"
        )
        
        return try {
            wl.acquire(timeout)
            block()
        } finally {
            if (wl.isHeld) {
                wl.release()
            }
        }
    }
}

/**
 * WakeLock 使用最佳实践
 */
object WakeLockBestPractices {
    
    /**
     * ❌ 错误示例1: 忘记释放 WakeLock
     */
    fun badExample1(context: Context) {
        val pm = context.getSystemService(Context.POWER_SERVICE) as PowerManager
        val wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "MyApp:Bad")
        wakeLock.acquire() // 没有超时，也没有释放
        // 执行任务...
        // 忘记调用 release()
    }
    
    /**
     * ❌ 错误示例2: 在异常情况下未释放
     */
    fun badExample2(context: Context) {
        val pm = context.getSystemService(Context.POWER_SERVICE) as PowerManager
        val wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "MyApp:Bad")
        wakeLock.acquire()
        
        doSomethingThatMightThrow() // 如果抛出异常，WakeLock 不会释放
        
        wakeLock.release()
    }
    
    /**
     * ✅ 正确示例1: 使用 try-finally
     */
    fun goodExample1(context: Context) {
        val pm = context.getSystemService(Context.POWER_SERVICE) as PowerManager
        val wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "MyApp:Good")
        
        try {
            wakeLock.acquire(60_000L) // 设置超时
            doSomething()
        } finally {
            if (wakeLock.isHeld) {
                wakeLock.release()
            }
        }
    }
    
    /**
     * ✅ 正确示例2: 使用 use 扩展函数
     */
    fun goodExample2(context: Context) {
        val pm = context.getSystemService(Context.POWER_SERVICE) as PowerManager
        
        pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "MyApp:Good").use { wakeLock ->
            wakeLock.acquire(60_000L)
            doSomething()
        }
    }
    
    /**
     * ✅ 正确示例3: 在 Service 中使用
     */
    class MyService : Service() {
        private var wakeLock: PowerManager.WakeLock? = null
        
        override fun onCreate() {
            super.onCreate()
            val pm = getSystemService(Context.POWER_SERVICE) as PowerManager
            wakeLock = pm.newWakeLock(
                PowerManager.PARTIAL_WAKE_LOCK,
                "MyApp:ServiceWakeLock"
            )
        }
        
        override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
            wakeLock?.acquire(10 * 60 * 1000L) // 10 分钟超时
            
            // 在后台线程执行任务
            thread {
                try {
                    doBackgroundWork()
                } finally {
                    wakeLock?.let {
                        if (it.isHeld) it.release()
                    }
                    stopSelf()
                }
            }
            
            return START_NOT_STICKY
        }
        
        override fun onDestroy() {
            super.onDestroy()
            wakeLock?.let {
                if (it.isHeld) it.release()
            }
        }
        
        override fun onBind(intent: Intent?): IBinder? = null
    }
    
    private fun doSomething() {}
    private fun doSomethingThatMightThrow() {}
    private fun doBackgroundWork() {}
}

/**
 * WakeLock 扩展函数
 */
inline fun PowerManager.WakeLock.use(block: (PowerManager.WakeLock) -> Unit) {
    try {
        block(this)
    } finally {
        if (isHeld) {
            release()
        }
    }
}
```

### 4.3 JobScheduler 使用实践

```kotlin
/**
 * JobScheduler 使用示例
 */
class MyJobService : JobService() {
    
    companion object {
        const val JOB_ID_SYNC = 1001
        const val JOB_ID_CLEANUP = 1002
        
        /**
         * 调度同步任务
         */
        fun scheduleSyncJob(context: Context) {
            val jobScheduler = context.getSystemService(Context.JOB_SCHEDULER_SERVICE) 
                as JobScheduler
            
            val jobInfo = JobInfo.Builder(
                JOB_ID_SYNC,
                ComponentName(context, MyJobService::class.java)
            ).apply {
                // 需要网络连接
                setRequiredNetworkType(JobInfo.NETWORK_TYPE_ANY)
                
                // 设置延迟执行 (最少 5 分钟后)
                setMinimumLatency(5 * 60 * 1000L)
                
                // 设置最大延迟 (最多 30 分钟内执行)
                setOverrideDeadline(30 * 60 * 1000L)
                
                // 设备重启后保留任务
                setPersisted(true)
                
                // 设置重试策略
                setBackoffCriteria(
                    30_000L, // 初始重试延迟 30 秒
                    JobInfo.BACKOFF_POLICY_EXPONENTIAL // 指数退避
                )
                
                // 传递额外数据 (Android 8.0+)
                val extras = PersistableBundle().apply {
                    putString("sync_type", "full")
                }
                setExtras(extras)
            }.build()
            
            jobScheduler.schedule(jobInfo)
        }
        
        /**
         * 调度清理任务 (在充电且设备空闲时执行)
         */
        fun scheduleCleanupJob(context: Context) {
            val jobScheduler = context.getSystemService(Context.JOB_SCHEDULER_SERVICE) 
                as JobScheduler
            
            val jobInfo = JobInfo.Builder(
                JOB_ID_CLEANUP,
                ComponentName(context, MyJobService::class.java)
            ).apply {
                // 需要充电
                setRequiresCharging(true)
                
                // 需要设备空闲
                setRequiresDeviceIdle(true)
                
                // 需要电量不低
                setRequiresBatteryNotLow(true)
                
                // 周期性执行 (最小 15 分钟)
                setPeriodic(24 * 60 * 60 * 1000L) // 每天一次
                
                setPersisted(true)
            }.build()
            
            jobScheduler.schedule(jobInfo)
        }
        
        /**
         * 调度内容变化触发的任务
         */
        fun scheduleContentObserverJob(context: Context) {
            val jobScheduler = context.getSystemService(Context.JOB_SCHEDULER_SERVICE) 
                as JobScheduler
            
            val jobInfo = JobInfo.Builder(
                1003,
                ComponentName(context, MyJobService::class.java)
            ).apply {
                // 监听媒体库变化
                addTriggerContentUri(
                    JobInfo.TriggerContentUri(
                        MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
                        JobInfo.TriggerContentUri.FLAG_NOTIFY_FOR_DESCENDANTS
                    )
                )
                
                // 设置触发延迟 (合并多次变化)
                setTriggerContentUpdateDelay(5_000L)
                
                // 设置最大延迟
                setTriggerContentMaxDelay(30_000L)
            }.build()
            
            jobScheduler.schedule(jobInfo)
        }
    }
    
    override fun onStartJob(params: JobParameters): Boolean {
        // 返回 true 表示任务在后台线程执行
        // 需要在任务完成后调用 jobFinished()
        
        when (params.jobId) {
            JOB_ID_SYNC -> {
                doSyncInBackground(params)
            }
            JOB_ID_CLEANUP -> {
                doCleanupInBackground(params)
            }
        }
        
        return true // 任务在后台执行
    }
    
    override fun onStopJob(params: JobParameters): Boolean {
        // 系统要求停止任务时调用
        // 返回 true 表示需要重新调度
        // 返回 false 表示不需要重新调度
        
        cancelOngoingWork(params.jobId)
        
        return true // 需要重新调度
    }
    
    private fun doSyncInBackground(params: JobParameters) {
        thread {
            try {
                // 执行同步任务
                performSync()
                
                // 任务成功完成
                jobFinished(params, false) // false = 不需要重新调度
            } catch (e: Exception) {
                // 任务失败，需要重试
                jobFinished(params, true) // true = 需要重新调度
            }
        }
    }
    
    private fun doCleanupInBackground(params: JobParameters) {
        thread {
            try {
                performCleanup()
                jobFinished(params, false)
            } catch (e: Exception) {
                jobFinished(params, true)
            }
        }
    }
    
    private fun performSync() { /* 同步逻辑 */ }
    private fun performCleanup() { /* 清理逻辑 */ }
    private fun cancelOngoingWork(jobId: Int) { /* 取消任务 */ }
}
```

### 4.4 WorkManager 使用实践

```kotlin
/**
 * WorkManager 使用示例
 */

// 1. 定义 Worker
class SyncWorker(
    context: Context,
    params: WorkerParameters
) : CoroutineWorker(context, params) {
    
    override suspend fun doWork(): Result {
        return try {
            // 获取输入数据
            val syncType = inputData.getString("sync_type") ?: "incremental"
            
            // 执行同步
            performSync(syncType)
            
            // 返回成功
            Result.success()
        } catch (e: Exception) {
            if (runAttemptCount < 3) {
                // 重试
                Result.retry()
            } else {
                // 失败
                Result.failure(
                    workDataOf("error" to e.message)
                )
            }
        }
    }
    
    private suspend fun performSync(syncType: String) {
        // 同步逻辑
    }
}

// 2. 定义前台 Worker (长时间运行的任务)
class UploadWorker(
    context: Context,
    params: WorkerParameters
) : CoroutineWorker(context, params) {
    
    override suspend fun doWork(): Result {
        // 设置前台通知
        setForeground(createForegroundInfo())
        
        return try {
            val fileUri = inputData.getString("file_uri") ?: return Result.failure()
            
            uploadFile(fileUri) { progress ->
                // 更新进度
                setProgress(workDataOf("progress" to progress))
            }
            
            Result.success()
        } catch (e: Exception) {
            Result.failure()
        }
    }
    
    private fun createForegroundInfo(): ForegroundInfo {
        val notification = NotificationCompat.Builder(applicationContext, "upload_channel")
            .setContentTitle("正在上传")
            .setSmallIcon(R.drawable.ic_upload)
            .setOngoing(true)
            .build()
        
        return ForegroundInfo(
            NOTIFICATION_ID,
            notification,
            ServiceInfo.FOREGROUND_SERVICE_TYPE_DATA_SYNC
        )
    }
    
    private suspend fun uploadFile(uri: String, onProgress: (Int) -> Unit) {
        // 上传逻辑
    }
    
    companion object {
        private const val NOTIFICATION_ID = 1
    }
}

// 3. 调度任务
object WorkManagerHelper {
    
    /**
     * 调度一次性同步任务
     */
    fun scheduleSyncWork(context: Context) {
        val constraints = Constraints.Builder()
            .setRequiredNetworkType(NetworkType.CONNECTED)
            .setRequiresBatteryNotLow(true)
            .build()
        
        val syncRequest = OneTimeWorkRequestBuilder<SyncWorker>()
            .setConstraints(constraints)
            .setInputData(workDataOf("sync_type" to "full"))
            .setBackoffCriteria(
                BackoffPolicy.EXPONENTIAL,
                30, TimeUnit.SECONDS
            )
            .addTag("sync")
            .build()
        
        WorkManager.getInstance(context)
            .enqueueUniqueWork(
                "unique_sync",
                ExistingWorkPolicy.REPLACE,
                syncRequest
            )
    }
    
    /**
     * 调度周期性任务
     */
    fun schedulePeriodicSync(context: Context) {
        val constraints = Constraints.Builder()
            .setRequiredNetworkType(NetworkType.UNMETERED) // WiFi
            .setRequiresCharging(true)
            .build()
        
        val periodicRequest = PeriodicWorkRequestBuilder<SyncWorker>(
            repeatInterval = 6, TimeUnit.HOURS,
            flexTimeInterval = 30, TimeUnit.MINUTES
        )
            .setConstraints(constraints)
            .addTag("periodic_sync")
            .build()
        
        WorkManager.getInstance(context)
            .enqueueUniquePeriodicWork(
                "periodic_sync",
                ExistingPeriodicWorkPolicy.UPDATE,
                periodicRequest
            )
    }
    
    /**
     * 链式任务
     */
    fun scheduleChainedWork(context: Context) {
        val downloadWork = OneTimeWorkRequestBuilder<DownloadWorker>()
            .addTag("download")
            .build()
        
        val processWork = OneTimeWorkRequestBuilder<ProcessWorker>()
            .addTag("process")
            .build()
        
        val uploadWork = OneTimeWorkRequestBuilder<UploadWorker>()
            .addTag("upload")
            .build()
        
        // 下载 -> 处理 -> 上传
        WorkManager.getInstance(context)
            .beginWith(downloadWork)
            .then(processWork)
            .then(uploadWork)
            .enqueue()
    }
    
    /**
     * 并行任务
     */
    fun scheduleParallelWork(context: Context) {
        val work1 = OneTimeWorkRequestBuilder<Worker1>().build()
        val work2 = OneTimeWorkRequestBuilder<Worker2>().build()
        val work3 = OneTimeWorkRequestBuilder<Worker3>().build()
        val finalWork = OneTimeWorkRequestBuilder<FinalWorker>().build()
        
        // work1, work2, work3 并行执行，完成后执行 finalWork
        WorkManager.getInstance(context)
            .beginWith(listOf(work1, work2, work3))
            .then(finalWork)
            .enqueue()
    }
    
    /**
     * 观察任务状态
     */
    fun observeWork(context: Context, lifecycleOwner: LifecycleOwner) {
        WorkManager.getInstance(context)
            .getWorkInfosByTagLiveData("sync")
            .observe(lifecycleOwner) { workInfoList ->
                workInfoList.forEach { workInfo ->
                    when (workInfo.state) {
                        WorkInfo.State.ENQUEUED -> { /* 已入队 */ }
                        WorkInfo.State.RUNNING -> {
                            val progress = workInfo.progress.getInt("progress", 0)
                            // 更新进度
                        }
                        WorkInfo.State.SUCCEEDED -> { /* 成功 */ }
                        WorkInfo.State.FAILED -> {
                            val error = workInfo.outputData.getString("error")
                            // 处理失败
                        }
                        WorkInfo.State.CANCELLED -> { /* 已取消 */ }
                        WorkInfo.State.BLOCKED -> { /* 被阻塞 */ }
                    }
                }
            }
    }
}

// 占位 Worker 类
class DownloadWorker(context: Context, params: WorkerParameters) : Worker(context, params) {
    override fun doWork(): Result = Result.success()
}
class ProcessWorker(context: Context, params: WorkerParameters) : Worker(context, params) {
    override fun doWork(): Result = Result.success()
}
class Worker1(context: Context, params: WorkerParameters) : Worker(context, params) {
    override fun doWork(): Result = Result.success()
}
class Worker2(context: Context, params: WorkerParameters) : Worker(context, params) {
    override fun doWork(): Result = Result.success()
}
class Worker3(context: Context, params: WorkerParameters) : Worker(context, params) {
    override fun doWork(): Result = Result.success()
}
class FinalWorker(context: Context, params: WorkerParameters) : Worker(context, params) {
    override fun doWork(): Result = Result.success()
}
```

### 4.5 网络请求功耗优化

```kotlin
/**
 * 网络请求功耗优化策略
 */
object NetworkPowerOptimization {
    
    /**
     * 1. 批量请求 - 合并多个小请求
     */
    class BatchRequestManager {
        private val pendingRequests = mutableListOf<Request>()
        private val handler = Handler(Looper.getMainLooper())
        private var batchRunnable: Runnable? = null
        
        // 批量延迟时间
        private val batchDelay = 5000L // 5 秒
        
        fun addRequest(request: Request) {
            synchronized(pendingRequests) {
                pendingRequests.add(request)
                
                // 取消之前的定时器
                batchRunnable?.let { handler.removeCallbacks(it) }
                
                // 设置新的定时器
                batchRunnable = Runnable { executeBatch() }
                handler.postDelayed(batchRunnable!!, batchDelay)
            }
        }
        
        private fun executeBatch() {
            synchronized(pendingRequests) {
                if (pendingRequests.isEmpty()) return
                
                // 合并请求
                val batchRequest = mergRequests(pendingRequests.toList())
                pendingRequests.clear()
                
                // 执行批量请求
                executeBatchRequest(batchRequest)
            }
        }
        
        private fun mergRequests(requests: List<Request>): BatchRequest {
            // 合并逻辑
            return BatchRequest(requests)
        }
        
        private fun executeBatchRequest(request: BatchRequest) {
            // 执行请求
        }
    }
    
    /**
     * 2. 预取策略 - 在 WiFi 下预取数据
     */
    class PrefetchManager(private val context: Context) {
        
        fun shouldPrefetch(): Boolean {
            val connectivityManager = context.getSystemService(Context.CONNECTIVITY_SERVICE) 
                as ConnectivityManager
            
            val network = connectivityManager.activeNetwork ?: return false
            val capabilities = connectivityManager.getNetworkCapabilities(network) ?: return false
            
            // 只在 WiFi 且未计量网络下预取
            return capabilities.hasTransport(NetworkCapabilities.TRANSPORT_WIFI) &&
                   capabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_NOT_METERED)
        }
        
        fun prefetchData() {
            if (!shouldPrefetch()) return
            
            // 预取常用数据
            prefetchUserProfile()
            prefetchFeedData()
            prefetchImages()
        }
        
        private fun prefetchUserProfile() { /* 预取用户信息 */ }
        private fun prefetchFeedData() { /* 预取 Feed 数据 */ }
        private fun prefetchImages() { /* 预取图片 */ }
    }
    
    /**
     * 3. 网络状态感知
     */
    class NetworkAwareManager(private val context: Context) {
        
        private val connectivityManager = context.getSystemService(Context.CONNECTIVITY_SERVICE) 
            as ConnectivityManager
        
        // 网络回调
        private val networkCallback = object : ConnectivityManager.NetworkCallback() {
            override fun onAvailable(network: Network) {
                // 网络可用，执行待处理的请求
                executePendingRequests()
            }
            
            override fun onLost(network: Network) {
                // 网络断开，暂停请求
                pauseRequests()
            }
            
            override fun onCapabilitiesChanged(
                network: Network,
                capabilities: NetworkCapabilities
            ) {
                // 网络能力变化
                val isWifi = capabilities.hasTransport(NetworkCapabilities.TRANSPORT_WIFI)
                val isUnmetered = capabilities.hasCapability(
                    NetworkCapabilities.NET_CAPABILITY_NOT_METERED
                )
                
                if (isWifi && isUnmetered) {
                    // WiFi 网络，可以执行大数据传输
                    executeLargeDataTransfer()
                }
            }
        }
        
        fun register() {
            val request = NetworkRequest.Builder()
                .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
                .build()
            
            connectivityManager.registerNetworkCallback(request, networkCallback)
        }
        
        fun unregister() {
            connectivityManager.unregisterNetworkCallback(networkCallback)
        }
        
        private fun executePendingRequests() { /* 执行待处理请求 */ }
        private fun pauseRequests() { /* 暂停请求 */ }
        private fun executeLargeDataTransfer() { /* 执行大数据传输 */ }
    }
    
    /**
     * 4. 请求压缩与缓存
     */
    fun createOptimizedOkHttpClient(): OkHttpClient {
        return OkHttpClient.Builder()
            // 启用 GZIP 压缩 (OkHttp 默认支持)
            .addInterceptor { chain ->
                val request = chain.request().newBuilder()
                    .header("Accept-Encoding", "gzip")
                    .build()
                chain.proceed(request)
            }
            // 设置缓存
            .cache(Cache(
                directory = File(context.cacheDir, "http_cache"),
                maxSize = 50L * 1024 * 1024 // 50 MB
            ))
            // 设置超时
            .connectTimeout(15, TimeUnit.SECONDS)
            .readTimeout(15, TimeUnit.SECONDS)
            .writeTimeout(15, TimeUnit.SECONDS)
            // 连接池复用
            .connectionPool(ConnectionPool(
                maxIdleConnections = 5,
                keepAliveDuration = 5,
                timeUnit = TimeUnit.MINUTES
            ))
            .build()
    }
    
    private lateinit var context: Context
}

/**
 * 网络请求功耗优化最佳实践
 */
object NetworkBestPractices {
    
    /**
     * ❌ 错误示例: 频繁的小请求
     */
    fun badExample() {
        // 每次数据变化都立即请求
        dataChanges.forEach { change ->
            api.syncChange(change) // 频繁请求，功耗高
        }
    }
    
    /**
     * ✅ 正确示例: 批量请求
     */
    fun goodExample() {
        // 收集变化，批量同步
        val changes = collectChanges()
        if (changes.isNotEmpty()) {
            api.syncChanges(changes) // 一次请求
        }
    }
    
    /**
     * ❌ 错误示例: 轮询
     */
    fun badPolling() {
        // 每 5 秒轮询一次
        handler.postDelayed({
            api.checkUpdates()
            badPolling()
        }, 5000)
    }
    
    /**
     * ✅ 正确示例: 使用推送
     */
    fun goodPush() {
        // 使用 FCM 推送
        FirebaseMessaging.getInstance().subscribeToTopic("updates")
    }
    
    private val dataChanges = listOf<Any>()
    private fun collectChanges(): List<Any> = emptyList()
    private val api = object {
        fun syncChange(change: Any) {}
        fun syncChanges(changes: List<Any>) {}
        fun checkUpdates() {}
    }
    private val handler = Handler(Looper.getMainLooper())
}

// 辅助类
data class Request(val url: String, val data: Any)
data class BatchRequest(val requests: List<Request>)
```

### 4.6 定位功耗优化

```kotlin
/**
 * 定位功耗优化策略
 */
object LocationPowerOptimization {
    
    /**
     * 定位精度与功耗对比
     */
    /*
    ┌────────────────────┬──────────────┬──────────────┬──────────────────┐
    │      精度          │    功耗      │    精度范围  │      适用场景    │
    ├────────────────────┼──────────────┼──────────────┼──────────────────┤
    │ PRIORITY_HIGH_     │    最高      │    ~10m      │ 导航、打车       │
    │ ACCURACY           │              │              │                  │
    ├────────────────────┼──────────────┼──────────────┼──────────────────┤
    │ PRIORITY_BALANCED_ │    中等      │    ~100m     │ 天气、附近推荐   │
    │ POWER_ACCURACY     │              │              │                  │
    ├────────────────────┼──────────────┼──────────────┼──────────────────┤
    │ PRIORITY_LOW_      │    较低      │    ~1km      │ 城市级定位       │
    │ POWER              │              │              │                  │
    ├────────────────────┼──────────────┼──────────────┼──────────────────┤
    │ PRIORITY_NO_       │    最低      │    被动接收  │ 后台位置记录     │
    │ POWER              │              │              │                  │
    └────────────────────┴──────────────┴──────────────┴──────────────────┘
    */
    
    /**
     * 使用 FusedLocationProviderClient (推荐)
     */
    class OptimizedLocationManager(private val context: Context) {
        
        private val fusedLocationClient = LocationServices.getFusedLocationProviderClient(context)
        private var locationCallback: LocationCallback? = null
        
        /**
         * 获取单次位置 (最省电)
         */
        @SuppressLint("MissingPermission")
        fun getLastLocation(onSuccess: (Location) -> Unit, onFailure: () -> Unit) {
            fusedLocationClient.lastLocation
                .addOnSuccessListener { location ->
                    if (location != null) {
                        onSuccess(location)
                    } else {
                        // 没有缓存位置，请求一次
                        requestSingleLocation(onSuccess, onFailure)
                    }
                }
                .addOnFailureListener {
                    onFailure()
                }
        }
        
        /**
         * 请求单次位置更新
         */
        @SuppressLint("MissingPermission")
        fun requestSingleLocation(onSuccess: (Location) -> Unit, onFailure: () -> Unit) {
            val request = LocationRequest.Builder(
                Priority.PRIORITY_BALANCED_POWER_ACCURACY,
                10000L // 10 秒
            )
                .setMaxUpdates(1) // 只获取一次
                .setMaxUpdateDelayMillis(5000L)
                .build()
            
            val callback = object : LocationCallback() {
                override fun onLocationResult(result: LocationResult) {
                    result.lastLocation?.let { onSuccess(it) } ?: onFailure()
                    fusedLocationClient.removeLocationUpdates(this)
                }
            }
            
            fusedLocationClient.requestLocationUpdates(
                request,
                callback,
                Looper.getMainLooper()
            )
        }
        
        /**
         * 前台持续定位 (导航场景)
         */
        @SuppressLint("MissingPermission")
        fun startForegroundLocationUpdates(callback: (Location) -> Unit) {
            val request = LocationRequest.Builder(
                Priority.PRIORITY_HIGH_ACCURACY,
                5000L // 5 秒间隔
            )
                .setMinUpdateIntervalMillis(2000L)
                .setMinUpdateDistanceMeters(10f) // 最小移动 10 米
                .build()
            
            locationCallback = object : LocationCallback() {
                override fun onLocationResult(result: LocationResult) {
                    result.lastLocation?.let { callback(it) }
                }
            }
            
            fusedLocationClient.requestLocationUpdates(
                request,
                locationCallback!!,
                Looper.getMainLooper()
            )
        }
        
        /**
         * 后台低功耗定位
         */
        @SuppressLint("MissingPermission")
        fun startBackgroundLocationUpdates(callback: (Location) -> Unit) {
            val request = LocationRequest.Builder(
                Priority.PRIORITY_BALANCED_POWER_ACCURACY,
                60000L // 1 分钟间隔
            )
                .setMinUpdateIntervalMillis(30000L)
                .setMinUpdateDistanceMeters(100f) // 最小移动 100 米
                .setMaxUpdateDelayMillis(120000L) // 批量延迟 2 分钟
                .build()
            
            locationCallback = object : LocationCallback() {
                override fun onLocationResult(result: LocationResult) {
                    result.lastLocation?.let { callback(it) }
                }
            }
            
            fusedLocationClient.requestLocationUpdates(
                request,
                locationCallback!!,
                Looper.getMainLooper()
            )
        }
        
        /**
         * 停止定位更新
         */
        fun stopLocationUpdates() {
            locationCallback?.let {
                fusedLocationClient.removeLocationUpdates(it)
            }
            locationCallback = null
        }
    }
    
    /**
     * 使用 Geofencing (地理围栏)
     * 比持续定位更省电
     */
    class GeofenceManager(private val context: Context) {
        
        private val geofencingClient = LocationServices.getGeofencingClient(context)
        
        @SuppressLint("MissingPermission")
        fun addGeofence(
            id: String,
            latitude: Double,
            longitude: Double,
            radius: Float,
            pendingIntent: PendingIntent
        ) {
            val geofence = Geofence.Builder()
                .setRequestId(id)
                .setCircularRegion(latitude, longitude, radius)
                .setExpirationDuration(Geofence.NEVER_EXPIRE)
                .setTransitionTypes(
                    Geofence.GEOFENCE_TRANSITION_ENTER or
                    Geofence.GEOFENCE_TRANSITION_EXIT
                )
                .build()
            
            val request = GeofencingRequest.Builder()
                .setInitialTrigger(GeofencingRequest.INITIAL_TRIGGER_ENTER)
                .addGeofence(geofence)
                .build()
            
            geofencingClient.addGeofences(request, pendingIntent)
        }
        
        fun removeGeofence(id: String) {
            geofencingClient.removeGeofences(listOf(id))
        }
    }
}

/**
 * 定位功耗优化最佳实践
 */
object LocationBestPractices {
    
    /**
     * ❌ 错误示例: 始终使用高精度
     */
    fun badExample(context: Context) {
        val locationManager = context.getSystemService(Context.LOCATION_SERVICE) 
            as LocationManager
        
        // 始终使用 GPS，功耗极高
        locationManager.requestLocationUpdates(
            LocationManager.GPS_PROVIDER,
            1000L, // 1 秒
            0f,    // 0 米
            locationListener
        )
    }
    
    /**
     * ✅ 正确示例: 根据场景选择精度
     */
    fun goodExample(context: Context, scenario: LocationScenario) {
        val fusedClient = LocationServices.getFusedLocationProviderClient(context)
        
        val request = when (scenario) {
            LocationScenario.NAVIGATION -> {
                // 导航需要高精度
                LocationRequest.Builder(Priority.PRIORITY_HIGH_ACCURACY, 5000L)
                    .setMinUpdateDistanceMeters(10f)
                    .build()
            }
            LocationScenario.WEATHER -> {
                // 天气只需要城市级
                LocationRequest.Builder(Priority.PRIORITY_LOW_POWER, 3600000L)
                    .build()
            }
            LocationScenario.BACKGROUND_TRACKING -> {
                // 后台追踪使用被动定位
                LocationRequest.Builder(Priority.PRIORITY_PASSIVE, 0L)
                    .build()
            }
        }
        
        fusedClient.requestLocationUpdates(request, locationCallback, Looper.getMainLooper())
    }
    
    enum class LocationScenario {
        NAVIGATION,
        WEATHER,
        BACKGROUND_TRACKING
    }
    
    private val locationListener = object : android.location.LocationListener {
        override fun onLocationChanged(location: Location) {}
    }
    
    private val locationCallback = object : LocationCallback() {
        override fun onLocationResult(result: LocationResult) {}
    }
}
```

### 4.7 AlarmManager 优化

```kotlin
/**
 * AlarmManager 功耗优化
 */
object AlarmManagerOptimization {
    
    /**
     * AlarmManager 类型对比
     */
    /*
    ┌─────────────────────────────┬──────────────┬──────────────────────────┐
    │          方法               │    功耗      │          说明            │
    ├─────────────────────────────┼──────────────┼──────────────────────────┤
    │ set()                       │    低        │ 不精确，系统会批量处理   │
    ├─────────────────────────────┼──────────────┼──────────────────────────┤
    │ setExact()                  │    中        │ 精确触发，但 Doze 下延迟 │
    ├─────────────────────────────┼──────────────┼──────────────────────────┤
    │ setExactAndAllowWhileIdle() │    高        │ Doze 下也能触发，有限制  │
    ├─────────────────────────────┼──────────────┼──────────────────────────┤
    │ setAlarmClock()             │    最高      │ 闹钟，会唤醒设备并显示   │
    └─────────────────────────────┴──────────────┴──────────────────────────┘
    */
    
    /**
     * 正确使用 AlarmManager
     */
    class OptimizedAlarmManager(private val context: Context) {
        
        private val alarmManager = context.getSystemService(Context.ALARM_SERVICE) 
            as AlarmManager
        
        /**
         * 设置非精确闘钟 (推荐)
         * 系统会将相近时间的闹钟批量处理，节省功耗
         */
        fun setInexactAlarm(triggerTime: Long, pendingIntent: PendingIntent) {
            // 使用 setWindow 允许系统在窗口内灵活调度
            alarmManager.setWindow(
                AlarmManager.ELAPSED_REALTIME,
                triggerTime,
                10 * 60 * 1000L, // 10 分钟窗口
                pendingIntent
            )
        }
        
        /**
         * 设置精确闹钟 (仅在必要时使用)
         */
        fun setExactAlarm(triggerTime: Long, pendingIntent: PendingIntent) {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                // Android 12+ 需要检查权限
                if (alarmManager.canScheduleExactAlarms()) {
                    alarmManager.setExact(
                        AlarmManager.RTC_WAKEUP,
                        triggerTime,
                        pendingIntent
                    )
                } else {
                    // 引导用户授权
                    requestExactAlarmPermission()
                }
            } else {
                alarmManager.setExact(
                    AlarmManager.RTC_WAKEUP,
                    triggerTime,
                    pendingIntent
                )
            }
        }
        
        /**
         * 设置 Doze 模式下也能触发的闹钟
         * 注意: 有频率限制，不要滥用
         */
        fun setAlarmAllowWhileIdle(triggerTime: Long, pendingIntent: PendingIntent) {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                alarmManager.setExactAndAllowWhileIdle(
                    AlarmManager.RTC_WAKEUP,
                    triggerTime,
                    pendingIntent
                )
            } else {
                alarmManager.setExact(
                    AlarmManager.RTC_WAKEUP,
                    triggerTime,
                    pendingIntent
                )
            }
        }
        
        /**
         * 设置用户闹钟 (最高优先级)
         */
        fun setUserAlarm(triggerTime: Long, pendingIntent: PendingIntent) {
            val alarmClockInfo = AlarmManager.AlarmClockInfo(
                triggerTime,
                pendingIntent // 点击闹钟通知时的 Intent
            )
            
            alarmManager.setAlarmClock(alarmClockInfo, pendingIntent)
        }
        
        /**
         * 设置重复闹钟
         * 注意: 最小间隔为 1 分钟，推荐使用 JobScheduler/WorkManager
         */
        fun setRepeatingAlarm(
            intervalMillis: Long,
            pendingIntent: PendingIntent
        ) {
            // 使用 setInexactRepeating 让系统优化
            alarmManager.setInexactRepeating(
                AlarmManager.ELAPSED_REALTIME,
                SystemClock.elapsedRealtime() + intervalMillis,
                intervalMillis,
                pendingIntent
            )
        }
        
        /**
         * 取消闹钟
         */
        fun cancelAlarm(pendingIntent: PendingIntent) {
            alarmManager.cancel(pendingIntent)
        }
        
        @RequiresApi(Build.VERSION_CODES.S)
        private fun requestExactAlarmPermission() {
            val intent = Intent(Settings.ACTION_REQUEST_SCHEDULE_EXACT_ALARM).apply {
                data = Uri.parse("package:${context.packageName}")
            }
            context.startActivity(intent)
        }
    }
}

/**
 * AlarmManager 最佳实践
 */
object AlarmBestPractices {
    
    /**
     * ❌ 错误示例: 频繁的精确闹钟
     */
    fun badExample(context: Context) {
        val alarmManager = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager
        
        // 每分钟触发一次精确闹钟，功耗极高
        alarmManager.setRepeating(
            AlarmManager.RTC_WAKEUP,
            System.currentTimeMillis(),
            60 * 1000L, // 1 分钟
            pendingIntent
        )
    }
    
    /**
     * ✅ 正确示例: 使用 JobScheduler 替代
     */
    fun goodExample(context: Context) {
        val jobScheduler = context.getSystemService(Context.JOB_SCHEDULER_SERVICE) 
            as JobScheduler
        
        val jobInfo = JobInfo.Builder(
            1001,
            ComponentName(context, MyJobService::class.java)
        )
            .setPeriodic(15 * 60 * 1000L) // 最小 15 分钟
            .setRequiredNetworkType(JobInfo.NETWORK_TYPE_ANY)
            .build()
        
        jobScheduler.schedule(jobInfo)
    }
    
    /**
     * 选择合适的定时方案
     */
    fun chooseTimingMethod(scenario: TimingScenario): String {
        return when (scenario) {
            TimingScenario.USER_ALARM -> 
                "使用 AlarmManager.setAlarmClock()"
            
            TimingScenario.PERIODIC_SYNC -> 
                "使用 WorkManager 的 PeriodicWorkRequest"
            
            TimingScenario.DELAYED_TASK -> 
                "使用 WorkManager 的 OneTimeWorkRequest + setInitialDelay"
            
            TimingScenario.EXACT_TIMING -> 
                "使用 AlarmManager.setExact() (需要 SCHEDULE_EXACT_ALARM 权限)"
            
            TimingScenario.BACKGROUND_WORK -> 
                "使用 JobScheduler 或 WorkManager"
        }
    }
    
    enum class TimingScenario {
        USER_ALARM,      // 用户设置的闹钟
        PERIODIC_SYNC,   // 周期性同步
        DELAYED_TASK,    // 延迟任务
        EXACT_TIMING,    // 精确定时
        BACKGROUND_WORK  // 后台工作
    }
    
    private val pendingIntent: PendingIntent = TODO()
}
```

### 4.8 后台任务优化

```kotlin
/**
 * 后台任务优化策略
 */
object BackgroundTaskOptimization {
    
    /**
     * 后台任务方案选择
     */
    /*
    ┌─────────────────────┬──────────────────────────────────────────────────┐
    │       场景          │                  推荐方案                        │
    ├─────────────────────┼──────────────────────────────────────────────────┤
    │ 即时任务            │ Kotlin 协程 / 线程池                             │
    ├─────────────────────┼──────────────────────────────────────────────────┤
    │ 可延迟任务          │ WorkManager (推荐)                               │
    ├─────────────────────┼──────────────────────────────────────────────────┤
    │ 精确定时任务        │ AlarmManager                                     │
    ├─────────────────────┼──────────────────────────────────────────────────┤
    │ 长时间运行任务      │ 前台服务 + WorkManager                           │
    ├─────────────────────┼──────────────────────────────────────────────────┤
    │ 用户发起的任务      │ 前台服务 (Android 14+ 需要声明类型)              │
    └─────────────────────┴──────────────────────────────────────────────────┘
    */
    
    /**
     * 前台服务最佳实践 (Android 14+)
     */
    class OptimizedForegroundService : Service() {
        
        override fun onCreate() {
            super.onCreate()
            
            // 创建通知渠道
            createNotificationChannel()
        }
        
        override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
            val notification = createNotification()
            
            // Android 14+ 需要指定前台服务类型
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.UPSIDE_DOWN_CAKE) {
                startForeground(
                    NOTIFICATION_ID,
                    notification,
                    ServiceInfo.FOREGROUND_SERVICE_TYPE_DATA_SYNC
                )
            } else {
                startForeground(NOTIFICATION_ID, notification)
            }
            
            // 执行任务
            performTask()
            
            return START_NOT_STICKY
        }
        
        private fun createNotificationChannel() {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                val channel = NotificationChannel(
                    CHANNEL_ID,
                    "后台任务",
                    NotificationManager.IMPORTANCE_LOW
                )
                
                val notificationManager = getSystemService(NotificationManager::class.java)
                notificationManager.createNotificationChannel(channel)
            }
        }
        
        private fun createNotification(): Notification {
            return NotificationCompat.Builder(this, CHANNEL_ID)
                .setContentTitle("正在同步数据")
                .setSmallIcon(R.drawable.ic_sync)
                .setOngoing(true)
                .build()
        }
        
        private fun performTask() {
            // 在后台线程执行任务
            thread {
                try {
                    doWork()
                } finally {
                    stopSelf()
                }
            }
        }
        
        private fun doWork() {
            // 实际工作
        }
        
        override fun onBind(intent: Intent?): IBinder? = null
        
        companion object {
            private const val NOTIFICATION_ID = 1
            private const val CHANNEL_ID = "background_task"
        }
    }
    
    /**
     * 后台任务合并策略
     */
    class TaskBatcher {
        
        private val pendingTasks = mutableListOf<Task>()
        private val lock = Any()
        
        // 批量执行阈值
        private val batchSize = 10
        private val batchTimeout = 30_000L // 30 秒
        
        private var lastBatchTime = SystemClock.elapsedRealtime()
        
        fun addTask(task: Task) {
            synchronized(lock) {
                pendingTasks.add(task)
                
                val shouldExecute = pendingTasks.size >= batchSize ||
                    SystemClock.elapsedRealtime() - lastBatchTime >= batchTimeout
                
                if (shouldExecute) {
                    executeBatch()
                }
            }
        }
        
        private fun executeBatch() {
            val tasks = pendingTasks.toList()
            pendingTasks.clear()
            lastBatchTime = SystemClock.elapsedRealtime()
            
            // 批量执行
            executeTasks(tasks)
        }
        
        private fun executeTasks(tasks: List<Task>) {
            // 合并执行任务
        }
    }
    
    /**
     * 智能后台任务调度
     */
    class SmartTaskScheduler(private val context: Context) {
        
        private val batteryManager = context.getSystemService(Context.BATTERY_SERVICE) 
            as BatteryManager
        
        private val connectivityManager = context.getSystemService(Context.CONNECTIVITY_SERVICE) 
            as ConnectivityManager
        
        /**
         * 判断当前是否适合执行后台任务
         */
        fun isGoodTimeForBackgroundWork(): Boolean {
            return isCharging() && isOnWifi() && !isBatteryLow()
        }
        
        /**
         * 是否正在充电
         */
        fun isCharging(): Boolean {
            return batteryManager.isCharging
        }
        
        /**
         * 是否连接 WiFi
         */
        fun isOnWifi(): Boolean {
            val network = connectivityManager.activeNetwork ?: return false
            val capabilities = connectivityManager.getNetworkCapabilities(network) ?: return false
            return capabilities.hasTransport(NetworkCapabilities.TRANSPORT_WIFI)
        }
        
        /**
         * 电量是否低
         */
        fun isBatteryLow(): Boolean {
            val batteryLevel = batteryManager.getIntProperty(
                BatteryManager.BATTERY_PROPERTY_CAPACITY
            )
            return batteryLevel < 20
        }
        
        /**
         * 根据条件调度任务
         */
        fun scheduleTask(task: () -> Unit, constraints: TaskConstraints) {
            when {
                constraints.requiresCharging && !isCharging() -> {
                    // 等待充电时执行
                    scheduleForCharging(task)
                }
                constraints.requiresWifi && !isOnWifi() -> {
                    // 等待 WiFi 时执行
                    scheduleForWifi(task)
                }
                constraints.requiresBatteryNotLow && isBatteryLow() -> {
                    // 等待电量充足时执行
                    scheduleForBattery(task)
                }
                else -> {
                    // 立即执行
                    task()
                }
            }
        }
        
        private fun scheduleForCharging(task: () -> Unit) {
            // 使用 WorkManager 调度
        }
        
        private fun scheduleForWifi(task: () -> Unit) {
            // 使用 WorkManager 调度
        }
        
        private fun scheduleForBattery(task: () -> Unit) {
            // 使用 WorkManager 调度
        }
    }
    
    data class Task(val id: String, val action: () -> Unit)
    
    data class TaskConstraints(
        val requiresCharging: Boolean = false,
        val requiresWifi: Boolean = false,
        val requiresBatteryNotLow: Boolean = false
    )
}
```

### 4.9 功耗优化实战案例

```kotlin
/**
 * 功耗优化实战案例
 */
object PowerOptimizationCases {
    
    /**
     * 案例1: 新闻应用后台刷新优化
     * 
     * 问题: 应用每 5 分钟后台刷新一次，功耗过高
     * 解决: 使用 WorkManager + 智能调度
     */
    class NewsRefreshOptimization(private val context: Context) {
        
        // 优化前: 频繁的后台刷新
        fun beforeOptimization() {
            val handler = Handler(Looper.getMainLooper())
            
            fun scheduleRefresh() {
                handler.postDelayed({
                    refreshNews() // 每 5 分钟刷新
                    scheduleRefresh()
                }, 5 * 60 * 1000L)
            }
            
            scheduleRefresh()
        }
        
        // 优化后: 智能调度
        fun afterOptimization() {
            val constraints = Constraints.Builder()
                .setRequiredNetworkType(NetworkType.CONNECTED)
                .setRequiresBatteryNotLow(true)
                .build()
            
            val refreshRequest = PeriodicWorkRequestBuilder<NewsRefreshWorker>(
                repeatInterval = 1, TimeUnit.HOURS, // 改为 1 小时
                flexTimeInterval = 15, TimeUnit.MINUTES
            )
                .setConstraints(constraints)
                .build()
            
            WorkManager.getInstance(context)
                .enqueueUniquePeriodicWork(
                    "news_refresh",
                    ExistingPeriodicWorkPolicy.UPDATE,
                    refreshRequest
                )
        }
        
        // 同时使用 FCM 推送重要新闻
        fun setupPushNotification() {
            FirebaseMessaging.getInstance().subscribeToTopic("breaking_news")
        }
        
        private fun refreshNews() {}
    }
    
    /**
     * 案例2: 运动追踪应用定位优化
     * 
     * 问题: 始终使用高精度 GPS，电量消耗快
     * 解决: 根据运动状态动态调整定位策略
     */
    class FitnessTrackingOptimization(private val context: Context) {
        
        private val fusedLocationClient = LocationServices.getFusedLocationProviderClient(context)
        private var currentRequest: LocationRequest? = null
        private var locationCallback: LocationCallback? = null
        
        // 运动状态
        enum class ActivityState {
            STATIONARY,  // 静止
            WALKING,     // 步行
            RUNNING,     // 跑步
            CYCLING      // 骑行
        }
        
        @SuppressLint("MissingPermission")
        fun updateLocationStrategy(state: ActivityState) {
            // 先停止当前定位
            locationCallback?.let {
                fusedLocationClient.removeLocationUpdates(it)
            }
            
            // 根据状态选择定位策略
            currentRequest = when (state) {
                ActivityState.STATIONARY -> {
                    // 静止时使用被动定位
                    LocationRequest.Builder(Priority.PRIORITY_PASSIVE, 0L)
                        .build()
                }
                ActivityState.WALKING -> {
                    // 步行时使用平衡模式，10 秒间隔
                    LocationRequest.Builder(
                        Priority.PRIORITY_BALANCED_POWER_ACCURACY,
                        10_000L
                    )
                        .setMinUpdateDistanceMeters(20f)
                        .build()
                }
                ActivityState.RUNNING -> {
                    // 跑步时使用高精度，5 秒间隔
                    LocationRequest.Builder(
                        Priority.PRIORITY_HIGH_ACCURACY,
                        5_000L
                    )
                        .setMinUpdateDistanceMeters(10f)
                        .build()
                }
                ActivityState.CYCLING -> {
                    // 骑行时使用高精度，3 秒间隔
                    LocationRequest.Builder(
                        Priority.PRIORITY_HIGH_ACCURACY,
                        3_000L
                    )
                        .setMinUpdateDistanceMeters(15f)
                        .build()
                }
            }
            
            locationCallback = object : LocationCallback() {
                override fun onLocationResult(result: LocationResult) {
                    result.lastLocation?.let { processLocation(it) }
                }
            }
            
            fusedLocationClient.requestLocationUpdates(
                currentRequest!!,
                locationCallback!!,
                Looper.getMainLooper()
            )
        }
        
        private fun processLocation(location: Location) {
            // 处理位置数据
        }
    }
    
    /**
     * 案例3: 即时通讯应用消息同步优化
     * 
     * 问题: 使用轮询检查新消息，功耗高
     * 解决: 使用 FCM + WebSocket + 智能重连
     */
    class MessagingOptimization(private val context: Context) {
        
        private var webSocket: WebSocket? = null
        private val reconnectHandler = Handler(Looper.getMainLooper())
        
        // 重连延迟 (指数退避)
        private var reconnectDelay = 1000L
        private val maxReconnectDelay = 60_000L
        
        /**
         * 初始化消息通道
         */
        fun initialize() {
            // 1. 注册 FCM 推送
            setupFCM()
            
            // 2. 建立 WebSocket 连接 (前台时)
            if (isAppInForeground()) {
                connectWebSocket()
            }
        }
        
        private fun setupFCM() {
            // FCM 作为后备通道
            FirebaseMessaging.getInstance().token.addOnSuccessListener { token ->
                registerTokenToServer(token)
            }
        }
        
        private fun connectWebSocket() {
            val client = OkHttpClient.Builder()
                .pingInterval(30, TimeUnit.SECONDS) // 心跳
                .build()
            
            val request = Request.Builder()
                .url("wss://api.example.com/ws")
                .build()
            
            webSocket = client.newWebSocket(request, object : WebSocketListener() {
                override fun onOpen(webSocket: WebSocket, response: Response) {
                    // 连接成功，重置重连延迟
                    reconnectDelay = 1000L
                }
                
                override fun onMessage(webSocket: WebSocket, text: String) {
                    // 处理消息
                    handleMessage(text)
                }
                
                override fun onFailure(webSocket: WebSocket, t: Throwable, response: Response?) {
                    // 连接失败，尝试重连
                    scheduleReconnect()
                }
                
                override fun onClosed(webSocket: WebSocket, code: Int, reason: String) {
                    // 连接关闭
                    if (isAppInForeground()) {
                        scheduleReconnect()
                    }
                }
            })
        }
        
        private fun scheduleReconnect() {
            reconnectHandler.postDelayed({
                if (isAppInForeground()) {
                    connectWebSocket()
                }
            }, reconnectDelay)
            
            // 指数退避
            reconnectDelay = minOf(reconnectDelay * 2, maxReconnectDelay)
        }
        
        /**
         * 应用进入后台时断开 WebSocket
         */
        fun onAppBackground() {
            webSocket?.close(1000, "App in background")
            webSocket = null
            reconnectHandler.removeCallbacksAndMessages(null)
            
            // 后台依赖 FCM 推送
        }
        
        /**
         * 应用进入前台时重连 WebSocket
         */
        fun onAppForeground() {
            reconnectDelay = 1000L
            connectWebSocket()
        }
        
        private fun isAppInForeground(): Boolean {
            val activityManager = context.getSystemService(Context.ACTIVITY_SERVICE) 
                as ActivityManager
            val appProcesses = activityManager.runningAppProcesses ?: return false
            
            return appProcesses.any { process ->
                process.importance == ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND &&
                process.processName == context.packageName
            }
        }
        
        private fun registerTokenToServer(token: String) {}
        private fun handleMessage(message: String) {}
    }
    
    // 辅助 Worker 类
    class NewsRefreshWorker(context: Context, params: WorkerParameters) 
        : Worker(context, params) {
        override fun doWork(): Result {
            // 刷新新闻
            return Result.success()
        }
    }
}
```

### 4.10 功耗监控与检测

```kotlin
/**
 * 功耗监控工具
 */
object PowerMonitoring {
    
    /**
     * 电量信息获取
     */
    class BatteryInfoManager(private val context: Context) {
        
        private val batteryManager = context.getSystemService(Context.BATTERY_SERVICE) 
            as BatteryManager
        
        /**
         * 获取电池信息
         */
        fun getBatteryInfo(): BatteryInfo {
            val level = batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY)
            val isCharging = batteryManager.isCharging
            val chargeCounter = batteryManager.getIntProperty(
                BatteryManager.BATTERY_PROPERTY_CHARGE_COUNTER
            )
            val currentNow = batteryManager.getIntProperty(
                BatteryManager.BATTERY_PROPERTY_CURRENT_NOW
            )
            val currentAverage = batteryManager.getIntProperty(
                BatteryManager.BATTERY_PROPERTY_CURRENT_AVERAGE
            )
            
            return BatteryInfo(
                level = level,
                isCharging = isCharging,
                chargeCounter = chargeCounter,
                currentNow = currentNow,
                currentAverage = currentAverage
            )
        }
        
        /**
         * 监听电池状态变化
         */
        fun registerBatteryReceiver(callback: (BatteryStatus) -> Unit): BroadcastReceiver {
            val receiver = object : BroadcastReceiver() {
                override fun onReceive(context: Context, intent: Intent) {
                    val level = intent.getIntExtra(BatteryManager.EXTRA_LEVEL, -1)
                    val scale = intent.getIntExtra(BatteryManager.EXTRA_SCALE, -1)
                    val status = intent.getIntExtra(BatteryManager.EXTRA_STATUS, -1)
                    val plugged = intent.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1)
                    
                    val percentage = level * 100 / scale
                    val isCharging = status == BatteryManager.BATTERY_STATUS_CHARGING ||
                                    status == BatteryManager.BATTERY_STATUS_FULL
                    
                    callback(BatteryStatus(percentage, isCharging, plugged))
                }
            }
            
            val filter = IntentFilter(Intent.ACTION_BATTERY_CHANGED)
            context.registerReceiver(receiver, filter)
            
            return receiver
        }
    }
    
    /**
     * WakeLock 监控
     */
    class WakeLockMonitor {
        
        private val activeWakeLocks = mutableMapOf<String, WakeLockInfo>()
        
        fun onWakeLockAcquired(tag: String) {
            activeWakeLocks[tag] = WakeLockInfo(
                tag = tag,
                acquireTime = SystemClock.elapsedRealtime(),
                stackTrace = Thread.currentThread().stackTrace.joinToString("\n")
            )
        }
        
        fun onWakeLockReleased(tag: String) {
            val info = activeWakeLocks.remove(tag)
            info?.let {
                val duration = SystemClock.elapsedRealtime() - it.acquireTime
                logWakeLockUsage(tag, duration)
                
                // 检查是否持有时间过长
                if (duration > 60_000L) { // 超过 1 分钟
                    reportLongWakeLock(tag, duration, it.stackTrace)
                }
            }
        }
        
        fun getActiveWakeLocks(): List<WakeLockInfo> {
            return activeWakeLocks.values.toList()
        }
        
        private fun logWakeLockUsage(tag: String, duration: Long) {
            Log.d("WakeLockMonitor", "WakeLock '$tag' held for ${duration}ms")
        }
        
        private fun reportLongWakeLock(tag: String, duration: Long, stackTrace: String) {
            Log.w("WakeLockMonitor", "Long WakeLock detected: $tag, duration: ${duration}ms")
            Log.w("WakeLockMonitor", "Stack trace: $stackTrace")
        }
    }
    
    /**
     * 功耗统计上报
     */
    class PowerStatsReporter(private val context: Context) {
        
        /**
         * 收集功耗统计数据
         */
        fun collectPowerStats(): PowerStats {
            val batteryInfo = BatteryInfoManager(context).getBatteryInfo()
            
            return PowerStats(
                timestamp = System.currentTimeMillis(),
                batteryLevel = batteryInfo.level,
                isCharging = batteryInfo.isCharging,
                screenOnTime = getScreenOnTime(),
                cpuTime = getCpuTime(),
                networkUsage = getNetworkUsage(),
                locationRequests = getLocationRequestCount(),
                wakeLockTime = getWakeLockTime()
            )
        }
        
        private fun getScreenOnTime(): Long {
            // 获取屏幕亮屏时间
            return 0L
        }
        
        private fun getCpuTime(): Long {
            // 获取 CPU 使用时间
            return 0L
        }
        
        private fun getNetworkUsage(): Long {
            // 获取网络使用量
            val uid = android.os.Process.myUid()
            return TrafficStats.getUidRxBytes(uid) + TrafficStats.getUidTxBytes(uid)
        }
        
        private fun getLocationRequestCount(): Int {
            // 获取定位请求次数
            return 0
        }
        
        private fun getWakeLockTime(): Long {
            // 获取 WakeLock 持有时间
            return 0L
        }
    }
    
    // 数据类
    data class BatteryInfo(
        val level: Int,
        val isCharging: Boolean,
        val chargeCounter: Int,
        val currentNow: Int,
        val currentAverage: Int
    )
    
    data class BatteryStatus(
        val percentage: Int,
        val isCharging: Boolean,
        val pluggedType: Int
    )
    
    data class WakeLockInfo(
        val tag: String,
        val acquireTime: Long,
        val stackTrace: String
    )
    
    data class PowerStats(
        val timestamp: Long,
        val batteryLevel: Int,
        val isCharging: Boolean,
        val screenOnTime: Long,
        val cpuTime: Long,
        val networkUsage: Long,
        val locationRequests: Int,
        val wakeLockTime: Long
    )
}
```

---

## 5. 常见面试题

### 5.1 基础概念题

**问题1：请介绍 Android 的 Doze 模式，它是如何工作的？**

**答案要点：**
- **触发条件**：设备未充电、屏幕关闭、设备静止一段时间（约 30 分钟）
- **状态机**：ACTIVE → INACTIVE → IDLE_PENDING → SENSING → LOCATING → IDLE → IDLE_MAINTENANCE
- **限制行为**：
  - 暂停网络访问
  - 忽略 WakeLock
  - 延迟 AlarmManager（除 setExactAndAllowWhileIdle）
  - 延迟 JobScheduler 任务
  - 暂停 WiFi 扫描
- **维护窗口**：系统定期退出 Doze 进入维护窗口，间隔逐渐增加（1h → 2h → 4h → 6h）
- **轻度 Doze（Android 7.0+）**：设备移动时也能进入，限制较少

**问题2：App Standby Buckets 是什么？有哪些级别？**

**答案要点：**
- **定义**：Android 9.0 引入的应用待机分组机制，根据应用使用频率分配不同的资源限制
- **五个级别**：
  1. **Active（活跃）**：正在使用，无限制
  2. **Working Set（工作集）**：最近几小时使用过，轻度限制
  3. **Frequent（频繁）**：定期使用但非每天，中度限制
  4. **Rare（稀有）**：很少使用，严格限制
  5. **Restricted（受限，Android 12+）**：几乎不使用或消耗过多资源，最严格限制
- **限制内容**：Jobs 延迟、Alarms 延迟、网络访问限制、前台服务限制
- **提升方式**：用户主动使用、收到高优先级 FCM 消息

**问题3：WakeLock 有哪些类型？使用时需要注意什么？**

**答案要点：**
- **类型**：
  - `PARTIAL_WAKE_LOCK`：保持 CPU 运行，屏幕和键盘可关闭（最常用）
  - `SCREEN_DIM_WAKE_LOCK`：保持屏幕变暗（已废弃）
  - `SCREEN_BRIGHT_WAKE_LOCK`：保持屏幕全亮（已废弃）
  - `FULL_WAKE_LOCK`：保持屏幕和键盘全亮（已废弃）
- **注意事项**：
  1. 必须在 finally 中释放，或使用超时机制
  2. 设置 `setReferenceCounted(false)` 避免多次 acquire 导致无法释放
  3. 使用有意义的 Tag（格式：包名:标签名）便于调试
  4. 尽量使用超时版本的 `acquire(timeout)`
  5. 屏幕保持使用 `FLAG_KEEP_SCREEN_ON` 替代废弃的 WakeLock 类型
  6. 在 Doze 模式下，WakeLock 会被忽略

**问题4：JobScheduler 和 WorkManager 有什么区别？如何选择？**

**答案要点：**
- **JobScheduler**：
  - Android 5.0+ 原生 API
  - 直接与系统交互，性能好
  - 最小周期 15 分钟
  - 需要处理兼容性问题
- **WorkManager**：
  - Jetpack 组件，向后兼容到 API 14
  - 内部根据 API 级别选择 JobScheduler/AlarmManager/Firebase JobDispatcher
  - 支持链式任务、并行任务
  - 支持任务持久化（设备重启后恢复）
  - 支持约束条件、重试策略
  - 提供 LiveData 观察任务状态
- **选择建议**：
  - 优先使用 WorkManager（官方推荐）
  - 需要精确控制或特殊需求时使用 JobScheduler
  - 简单延迟任务可用 Handler.postDelayed

### 5.2 原理深入题

**问题5：请从源码角度分析 Doze 模式的实现原理？（OPPO/vivo 重点）**

**答案要点：**
- **核心类**：`DeviceIdleController`（位于 JobScheduler apex 中）
- **状态管理**：
  ```java
  // 状态常量
  STATE_ACTIVE = 0;           // 活跃
  STATE_INACTIVE = 1;         // 非活跃
  STATE_IDLE_PENDING = 2;     // 等待空闲
  STATE_SENSING = 3;          // 传感器检测
  STATE_LOCATING = 4;         // 定位
  STATE_IDLE = 5;             // 空闲（Doze）
  STATE_IDLE_MAINTENANCE = 6; // 维护窗口
  ```
- **状态切换**：`stepIdleStateLocked()` 方法控制状态机转换
- **运动检测**：使用 `AnyMotionDetector` 检测设备是否静止
- **限制实现**：
  - 通过 `PowerManagerService.setDeviceIdleMode()` 通知系统
  - `NetworkPolicyManagerService` 限制网络
  - `AlarmManagerService` 延迟闹钟
  - `JobSchedulerService` 延迟任务
- **白名单机制**：`isAppOnWhitelistInternal()` 检查应用是否在白名单

**问题6：Battery Historian 如何分析应用功耗问题？**

**答案要点：**
- **数据收集**：
  ```bash
  adb shell dumpsys batterystats --reset  # 重置统计
  # 进行测试...
  adb bugreport bugreport.zip             # 导出数据
  ```
- **关键指标分析**：
  1. **Wakelock**：查看持有时长、频率，识别长时间持有的 WakeLock
  2. **JobScheduler**：检查 Job 执行频率和时长
  3. **Network**：分析网络请求频率和时机
  4. **GPS**：查看定位使用时长和精度
  5. **Alarm**：检查闹钟触发频率
  6. **Screen**：屏幕亮屏时间
- **问题定位**：
  - 查看时间线上的异常峰值
  - 对比前后台功耗占比
  - 分析唤醒原因（wakeup_reason）

**问题7：Android 14 对后台任务有哪些新限制？**

**答案要点：**
- **前台服务类型声明**：
  - 必须在 Manifest 中声明 `foregroundServiceType`
  - 类型包括：`camera`、`connectedDevice`、`dataSync`、`health`、`location`、`mediaPlayback`、`mediaProjection`、`microphone`、`phoneCall`、`remoteMessaging`、`shortService`、`specialUse`、`systemExempted`
- **精确闹钟权限**：
  - 需要 `SCHEDULE_EXACT_ALARM` 权限
  - 用户可以在设置中撤销
- **后台启动限制**：
  - 更严格的后台启动 Activity 限制
  - 后台启动前台服务限制
- **应对策略**：
  - 正确声明前台服务类型
  - 使用 WorkManager 替代自定义后台任务
  - 检查精确闹钟权限 `canScheduleExactAlarms()`

### 5.3 实战优化题

**问题8：如何优化一个高功耗的后台定位应用？（快手/美团重点）**

**答案要点：**
- **定位策略优化**：
  1. 根据场景选择精度：导航用高精度，天气用低精度
  2. 使用 `FusedLocationProviderClient` 替代原生 LocationManager
  3. 设置合理的更新间隔和最小移动距离
  4. 使用被动定位（`PRIORITY_PASSIVE`）接收其他应用的定位结果
- **后台定位优化**：
  1. 使用 Geofencing 替代持续定位
  2. 降低后台定位频率和精度
  3. 批量上报位置数据（`setMaxUpdateDelayMillis`）
- **智能调度**：
  1. 根据运动状态动态调整定位策略
  2. 使用 Activity Recognition API 检测用户活动
  3. 静止时停止定位或使用被动模式
- **代码示例**：
  ```kotlin
  // 后台低功耗定位
  val request = LocationRequest.Builder(
      Priority.PRIORITY_BALANCED_POWER_ACCURACY,
      60000L // 1 分钟
  )
      .setMinUpdateDistanceMeters(100f)
      .setMaxUpdateDelayMillis(120000L) // 批量延迟
      .build()
  ```

**问题9：如何设计一个省电的消息推送方案？（字节重点）**

**答案要点：**
- **推送方案选择**：
  1. **FCM/厂商推送**：最省电，系统级通道
  2. **WebSocket**：前台使用，后台断开
  3. **轮询**：最耗电，应避免
- **混合方案设计**：
  ```
  前台：WebSocket 实时连接
  后台：FCM 推送 + 厂商推送（华为、小米、OPPO、vivo）
  ```
- **WebSocket 优化**：
  1. 使用心跳保活（30-60 秒间隔）
  2. 指数退避重连策略
  3. 应用进入后台时断开连接
- **FCM 优化**：
  1. 使用高优先级消息唤醒应用
  2. 合理使用 data message 和 notification message
  3. 集成厂商推送提高到达率
- **网络状态感知**：
  1. 监听网络变化，及时重连
  2. WiFi 下可以更频繁同步
  3. 弱网环境下降低同步频率

**问题10：OPPO/vivo 手机上应用被杀死后如何保证任务执行？**

**答案要点：**
- **理解厂商限制**：
  - OPPO/vivo 有严格的后台管理策略
  - 应用可能被系统主动杀死
  - 不建议对抗系统策略
- **合规方案**：
  1. **使用 WorkManager**：任务持久化，设备重启后恢复
  2. **使用厂商推送**：通过推送唤醒应用执行任务
  3. **申请白名单**：引导用户将应用加入电池优化白名单
  4. **前台服务**：对于用户感知的任务使用前台服务
- **引导用户设置**：
  ```kotlin
  // 引导用户关闭电池优化
  val intent = Intent(Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS)
  intent.data = Uri.parse("package:${packageName}")
  startActivity(intent)
  ```
- **最佳实践**：
  1. 减少后台任务，优化用户体验
  2. 合并任务，减少唤醒次数
  3. 使用系统提供的调度机制
  4. 不要使用保活黑科技（1 像素 Activity、双进程守护等）

### 5.4 综合场景题

**问题11：设计一个功耗优化监控系统**

**答案要点：**
- **数据采集层**：
  1. 电池信息：电量、充电状态、电流
  2. WakeLock：持有时长、获取/释放堆栈
  3. 网络请求：频率、数据量、时机
  4. 定位请求：频率、精度、时长
  5. 闹钟/Job：触发频率、执行时长
- **分析层**：
  1. 异常检测：长时间 WakeLock、频繁唤醒
  2. 功耗归因：按模块统计功耗占比
  3. 趋势分析：版本间功耗对比
- **告警层**：
  1. 实时告警：检测到异常立即通知
  2. 阈值配置：可配置的告警阈值
- **展示层**：
  1. 功耗报表：日/周/月报表
  2. 问题列表：待优化问题清单
  3. 优化建议：自动生成优化建议
- **线上监控**：
  1. 采样上报：按比例采样用户数据
  2. 聚合分析：服务端聚合分析
  3. 版本对比：新版本功耗回归检测

**问题12：如何排查一个应用后台耗电严重的问题？**

**答案要点：**
- **问题定位步骤**：
  1. **收集数据**：使用 Battery Historian 收集电量数据
  2. **分析时间线**：查看后台期间的活动
  3. **检查 WakeLock**：是否有长时间持有的 WakeLock
  4. **检查网络**：是否有频繁的后台网络请求
  5. **检查定位**：是否有不必要的后台定位
  6. **检查闹钟**：是否有过于频繁的闹钟
- **常见原因**：
  1. WakeLock 未释放或持有时间过长
  2. 后台轮询或频繁网络请求
  3. 高精度后台定位
  4. 频繁的精确闹钟
  5. 后台播放或传感器使用
- **排查工具**：
  ```bash
  # 查看 WakeLock 统计
  adb shell dumpsys power | grep -A 20 "Wake Locks"
  
  # 查看闘钟统计
  adb shell dumpsys alarm | grep -A 10 "包名"
  
  # 查看 Job 统计
  adb shell dumpsys jobscheduler | grep -A 10 "包名"
  ```
- **优化方案**：
  1. 使用 WorkManager 替代自定义后台任务
  2. 合并网络请求，使用推送替代轮询
  3. 降低后台定位精度和频率
  4. 使用非精确闹钟，让系统批量处理

---

## 6. 总结

### 6.1 功耗优化核心原则

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      功耗优化核心原则                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  1. 减少唤醒:                                                           │
│     • 合并任务，减少唤醒次数                                            │
│     • 使用系统调度机制（JobScheduler/WorkManager）                      │
│     • 避免频繁的精确闹钟                                                │
│                                                                         │
│  2. 缩短唤醒时间:                                                       │
│     • 快速完成任务，及时释放资源                                        │
│     • 使用超时机制保护 WakeLock                                         │
│     • 批量处理数据，减少 I/O 操作                                       │
│                                                                         │
│  3. 延迟非紧急任务:                                                     │
│     • 等待充电时执行大任务                                              │
│     • 等待 WiFi 时传输大数据                                            │
│     • 使用约束条件调度任务                                              │
│                                                                         │
│  4. 遵循系统策略:                                                       │
│     • 适配 Doze 模式                                                    │
│     • 适配 App Standby                                                  │
│     • 不对抗系统省电策略                                                │
│                                                                         │
│  5. 持续监控:                                                           │
│     • 使用 Battery Historian 分析                                       │
│     • 建立功耗监控体系                                                  │
│     • 版本间功耗对比                                                    │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 6.2 功耗优化 Checklist

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      功耗优化 Checklist                                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  □ WakeLock 使用检查                                                    │
│    □ 是否设置了超时时间                                                 │
│    □ 是否在 finally 中释放                                              │
│    □ Tag 是否有意义便于调试                                             │
│                                                                         │
│  □ 后台任务检查                                                         │
│    □ 是否使用 WorkManager/JobScheduler                                  │
│    □ 是否设置了合理的约束条件                                           │
│    □ 是否避免了频繁的后台唤醒                                           │
│                                                                         │
│  □ 网络请求检查                                                         │
│    □ 是否合并了小请求                                                   │
│    □ 是否使用推送替代轮询                                               │
│    □ 是否在 WiFi 下预取数据                                             │
│                                                                         │
│  □ 定位检查                                                             │
│    □ 是否根据场景选择精度                                               │
│    □ 是否使用 FusedLocationProvider                                     │
│    □ 后台是否降低了定位频率                                             │
│                                                                         │
│  □ 闹钟检查                                                             │
│    □ 是否使用非精确闹钟                                                 │
│    □ 是否避免了频繁的精确闹钟                                           │
│    □ 是否考虑使用 JobScheduler 替代                                     │
│                                                                         │
│  □ 前台服务检查 (Android 14+)                                           │
│    □ 是否声明了正确的 foregroundServiceType                             │
│    □ 是否在任务完成后停止服务                                           │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

*文档版本: v1.0*  
*更新时间: 2025-01*  
*适用版本: Android W*
