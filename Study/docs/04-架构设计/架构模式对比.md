# Android 架构模式对比

## 1. 概述

在 Android 应用开发中，选择合适的架构模式对于代码的可维护性、可测试性和可扩展性至关重要。本文将深入对比 MVC、MVP、MVVM、MVI 四种主流架构模式，以及 Clean Architecture 的设计理念，帮助开发者在面试和实际项目中做出正确的架构选择。

### 1.1 为什么需要架构模式

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        架构模式的价值                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  没有架构的问题:                                                        │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  1. Activity/Fragment 臃肿 (God Activity)                       │   │
│  │  2. 业务逻辑与 UI 逻辑混杂                                      │   │
│  │  3. 代码难以测试                                                │   │
│  │  4. 团队协作困难                                                │   │
│  │  5. 代码复用性差                                                │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  架构模式的目标:                                                        │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  ✓ 关注点分离 (Separation of Concerns)                          │   │
│  │  ✓ 提高可测试性 (Testability)                                   │   │
│  │  ✓ 降低耦合度 (Low Coupling)                                    │   │
│  │  ✓ 提高可维护性 (Maintainability)                               │   │
│  │  ✓ 便于团队协作 (Team Collaboration)                            │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 1.2 架构模式演进历程

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      Android 架构演进时间线                              │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  2008 ──────────────────────────────────────────────────────────→ 2024  │
│    │                                                                    │
│    │  MVC (传统)                                                        │
│    │    └── Activity 承担 Controller 角色                               │
│    │                                                                    │
│    │        MVP (2014-2016 流行)                                        │
│    │          └── Google 官方 MVP 示例                                  │
│    │                                                                    │
│    │              MVVM (2017-至今)                                      │
│    │                └── Architecture Components 发布                    │
│    │                └── ViewModel + LiveData + DataBinding              │
│    │                                                                    │
│    │                    MVI (2019-至今)                                  │
│    │                      └── 单向数据流                                │
│    │                      └── Compose 推动                              │
│    │                                                                    │
│    │                          Clean Architecture                        │
│    │                            └── 分层架构思想                        │
│    │                            └── 与 MVVM/MVI 结合                    │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```


## 2. 核心原理

### 2.1 MVC 模式 (Model-View-Controller)

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          MVC 架构模式                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  组件职责:                                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  Model      → 数据层，负责数据获取、存储、业务逻辑               │   │
│  │  View       → 视图层，负责 UI 展示 (XML 布局)                    │   │
│  │  Controller → 控制层，处理用户输入，协调 Model 和 View           │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  数据流向:                                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │         用户操作                                                │   │
│  │            │                                                    │   │
│  │            ↓                                                    │   │
│  │      ┌──────────┐                                               │   │
│  │      │Controller│ ←──────────────────────┐                      │   │
│  │      │(Activity)│                        │                      │   │
│  │      └────┬─────┘                        │                      │   │
│  │           │                              │                      │   │
│  │     操作数据                         更新通知                   │   │
│  │           │                              │                      │   │
│  │           ↓                              │                      │   │
│  │      ┌──────────┐                   ┌──────────┐                │   │
│  │      │  Model   │ ─────────────────→│   View   │                │   │
│  │      │ (数据层) │     数据变化       │  (XML)   │                │   │
│  │      └──────────┘                   └──────────┘                │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  Android 中的 MVC 问题:                                                 │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  ✗ Activity 既是 Controller 又是 View 的一部分                  │   │
│  │  ✗ Activity 容易变得臃肿 (God Activity)                         │   │
│  │  ✗ View 和 Controller 耦合严重                                  │   │
│  │  ✗ 难以进行单元测试                                             │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.2 MVP 模式 (Model-View-Presenter)

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          MVP 架构模式                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  组件职责:                                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  Model     → 数据层，负责数据获取、存储、业务逻辑                │   │
│  │  View      → 视图层，Activity/Fragment 实现 View 接口            │   │
│  │  Presenter → 中介层，处理业务逻辑，连接 Model 和 View            │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  数据流向:                                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │         用户操作                                                │   │
│  │            │                                                    │   │
│  │            ↓                                                    │   │
│  │      ┌──────────┐         调用方法         ┌──────────┐         │   │
│  │      │   View   │ ───────────────────────→ │ Presenter│         │   │
│  │      │(Activity)│ ←─────────────────────── │          │         │   │
│  │      └──────────┘      更新 UI 接口        └────┬─────┘         │   │
│  │                                                 │               │   │
│  │                                           请求数据              │   │
│  │                                                 │               │   │
│  │                                                 ↓               │   │
│  │                                            ┌──────────┐         │   │
│  │                                            │  Model   │         │   │
│  │                                            │ (数据层) │         │   │
│  │                                            └──────────┘         │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  MVP 核心特点:                                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  ✓ View 和 Presenter 通过接口通信                               │   │
│  │  ✓ Presenter 不持有 Android 组件引用                            │   │
│  │  ✓ 便于单元测试 (Mock View 接口)                                │   │
│  │  ✗ 接口数量膨胀                                                 │   │
│  │  ✗ Presenter 可能变得臃肿                                       │   │
│  │  ✗ 需要手动处理生命周期                                         │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```


### 2.3 MVVM 模式 (Model-View-ViewModel)

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          MVVM 架构模式                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  组件职责:                                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  Model     → 数据层，Repository 模式管理数据源                   │   │
│  │  View      → 视图层，Activity/Fragment，观察 ViewModel 数据      │   │
│  │  ViewModel → 视图模型，持有 UI 状态，处理业务逻辑                │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  数据流向 (数据绑定):                                                   │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │         用户操作                                                │   │
│  │            │                                                    │   │
│  │            ↓                                                    │   │
│  │      ┌──────────┐                          ┌──────────┐         │   │
│  │      │   View   │ ─────── 调用方法 ───────→│ViewModel │         │   │
│  │      │(Activity)│                          │          │         │   │
│  │      │          │ ←─── 观察 LiveData ───── │          │         │   │
│  │      └──────────┘      (自动更新)          └────┬─────┘         │   │
│  │                                                 │               │   │
│  │                                           请求数据              │   │
│  │                                                 │               │   │
│  │                                                 ↓               │   │
│  │                                            ┌──────────┐         │   │
│  │                                            │Repository│         │   │
│  │                                            │ (Model)  │         │   │
│  │                                            └──────────┘         │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  MVVM 核心特点:                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  ✓ 数据驱动 UI (LiveData/StateFlow 观察者模式)                  │   │
│  │  ✓ ViewModel 生命周期感知，配置变更时保留数据                   │   │
│  │  ✓ View 和 ViewModel 解耦，便于测试                             │   │
│  │  ✓ 支持 DataBinding 双向绑定                                    │   │
│  │  ✗ 学习曲线较陡                                                 │   │
│  │  ✗ 复杂场景下状态管理困难                                       │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  Android Jetpack 支持:                                                  │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  - ViewModel: 管理 UI 相关数据，生命周期感知                    │   │
│  │  - LiveData: 可观察的数据持有者，生命周期感知                   │   │
│  │  - DataBinding: XML 中直接绑定数据                              │   │
│  │  - StateFlow: Kotlin 协程的状态流                               │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.4 MVI 模式 (Model-View-Intent)

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          MVI 架构模式                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  组件职责:                                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  Model  → 不可变的 UI 状态 (State)                               │   │
│  │  View   → 渲染状态，发送用户意图                                 │   │
│  │  Intent → 用户意图/事件，触发状态变化                            │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  单向数据流:                                                            │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │      ┌──────────────────────────────────────────────────────┐   │   │
│  │      │                                                      │   │   │
│  │      │    Intent        State         Render                │   │   │
│  │      │   (用户意图)    (UI状态)       (渲染)                 │   │   │
│  │      │                                                      │   │   │
│  │      │      │             │             │                   │   │   │
│  │      │      ↓             ↓             ↓                   │   │   │
│  │      │  ┌───────┐    ┌─────────┐    ┌───────┐               │   │   │
│  │      │  │ View  │───→│ViewModel│───→│ View  │               │   │   │
│  │      │  │(发送) │    │(处理)   │    │(渲染) │               │   │   │
│  │      │  └───────┘    └─────────┘    └───────┘               │   │   │
│  │      │      ↑                           │                   │   │   │
│  │      │      └───────────────────────────┘                   │   │   │
│  │      │              用户交互                                │   │   │
│  │      │                                                      │   │   │
│  │      └──────────────────────────────────────────────────────┘   │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  MVI 核心概念:                                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  1. 单一数据源 (Single Source of Truth)                         │   │
│  │     - 整个 UI 状态由一个 State 对象表示                         │   │
│  │                                                                 │   │
│  │  2. 不可变状态 (Immutable State)                                │   │
│  │     - State 是 data class，每次更新创建新对象                   │   │
│  │                                                                 │   │
│  │  3. 单向数据流 (Unidirectional Data Flow)                       │   │
│  │     - Intent → Reducer → State → View                           │   │
│  │                                                                 │   │
│  │  4. 纯函数 (Pure Functions)                                     │   │
│  │     - Reducer: (State, Intent) → State                          │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  MVI 优缺点:                                                            │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  ✓ 状态可预测，易于调试                                         │   │
│  │  ✓ 时间旅行调试 (Time Travel Debugging)                         │   │
│  │  ✓ 线程安全，状态不可变                                         │   │
│  │  ✓ 与 Compose 天然契合                                          │   │
│  │  ✗ 样板代码较多                                                 │   │
│  │  ✗ 简单场景过度设计                                             │   │
│  │  ✗ 状态对象可能很大                                             │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```


### 2.5 Clean Architecture

```
┌─────────────────────────────────────────────────────────────────────────┐
│                       Clean Architecture                                 │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  分层架构 (由内到外):                                                   │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │                    Presentation Layer                    │   │   │
│  │  │              (Activity, Fragment, ViewModel)             │   │   │
│  │  │  ┌─────────────────────────────────────────────────┐    │   │   │
│  │  │  │                  Domain Layer                    │    │   │   │
│  │  │  │            (UseCase, Entity, Repository接口)     │    │   │   │
│  │  │  │  ┌─────────────────────────────────────────┐    │    │   │   │
│  │  │  │  │              Data Layer                  │    │    │   │   │
│  │  │  │  │    (Repository实现, DataSource, API)     │    │    │   │   │
│  │  │  │  └─────────────────────────────────────────┘    │    │   │   │
│  │  │  └─────────────────────────────────────────────────┘    │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │                                                                 │   │
│  │  依赖规则: 外层依赖内层，内层不知道外层                         │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  各层职责:                                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  Presentation Layer (表现层):                                   │   │
│  │  ├── UI 组件 (Activity, Fragment, Compose)                      │   │
│  │  ├── ViewModel (持有 UI 状态)                                   │   │
│  │  └── 调用 UseCase                                               │   │
│  │                                                                 │   │
│  │  Domain Layer (领域层) - 核心业务逻辑:                          │   │
│  │  ├── UseCase (用例，单一职责)                                   │   │
│  │  ├── Entity (业务实体)                                          │   │
│  │  └── Repository 接口 (依赖倒置)                                 │   │
│  │                                                                 │   │
│  │  Data Layer (数据层):                                           │   │
│  │  ├── Repository 实现                                            │   │
│  │  ├── Remote DataSource (API)                                    │   │
│  │  ├── Local DataSource (Room, SharedPreferences)                 │   │
│  │  └── Data Mapper (DTO ↔ Entity)                                 │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  依赖倒置原则:                                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  传统依赖:                                                      │   │
│  │  ViewModel → Repository实现 → API                               │   │
│  │                                                                 │   │
│  │  依赖倒置:                                                      │   │
│  │  ViewModel → UseCase → Repository接口 ← Repository实现          │   │
│  │                              ↑                                  │   │
│  │                         Domain Layer                            │   │
│  │                         (不依赖任何外部)                        │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.6 架构模式对比总结

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        架构模式对比表                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌────────┬──────────┬──────────┬──────────┬──────────┬──────────┐     │
│  │ 特性   │   MVC    │   MVP    │   MVVM   │   MVI    │  Clean   │     │
│  ├────────┼──────────┼──────────┼──────────┼──────────┼──────────┤     │
│  │ 复杂度 │   低     │   中     │   中     │   高     │   高     │     │
│  ├────────┼──────────┼──────────┼──────────┼──────────┼──────────┤     │
│  │ 可测试 │   差     │   好     │   好     │   优秀   │   优秀   │     │
│  ├────────┼──────────┼──────────┼──────────┼──────────┼──────────┤     │
│  │ 解耦度 │   低     │   中     │   高     │   高     │   最高   │     │
│  ├────────┼──────────┼──────────┼──────────┼──────────┼──────────┤     │
│  │ 学习成本│   低     │   中     │   中     │   高     │   高     │     │
│  ├────────┼──────────┼──────────┼──────────┼──────────┼──────────┤     │
│  │ 样板代码│   少     │   多     │   中     │   多     │   最多   │     │
│  ├────────┼──────────┼──────────┼──────────┼──────────┼──────────┤     │
│  │ 状态管理│   混乱   │   一般   │   较好   │   优秀   │   优秀   │     │
│  ├────────┼──────────┼──────────┼──────────┼──────────┼──────────┤     │
│  │ 适用场景│ 小型项目 │ 中型项目 │ 中大型   │ 复杂状态 │ 大型项目 │     │
│  └────────┴──────────┴──────────┴──────────┴──────────┴──────────┘     │
│                                                                         │
│  推荐选择:                                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  小型项目/Demo     → MVC 或简单 MVVM                            │   │
│  │  中型项目          → MVVM + Repository                          │   │
│  │  大型项目          → MVVM/MVI + Clean Architecture              │   │
│  │  Compose 项目      → MVI (单向数据流天然契合)                   │   │
│  │  需要时间旅行调试  → MVI                                        │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```


## 3. 关键源码解析

### 3.1 MVP 模式实现

```kotlin
/**
 * MVP 模式 - Contract 契约接口
 * 定义 View 和 Presenter 之间的通信协议
 */
interface UserContract {
    
    /**
     * View 接口 - Activity/Fragment 实现
     * 定义 UI 操作方法
     */
    interface View {
        fun showLoading()           // 显示加载中
        fun hideLoading()           // 隐藏加载
        fun showUser(user: User)    // 显示用户信息
        fun showError(message: String)  // 显示错误
        fun isActive(): Boolean     // View 是否活跃（防止内存泄漏）
    }
    
    /**
     * Presenter 接口 - 定义业务操作
     */
    interface Presenter {
        fun attachView(view: View)  // 绑定 View
        fun detachView()            // 解绑 View
        fun loadUser(userId: String)  // 加载用户
    }
}

/**
 * Presenter 实现类
 * 处理业务逻辑，协调 Model 和 View
 */
class UserPresenter(
    private val userRepository: UserRepository  // 依赖注入 Repository
) : UserContract.Presenter {
    
    // 持有 View 的弱引用，防止内存泄漏
    private var view: UserContract.View? = null
    
    // 用于取消异步任务
    private var disposable: Disposable? = null
    
    override fun attachView(view: UserContract.View) {
        this.view = view
    }
    
    override fun detachView() {
        // 解绑时取消异步任务，防止内存泄漏
        disposable?.dispose()
        this.view = null
    }
    
    override fun loadUser(userId: String) {
        // 检查 View 是否存在
        view?.let { v ->
            v.showLoading()
            
            // 调用 Repository 获取数据
            disposable = userRepository.getUser(userId)
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(
                    { user ->
                        // 检查 View 是否仍然活跃
                        if (v.isActive()) {
                            v.hideLoading()
                            v.showUser(user)
                        }
                    },
                    { error ->
                        if (v.isActive()) {
                            v.hideLoading()
                            v.showError(error.message ?: "Unknown error")
                        }
                    }
                )
        }
    }
}

/**
 * Activity 实现 View 接口
 */
class UserActivity : AppCompatActivity(), UserContract.View {
    
    // 注入 Presenter
    private lateinit var presenter: UserContract.Presenter
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_user)
        
        // 创建 Presenter 并绑定 View
        presenter = UserPresenter(UserRepositoryImpl())
        presenter.attachView(this)
        
        // 加载数据
        presenter.loadUser("123")
    }
    
    override fun onDestroy() {
        // 解绑 View，防止内存泄漏
        presenter.detachView()
        super.onDestroy()
    }
    
    // 实现 View 接口方法
    override fun showLoading() {
        progressBar.visibility = View.VISIBLE
    }
    
    override fun hideLoading() {
        progressBar.visibility = View.GONE
    }
    
    override fun showUser(user: User) {
        tvUserName.text = user.name
        tvUserEmail.text = user.email
    }
    
    override fun showError(message: String) {
        Toast.makeText(this, message, Toast.LENGTH_SHORT).show()
    }
    
    override fun isActive(): Boolean = !isFinishing && !isDestroyed
}
```

### 3.2 MVVM 模式实现

```kotlin
/**
 * MVVM 模式 - ViewModel 实现
 * 使用 Jetpack ViewModel + LiveData/StateFlow
 */
class UserViewModel(
    private val userRepository: UserRepository  // 依赖注入
) : ViewModel() {
    
    // ==================== 使用 LiveData ====================
    
    // 私有可变 LiveData
    private val _user = MutableLiveData<User>()
    // 公开不可变 LiveData
    val user: LiveData<User> = _user
    
    private val _loading = MutableLiveData<Boolean>()
    val loading: LiveData<Boolean> = _loading
    
    private val _error = MutableLiveData<String>()
    val error: LiveData<String> = _error
    
    /**
     * 使用 LiveData 加载用户
     */
    fun loadUserWithLiveData(userId: String) {
        _loading.value = true
        
        viewModelScope.launch {
            try {
                // 在 IO 线程执行网络请求
                val result = withContext(Dispatchers.IO) {
                    userRepository.getUser(userId)
                }
                _user.value = result
            } catch (e: Exception) {
                _error.value = e.message
            } finally {
                _loading.value = false
            }
        }
    }
    
    // ==================== 使用 StateFlow (推荐) ====================
    
    // UI 状态封装
    data class UserUiState(
        val user: User? = null,
        val isLoading: Boolean = false,
        val error: String? = null
    )
    
    // 使用 StateFlow 管理状态
    private val _uiState = MutableStateFlow(UserUiState())
    val uiState: StateFlow<UserUiState> = _uiState.asStateFlow()
    
    /**
     * 使用 StateFlow 加载用户
     */
    fun loadUserWithStateFlow(userId: String) {
        viewModelScope.launch {
            // 更新为加载状态
            _uiState.update { it.copy(isLoading = true, error = null) }
            
            try {
                val user = withContext(Dispatchers.IO) {
                    userRepository.getUser(userId)
                }
                // 更新为成功状态
                _uiState.update { it.copy(user = user, isLoading = false) }
            } catch (e: Exception) {
                // 更新为错误状态
                _uiState.update { it.copy(error = e.message, isLoading = false) }
            }
        }
    }
}

/**
 * Activity 观察 ViewModel 数据
 */
class UserActivity : AppCompatActivity() {
    
    // 使用 by viewModels() 委托创建 ViewModel
    private val viewModel: UserViewModel by viewModels {
        UserViewModelFactory(UserRepositoryImpl())
    }
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_user)
        
        // ========== 观察 LiveData ==========
        viewModel.user.observe(this) { user ->
            tvUserName.text = user.name
        }
        
        viewModel.loading.observe(this) { isLoading ->
            progressBar.visibility = if (isLoading) View.VISIBLE else View.GONE
        }
        
        viewModel.error.observe(this) { error ->
            error?.let { Toast.makeText(this, it, Toast.LENGTH_SHORT).show() }
        }
        
        // ========== 观察 StateFlow ==========
        lifecycleScope.launch {
            // repeatOnLifecycle 确保只在 STARTED 状态收集
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.uiState.collect { state ->
                    // 根据状态更新 UI
                    progressBar.visibility = if (state.isLoading) View.VISIBLE else View.GONE
                    state.user?.let { tvUserName.text = it.name }
                    state.error?.let { showError(it) }
                }
            }
        }
        
        // 触发加载
        viewModel.loadUserWithStateFlow("123")
    }
}

/**
 * ViewModel Factory - 用于依赖注入
 */
class UserViewModelFactory(
    private val repository: UserRepository
) : ViewModelProvider.Factory {
    
    @Suppress("UNCHECKED_CAST")
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(UserViewModel::class.java)) {
            return UserViewModel(repository) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class")
    }
}
```


### 3.3 MVI 模式实现

```kotlin
/**
 * MVI 模式 - 单向数据流实现
 * Intent → Reducer → State → View
 */

// ==================== 1. 定义 State (不可变状态) ====================

/**
 * UI 状态 - 使用 data class 保证不可变性
 * 包含 UI 需要的所有数据
 */
data class UserState(
    val user: User? = null,
    val isLoading: Boolean = false,
    val error: String? = null,
    val users: List<User> = emptyList()
) {
    companion object {
        // 初始状态
        fun initial() = UserState()
    }
}

// ==================== 2. 定义 Intent (用户意图) ====================

/**
 * 用户意图 - 使用 sealed class 枚举所有可能的操作
 */
sealed class UserIntent {
    data class LoadUser(val userId: String) : UserIntent()
    data class SearchUsers(val query: String) : UserIntent()
    object RefreshUsers : UserIntent()
    data class DeleteUser(val userId: String) : UserIntent()
}

// ==================== 3. 定义 Side Effect (一次性事件) ====================

/**
 * 副作用 - 一次性事件，如 Toast、导航等
 */
sealed class UserEffect {
    data class ShowToast(val message: String) : UserEffect()
    data class NavigateToDetail(val userId: String) : UserEffect()
    object NavigateBack : UserEffect()
}

// ==================== 4. ViewModel 实现 ====================

/**
 * MVI ViewModel
 * 处理 Intent，更新 State，发送 Effect
 */
class UserMviViewModel(
    private val userRepository: UserRepository
) : ViewModel() {
    
    // 当前状态
    private val _state = MutableStateFlow(UserState.initial())
    val state: StateFlow<UserState> = _state.asStateFlow()
    
    // 一次性事件 (使用 Channel 确保只消费一次)
    private val _effect = Channel<UserEffect>()
    val effect: Flow<UserEffect> = _effect.receiveAsFlow()
    
    /**
     * 处理用户意图
     * 这是 MVI 的核心入口
     */
    fun processIntent(intent: UserIntent) {
        when (intent) {
            is UserIntent.LoadUser -> loadUser(intent.userId)
            is UserIntent.SearchUsers -> searchUsers(intent.query)
            is UserIntent.RefreshUsers -> refreshUsers()
            is UserIntent.DeleteUser -> deleteUser(intent.userId)
        }
    }
    
    /**
     * 加载单个用户
     */
    private fun loadUser(userId: String) {
        viewModelScope.launch {
            // 更新为加载状态 (使用 reduce 函数)
            reduce { copy(isLoading = true, error = null) }
            
            try {
                val user = withContext(Dispatchers.IO) {
                    userRepository.getUser(userId)
                }
                // 更新为成功状态
                reduce { copy(user = user, isLoading = false) }
            } catch (e: Exception) {
                // 更新为错误状态
                reduce { copy(error = e.message, isLoading = false) }
                // 发送一次性事件
                sendEffect(UserEffect.ShowToast("加载失败: ${e.message}"))
            }
        }
    }
    
    /**
     * 搜索用户
     */
    private fun searchUsers(query: String) {
        viewModelScope.launch {
            reduce { copy(isLoading = true) }
            
            try {
                val users = withContext(Dispatchers.IO) {
                    userRepository.searchUsers(query)
                }
                reduce { copy(users = users, isLoading = false) }
            } catch (e: Exception) {
                reduce { copy(error = e.message, isLoading = false) }
            }
        }
    }
    
    /**
     * 刷新用户列表
     */
    private fun refreshUsers() {
        viewModelScope.launch {
            reduce { copy(isLoading = true) }
            
            try {
                val users = withContext(Dispatchers.IO) {
                    userRepository.getAllUsers()
                }
                reduce { copy(users = users, isLoading = false) }
                sendEffect(UserEffect.ShowToast("刷新成功"))
            } catch (e: Exception) {
                reduce { copy(error = e.message, isLoading = false) }
            }
        }
    }
    
    /**
     * 删除用户
     */
    private fun deleteUser(userId: String) {
        viewModelScope.launch {
            try {
                withContext(Dispatchers.IO) {
                    userRepository.deleteUser(userId)
                }
                // 从列表中移除
                reduce { copy(users = users.filter { it.id != userId }) }
                sendEffect(UserEffect.ShowToast("删除成功"))
            } catch (e: Exception) {
                sendEffect(UserEffect.ShowToast("删除失败: ${e.message}"))
            }
        }
    }
    
    /**
     * Reducer 函数 - 更新状态
     * 使用 inline 和 crossinline 优化性能
     */
    private inline fun reduce(crossinline reducer: UserState.() -> UserState) {
        _state.update { it.reducer() }
    }
    
    /**
     * 发送一次性事件
     */
    private fun sendEffect(effect: UserEffect) {
        viewModelScope.launch {
            _effect.send(effect)
        }
    }
}

// ==================== 5. View 层实现 ====================

/**
 * Activity/Fragment 实现
 */
class UserMviActivity : AppCompatActivity() {
    
    private val viewModel: UserMviViewModel by viewModels()
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_user)
        
        // 观察状态
        observeState()
        // 观察一次性事件
        observeEffects()
        // 设置用户交互
        setupUserInteractions()
        
        // 初始加载
        viewModel.processIntent(UserIntent.LoadUser("123"))
    }
    
    /**
     * 观察状态变化，更新 UI
     */
    private fun observeState() {
        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.state.collect { state ->
                    // 根据状态渲染 UI
                    renderState(state)
                }
            }
        }
    }
    
    /**
     * 渲染状态
     */
    private fun renderState(state: UserState) {
        // 加载状态
        progressBar.visibility = if (state.isLoading) View.VISIBLE else View.GONE
        
        // 用户信息
        state.user?.let { user ->
            tvUserName.text = user.name
            tvUserEmail.text = user.email
        }
        
        // 用户列表
        userAdapter.submitList(state.users)
        
        // 错误状态
        state.error?.let { error ->
            tvError.text = error
            tvError.visibility = View.VISIBLE
        } ?: run {
            tvError.visibility = View.GONE
        }
    }
    
    /**
     * 观察一次性事件
     */
    private fun observeEffects() {
        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.effect.collect { effect ->
                    when (effect) {
                        is UserEffect.ShowToast -> {
                            Toast.makeText(this@UserMviActivity, effect.message, Toast.LENGTH_SHORT).show()
                        }
                        is UserEffect.NavigateToDetail -> {
                            startActivity(UserDetailActivity.newIntent(this@UserMviActivity, effect.userId))
                        }
                        is UserEffect.NavigateBack -> {
                            finish()
                        }
                    }
                }
            }
        }
    }
    
    /**
     * 设置用户交互 - 发送 Intent
     */
    private fun setupUserInteractions() {
        // 刷新按钮
        btnRefresh.setOnClickListener {
            viewModel.processIntent(UserIntent.RefreshUsers)
        }
        
        // 搜索
        etSearch.doAfterTextChanged { text ->
            viewModel.processIntent(UserIntent.SearchUsers(text.toString()))
        }
        
        // 列表项点击
        userAdapter.onItemClick = { user ->
            viewModel.processIntent(UserIntent.DeleteUser(user.id))
        }
    }
}
```


### 3.4 Clean Architecture 实现

```kotlin
/**
 * Clean Architecture 分层实现
 * Domain Layer → Data Layer → Presentation Layer
 */

// ==================== Domain Layer (领域层) ====================

/**
 * Entity - 业务实体
 * 纯 Kotlin 类，不依赖任何框架
 */
data class User(
    val id: String,
    val name: String,
    val email: String,
    val avatar: String,
    val createdAt: Long
)

/**
 * Repository 接口 - 定义在 Domain 层
 * 依赖倒置原则：Domain 层定义接口，Data 层实现
 */
interface UserRepository {
    suspend fun getUser(userId: String): User
    suspend fun getAllUsers(): List<User>
    suspend fun saveUser(user: User)
    suspend fun deleteUser(userId: String)
    suspend fun searchUsers(query: String): List<User>
}

/**
 * UseCase - 用例，封装单一业务逻辑
 * 每个 UseCase 只做一件事 (单一职责原则)
 */
class GetUserUseCase(
    private val userRepository: UserRepository  // 依赖接口，不依赖实现
) {
    /**
     * 使用 operator fun invoke 简化调用
     * 可以直接 getUserUseCase(userId) 调用
     */
    suspend operator fun invoke(userId: String): Result<User> {
        return try {
            val user = userRepository.getUser(userId)
            Result.success(user)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}

/**
 * 带参数的 UseCase 基类
 */
abstract class UseCase<in P, R> {
    abstract suspend fun execute(parameters: P): R
    
    suspend operator fun invoke(parameters: P): Result<R> {
        return try {
            Result.success(execute(parameters))
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}

/**
 * 获取用户列表 UseCase
 */
class GetUsersUseCase(
    private val userRepository: UserRepository
) : UseCase<Unit, List<User>>() {
    
    override suspend fun execute(parameters: Unit): List<User> {
        return userRepository.getAllUsers()
    }
}

/**
 * 搜索用户 UseCase
 */
class SearchUsersUseCase(
    private val userRepository: UserRepository
) : UseCase<String, List<User>>() {
    
    override suspend fun execute(parameters: String): List<User> {
        // 业务逻辑：搜索词至少 2 个字符
        require(parameters.length >= 2) { "搜索词至少需要 2 个字符" }
        return userRepository.searchUsers(parameters)
    }
}

// ==================== Data Layer (数据层) ====================

/**
 * DTO - 数据传输对象 (API 响应)
 */
data class UserDto(
    @SerializedName("id") val id: String,
    @SerializedName("name") val name: String,
    @SerializedName("email") val email: String,
    @SerializedName("avatar_url") val avatarUrl: String,
    @SerializedName("created_at") val createdAt: String
)

/**
 * Entity - Room 数据库实体
 */
@Entity(tableName = "users")
data class UserEntity(
    @PrimaryKey val id: String,
    val name: String,
    val email: String,
    val avatar: String,
    val createdAt: Long,
    val updatedAt: Long = System.currentTimeMillis()
)

/**
 * Mapper - 数据转换器
 * DTO ↔ Domain Entity ↔ Database Entity
 */
object UserMapper {
    
    // DTO → Domain Entity
    fun UserDto.toDomain(): User {
        return User(
            id = id,
            name = name,
            email = email,
            avatar = avatarUrl,
            createdAt = parseDate(createdAt)
        )
    }
    
    // Database Entity → Domain Entity
    fun UserEntity.toDomain(): User {
        return User(
            id = id,
            name = name,
            email = email,
            avatar = avatar,
            createdAt = createdAt
        )
    }
    
    // Domain Entity → Database Entity
    fun User.toEntity(): UserEntity {
        return UserEntity(
            id = id,
            name = name,
            email = email,
            avatar = avatar,
            createdAt = createdAt
        )
    }
    
    private fun parseDate(dateStr: String): Long {
        // 日期解析逻辑
        return SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss", Locale.getDefault())
            .parse(dateStr)?.time ?: 0L
    }
}

/**
 * Remote DataSource - 远程数据源
 */
interface UserRemoteDataSource {
    suspend fun getUser(userId: String): UserDto
    suspend fun getAllUsers(): List<UserDto>
    suspend fun searchUsers(query: String): List<UserDto>
}

class UserRemoteDataSourceImpl(
    private val apiService: UserApiService
) : UserRemoteDataSource {
    
    override suspend fun getUser(userId: String): UserDto {
        return apiService.getUser(userId)
    }
    
    override suspend fun getAllUsers(): List<UserDto> {
        return apiService.getAllUsers()
    }
    
    override suspend fun searchUsers(query: String): List<UserDto> {
        return apiService.searchUsers(query)
    }
}

/**
 * Local DataSource - 本地数据源
 */
interface UserLocalDataSource {
    suspend fun getUser(userId: String): UserEntity?
    suspend fun getAllUsers(): List<UserEntity>
    suspend fun saveUser(user: UserEntity)
    suspend fun saveUsers(users: List<UserEntity>)
    suspend fun deleteUser(userId: String)
    suspend fun clearAll()
}

class UserLocalDataSourceImpl(
    private val userDao: UserDao
) : UserLocalDataSource {
    
    override suspend fun getUser(userId: String): UserEntity? {
        return userDao.getUserById(userId)
    }
    
    override suspend fun getAllUsers(): List<UserEntity> {
        return userDao.getAllUsers()
    }
    
    override suspend fun saveUser(user: UserEntity) {
        userDao.insertUser(user)
    }
    
    override suspend fun saveUsers(users: List<UserEntity>) {
        userDao.insertUsers(users)
    }
    
    override suspend fun deleteUser(userId: String) {
        userDao.deleteUserById(userId)
    }
    
    override suspend fun clearAll() {
        userDao.clearAll()
    }
}

/**
 * Repository 实现 - 协调远程和本地数据源
 * 实现缓存策略
 */
class UserRepositoryImpl(
    private val remoteDataSource: UserRemoteDataSource,
    private val localDataSource: UserLocalDataSource,
    private val networkChecker: NetworkChecker
) : UserRepository {
    
    override suspend fun getUser(userId: String): User {
        // 策略：先从本地获取，如果没有或过期则从网络获取
        val localUser = localDataSource.getUser(userId)
        
        return if (localUser != null && !isExpired(localUser)) {
            // 本地数据有效，直接返回
            localUser.toDomain()
        } else if (networkChecker.isConnected()) {
            // 从网络获取
            val remoteUser = remoteDataSource.getUser(userId)
            // 保存到本地
            localDataSource.saveUser(remoteUser.toDomain().toEntity())
            remoteUser.toDomain()
        } else {
            // 无网络，返回本地数据（即使过期）
            localUser?.toDomain() ?: throw NoDataException("无法获取用户数据")
        }
    }
    
    override suspend fun getAllUsers(): List<User> {
        return if (networkChecker.isConnected()) {
            // 有网络，从远程获取并缓存
            val remoteUsers = remoteDataSource.getAllUsers()
            val domainUsers = remoteUsers.map { it.toDomain() }
            localDataSource.saveUsers(domainUsers.map { it.toEntity() })
            domainUsers
        } else {
            // 无网络，从本地获取
            localDataSource.getAllUsers().map { it.toDomain() }
        }
    }
    
    override suspend fun saveUser(user: User) {
        localDataSource.saveUser(user.toEntity())
    }
    
    override suspend fun deleteUser(userId: String) {
        localDataSource.deleteUser(userId)
    }
    
    override suspend fun searchUsers(query: String): List<User> {
        return remoteDataSource.searchUsers(query).map { it.toDomain() }
    }
    
    // 检查数据是否过期 (例如 5 分钟)
    private fun isExpired(entity: UserEntity): Boolean {
        val cacheTime = 5 * 60 * 1000L // 5 分钟
        return System.currentTimeMillis() - entity.updatedAt > cacheTime
    }
}

// ==================== Presentation Layer (表现层) ====================

/**
 * ViewModel - 使用 UseCase
 */
class UserViewModel(
    private val getUserUseCase: GetUserUseCase,
    private val getUsersUseCase: GetUsersUseCase,
    private val searchUsersUseCase: SearchUsersUseCase
) : ViewModel() {
    
    private val _state = MutableStateFlow(UserUiState())
    val state: StateFlow<UserUiState> = _state.asStateFlow()
    
    fun loadUser(userId: String) {
        viewModelScope.launch {
            _state.update { it.copy(isLoading = true) }
            
            // 调用 UseCase
            getUserUseCase(userId)
                .onSuccess { user ->
                    _state.update { it.copy(user = user, isLoading = false) }
                }
                .onFailure { error ->
                    _state.update { it.copy(error = error.message, isLoading = false) }
                }
        }
    }
    
    fun loadUsers() {
        viewModelScope.launch {
            _state.update { it.copy(isLoading = true) }
            
            getUsersUseCase(Unit)
                .onSuccess { users ->
                    _state.update { it.copy(users = users, isLoading = false) }
                }
                .onFailure { error ->
                    _state.update { it.copy(error = error.message, isLoading = false) }
                }
        }
    }
    
    fun searchUsers(query: String) {
        viewModelScope.launch {
            searchUsersUseCase(query)
                .onSuccess { users ->
                    _state.update { it.copy(users = users) }
                }
                .onFailure { error ->
                    _state.update { it.copy(error = error.message) }
                }
        }
    }
}
```


### 3.5 Jetpack Compose 中的 MVI 实现

```kotlin
/**
 * Jetpack Compose + MVI 最佳实践
 * 单向数据流与声明式 UI 天然契合
 */

// ==================== State & Intent 定义 ====================

/**
 * UI 状态
 */
data class UserListState(
    val users: List<User> = emptyList(),
    val isLoading: Boolean = false,
    val error: String? = null,
    val selectedUser: User? = null
)

/**
 * 用户意图
 */
sealed interface UserListIntent {
    object LoadUsers : UserListIntent
    object RefreshUsers : UserListIntent
    data class SelectUser(val user: User) : UserListIntent
    data class DeleteUser(val userId: String) : UserListIntent
    object DismissError : UserListIntent
}

/**
 * 一次性事件
 */
sealed interface UserListEffect {
    data class ShowSnackbar(val message: String) : UserListEffect
    data class NavigateToDetail(val userId: String) : UserListEffect
}

// ==================== ViewModel ====================

/**
 * Compose MVI ViewModel
 */
class UserListViewModel(
    private val getUsersUseCase: GetUsersUseCase,
    private val deleteUserUseCase: DeleteUserUseCase
) : ViewModel() {
    
    // 状态
    private val _state = MutableStateFlow(UserListState())
    val state: StateFlow<UserListState> = _state.asStateFlow()
    
    // 一次性事件
    private val _effect = Channel<UserListEffect>(Channel.BUFFERED)
    val effect: Flow<UserListEffect> = _effect.receiveAsFlow()
    
    init {
        // 初始加载
        handleIntent(UserListIntent.LoadUsers)
    }
    
    /**
     * 处理意图 - 统一入口
     */
    fun handleIntent(intent: UserListIntent) {
        when (intent) {
            is UserListIntent.LoadUsers -> loadUsers()
            is UserListIntent.RefreshUsers -> refreshUsers()
            is UserListIntent.SelectUser -> selectUser(intent.user)
            is UserListIntent.DeleteUser -> deleteUser(intent.userId)
            is UserListIntent.DismissError -> dismissError()
        }
    }
    
    private fun loadUsers() {
        viewModelScope.launch {
            _state.update { it.copy(isLoading = true, error = null) }
            
            getUsersUseCase(Unit)
                .onSuccess { users ->
                    _state.update { it.copy(users = users, isLoading = false) }
                }
                .onFailure { e ->
                    _state.update { it.copy(error = e.message, isLoading = false) }
                }
        }
    }
    
    private fun refreshUsers() {
        viewModelScope.launch {
            getUsersUseCase(Unit)
                .onSuccess { users ->
                    _state.update { it.copy(users = users) }
                    _effect.send(UserListEffect.ShowSnackbar("刷新成功"))
                }
                .onFailure { e ->
                    _effect.send(UserListEffect.ShowSnackbar("刷新失败: ${e.message}"))
                }
        }
    }
    
    private fun selectUser(user: User) {
        _state.update { it.copy(selectedUser = user) }
        viewModelScope.launch {
            _effect.send(UserListEffect.NavigateToDetail(user.id))
        }
    }
    
    private fun deleteUser(userId: String) {
        viewModelScope.launch {
            deleteUserUseCase(userId)
                .onSuccess {
                    _state.update { state ->
                        state.copy(users = state.users.filter { it.id != userId })
                    }
                    _effect.send(UserListEffect.ShowSnackbar("删除成功"))
                }
                .onFailure { e ->
                    _effect.send(UserListEffect.ShowSnackbar("删除失败: ${e.message}"))
                }
        }
    }
    
    private fun dismissError() {
        _state.update { it.copy(error = null) }
    }
}

// ==================== Compose UI ====================

/**
 * 用户列表屏幕
 */
@Composable
fun UserListScreen(
    viewModel: UserListViewModel = hiltViewModel(),
    onNavigateToDetail: (String) -> Unit
) {
    // 收集状态
    val state by viewModel.state.collectAsStateWithLifecycle()
    
    // 处理一次性事件
    val snackbarHostState = remember { SnackbarHostState() }
    
    LaunchedEffect(Unit) {
        viewModel.effect.collect { effect ->
            when (effect) {
                is UserListEffect.ShowSnackbar -> {
                    snackbarHostState.showSnackbar(effect.message)
                }
                is UserListEffect.NavigateToDetail -> {
                    onNavigateToDetail(effect.userId)
                }
            }
        }
    }
    
    // UI 渲染
    UserListContent(
        state = state,
        snackbarHostState = snackbarHostState,
        onIntent = viewModel::handleIntent
    )
}

/**
 * 用户列表内容 - 纯 UI 组件
 * 接收状态，发送意图
 */
@Composable
fun UserListContent(
    state: UserListState,
    snackbarHostState: SnackbarHostState,
    onIntent: (UserListIntent) -> Unit
) {
    Scaffold(
        snackbarHost = { SnackbarHost(snackbarHostState) },
        topBar = {
            TopAppBar(
                title = { Text("用户列表") },
                actions = {
                    IconButton(onClick = { onIntent(UserListIntent.RefreshUsers) }) {
                        Icon(Icons.Default.Refresh, contentDescription = "刷新")
                    }
                }
            )
        }
    ) { paddingValues ->
        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            when {
                // 加载中
                state.isLoading -> {
                    CircularProgressIndicator(
                        modifier = Modifier.align(Alignment.Center)
                    )
                }
                // 错误状态
                state.error != null -> {
                    ErrorContent(
                        message = state.error,
                        onRetry = { onIntent(UserListIntent.LoadUsers) },
                        onDismiss = { onIntent(UserListIntent.DismissError) }
                    )
                }
                // 空状态
                state.users.isEmpty() -> {
                    EmptyContent(
                        onRefresh = { onIntent(UserListIntent.RefreshUsers) }
                    )
                }
                // 正常显示列表
                else -> {
                    UserList(
                        users = state.users,
                        onUserClick = { user ->
                            onIntent(UserListIntent.SelectUser(user))
                        },
                        onUserDelete = { userId ->
                            onIntent(UserListIntent.DeleteUser(userId))
                        }
                    )
                }
            }
        }
    }
}

/**
 * 用户列表组件
 */
@Composable
fun UserList(
    users: List<User>,
    onUserClick: (User) -> Unit,
    onUserDelete: (String) -> Unit
) {
    LazyColumn(
        modifier = Modifier.fillMaxSize(),
        contentPadding = PaddingValues(16.dp),
        verticalArrangement = Arrangement.spacedBy(8.dp)
    ) {
        items(
            items = users,
            key = { it.id }  // 使用唯一 key 优化重组
        ) { user ->
            UserItem(
                user = user,
                onClick = { onUserClick(user) },
                onDelete = { onUserDelete(user.id) }
            )
        }
    }
}

/**
 * 用户列表项
 */
@Composable
fun UserItem(
    user: User,
    onClick: () -> Unit,
    onDelete: () -> Unit
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .clickable(onClick = onClick),
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            // 头像
            AsyncImage(
                model = user.avatar,
                contentDescription = null,
                modifier = Modifier
                    .size(48.dp)
                    .clip(CircleShape)
            )
            
            Spacer(modifier = Modifier.width(16.dp))
            
            // 用户信息
            Column(modifier = Modifier.weight(1f)) {
                Text(
                    text = user.name,
                    style = MaterialTheme.typography.titleMedium
                )
                Text(
                    text = user.email,
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
            
            // 删除按钮
            IconButton(onClick = onDelete) {
                Icon(
                    Icons.Default.Delete,
                    contentDescription = "删除",
                    tint = MaterialTheme.colorScheme.error
                )
            }
        }
    }
}
```


## 4. 实战应用

### 4.1 架构选型指南

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        架构选型决策树                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  项目规模?                                                              │
│      │                                                                  │
│      ├── 小型项目 (< 10 个页面)                                        │
│      │       │                                                          │
│      │       └── 使用 Compose?                                         │
│      │               ├── 是 → 简单 MVVM + StateFlow                    │
│      │               └── 否 → MVVM + LiveData                          │
│      │                                                                  │
│      ├── 中型项目 (10-50 个页面)                                       │
│      │       │                                                          │
│      │       └── 状态复杂度?                                           │
│      │               ├── 简单 → MVVM + Repository                      │
│      │               └── 复杂 → MVI + Repository                       │
│      │                                                                  │
│      └── 大型项目 (> 50 个页面)                                        │
│              │                                                          │
│              └── Clean Architecture + MVVM/MVI                          │
│                  + 模块化                                               │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 4.2 字节/美团等大厂架构实践

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      大厂架构实践参考                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  字节跳动:                                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  - 自研 MVVM 框架                                               │   │
│  │  - 组件化 + 路由 (类似 ARouter)                                 │   │
│  │  - 统一状态管理                                                 │   │
│  │  - 动态化能力 (Lynx)                                            │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  美团:                                                                  │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  - MVVM + Clean Architecture                                    │   │
│  │  - 模块化架构 (业务模块独立)                                    │   │
│  │  - 统一网络层、图片加载                                         │   │
│  │  - 自研组件化框架 WMRouter                                      │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  快手:                                                                  │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  - MVI 单向数据流                                               │   │
│  │  - Kotlin 协程 + Flow                                           │   │
│  │  - 组件化 + 插件化                                              │   │
│  │  - 性能优化 (启动、内存、卡顿)                                  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  OPPO/vivo:                                                             │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  - MVVM + Jetpack                                               │   │
│  │  - 系统级优化                                                   │   │
│  │  - 多进程架构                                                   │   │
│  │  - 跨端方案 (Flutter/RN)                                        │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 4.3 最佳实践

```kotlin
/**
 * 最佳实践 1: 分层清晰，职责单一
 */

// ❌ 错误示例：ViewModel 直接调用 API
class BadViewModel : ViewModel() {
    fun loadUser() {
        viewModelScope.launch {
            // 直接调用 Retrofit，违反分层原则
            val user = RetrofitClient.api.getUser("123")
            _user.value = user
        }
    }
}

// ✅ 正确示例：通过 Repository/UseCase
class GoodViewModel(
    private val getUserUseCase: GetUserUseCase
) : ViewModel() {
    fun loadUser() {
        viewModelScope.launch {
            getUserUseCase("123")
                .onSuccess { _user.value = it }
                .onFailure { _error.value = it.message }
        }
    }
}

/**
 * 最佳实践 2: 状态不可变
 */

// ❌ 错误示例：可变状态
class BadState {
    var users = mutableListOf<User>()  // 可变列表
    var isLoading = false              // 可变属性
}

// ✅ 正确示例：不可变状态
data class GoodState(
    val users: List<User> = emptyList(),  // 不可变列表
    val isLoading: Boolean = false         // val 属性
)

/**
 * 最佳实践 3: 单一数据源
 */

// ❌ 错误示例：多个 LiveData 管理状态
class BadViewModel : ViewModel() {
    val user = MutableLiveData<User>()
    val loading = MutableLiveData<Boolean>()
    val error = MutableLiveData<String>()
    // 状态分散，难以管理
}

// ✅ 正确示例：单一状态对象
class GoodViewModel : ViewModel() {
    private val _state = MutableStateFlow(UiState())
    val state: StateFlow<UiState> = _state.asStateFlow()
    
    data class UiState(
        val user: User? = null,
        val isLoading: Boolean = false,
        val error: String? = null
    )
}

/**
 * 最佳实践 4: 生命周期感知
 */

// ❌ 错误示例：不处理生命周期
class BadActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        lifecycleScope.launch {
            viewModel.state.collect { state ->
                // 可能在后台收集，浪费资源
                updateUI(state)
            }
        }
    }
}

// ✅ 正确示例：使用 repeatOnLifecycle
class GoodActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.state.collect { state ->
                    // 只在 STARTED 状态收集
                    updateUI(state)
                }
            }
        }
    }
}

/**
 * 最佳实践 5: 依赖注入
 */

// ❌ 错误示例：硬编码依赖
class BadViewModel : ViewModel() {
    // 直接创建依赖，难以测试
    private val repository = UserRepositoryImpl(
        UserRemoteDataSourceImpl(RetrofitClient.api),
        UserLocalDataSourceImpl(AppDatabase.getInstance().userDao())
    )
}

// ✅ 正确示例：构造函数注入
@HiltViewModel
class GoodViewModel @Inject constructor(
    private val getUserUseCase: GetUserUseCase  // 依赖注入
) : ViewModel()

/**
 * 最佳实践 6: 错误处理
 */

// ❌ 错误示例：忽略异常
class BadViewModel : ViewModel() {
    fun loadUser() {
        viewModelScope.launch {
            try {
                val user = repository.getUser("123")
                _user.value = user
            } catch (e: Exception) {
                // 忽略异常，用户无感知
            }
        }
    }
}

// ✅ 正确示例：统一错误处理
class GoodViewModel : ViewModel() {
    fun loadUser() {
        viewModelScope.launch {
            _state.update { it.copy(isLoading = true, error = null) }
            
            repository.getUser("123")
                .onSuccess { user ->
                    _state.update { it.copy(user = user, isLoading = false) }
                }
                .onFailure { e ->
                    _state.update { it.copy(error = e.toUserMessage(), isLoading = false) }
                    // 上报错误
                    ErrorReporter.report(e)
                }
        }
    }
    
    // 将异常转换为用户友好的消息
    private fun Throwable.toUserMessage(): String = when (this) {
        is IOException -> "网络连接失败，请检查网络"
        is HttpException -> "服务器错误 (${code()})"
        else -> "未知错误，请稍后重试"
    }
}
```


## 5. 常见面试题

### 5.1 基础概念题

**Q1: MVC、MVP、MVVM 三种架构模式的区别是什么？各自的优缺点？**

**答案要点：**

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        三种架构模式对比                                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  MVC:                                                                   │
│  - Controller 处理用户输入，更新 Model                                  │
│  - Model 变化通知 View 更新                                             │
│  - Android 中 Activity 既是 Controller 又是 View                        │
│  - 优点：简单直观                                                       │
│  - 缺点：Activity 臃肿，难以测试                                        │
│                                                                         │
│  MVP:                                                                   │
│  - View 和 Presenter 通过接口通信                                       │
│  - Presenter 持有 View 接口引用                                         │
│  - 优点：View 和业务逻辑分离，便于单元测试                              │
│  - 缺点：接口膨胀，需手动管理生命周期                                   │
│                                                                         │
│  MVVM:                                                                  │
│  - View 观察 ViewModel 的数据变化                                       │
│  - ViewModel 不持有 View 引用                                           │
│  - 使用 LiveData/StateFlow 实现数据绑定                                 │
│  - 优点：解耦彻底，生命周期感知，便于测试                               │
│  - 缺点：学习成本高，复杂场景状态管理困难                               │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

**Q2: 为什么 Google 推荐使用 MVVM 而不是 MVP？**

**答案要点：**

1. **生命周期感知**：ViewModel 配合 Lifecycle 组件，自动处理配置变更
2. **数据驱动**：LiveData/StateFlow 观察者模式，避免手动更新 UI
3. **解耦更彻底**：ViewModel 不持有 View 引用，避免内存泄漏
4. **官方支持**：Jetpack 组件（ViewModel、LiveData、DataBinding）原生支持
5. **测试友好**：ViewModel 是纯 Kotlin 类，易于单元测试

**Q3: MVI 模式的核心思想是什么？与 MVVM 有什么区别？**

**答案要点：**

```kotlin
// MVI 核心思想：单向数据流
// Intent → Model (State) → View

// 1. 单一数据源 (Single Source of Truth)
data class UiState(
    val users: List<User> = emptyList(),
    val isLoading: Boolean = false,
    val error: String? = null
)

// 2. 不可变状态
// 每次更新创建新的 State 对象
_state.update { it.copy(isLoading = true) }

// 3. 用户意图 (Intent) 驱动
sealed class UserIntent {
    object LoadUsers : UserIntent()
    data class DeleteUser(val id: String) : UserIntent()
}

// 与 MVVM 的区别：
// - MVVM: 多个 LiveData，状态分散
// - MVI: 单一 State，状态集中
// - MVVM: 双向绑定可能导致状态不一致
// - MVI: 单向数据流，状态可预测
```


### 5.2 原理深入题

**Q4: ViewModel 是如何在配置变更时保留数据的？（字节/美团高频）**

**答案要点：**

```kotlin
// ViewModel 存储原理

// 1. ViewModelStore - 存储 ViewModel 的容器
class ViewModelStore {
    private val map = HashMap<String, ViewModel>()
    
    fun put(key: String, viewModel: ViewModel) {
        map[key] = viewModel
    }
    
    fun get(key: String): ViewModel? = map[key]
    
    fun clear() {
        for (vm in map.values) {
            vm.clear()  // 调用 onCleared()
        }
        map.clear()
    }
}

// 2. Activity 持有 ViewModelStore
class ComponentActivity : Activity(), ViewModelStoreOwner {
    private var viewModelStore: ViewModelStore? = null
    
    override fun getViewModelStore(): ViewModelStore {
        // 配置变更时，从 NonConfigurationInstances 恢复
        if (viewModelStore == null) {
            val nc = lastNonConfigurationInstance as? NonConfigurationInstances
            viewModelStore = nc?.viewModelStore ?: ViewModelStore()
        }
        return viewModelStore!!
    }
    
    // 配置变更时保存
    override fun onRetainNonConfigurationInstance(): Any? {
        return NonConfigurationInstances(viewModelStore)
    }
}

// 3. 关键点：
// - 配置变更时 Activity 销毁重建，但 ViewModelStore 通过
//   onRetainNonConfigurationInstance() 保留
// - 只有 Activity 真正 finish() 时才清除 ViewModel
// - Fragment 的 ViewModel 存储在 Activity 的 ViewModelStore 中
```

**Q5: LiveData 和 StateFlow 的区别？什么场景用哪个？（快手/美团高频）**

**答案要点：**

```kotlin
// LiveData vs StateFlow 对比

// 1. 生命周期感知
// LiveData: 自动感知，只在 STARTED 以上状态接收
// StateFlow: 需要配合 repeatOnLifecycle

// LiveData 使用
viewModel.user.observe(this) { user ->
    // 自动在 STARTED 状态接收
}

// StateFlow 使用
lifecycleScope.launch {
    repeatOnLifecycle(Lifecycle.State.STARTED) {
        viewModel.user.collect { user ->
            // 需要手动处理生命周期
        }
    }
}

// 2. 初始值
// LiveData: 可以没有初始值
// StateFlow: 必须有初始值

val liveData = MutableLiveData<User>()  // 无初始值
val stateFlow = MutableStateFlow<User?>(null)  // 必须有初始值

// 3. 数据发射
// LiveData: setValue (主线程), postValue (任意线程)
// StateFlow: value 或 emit (协程中)

// 4. 背压处理
// LiveData: 无背压概念，总是最新值
// StateFlow: conflated，只保留最新值

// 5. 推荐场景
// LiveData: 简单 UI 状态，Java 项目
// StateFlow: 复杂状态管理，纯 Kotlin 项目，需要 Flow 操作符
```

**Q6: Clean Architecture 中为什么 Domain 层不能依赖 Data 层？（字节/OPPO 高频）**

**答案要点：**

```
依赖倒置原则 (Dependency Inversion Principle)

1. 传统依赖方向：
   Presentation → Domain → Data
   
   问题：Domain 层依赖 Data 层的具体实现
   - 更换数据源需要修改 Domain 层
   - Domain 层难以单独测试

2. 依赖倒置后：
   Presentation → Domain ← Data
                    ↑
              Repository 接口
   
   - Domain 层定义 Repository 接口
   - Data 层实现 Repository 接口
   - Domain 层不知道具体实现

3. 好处：
   - Domain 层纯净，只包含业务逻辑
   - 可以独立测试 Domain 层 (Mock Repository)
   - 更换数据源不影响 Domain 层
   - 符合开闭原则 (对扩展开放，对修改关闭)

4. 代码示例：
   // Domain 层定义接口
   interface UserRepository {
       suspend fun getUser(id: String): User
   }
   
   // Data 层实现接口
   class UserRepositoryImpl(
       private val api: UserApi,
       private val dao: UserDao
   ) : UserRepository {
       override suspend fun getUser(id: String): User {
           // 具体实现
       }
   }
```


### 5.3 实战场景题

**Q7: 如何处理 ViewModel 中的一次性事件（如 Toast、导航）？（美团/快手高频）**

**答案要点：**

```kotlin
// 问题：LiveData/StateFlow 是状态，会在配置变更后重新发射
// 导致 Toast 重复显示、重复导航

// ❌ 错误方式：使用普通 LiveData
class BadViewModel : ViewModel() {
    val toastMessage = MutableLiveData<String>()
    
    fun doSomething() {
        toastMessage.value = "操作成功"
        // 配置变更后会重新触发 Toast
    }
}

// ✅ 方案 1：SingleLiveEvent (Google 示例)
class SingleLiveEvent<T> : MutableLiveData<T>() {
    private val pending = AtomicBoolean(false)
    
    override fun observe(owner: LifecycleOwner, observer: Observer<in T>) {
        super.observe(owner) { t ->
            if (pending.compareAndSet(true, false)) {
                observer.onChanged(t)
            }
        }
    }
    
    override fun setValue(value: T?) {
        pending.set(true)
        super.setValue(value)
    }
}

// ✅ 方案 2：Channel + Flow (推荐)
class GoodViewModel : ViewModel() {
    private val _effect = Channel<UiEffect>(Channel.BUFFERED)
    val effect: Flow<UiEffect> = _effect.receiveAsFlow()
    
    fun doSomething() {
        viewModelScope.launch {
            _effect.send(UiEffect.ShowToast("操作成功"))
        }
    }
}

// Activity 中收集
lifecycleScope.launch {
    repeatOnLifecycle(Lifecycle.State.STARTED) {
        viewModel.effect.collect { effect ->
            when (effect) {
                is UiEffect.ShowToast -> showToast(effect.message)
                is UiEffect.Navigate -> navigate(effect.route)
            }
        }
    }
}

// ✅ 方案 3：SharedFlow (replay = 0)
private val _effect = MutableSharedFlow<UiEffect>()
val effect: SharedFlow<UiEffect> = _effect.asSharedFlow()
```

**Q8: 大型项目如何进行模块化架构设计？（字节/美团高频）**

**答案要点：**

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        模块化架构设计                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  模块分层:                                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │                    App Module                            │   │   │
│  │  │              (Application, 启动入口)                     │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │                           │                                     │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │              Feature Modules (业务模块)                  │   │   │
│  │  │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐        │   │   │
│  │  │  │  首页   │ │  商城   │ │  消息   │ │  我的   │        │   │   │
│  │  │  └─────────┘ └─────────┘ └─────────┘ └─────────┘        │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │                           │                                     │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │              Common Modules (公共模块)                   │   │   │
│  │  │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐        │   │   │
│  │  │  │ Network │ │ Router  │ │  Utils  │ │   UI    │        │   │   │
│  │  │  └─────────┘ └─────────┘ └─────────┘ └─────────┘        │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │                           │                                     │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │                    Base Module                           │   │   │
│  │  │           (基础组件, 第三方库封装)                       │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  关键技术点:                                                            │
│  1. 路由框架 (ARouter/WMRouter) - 模块间页面跳转                        │
│  2. 接口下沉 - 公共接口定义在 Common 模块                               │
│  3. 依赖注入 (Hilt) - 跨模块依赖管理                                    │
│  4. 组件通信 - EventBus/接口回调                                        │
│  5. 独立编译 - 业务模块可独立运行调试                                   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

**Q9: 如何设计一个可测试的架构？（OPPO/vivo 高频）**

**答案要点：**

```kotlin
// 可测试架构的关键：依赖注入 + 接口抽象

// 1. 使用接口抽象外部依赖
interface UserRepository {
    suspend fun getUser(id: String): User
}

// 2. 构造函数注入依赖
class GetUserUseCase(
    private val repository: UserRepository  // 接口，非实现
) {
    suspend operator fun invoke(id: String): Result<User> {
        return try {
            Result.success(repository.getUser(id))
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}

// 3. ViewModel 注入 UseCase
class UserViewModel(
    private val getUserUseCase: GetUserUseCase
) : ViewModel() {
    // ...
}

// 4. 单元测试 - Mock 依赖
class UserViewModelTest {
    
    @Test
    fun `loadUser success should update state`() = runTest {
        // Arrange - 创建 Mock
        val mockRepository = mockk<UserRepository>()
        val fakeUser = User("1", "Test", "test@test.com")
        coEvery { mockRepository.getUser("1") } returns fakeUser
        
        val useCase = GetUserUseCase(mockRepository)
        val viewModel = UserViewModel(useCase)
        
        // Act
        viewModel.loadUser("1")
        
        // Assert
        assertEquals(fakeUser, viewModel.state.value.user)
        assertEquals(false, viewModel.state.value.isLoading)
    }
    
    @Test
    fun `loadUser failure should show error`() = runTest {
        // Arrange
        val mockRepository = mockk<UserRepository>()
        coEvery { mockRepository.getUser("1") } throws IOException("Network error")
        
        val useCase = GetUserUseCase(mockRepository)
        val viewModel = UserViewModel(useCase)
        
        // Act
        viewModel.loadUser("1")
        
        // Assert
        assertNotNull(viewModel.state.value.error)
    }
}

// 5. 使用 Hilt 进行依赖注入
@HiltViewModel
class UserViewModel @Inject constructor(
    private val getUserUseCase: GetUserUseCase
) : ViewModel()

@Module
@InstallIn(SingletonComponent::class)
abstract class RepositoryModule {
    @Binds
    abstract fun bindUserRepository(impl: UserRepositoryImpl): UserRepository
}
```


### 5.4 进阶问题

**Q10: Jetpack Compose 为什么更适合 MVI 架构？（字节/快手高频）**

**答案要点：**

```kotlin
// Compose + MVI 天然契合的原因

// 1. 声明式 UI - 状态驱动
// Compose: UI = f(State)
// MVI: View = render(State)

@Composable
fun UserScreen(state: UserState) {
    // 根据状态渲染 UI，状态变化自动重组
    when {
        state.isLoading -> LoadingView()
        state.error != null -> ErrorView(state.error)
        else -> UserContent(state.user)
    }
}

// 2. 不可变状态
// Compose 依赖状态比较来决定是否重组
// MVI 的不可变 State 正好满足这一需求

data class UserState(
    val user: User? = null,
    val isLoading: Boolean = false
)

// 状态更新创建新对象，触发重组
_state.update { it.copy(isLoading = true) }

// 3. 单向数据流
// Compose: State 向下流动，Event 向上流动
// MVI: Intent → State → View

@Composable
fun UserScreen(
    state: UserState,           // 状态向下
    onIntent: (UserIntent) -> Unit  // 事件向上
) {
    Button(onClick = { onIntent(UserIntent.LoadUser) }) {
        Text("加载")
    }
}

// 4. 状态提升 (State Hoisting)
// Compose 推荐将状态提升到上层
// 与 MVI 的 ViewModel 持有状态一致

// 5. 副作用处理
// Compose 的 LaunchedEffect 处理一次性事件
LaunchedEffect(Unit) {
    viewModel.effect.collect { effect ->
        when (effect) {
            is ShowToast -> snackbarHostState.showSnackbar(effect.message)
        }
    }
}
```

**Q11: 如何处理复杂页面的状态管理？（美团/字节高频）**

**答案要点：**

```kotlin
// 复杂页面状态管理策略

// 1. 状态分层 - 将大状态拆分为子状态
data class OrderDetailState(
    val orderInfo: OrderInfoState = OrderInfoState(),
    val productList: ProductListState = ProductListState(),
    val logistics: LogisticsState = LogisticsState(),
    val payment: PaymentState = PaymentState()
)

data class OrderInfoState(
    val order: Order? = null,
    val isLoading: Boolean = false
)

data class ProductListState(
    val products: List<Product> = emptyList(),
    val isLoading: Boolean = false
)

// 2. 使用 sealed class 管理加载状态
sealed class LoadState<out T> {
    object Loading : LoadState<Nothing>()
    data class Success<T>(val data: T) : LoadState<T>()
    data class Error(val message: String) : LoadState<Nothing>()
}

data class OrderDetailState(
    val orderInfo: LoadState<Order> = LoadState.Loading,
    val products: LoadState<List<Product>> = LoadState.Loading
)

// 3. 组合多个 Flow
class OrderDetailViewModel(
    private val getOrderUseCase: GetOrderUseCase,
    private val getProductsUseCase: GetProductsUseCase
) : ViewModel() {
    
    fun loadOrderDetail(orderId: String) {
        viewModelScope.launch {
            // 并行加载
            val orderDeferred = async { getOrderUseCase(orderId) }
            val productsDeferred = async { getProductsUseCase(orderId) }
            
            // 等待结果
            val orderResult = orderDeferred.await()
            val productsResult = productsDeferred.await()
            
            // 更新状态
            _state.update { state ->
                state.copy(
                    orderInfo = orderResult.toLoadState(),
                    products = productsResult.toLoadState()
                )
            }
        }
    }
}

// 4. 使用 combine 合并多个 Flow
val combinedState: StateFlow<OrderDetailState> = combine(
    orderFlow,
    productsFlow,
    logisticsFlow
) { order, products, logistics ->
    OrderDetailState(
        orderInfo = order,
        products = products,
        logistics = logistics
    )
}.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), OrderDetailState())
```

**Q12: 如何在架构中处理跨模块通信？（字节/美团高频）**

**答案要点：**

```kotlin
// 跨模块通信方案

// 方案 1: 路由框架 (ARouter)
// 页面跳转
@Route(path = "/user/detail")
class UserDetailActivity : AppCompatActivity()

// 跳转
ARouter.getInstance()
    .build("/user/detail")
    .withString("userId", "123")
    .navigation()

// 方案 2: 接口下沉 + 依赖注入
// 在 common 模块定义接口
interface IUserService {
    fun getUserInfo(): User?
    fun isLoggedIn(): Boolean
}

// 在 user 模块实现
@Singleton
class UserServiceImpl @Inject constructor() : IUserService {
    override fun getUserInfo(): User? = UserManager.currentUser
    override fun isLoggedIn(): Boolean = UserManager.isLoggedIn
}

// 在其他模块使用
class OrderViewModel @Inject constructor(
    private val userService: IUserService
) : ViewModel() {
    fun checkLogin() {
        if (!userService.isLoggedIn()) {
            // 跳转登录
        }
    }
}

// 方案 3: EventBus (不推荐，难以追踪)
// 发送事件
EventBus.getDefault().post(LoginSuccessEvent(user))

// 接收事件
@Subscribe(threadMode = ThreadMode.MAIN)
fun onLoginSuccess(event: LoginSuccessEvent) {
    // 处理登录成功
}

// 方案 4: SharedFlow 事件总线 (推荐)
object AppEventBus {
    private val _events = MutableSharedFlow<AppEvent>()
    val events: SharedFlow<AppEvent> = _events.asSharedFlow()
    
    suspend fun emit(event: AppEvent) {
        _events.emit(event)
    }
}

sealed class AppEvent {
    data class LoginSuccess(val user: User) : AppEvent()
    object Logout : AppEvent()
}

// 发送
viewModelScope.launch {
    AppEventBus.emit(AppEvent.LoginSuccess(user))
}

// 接收
lifecycleScope.launch {
    AppEventBus.events.collect { event ->
        when (event) {
            is AppEvent.LoginSuccess -> refreshUserInfo()
            is AppEvent.Logout -> clearUserData()
        }
    }
}
```


### 5.5 综合场景题

**Q13: 设计一个电商 App 的架构，需要考虑哪些方面？（字节/美团终面高频）**

**答案要点：**

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     电商 App 架构设计                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  1. 整体架构选型:                                                       │
│     - 表现层: MVVM/MVI + Jetpack Compose                               │
│     - 业务层: Clean Architecture (UseCase)                             │
│     - 数据层: Repository + 多数据源                                    │
│                                                                         │
│  2. 模块划分:                                                           │
│     ┌─────────────────────────────────────────────────────────────┐    │
│     │  App Module                                                  │    │
│     │  ├── feature-home (首页)                                     │    │
│     │  ├── feature-category (分类)                                 │    │
│     │  ├── feature-cart (购物车)                                   │    │
│     │  ├── feature-order (订单)                                    │    │
│     │  ├── feature-user (用户中心)                                 │    │
│     │  ├── feature-search (搜索)                                   │    │
│     │  ├── feature-product (商品详情)                              │    │
│     │  │                                                           │    │
│     │  ├── common-network (网络层)                                 │    │
│     │  ├── common-database (数据库)                                │    │
│     │  ├── common-ui (公共 UI 组件)                                │    │
│     │  ├── common-utils (工具类)                                   │    │
│     │  └── common-router (路由)                                    │    │
│     └─────────────────────────────────────────────────────────────┘    │
│                                                                         │
│  3. 关键技术点:                                                         │
│     - 网络层: Retrofit + OkHttp + 拦截器 (Token、日志、重试)           │
│     - 缓存策略: Room + 内存缓存 + 网络缓存                             │
│     - 图片加载: Coil/Glide + 多级缓存                                  │
│     - 路由: ARouter/Navigation                                         │
│     - 依赖注入: Hilt                                                   │
│     - 异步处理: Kotlin 协程 + Flow                                     │
│                                                                         │
│  4. 性能优化:                                                           │
│     - 启动优化: 延迟初始化、异步初始化                                 │
│     - 列表优化: RecyclerView/LazyColumn 复用                           │
│     - 内存优化: 图片压缩、内存泄漏检测                                 │
│     - 网络优化: 请求合并、预加载                                       │
│                                                                         │
│  5. 稳定性保障:                                                         │
│     - 崩溃监控: Firebase Crashlytics                                   │
│     - 性能监控: APM                                                    │
│     - 日志系统: 分级日志 + 上报                                        │
│     - 灰度发布: 功能开关                                               │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

**Q14: 如何从 MVP 迁移到 MVVM？需要注意什么？（OPPO/vivo 高频）**

**答案要点：**

```kotlin
// MVP → MVVM 迁移步骤

// 1. 原 MVP 代码
interface UserContract {
    interface View {
        fun showUser(user: User)
        fun showLoading()
        fun hideLoading()
    }
    interface Presenter {
        fun loadUser(id: String)
    }
}

class UserPresenter(private val view: UserContract.View) : UserContract.Presenter {
    override fun loadUser(id: String) {
        view.showLoading()
        // 加载数据...
        view.showUser(user)
        view.hideLoading()
    }
}

// 2. 迁移后 MVVM 代码
class UserViewModel : ViewModel() {
    private val _state = MutableStateFlow(UserUiState())
    val state: StateFlow<UserUiState> = _state.asStateFlow()
    
    fun loadUser(id: String) {
        viewModelScope.launch {
            _state.update { it.copy(isLoading = true) }
            // 加载数据...
            _state.update { it.copy(user = user, isLoading = false) }
        }
    }
}

data class UserUiState(
    val user: User? = null,
    val isLoading: Boolean = false,
    val error: String? = null
)

// 3. 迁移注意事项:
// ✓ 删除 View 接口，改用 LiveData/StateFlow 观察
// ✓ Presenter 中的 view.showXxx() 改为更新状态
// ✓ Activity 中 observe 状态变化
// ✓ 处理生命周期 (repeatOnLifecycle)
// ✓ 一次性事件使用 Channel/SharedFlow
// ✓ 逐步迁移，可以 MVP 和 MVVM 共存

// 4. 迁移策略:
// - 新功能使用 MVVM
// - 旧功能逐步迁移
// - 先迁移简单页面，积累经验
// - 建立 MVVM 基类和模板
```

**Q15: 你在项目中遇到过哪些架构问题？如何解决的？（开放题）**

**答案要点：**

```
常见架构问题及解决方案:

1. ViewModel 臃肿问题
   问题: 一个 ViewModel 处理太多业务逻辑
   解决: 
   - 拆分为多个 ViewModel
   - 使用 UseCase 封装业务逻辑
   - 复杂页面使用组合 ViewModel

2. 状态管理混乱
   问题: 多个 LiveData，状态分散，难以追踪
   解决:
   - 使用单一 State 对象
   - 采用 MVI 单向数据流
   - 状态变更集中在 reduce 函数

3. 内存泄漏
   问题: Presenter 持有 View 引用导致泄漏
   解决:
   - 迁移到 MVVM，ViewModel 不持有 View
   - 使用 WeakReference
   - 在 onDestroy 中解绑

4. 模块间耦合
   问题: 业务模块直接依赖，难以独立开发
   解决:
   - 接口下沉到 common 模块
   - 使用路由框架解耦页面跳转
   - 依赖注入管理跨模块依赖

5. 测试困难
   问题: 代码耦合严重，无法单元测试
   解决:
   - 依赖注入，面向接口编程
   - 分层架构，各层独立测试
   - Mock 外部依赖

6. 配置变更数据丢失
   问题: 屏幕旋转后数据丢失
   解决:
   - 使用 ViewModel 保存数据
   - SavedStateHandle 持久化关键数据
```

---

## 6. 总结

### 6.1 架构选型建议

| 项目类型 | 推荐架构 | 理由 |
|---------|---------|------|
| 小型项目 | MVVM | 简单够用，官方支持 |
| 中型项目 | MVVM + Repository | 分层清晰，便于维护 |
| 大型项目 | Clean Architecture + MVI | 高度解耦，便于测试和扩展 |
| Compose 项目 | MVI | 单向数据流与声明式 UI 契合 |

### 6.2 面试准备建议

1. **理解原理**：不仅要会用，更要理解为什么这样设计
2. **对比分析**：能够清晰对比各架构的优缺点
3. **实战经验**：准备 1-2 个架构相关的项目经验
4. **源码阅读**：了解 ViewModel、LiveData 等组件的实现原理
5. **最佳实践**：掌握状态管理、依赖注入、测试等最佳实践

### 6.3 参考资源

- [Android 官方架构指南](https://developer.android.com/topic/architecture)
- [Google Architecture Samples](https://github.com/android/architecture-samples)
- [Now in Android](https://github.com/android/nowinandroid)
- [Clean Architecture by Uncle Bob](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
