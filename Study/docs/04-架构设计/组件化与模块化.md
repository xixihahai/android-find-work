# 组件化与模块化

## 1. 概述

组件化与模块化是大型 Android 应用架构设计的核心策略。**模块化**是将应用拆分为独立的功能模块，降低耦合度；**组件化**则更进一步，使每个模块可以独立编译、运行和调试。本文将深入讲解组件化架构设计、模块间通信方案、ARouter 原理、依赖注入框架（Hilt/Dagger/Koin）等核心知识点。

### 1.1 模块化 vs 组件化

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      模块化 vs 组件化对比                                │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  模块化 (Modularization):                                               │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  - 将应用按功能/业务拆分为多个 Module                           │   │
│  │  - 模块之间存在依赖关系                                         │   │
│  │  - 模块不能独立运行                                             │   │
│  │  - 主要目的：代码复用、职责分离、编译加速                       │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  组件化 (Componentization):                                             │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  - 在模块化基础上，每个模块可独立编译运行                       │   │
│  │  - 模块之间完全解耦，通过路由通信                               │   │
│  │  - 支持单独调试、独立发布                                       │   │
│  │  - 主要目的：团队并行开发、快速迭代、灵活组合                   │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  关系：组件化 = 模块化 + 独立运行能力 + 路由通信                        │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 1.2 为什么需要组件化


```
┌─────────────────────────────────────────────────────────────────────────┐
│                      组件化解决的问题                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  传统单体架构问题:                                                      │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  1. 编译慢：代码量大，全量编译耗时长                            │   │
│  │  2. 耦合高：模块间相互依赖，牵一发动全身                        │   │
│  │  3. 协作难：多人开发容易冲突，合并代码困难                      │   │
│  │  4. 测试难：无法单独测试某个功能模块                            │   │
│  │  5. 复用难：功能模块难以在其他项目中复用                        │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  组件化带来的优势:                                                      │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  1. 编译加速：只编译修改的模块，增量编译                        │   │
│  │  2. 解耦彻底：模块间通过接口/路由通信，无直接依赖               │   │
│  │  3. 并行开发：团队可独立开发各自模块                            │   │
│  │  4. 独立调试：单个组件可作为 App 独立运行调试                   │   │
│  │  5. 灵活组合：按需组合模块，支持多 App 共享组件                 │   │
│  │  6. 动态化：支持组件动态加载、热更新                            │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

## 2. 核心原理

### 2.1 组件化架构设计

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      组件化分层架构                                      │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                         App 壳工程层                             │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │  app (主工程)                                            │   │   │
│  │  │  - 负责组装各业务组件                                    │   │   │
│  │  │  - 初始化配置、路由注册                                  │   │   │
│  │  │  - 打包发布                                              │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                              │                                          │
│                              ↓                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                         业务组件层                               │   │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐        │   │
│  │  │  首页    │  │  商城    │  │  消息    │  │  我的    │        │   │
│  │  │ module   │  │ module   │  │ module   │  │ module   │        │   │
│  │  └──────────┘  └──────────┘  └──────────┘  └──────────┘        │   │
│  │  - 可独立编译运行                                               │   │
│  │  - 包含完整的业务功能                                           │   │
│  │  - 通过路由与其他组件通信                                       │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                              │                                          │
│                              ↓                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                         功能组件层                               │   │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐        │   │
│  │  │  登录    │  │  支付    │  │  分享    │  │  推送    │        │   │
│  │  │ module   │  │ module   │  │ module   │  │ module   │        │   │
│  │  └──────────┘  └──────────┘  └──────────┘  └──────────┘        │   │
│  │  - 提供通用功能服务                                             │   │
│  │  - 被业务组件依赖                                               │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                              │                                          │
│                              ↓                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                         基础组件层                               │   │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐        │   │
│  │  │  网络    │  │  图片    │  │  日志    │  │  工具    │        │   │
│  │  │ module   │  │ module   │  │ module   │  │ module   │        │   │
│  │  └──────────┘  └──────────┘  └──────────┘  └──────────┘        │   │
│  │  - 与业务无关的基础能力                                         │   │
│  │  - 可跨项目复用                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                              │                                          │
│                              ↓                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                         公共层 (Common)                          │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │  - 路由服务接口定义                                      │   │   │
│  │  │  - 公共实体类、常量                                      │   │   │
│  │  │  - 基类 (BaseActivity, BaseFragment, BaseViewModel)      │   │   │
│  │  │  - 所有模块都依赖此层                                    │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.2 组件独立运行原理


```
┌─────────────────────────────────────────────────────────────────────────┐
│                      组件独立运行配置                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  核心思路：通过 Gradle 配置动态切换 Library/Application 模式            │
│                                                                         │
│  gradle.properties 配置:                                                │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  # 是否独立运行模式                                             │   │
│  │  isRunAlone=false                                               │   │
│  │                                                                 │   │
│  │  # 各模块独立运行开关                                           │   │
│  │  isHomeRunAlone=false                                           │   │
│  │  isShopRunAlone=false                                           │   │
│  │  isMineRunAlone=false                                           │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  模块 build.gradle 配置:                                                │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  // 动态切换插件                                                │   │
│  │  if (isHomeRunAlone.toBoolean()) {                              │   │
│  │      apply plugin: 'com.android.application'                    │   │
│  │  } else {                                                       │   │
│  │      apply plugin: 'com.android.library'                        │   │
│  │  }                                                              │   │
│  │                                                                 │   │
│  │  android {                                                      │   │
│  │      defaultConfig {                                            │   │
│  │          if (isHomeRunAlone.toBoolean()) {                      │   │
│  │              applicationId "com.example.home"                   │   │
│  │          }                                                      │   │
│  │      }                                                          │   │
│  │                                                                 │   │
│  │      sourceSets {                                               │   │
│  │          main {                                                 │   │
│  │              if (isHomeRunAlone.toBoolean()) {                  │   │
│  │                  // 独立运行时使用单独的 manifest 和启动页       │   │
│  │                  manifest.srcFile 'src/main/alone/AndroidManifest.xml'│
│  │                  java.srcDirs += 'src/main/alone/java'          │   │
│  │              } else {                                           │   │
│  │                  manifest.srcFile 'src/main/AndroidManifest.xml'│   │
│  │              }                                                  │   │
│  │          }                                                      │   │
│  │      }                                                          │   │
│  │  }                                                              │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  目录结构:                                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  module_home/                                                   │   │
│  │  ├── src/main/                                                  │   │
│  │  │   ├── java/                    # 业务代码                    │   │
│  │  │   ├── res/                     # 资源文件                    │   │
│  │  │   ├── AndroidManifest.xml      # 集成模式 Manifest           │   │
│  │  │   └── alone/                   # 独立运行配置                │   │
│  │  │       ├── java/                # 独立运行入口                │   │
│  │  │       │   └── DebugActivity.kt # 调试启动页                  │   │
│  │  │       └── AndroidManifest.xml  # 独立运行 Manifest           │   │
│  │  └── build.gradle                                               │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.3 模块间通信方案

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      模块间通信方案对比                                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  方案一：接口下沉 + 实现注册                                            │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  ┌─────────────┐         ┌─────────────┐                       │   │
│  │  │  Module A   │         │  Module B   │                       │   │
│  │  │             │         │             │                       │   │
│  │  │  调用接口   │────────→│  实现接口   │                       │   │
│  │  └──────┬──────┘         └──────┬──────┘                       │   │
│  │         │                       │                               │   │
│  │         │    依赖               │    依赖                       │   │
│  │         ↓                       ↓                               │   │
│  │  ┌─────────────────────────────────────────┐                   │   │
│  │  │              Common Module              │                   │   │
│  │  │  ┌─────────────────────────────────┐   │                   │   │
│  │  │  │  interface IUserService {       │   │                   │   │
│  │  │  │      fun getUserInfo(): User    │   │                   │   │
│  │  │  │  }                              │   │                   │   │
│  │  │  └─────────────────────────────────┘   │                   │   │
│  │  └─────────────────────────────────────────┘                   │   │
│  │                                                                 │   │
│  │  优点：类型安全、IDE 支持好                                     │   │
│  │  缺点：接口变更需要修改 Common 模块                             │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  方案二：路由框架 (ARouter)                                             │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  ┌─────────────┐   路由跳转   ┌─────────────┐                  │   │
│  │  │  Module A   │─────────────→│  Module B   │                  │   │
│  │  │             │              │             │                  │   │
│  │  │  ARouter    │              │  @Route     │                  │   │
│  │  │  .build()   │              │  注解标记   │                  │   │
│  │  │  .navigation│              │             │                  │   │
│  │  └─────────────┘              └─────────────┘                  │   │
│  │                                                                 │   │
│  │  优点：完全解耦、支持拦截器、降级策略                           │   │
│  │  缺点：运行时反射、类型不安全                                   │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  方案三：EventBus / LiveDataBus                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  ┌─────────────┐   发送事件   ┌─────────────┐                  │   │
│  │  │  Module A   │─────────────→│  Module B   │                  │   │
│  │  │             │              │             │                  │   │
│  │  │  post()     │    Event     │  subscribe  │                  │   │
│  │  │             │     Bus      │  ()         │                  │   │
│  │  └─────────────┘              └─────────────┘                  │   │
│  │                                                                 │   │
│  │  优点：完全解耦、使用简单                                       │   │
│  │  缺点：难以追踪、容易滥用、不适合复杂通信                       │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  方案四：SPI (ServiceLoader)                                            │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  通过 ServiceLoader 加载接口实现                                │   │
│  │  Google AutoService 简化配置                                    │   │
│  │                                                                 │   │
│  │  优点：标准 Java 机制、无需额外框架                             │   │
│  │  缺点：配置繁琐、功能有限                                       │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.4 ARouter 原理详解


```
┌─────────────────────────────────────────────────────────────────────────┐
│                      ARouter 整体架构                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ARouter 工作流程:                                                      │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  编译期:                                                        │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │  @Route 注解  →  APT 处理  →  生成路由表 (Java 文件)    │   │   │
│  │  │                                                         │   │   │
│  │  │  @Route(path = "/user/login")                           │   │   │
│  │  │  class LoginActivity                                    │   │   │
│  │  │           ↓                                             │   │   │
│  │  │  ARouter$$Group$$user.java  (分组路由表)                │   │   │
│  │  │  ARouter$$Root$$app.java    (根路由表)                  │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │                                                                 │   │
│  │  运行期:                                                        │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │  1. 初始化：扫描 dex 加载路由表到内存                   │   │   │
│  │  │  2. 路由：根据 path 查找目标，执行跳转                  │   │   │
│  │  │                                                         │   │   │
│  │  │  ARouter.getInstance()                                  │   │   │
│  │  │      .build("/user/login")    // 构建 Postcard           │   │   │
│  │  │      .withString("key", "v")  // 携带参数               │   │   │
│  │  │      .navigation()            // 执行跳转               │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  核心类说明:                                                            │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  Postcard:     路由信息载体，包含 path、参数、目标类等          │   │
│  │  Warehouse:    路由仓库，存储所有路由表                         │   │
│  │  LogisticsCenter: 物流中心，负责路由查找和填充                  │   │
│  │  InterceptorService: 拦截器服务，处理拦截逻辑                   │   │
│  │  DegradeService: 降级服务，处理路由失败                         │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      ARouter 路由查找流程                                │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  ARouter.build("/user/login")                                   │   │
│  │         │                                                       │   │
│  │         ↓                                                       │   │
│  │  ┌──────────────┐                                               │   │
│  │  │  创建        │  path = "/user/login"                         │   │
│  │  │  Postcard    │  group = "user"                               │   │
│  │  └──────┬───────┘                                               │   │
│  │         │                                                       │   │
│  │         ↓ navigation()                                          │   │
│  │  ┌──────────────┐                                               │   │
│  │  │ Logistics    │  1. 检查 group 是否已加载                     │   │
│  │  │ Center       │  2. 未加载则从 Warehouse.groupsIndex 获取     │   │
│  │  │ .completion()│  3. 加载 group 下所有路由到 Warehouse.routes  │   │
│  │  └──────┬───────┘  4. 从 routes 获取 RouteMeta 填充 Postcard    │   │
│  │         │                                                       │   │
│  │         ↓                                                       │   │
│  │  ┌──────────────┐                                               │   │
│  │  │  拦截器链    │  遍历所有 IInterceptor                        │   │
│  │  │  处理       │  任一拦截则终止                                │   │
│  │  └──────┬───────┘                                               │   │
│  │         │                                                       │   │
│  │         ↓                                                       │   │
│  │  ┌──────────────┐                                               │   │
│  │  │  执行跳转    │  根据 RouteType 执行不同操作                  │   │
│  │  │             │  - ACTIVITY: startActivity                     │   │
│  │  │             │  - PROVIDER: 返回服务实例                      │   │
│  │  │             │  - FRAGMENT: 返回 Fragment 实例                │   │
│  │  └──────────────┘                                               │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.5 依赖注入原理


```
┌─────────────────────────────────────────────────────────────────────────┐
│                      依赖注入 (DI) 概述                                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  什么是依赖注入:                                                        │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  依赖注入是一种设计模式，将对象的依赖关系从内部创建改为外部注入  │   │
│  │                                                                 │   │
│  │  // 不使用 DI - 内部创建依赖                                    │   │
│  │  class UserRepository {                                         │   │
│  │      private val api = RetrofitClient.create()  // 硬编码依赖   │   │
│  │      private val db = AppDatabase.getInstance() // 难以测试     │   │
│  │  }                                                              │   │
│  │                                                                 │   │
│  │  // 使用 DI - 外部注入依赖                                      │   │
│  │  class UserRepository(                                          │   │
│  │      private val api: UserApi,    // 构造函数注入               │   │
│  │      private val db: UserDao      // 易于测试和替换             │   │
│  │  )                                                              │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  DI 框架对比:                                                           │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  框架      │  类型      │  特点                                 │   │
│  │  ─────────────────────────────────────────────────────────────  │   │
│  │  Dagger2   │  编译时    │  性能最优、学习曲线陡峭、配置复杂     │   │
│  │  Hilt      │  编译时    │  基于 Dagger、Android 官方推荐、简化配置│  │
│  │  Koin      │  运行时    │  纯 Kotlin DSL、简单易用、性能稍差    │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.6 Hilt 原理详解

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      Hilt 架构与原理                                     │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  Hilt 组件层级:                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │              SingletonComponent                         │   │   │
│  │  │              (Application 生命周期)                      │   │   │
│  │  │              @Singleton                                 │   │   │
│  │  └─────────────────────┬───────────────────────────────────┘   │   │
│  │                        │                                       │   │
│  │          ┌─────────────┼─────────────┐                         │   │
│  │          ↓             ↓             ↓                         │   │
│  │  ┌───────────┐  ┌───────────┐  ┌───────────┐                   │   │
│  │  │ Activity  │  │ Service   │  │ViewModel  │                   │   │
│  │  │ Retained  │  │ Component │  │ Component │                   │   │
│  │  │ Component │  │           │  │           │                   │   │
│  │  └─────┬─────┘  └───────────┘  └───────────┘                   │   │
│  │        │                                                       │   │
│  │        ↓                                                       │   │
│  │  ┌───────────┐                                                 │   │
│  │  │ Activity  │  (Activity 生命周期)                            │   │
│  │  │ Component │  @ActivityScoped                                │   │
│  │  └─────┬─────┘                                                 │   │
│  │        │                                                       │   │
│  │        ↓                                                       │   │
│  │  ┌───────────┐                                                 │   │
│  │  │ Fragment  │  (Fragment 生命周期)                            │   │
│  │  │ Component │  @FragmentScoped                                │   │
│  │  └─────┬─────┘                                                 │   │
│  │        │                                                       │   │
│  │        ↓                                                       │   │
│  │  ┌───────────┐                                                 │   │
│  │  │   View    │  (View 生命周期)                                │   │
│  │  │ Component │  @ViewScoped                                    │   │
│  │  └───────────┘                                                 │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  Hilt 工作原理:                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  编译期:                                                        │   │
│  │  1. 处理 @HiltAndroidApp、@AndroidEntryPoint 等注解             │   │
│  │  2. 生成 Hilt_XXXActivity 基类 (字节码插桩替换父类)             │   │
│  │  3. 生成 DaggerXXXComponent (Dagger 组件)                       │   │
│  │  4. 生成依赖注入代码                                            │   │
│  │                                                                 │   │
│  │  运行期:                                                        │   │
│  │  1. Application.onCreate() 时创建 SingletonComponent           │   │
│  │  2. Activity.onCreate() 时创建 ActivityComponent               │   │
│  │  3. 通过 Component 获取依赖实例并注入                           │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

## 3. 关键源码解析

### 3.1 ARouter 核心源码

```java
/**
 * ARouter 初始化源码分析
 * 路径: arouter-api/src/main/java/com/alibaba/android/arouter/launcher/ARouter.java
 */
public final class ARouter {
    
    // 单例模式
    private volatile static ARouter instance = null;
    
    public static ARouter getInstance() {
        if (instance == null) {
            synchronized (ARouter.class) {
                if (instance == null) {
                    instance = new ARouter();
                }
            }
        }
        return instance;
    }
    
    /**
     * 初始化 ARouter
     * 主要工作：扫描 dex 文件，加载路由表
     */
    public static void init(Application application) {
        if (!hasInit) {
            // 初始化日志
            logger = _ARouter.logger;
            // 初始化 LogisticsCenter（物流中心）
            // 这里会扫描所有 dex 文件，找到 ARouter 生成的路由类
            LogisticsCenter.init(mContext, executor);
            hasInit = true;
        }
    }
}

/**
 * LogisticsCenter 初始化 - 加载路由表
 * 路径: arouter-api/src/main/java/com/alibaba/android/arouter/core/LogisticsCenter.java
 */
public class LogisticsCenter {
    
    /**
     * 初始化物流中心
     * 扫描 dex 加载所有路由表到 Warehouse
     */
    public synchronized static void init(Context context, ThreadPoolExecutor executor) {
        try {
            // 尝试从缓存加载路由表（提升启动速度）
            loadRouterMap();
            
            if (registerByPlugin) {
                // 使用 arouter-register 插件，编译期注入路由表
                // 避免运行时扫描 dex，大幅提升初始化速度
            } else {
                // 运行时扫描 dex 文件
                Set<String> routerMap;
                
                // 判断是否需要重新扫描（新安装或升级）
                if (PackageUtils.isNewVersion(context)) {
                    // 扫描指定包名下的所有类
                    // 包名: com.alibaba.android.arouter.routes
                    routerMap = ClassUtils.getFileNameByPackageName(
                        mContext, ROUTE_ROOT_PAKCAGE);
                    // 缓存到 SP
                    PackageUtils.updateVersion(context);
                } else {
                    // 从缓存读取
                    routerMap = new HashSet<>(sp.getStringSet(
                        AROUTER_SP_KEY_MAP, new HashSet<String>()));
                }
                
                // 遍历所有路由类，加载到 Warehouse
                for (String className : routerMap) {
                    if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_ROOT)) {
                        // 加载 Root 类（包含所有 Group 的映射）
                        // 例如: ARouter$$Root$$app
                        ((IRouteRoot) Class.forName(className)
                            .getConstructor().newInstance())
                            .loadInto(Warehouse.groupsIndex);
                    } else if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_INTERCEPTORS)) {
                        // 加载拦截器
                        ((IInterceptorGroup) Class.forName(className)
                            .getConstructor().newInstance())
                            .loadInto(Warehouse.interceptorsIndex);
                    } else if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_PROVIDERS)) {
                        // 加载服务提供者
                        ((IProviderGroup) Class.forName(className)
                            .getConstructor().newInstance())
                            .loadInto(Warehouse.providersIndex);
                    }
                }
            }
        } catch (Exception e) {
            throw new HandlerException("ARouter init logistics center exception!");
        }
    }
}
```

### 3.2 ARouter 路由跳转源码


```java
/**
 * ARouter 路由跳转核心流程
 * 路径: arouter-api/src/main/java/com/alibaba/android/arouter/launcher/_ARouter.java
 */
final class _ARouter {
    
    /**
     * 构建 Postcard（路由信息载体）
     * @param path 路由路径，如 "/user/login"
     */
    protected Postcard build(String path) {
        if (TextUtils.isEmpty(path)) {
            throw new HandlerException("Parameter is invalid!");
        }
        // 提取 group，默认取 path 第一段
        // "/user/login" -> group = "user"
        return build(path, extractGroup(path));
    }
    
    protected Postcard build(String path, String group) {
        return new Postcard(path, group);
    }
    
    /**
     * 执行路由跳转
     * @param postcard 路由信息
     * @param requestCode Activity 请求码
     * @param callback 导航回调
     */
    protected Object navigation(final Context context, 
                                final Postcard postcard,
                                final int requestCode, 
                                final NavigationCallback callback) {
        try {
            // 1. 完善 Postcard 信息（查找路由表，填充目标类等信息）
            LogisticsCenter.completion(postcard);
        } catch (NoRouteFoundException ex) {
            // 路由未找到
            if (callback != null) {
                callback.onLost(postcard);
            } else {
                // 调用降级服务
                DegradeService degradeService = ARouter.getInstance()
                    .navigation(DegradeService.class);
                if (degradeService != null) {
                    degradeService.onLost(context, postcard);
                }
            }
            return null;
        }
        
        // 2. 回调 onFound
        if (callback != null) {
            callback.onFound(postcard);
        }
        
        // 3. 绿色通道检查（跳过拦截器）
        if (!postcard.isGreenChannel()) {
            // 执行拦截器链
            interceptorService.doInterceptions(postcard, new InterceptorCallback() {
                @Override
                public void onContinue(Postcard postcard) {
                    // 拦截器放行，继续执行跳转
                    _navigation(context, postcard, requestCode, callback);
                }
                
                @Override
                public void onInterrupt(Throwable exception) {
                    // 被拦截
                    if (callback != null) {
                        callback.onInterrupt(postcard);
                    }
                }
            });
        } else {
            // 绿色通道，直接跳转
            return _navigation(context, postcard, requestCode, callback);
        }
        
        return null;
    }
    
    /**
     * 实际执行跳转
     */
    private Object _navigation(final Context context,
                               final Postcard postcard,
                               final int requestCode,
                               final NavigationCallback callback) {
        final Context currentContext = (context == null) ? mContext : context;
        
        // 根据路由类型执行不同操作
        switch (postcard.getType()) {
            case ACTIVITY:
                // Activity 跳转
                final Intent intent = new Intent(currentContext, postcard.getDestination());
                intent.putExtras(postcard.getExtras());
                
                // 设置 Flags
                int flags = postcard.getFlags();
                if (flags != 0) {
                    intent.setFlags(flags);
                }
                
                // 非 Activity Context 需要添加 NEW_TASK flag
                if (!(currentContext instanceof Activity)) {
                    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                }
                
                // 转场动画
                String[] animations = postcard.getAnimations();
                
                // 主线程执行跳转
                runInMainThread(new Runnable() {
                    @Override
                    public void run() {
                        if (requestCode >= 0) {
                            // startActivityForResult
                            if (currentContext instanceof Activity) {
                                ((Activity) currentContext)
                                    .startActivityForResult(intent, requestCode);
                            }
                        } else {
                            currentContext.startActivity(intent);
                        }
                        
                        // 执行转场动画
                        if (animations != null && currentContext instanceof Activity) {
                            ((Activity) currentContext).overridePendingTransition(
                                Integer.parseInt(animations[0]),
                                Integer.parseInt(animations[1]));
                        }
                        
                        // 回调 onArrival
                        if (callback != null) {
                            callback.onArrival(postcard);
                        }
                    }
                });
                break;
                
            case PROVIDER:
                // 返回服务实例
                return postcard.getProvider();
                
            case FRAGMENT:
                // 返回 Fragment 实例
                Class<?> fragmentClass = postcard.getDestination();
                try {
                    Object instance = fragmentClass.getConstructor().newInstance();
                    if (instance instanceof Fragment) {
                        ((Fragment) instance).setArguments(postcard.getExtras());
                    }
                    return instance;
                } catch (Exception ex) {
                    logger.error("Fetch fragment instance error");
                }
                break;
                
            default:
                break;
        }
        
        return null;
    }
}

/**
 * LogisticsCenter.completion - 填充 Postcard 信息
 */
public class LogisticsCenter {
    
    /**
     * 完善 Postcard 信息
     * 从路由表查找目标类，填充到 Postcard
     */
    public synchronized static void completion(Postcard postcard) {
        // 1. 从 Warehouse.routes 查找路由元信息
        RouteMeta routeMeta = Warehouse.routes.get(postcard.getPath());
        
        if (routeMeta == null) {
            // 2. 路由未加载，尝试加载对应 Group
            Class<? extends IRouteGroup> groupMeta = 
                Warehouse.groupsIndex.get(postcard.getGroup());
            
            if (groupMeta == null) {
                throw new NoRouteFoundException("No route found: " + postcard.getPath());
            }
            
            // 3. 实例化 Group 类，加载该组所有路由
            IRouteGroup iGroupInstance = groupMeta.getConstructor().newInstance();
            iGroupInstance.loadInto(Warehouse.routes);
            
            // 4. 移除已加载的 Group（避免重复加载）
            Warehouse.groupsIndex.remove(postcard.getGroup());
            
            // 5. 递归调用，此时路由已加载
            completion(postcard);
        } else {
            // 6. 填充 Postcard 信息
            postcard.setDestination(routeMeta.getDestination());  // 目标类
            postcard.setType(routeMeta.getType());                // 路由类型
            postcard.setPriority(routeMeta.getPriority());        // 优先级
            postcard.setExtra(routeMeta.getExtra());              // 额外配置
            
            // 7. 处理 Provider 类型
            switch (routeMeta.getType()) {
                case PROVIDER:
                    // 获取或创建 Provider 实例
                    Class<? extends IProvider> providerClass = 
                        (Class<? extends IProvider>) routeMeta.getDestination();
                    IProvider provider = Warehouse.providers.get(providerClass);
                    
                    if (provider == null) {
                        // 创建实例并缓存
                        provider = providerClass.getConstructor().newInstance();
                        provider.init(mContext);
                        Warehouse.providers.put(providerClass, provider);
                    }
                    postcard.setProvider(provider);
                    postcard.greenChannel();  // Provider 默认绿色通道
                    break;
                default:
                    break;
            }
        }
    }
}
```

### 3.3 Hilt 核心源码分析


```kotlin
/**
 * Hilt 注解处理与代码生成原理
 * 
 * 原始代码:
 */
@HiltAndroidApp
class MyApplication : Application()

@AndroidEntryPoint
class MainActivity : AppCompatActivity() {
    
    @Inject
    lateinit var userRepository: UserRepository
}

@Singleton
class UserRepository @Inject constructor(
    private val api: UserApi,
    private val dao: UserDao
)

/**
 * Hilt 编译后生成的代码 (简化版)
 * 
 * 1. 生成 Hilt_MyApplication
 */
public abstract class Hilt_MyApplication extends Application 
    implements GeneratedComponentManagerHolder {
    
    // 组件管理器，持有 SingletonComponent
    private final ApplicationComponentManager componentManager = 
        new ApplicationComponentManager(this);
    
    @Override
    public void onCreate() {
        // 注入 Application
        ((ApplicationComponentManager) componentManager).inject(this);
        super.onCreate();
    }
    
    @Override
    public final GeneratedComponentManager<?> componentManager() {
        return componentManager;
    }
}

/**
 * 2. 生成 Hilt_MainActivity
 * 通过字节码插桩，将 MainActivity 的父类替换为 Hilt_MainActivity
 */
public abstract class Hilt_MainActivity extends AppCompatActivity 
    implements GeneratedComponentManagerHolder {
    
    private volatile ActivityComponentManager componentManager;
    
    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        // 在 super.onCreate 之前执行注入
        inject();
        super.onCreate(savedInstanceState);
    }
    
    protected void inject() {
        // 获取 ActivityComponent 并执行注入
        ((MainActivity_GeneratedInjector) this.generatedComponent())
            .injectMainActivity(UnsafeCasts.unsafeCast(this));
    }
    
    protected Object generatedComponent() {
        return this.componentManager().generatedComponent();
    }
}

/**
 * 3. 生成 DaggerMyApplication_HiltComponents_SingletonC
 * Dagger 组件实现类
 */
public final class DaggerMyApplication_HiltComponents_SingletonC {
    
    private final class SingletonCImpl extends MyApplication_HiltComponents.SingletonC {
        
        // 依赖提供者
        private Provider<UserApi> userApiProvider;
        private Provider<UserDao> userDaoProvider;
        private Provider<UserRepository> userRepositoryProvider;
        
        private void initialize() {
            // 初始化依赖提供者
            this.userApiProvider = DoubleCheck.provider(
                UserApiModule_ProvideUserApiFactory.create());
            this.userDaoProvider = DoubleCheck.provider(
                UserDaoModule_ProvideUserDaoFactory.create());
            // UserRepository 使用 @Singleton，使用 DoubleCheck 保证单例
            this.userRepositoryProvider = DoubleCheck.provider(
                UserRepository_Factory.create(userApiProvider, userDaoProvider));
        }
        
        @Override
        public UserRepository userRepository() {
            return userRepositoryProvider.get();
        }
    }
}

/**
 * 4. 生成 UserRepository_Factory
 * 工厂类，负责创建 UserRepository 实例
 */
public final class UserRepository_Factory implements Factory<UserRepository> {
    
    private final Provider<UserApi> apiProvider;
    private final Provider<UserDao> daoProvider;
    
    public UserRepository_Factory(
            Provider<UserApi> apiProvider, 
            Provider<UserDao> daoProvider) {
        this.apiProvider = apiProvider;
        this.daoProvider = daoProvider;
    }
    
    @Override
    public UserRepository get() {
        // 创建 UserRepository 实例，注入依赖
        return new UserRepository(apiProvider.get(), daoProvider.get());
    }
    
    public static UserRepository_Factory create(
            Provider<UserApi> apiProvider, 
            Provider<UserDao> daoProvider) {
        return new UserRepository_Factory(apiProvider, daoProvider);
    }
}

/**
 * 5. 生成 MainActivity_MembersInjector
 * 成员注入器，负责注入 @Inject 标注的字段
 */
public final class MainActivity_MembersInjector implements MembersInjector<MainActivity> {
    
    private final Provider<UserRepository> userRepositoryProvider;
    
    public MainActivity_MembersInjector(Provider<UserRepository> userRepositoryProvider) {
        this.userRepositoryProvider = userRepositoryProvider;
    }
    
    @Override
    public void injectMembers(MainActivity instance) {
        // 注入 userRepository 字段
        injectUserRepository(instance, userRepositoryProvider.get());
    }
    
    public static void injectUserRepository(
            MainActivity instance, 
            UserRepository userRepository) {
        // 直接赋值给字段
        instance.userRepository = userRepository;
    }
}
```

### 3.4 Koin 核心源码分析

```kotlin
/**
 * Koin 核心原理 - 运行时依赖注入
 * 基于 Kotlin DSL 和 ServiceLocator 模式
 */

/**
 * Koin 模块定义
 */
val appModule = module {
    // 单例
    single { UserRepository(get(), get()) }
    
    // 工厂模式（每次获取新实例）
    factory { UserViewModel(get()) }
    
    // 带参数的工厂
    factory { (id: String) -> UserDetailViewModel(id, get()) }
}

/**
 * Koin 核心类 - KoinApplication
 * 路径: koin-core/src/main/kotlin/org/koin/core/KoinApplication.kt
 */
class KoinApplication private constructor() {
    
    // Koin 实例
    val koin: Koin = Koin()
    
    /**
     * 加载模块
     */
    fun modules(vararg modules: Module): KoinApplication {
        koin.loadModules(modules.toList())
        return this
    }
    
    companion object {
        fun init(): KoinApplication = KoinApplication()
    }
}

/**
 * Koin 核心类 - Koin
 * 路径: koin-core/src/main/kotlin/org/koin/core/Koin.kt
 */
class Koin {
    
    // Scope 注册表，存储所有定义
    val scopeRegistry: ScopeRegistry = ScopeRegistry(this)
    
    // 根 Scope
    val rootScope: Scope = scopeRegistry.rootScope
    
    /**
     * 加载模块
     */
    fun loadModules(modules: List<Module>) {
        modules.forEach { module ->
            // 将模块中的定义注册到 ScopeRegistry
            scopeRegistry.loadModule(module)
        }
    }
    
    /**
     * 获取依赖实例
     */
    inline fun <reified T : Any> get(
        qualifier: Qualifier? = null,
        noinline parameters: ParametersDefinition? = null
    ): T {
        return rootScope.get(qualifier, parameters)
    }
}

/**
 * Scope - 作用域，管理依赖实例
 * 路径: koin-core/src/main/kotlin/org/koin/core/scope/Scope.kt
 */
class Scope(
    val scopeQualifier: Qualifier,
    val id: ScopeID,
    val isRoot: Boolean = false,
    private val _koin: Koin
) {
    // 实例缓存（用于单例）
    private val _instances = hashMapOf<IndexKey, InstanceFactory<*>>()
    
    /**
     * 获取依赖实例
     */
    fun <T : Any> get(
        clazz: KClass<T>,
        qualifier: Qualifier?,
        parameters: ParametersDefinition?
    ): T {
        // 1. 查找定义
        val definition = findDefinition(clazz, qualifier)
            ?: throw NoBeanDefFoundException("No definition found for $clazz")
        
        // 2. 根据定义类型获取实例
        return when (definition.kind) {
            Kind.Singleton -> {
                // 单例：从缓存获取或创建
                getOrCreateSingleInstance(definition, parameters)
            }
            Kind.Factory -> {
                // 工厂：每次创建新实例
                createInstance(definition, parameters)
            }
            Kind.Scoped -> {
                // 作用域单例
                getOrCreateScopedInstance(definition, parameters)
            }
        }
    }
    
    /**
     * 获取或创建单例实例
     */
    private fun <T : Any> getOrCreateSingleInstance(
        definition: BeanDefinition<T>,
        parameters: ParametersDefinition?
    ): T {
        val indexKey = indexKey(definition.primaryType, definition.qualifier)
        
        // 双重检查锁
        var instance = _instances[indexKey]?.get() as? T
        if (instance == null) {
            synchronized(this) {
                instance = _instances[indexKey]?.get() as? T
                if (instance == null) {
                    // 创建实例
                    instance = createInstance(definition, parameters)
                    // 缓存实例
                    _instances[indexKey] = SingleInstanceFactory(instance!!)
                }
            }
        }
        return instance!!
    }
    
    /**
     * 创建实例
     */
    private fun <T : Any> createInstance(
        definition: BeanDefinition<T>,
        parameters: ParametersDefinition?
    ): T {
        // 调用定义中的 lambda 创建实例
        val params = parameters?.invoke() ?: emptyParametersHolder()
        return definition.definition.invoke(this, params)
    }
}
```

## 4. 实战应用

### 4.1 组件化项目结构


```
┌─────────────────────────────────────────────────────────────────────────┐
│                      组件化项目结构示例                                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  project-root/                                                          │
│  ├── app/                          # 主工程（壳工程）                   │
│  │   ├── src/main/                                                     │
│  │   │   ├── java/.../App.kt       # Application                       │
│  │   │   └── AndroidManifest.xml                                       │
│  │   └── build.gradle.kts                                              │
│  │                                                                     │
│  ├── module-home/                  # 首页业务组件                       │
│  │   ├── src/main/                                                     │
│  │   │   ├── java/                                                     │
│  │   │   ├── res/                                                      │
│  │   │   └── AndroidManifest.xml   # 集成模式 Manifest                 │
│  │   ├── src/main/alone/           # 独立运行配置                      │
│  │   │   ├── java/                                                     │
│  │   │   │   └── HomeDebugActivity.kt                                  │
│  │   │   └── AndroidManifest.xml   # 独立运行 Manifest                 │
│  │   └── build.gradle.kts                                              │
│  │                                                                     │
│  ├── module-shop/                  # 商城业务组件                       │
│  ├── module-message/               # 消息业务组件                       │
│  ├── module-mine/                  # 我的业务组件                       │
│  │                                                                     │
│  ├── lib-common/                   # 公共库                            │
│  │   ├── src/main/java/                                                │
│  │   │   ├── base/                 # 基类                              │
│  │   │   │   ├── BaseActivity.kt                                       │
│  │   │   │   ├── BaseFragment.kt                                       │
│  │   │   │   └── BaseViewModel.kt                                      │
│  │   │   ├── router/               # 路由服务接口                      │
│  │   │   │   ├── RouterPath.kt     # 路由路径常量                      │
│  │   │   │   └── IUserService.kt   # 服务接口                          │
│  │   │   └── ext/                  # 扩展函数                          │
│  │   └── build.gradle.kts                                              │
│  │                                                                     │
│  ├── lib-network/                  # 网络库                            │
│  ├── lib-image/                    # 图片库                            │
│  ├── lib-utils/                    # 工具库                            │
│  │                                                                     │
│  ├── gradle.properties             # 组件开关配置                      │
│  ├── settings.gradle.kts                                               │
│  └── build.gradle.kts                                                  │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 4.2 ARouter 使用最佳实践

```kotlin
/**
 * 1. 路由路径统一管理
 * 放在 lib-common 模块
 */
object RouterPath {
    
    object Home {
        const val HOME = "/home/main"
        const val DETAIL = "/home/detail"
    }
    
    object User {
        const val LOGIN = "/user/login"
        const val PROFILE = "/user/profile"
        const val SETTINGS = "/user/settings"
    }
    
    object Shop {
        const val MAIN = "/shop/main"
        const val PRODUCT_DETAIL = "/shop/product/detail"
        const val CART = "/shop/cart"
    }
}

/**
 * 2. Activity 路由注册
 */
@Route(path = RouterPath.User.LOGIN)
class LoginActivity : BaseActivity() {
    
    // 自动注入参数
    @Autowired
    @JvmField
    var redirectUrl: String? = null
    
    @Autowired(name = "userId")
    @JvmField
    var uid: Long = 0
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        // 注入参数
        ARouter.getInstance().inject(this)
    }
}

/**
 * 3. 服务接口定义（放在 lib-common）
 */
interface IUserService : IProvider {
    fun isLogin(): Boolean
    fun getUserInfo(): User?
    fun logout()
}

/**
 * 4. 服务实现（放在 module-user）
 */
@Route(path = "/service/user")
class UserServiceImpl : IUserService {
    
    override fun init(context: Context) {
        // 初始化
    }
    
    override fun isLogin(): Boolean {
        return UserManager.isLogin
    }
    
    override fun getUserInfo(): User? {
        return UserManager.currentUser
    }
    
    override fun logout() {
        UserManager.logout()
    }
}

/**
 * 5. 路由跳转封装
 */
object Router {
    
    /**
     * 跳转到登录页
     */
    fun toLogin(redirectUrl: String? = null) {
        ARouter.getInstance()
            .build(RouterPath.User.LOGIN)
            .withString("redirectUrl", redirectUrl)
            .navigation()
    }
    
    /**
     * 跳转到商品详情
     */
    fun toProductDetail(productId: Long) {
        ARouter.getInstance()
            .build(RouterPath.Shop.PRODUCT_DETAIL)
            .withLong("productId", productId)
            .withTransition(R.anim.slide_in_right, R.anim.slide_out_left)
            .navigation()
    }
    
    /**
     * 获取用户服务
     */
    fun getUserService(): IUserService? {
        return ARouter.getInstance()
            .build("/service/user")
            .navigation() as? IUserService
    }
    
    /**
     * 获取 Fragment
     */
    fun getHomeFragment(): Fragment? {
        return ARouter.getInstance()
            .build("/home/fragment")
            .navigation() as? Fragment
    }
}

/**
 * 6. 登录拦截器
 */
@Interceptor(priority = 8, name = "登录拦截器")
class LoginInterceptor : IInterceptor {
    
    override fun init(context: Context) {}
    
    override fun process(postcard: Postcard, callback: InterceptorCallback) {
        // 检查是否需要登录
        val needLogin = postcard.extra and RouterExtra.NEED_LOGIN != 0
        
        if (needLogin && !Router.getUserService()?.isLogin()!!) {
            // 未登录，跳转登录页
            ARouter.getInstance()
                .build(RouterPath.User.LOGIN)
                .withString("redirectUrl", postcard.path)
                .navigation()
            // 拦截当前跳转
            callback.onInterrupt(RuntimeException("Need login"))
        } else {
            // 放行
            callback.onContinue(postcard)
        }
    }
}

/**
 * 7. 降级策略
 */
@Route(path = "/service/degrade")
class DegradeServiceImpl : DegradeService {
    
    override fun init(context: Context) {}
    
    override fun onLost(context: Context, postcard: Postcard) {
        // 路由未找到时的降级处理
        Log.e("Router", "Route not found: ${postcard.path}")
        
        // 可以跳转到 404 页面
        // 或者显示 Toast 提示
        Toast.makeText(context, "页面不存在", Toast.LENGTH_SHORT).show()
    }
}
```

### 4.3 Hilt 使用最佳实践


```kotlin
/**
 * Hilt 使用最佳实践
 */

// 1. Application 配置
@HiltAndroidApp
class MyApplication : Application()

// 2. Activity 注入
@AndroidEntryPoint
class MainActivity : AppCompatActivity() {
    
    // 字段注入
    @Inject
    lateinit var analytics: AnalyticsService
    
    // ViewModel 注入（推荐方式）
    private val viewModel: MainViewModel by viewModels()
}

// 3. Fragment 注入
@AndroidEntryPoint
class HomeFragment : Fragment() {
    
    // Fragment 作用域的 ViewModel
    private val viewModel: HomeViewModel by viewModels()
    
    // Activity 作用域的 ViewModel（共享）
    private val sharedViewModel: SharedViewModel by activityViewModels()
}

// 4. ViewModel 注入
@HiltViewModel
class MainViewModel @Inject constructor(
    private val userRepository: UserRepository,
    private val savedStateHandle: SavedStateHandle  // 自动注入
) : ViewModel() {
    
    // SavedStateHandle 可以获取 Intent/Arguments 参数
    private val userId: String = savedStateHandle.get<String>("userId") ?: ""
}

/**
 * 5. Module 定义 - 提供第三方库依赖
 */
@Module
@InstallIn(SingletonComponent::class)  // 安装到 SingletonComponent
object NetworkModule {
    
    @Provides
    @Singleton
    fun provideOkHttpClient(): OkHttpClient {
        return OkHttpClient.Builder()
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(30, TimeUnit.SECONDS)
            .addInterceptor(HttpLoggingInterceptor().apply {
                level = HttpLoggingInterceptor.Level.BODY
            })
            .build()
    }
    
    @Provides
    @Singleton
    fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit {
        return Retrofit.Builder()
            .baseUrl(BuildConfig.BASE_URL)
            .client(okHttpClient)
            .addConverterFactory(GsonConverterFactory.create())
            .build()
    }
    
    @Provides
    @Singleton
    fun provideUserApi(retrofit: Retrofit): UserApi {
        return retrofit.create(UserApi::class.java)
    }
}

/**
 * 6. Module 定义 - 数据库
 */
@Module
@InstallIn(SingletonComponent::class)
object DatabaseModule {
    
    @Provides
    @Singleton
    fun provideDatabase(@ApplicationContext context: Context): AppDatabase {
        return Room.databaseBuilder(
            context,
            AppDatabase::class.java,
            "app_database"
        ).build()
    }
    
    @Provides
    fun provideUserDao(database: AppDatabase): UserDao {
        return database.userDao()
    }
}

/**
 * 7. 接口绑定 - 使用 @Binds
 */
@Module
@InstallIn(SingletonComponent::class)
abstract class RepositoryModule {
    
    // 将接口绑定到实现类
    @Binds
    @Singleton
    abstract fun bindUserRepository(impl: UserRepositoryImpl): UserRepository
    
    @Binds
    abstract fun bindAnalyticsService(impl: FirebaseAnalyticsService): AnalyticsService
}

/**
 * 8. 限定符 - 区分同类型的不同实例
 */
@Qualifier
@Retention(AnnotationRetention.BINARY)
annotation class IoDispatcher

@Qualifier
@Retention(AnnotationRetention.BINARY)
annotation class DefaultDispatcher

@Module
@InstallIn(SingletonComponent::class)
object DispatcherModule {
    
    @Provides
    @IoDispatcher
    fun provideIoDispatcher(): CoroutineDispatcher = Dispatchers.IO
    
    @Provides
    @DefaultDispatcher
    fun provideDefaultDispatcher(): CoroutineDispatcher = Dispatchers.Default
}

// 使用限定符
class UserRepository @Inject constructor(
    private val api: UserApi,
    @IoDispatcher private val ioDispatcher: CoroutineDispatcher
) {
    suspend fun getUser(id: String): User = withContext(ioDispatcher) {
        api.getUser(id)
    }
}

/**
 * 9. 组件化中使用 Hilt
 * 每个模块定义自己的 Module
 */
// module-user 中的 Module
@Module
@InstallIn(SingletonComponent::class)
object UserModule {
    
    @Provides
    @Singleton
    fun provideUserManager(): UserManager {
        return UserManager()
    }
}

// module-shop 中的 Module
@Module
@InstallIn(SingletonComponent::class)
object ShopModule {
    
    @Provides
    @Singleton
    fun provideCartManager(userManager: UserManager): CartManager {
        return CartManager(userManager)
    }
}

/**
 * 10. 测试中替换依赖
 */
@HiltAndroidTest
@UninstallModules(NetworkModule::class)  // 卸载生产环境 Module
class MainActivityTest {
    
    @get:Rule
    var hiltRule = HiltAndroidRule(this)
    
    @Module
    @InstallIn(SingletonComponent::class)
    object TestNetworkModule {
        
        @Provides
        @Singleton
        fun provideUserApi(): UserApi {
            // 返回 Mock 实现
            return FakeUserApi()
        }
    }
    
    @Test
    fun testSomething() {
        // 测试代码
    }
}
```

### 4.4 组件化实践经验

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      组件化实践经验总结                                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  1. 资源命名规范:                                                       │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  问题：不同模块资源名冲突                                       │   │
│  │  解决：添加模块前缀                                             │   │
│  │                                                                 │   │
│  │  // build.gradle.kts                                            │   │
│  │  android {                                                      │   │
│  │      resourcePrefix = "home_"  // 强制资源前缀                  │   │
│  │  }                                                              │   │
│  │                                                                 │   │
│  │  命名示例：                                                     │   │
│  │  - 布局：home_activity_main.xml                                 │   │
│  │  - 字符串：home_title_xxx                                       │   │
│  │  - 颜色：home_color_primary                                     │   │
│  │  - 图片：home_ic_xxx                                            │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  2. 依赖管理:                                                           │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  使用 Version Catalog 统一管理依赖版本                          │   │
│  │                                                                 │   │
│  │  // gradle/libs.versions.toml                                   │   │
│  │  [versions]                                                     │   │
│  │  kotlin = "1.9.22"                                              │   │
│  │  hilt = "2.50"                                                  │   │
│  │  arouter = "1.5.2"                                              │   │
│  │                                                                 │   │
│  │  [libraries]                                                    │   │
│  │  hilt-android = { module = "com.google.dagger:hilt-android",    │   │
│  │                   version.ref = "hilt" }                        │   │
│  │  arouter-api = { module = "com.alibaba:arouter-api",            │   │
│  │                  version.ref = "arouter" }                      │   │
│  │                                                                 │   │
│  │  // 使用                                                        │   │
│  │  implementation(libs.hilt.android)                              │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  3. 组件初始化:                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  使用 App Startup 管理组件初始化                                │   │
│  │                                                                 │   │
│  │  // 每个模块定义自己的 Initializer                              │   │
│  │  class HomeInitializer : Initializer<Unit> {                    │   │
│  │      override fun create(context: Context) {                    │   │
│  │          // 初始化首页模块                                      │   │
│  │      }                                                          │   │
│  │      override fun dependencies(): List<Class<out Initializer<*>>>│  │
│  │          = listOf(CommonInitializer::class.java)                │   │
│  │  }                                                              │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  4. 组件通信最佳实践:                                                   │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  - 页面跳转：使用 ARouter                                       │   │
│  │  - 获取数据：使用 ARouter IProvider 服务                        │   │
│  │  - 事件通知：使用 LiveDataBus / Flow                            │   │
│  │  - 共享数据：使用 Hilt 单例                                     │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  5. 编译优化:                                                           │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  - 使用 arouter-register 插件避免运行时扫描                     │   │
│  │  - 开启 Gradle 构建缓存                                         │   │
│  │  - 使用 Configuration Cache                                     │   │
│  │  - 合理拆分模块粒度（不宜过细）                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  6. 常见问题与解决:                                                     │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  问题1：Application 获取                                        │   │
│  │  解决：在 lib-common 提供 ApplicationProvider                   │   │
│  │                                                                 │   │
│  │  问题2：跨模块 Fragment 通信                                    │   │
│  │  解决：使用 SharedViewModel + Hilt                              │   │
│  │                                                                 │   │
│  │  问题3：模块间数据库共享                                        │   │
│  │  解决：数据库放在 lib-common 或独立 lib-database                │   │
│  │                                                                 │   │
│  │  问题4：Manifest 合并冲突                                       │   │
│  │  解决：使用 tools:replace 或 tools:node="remove"                │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

## 5. 常见面试题

### 5.1 组件化基础

**问题1：什么是组件化？组件化和模块化有什么区别？**

答案要点：
- **模块化**：将应用按功能/业务拆分为多个 Module，降低耦合度，但模块间可能存在依赖，不能独立运行
- **组件化**：在模块化基础上，每个模块可以独立编译、运行和调试，模块间完全解耦，通过路由通信
- **关系**：组件化 = 模块化 + 独立运行能力 + 路由通信
- **组件化优势**：
  - 编译加速（增量编译）
  - 团队并行开发
  - 独立调试测试
  - 灵活组合复用

**问题2：组件化架构如何分层？各层职责是什么？**

答案要点：
- **App 壳工程层**：负责组装各业务组件、初始化配置、打包发布
- **业务组件层**：包含完整业务功能，可独立运行，如首页、商城、消息等
- **功能组件层**：提供通用功能服务，如登录、支付、分享等
- **基础组件层**：与业务无关的基础能力，如网络、图片、日志等
- **公共层 (Common)**：路由接口定义、公共实体类、基类等，所有模块都依赖

**问题3：组件如何实现独立运行？**

答案要点：
- 通过 Gradle 配置动态切换 Library/Application 模式
- 在 `gradle.properties` 中定义开关变量
- 在模块 `build.gradle` 中根据开关动态应用插件
- 独立运行时使用单独的 `AndroidManifest.xml` 和启动 Activity
- 目录结构：`src/main/alone/` 存放独立运行配置


### 5.2 模块间通信

**问题4：组件化中模块间如何通信？有哪些方案？**

答案要点：
- **接口下沉 + 实现注册**：
  - 接口定义在 Common 模块
  - 实现类在各业务模块
  - 通过 ServiceLoader 或手动注册获取实现
  - 优点：类型安全；缺点：接口变更需修改 Common
  
- **路由框架 (ARouter)**：
  - 通过路径字符串跳转
  - 支持 Activity、Fragment、Service
  - 优点：完全解耦；缺点：运行时反射、类型不安全
  
- **EventBus / LiveDataBus**：
  - 发布-订阅模式
  - 优点：简单解耦；缺点：难以追踪、容易滥用
  
- **依赖注入 (Hilt)**：
  - 通过 DI 容器管理依赖
  - 优点：编译时检查、类型安全

**问题5：ARouter 的原理是什么？**

答案要点：
- **编译期**：
  - APT 处理 `@Route` 注解
  - 生成路由表 Java 文件（分组存储）
  - `ARouter$$Group$$xxx` 存储组内路由
  - `ARouter$$Root$$xxx` 存储组索引
  
- **运行期**：
  - 初始化时扫描 dex 加载路由表到 Warehouse
  - 路由时根据 path 查找目标类
  - 支持拦截器链处理
  - 根据类型执行跳转（Activity/Fragment/Provider）
  
- **优化**：使用 arouter-register 插件，编译期注入路由表，避免运行时扫描

**问题6：ARouter 如何实现登录拦截？**

答案要点：
```kotlin
// 1. 定义拦截器
@Interceptor(priority = 8, name = "登录拦截器")
class LoginInterceptor : IInterceptor {
    override fun process(postcard: Postcard, callback: InterceptorCallback) {
        // 检查是否需要登录
        val needLogin = postcard.extra and RouterExtra.NEED_LOGIN != 0
        if (needLogin && !isLogin()) {
            // 跳转登录页
            ARouter.getInstance().build("/user/login").navigation()
            callback.onInterrupt(RuntimeException("Need login"))
        } else {
            callback.onContinue(postcard)
        }
    }
}

// 2. 标记需要登录的页面
@Route(path = "/shop/cart", extras = RouterExtra.NEED_LOGIN)
class CartActivity : BaseActivity()
```

### 5.3 依赖注入

**问题7：Hilt 的原理是什么？相比 Dagger 有什么优势？**

答案要点：
- **Hilt 原理**：
  - 基于 Dagger，通过注解处理器生成代码
  - 编译期生成 `Hilt_XXXActivity` 基类
  - 通过字节码插桩替换 Activity 父类
  - 预定义组件层级（SingletonComponent、ActivityComponent 等）
  - 自动管理组件生命周期
  
- **相比 Dagger 的优势**：
  - 简化配置：预定义组件，无需手动创建
  - Android 集成：自动绑定 Android 类（Activity、Fragment、ViewModel）
  - 标准化：统一的依赖注入方式
  - 测试友好：方便替换依赖

**问题8：Hilt 中 @Provides 和 @Binds 有什么区别？**

答案要点：
- **@Provides**：
  - 用于提供第三方库实例或需要配置的实例
  - 需要写方法体，手动创建实例
  - 可以有多个参数
  ```kotlin
  @Provides
  fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit {
      return Retrofit.Builder().client(okHttpClient).build()
  }
  ```

- **@Binds**：
  - 用于绑定接口和实现类
  - 必须是抽象方法
  - 只能有一个参数（实现类）
  - 性能更优（不生成额外代码）
  ```kotlin
  @Binds
  abstract fun bindRepository(impl: UserRepositoryImpl): UserRepository
  ```

**问题9：Hilt 的作用域有哪些？如何选择？**

答案要点：
| 作用域 | 组件 | 生命周期 | 使用场景 |
|--------|------|----------|----------|
| @Singleton | SingletonComponent | Application | 全局单例，如 Retrofit、Database |
| @ActivityRetainedScoped | ActivityRetainedComponent | ViewModel | 配置变更保留 |
| @ActivityScoped | ActivityComponent | Activity | Activity 内共享 |
| @FragmentScoped | FragmentComponent | Fragment | Fragment 内共享 |
| @ViewScoped | ViewComponent | View | View 内共享 |
| @ViewModelScoped | ViewModelComponent | ViewModel | ViewModel 内共享 |

**问题10：Koin 和 Hilt 有什么区别？如何选择？**

答案要点：
| 特性 | Hilt | Koin |
|------|------|------|
| 类型 | 编译时 DI | 运行时 DI |
| 性能 | 更优（编译时生成代码） | 稍差（运行时反射） |
| 错误检测 | 编译时 | 运行时 |
| 学习曲线 | 较陡（基于 Dagger） | 平缓（纯 Kotlin DSL） |
| 配置复杂度 | 中等 | 简单 |
| 官方支持 | Google 官方推荐 | 社区维护 |

**选择建议**：
- 大型项目、团队协作：选 Hilt（编译时检查、类型安全）
- 小型项目、快速开发：选 Koin（简单易用）
- 已使用 Dagger：迁移到 Hilt

### 5.4 组件化实践

**问题11：组件化开发中如何处理资源冲突？**

答案要点：
- **添加资源前缀**：
  ```kotlin
  android {
      resourcePrefix = "home_"  // 强制资源前缀
  }
  ```
- **命名规范**：
  - 布局：`模块名_类型_功能.xml`，如 `home_activity_main.xml`
  - 字符串：`模块名_功能`，如 `home_title_welcome`
  - 颜色/尺寸：`模块名_类型_名称`
- **公共资源**：放在 lib-common 模块，不加前缀

**问题12：组件化中如何管理组件初始化？**

答案要点：
- **使用 App Startup**：
  ```kotlin
  class HomeInitializer : Initializer<Unit> {
      override fun create(context: Context) {
          // 初始化首页模块
      }
      override fun dependencies(): List<Class<out Initializer<*>>> {
          return listOf(CommonInitializer::class.java)
      }
  }
  ```
- **优势**：
  - 声明式依赖管理
  - 自动处理初始化顺序
  - 支持懒加载
  - 避免 ContentProvider 滥用

**问题13：字节/美团等大厂的组件化方案有什么特点？**

答案要点：
- **字节跳动**：
  - 自研路由框架
  - 强调编译速度优化
  - 模块粒度较细
  - 支持动态化
  
- **美团**：
  - WMRouter 路由框架
  - 支持多进程
  - 强调稳定性
  - 完善的降级策略
  
- **共同特点**：
  - 分层架构清晰
  - 路由 + 服务发现
  - 编译优化（增量编译、缓存）
  - 完善的监控和降级

**问题14：如何设计一个路由框架？**

答案要点：
- **核心功能**：
  - 页面跳转（Activity、Fragment）
  - 服务发现（获取接口实现）
  - 参数传递与自动注入
  - 拦截器机制
  - 降级策略
  
- **实现方案**：
  - 编译期：APT 生成路由表
  - 运行期：加载路由表、查找目标、执行跳转
  
- **关键设计**：
  - 路由表分组加载（按需加载）
  - 拦截器链（责任链模式）
  - 线程安全（路由表并发访问）
  - 性能优化（避免运行时扫描）

**问题15：组件化项目如何进行单元测试？**

答案要点：
- **依赖注入替换**：
  ```kotlin
  @HiltAndroidTest
  @UninstallModules(NetworkModule::class)
  class UserRepositoryTest {
      @Module
      @InstallIn(SingletonComponent::class)
      object TestModule {
          @Provides
          fun provideUserApi(): UserApi = FakeUserApi()
      }
  }
  ```
- **Mock 路由服务**：
  ```kotlin
  // 测试时注入 Mock 服务
  val mockUserService = mockk<IUserService>()
  every { mockUserService.isLogin() } returns true
  ```
- **组件独立测试**：
  - 每个组件可独立运行
  - 使用 Mock 依赖隔离测试
  - 编写组件级集成测试

---

*文档版本: v1.0*  
*更新时间: 2025-01*  
*适用版本: Android W*
