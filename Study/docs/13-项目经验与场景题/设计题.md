# 设计题

## 概述

设计题是 Android 高级开发面试中的重要环节，主要考察候选人的系统设计能力、架构思维和工程实践经验。本文档涵盖六大经典设计题：图片加载框架、网络请求框架、EventBus、路由框架、日志系统和埋点系统。

面试官通过设计题考察的核心能力：
- **架构设计能力**：能否设计出高内聚、低耦合的系统
- **技术深度**：对底层原理的理解程度
- **工程思维**：对性能、扩展性、可维护性的考量
- **问题分析能力**：需求分析和问题拆解能力
- **表达能力**：能否清晰地阐述设计思路

---

## 一、设计图片加载框架

### 1.1 需求分析

#### 功能性需求
- 支持多种图片来源：网络、本地文件、资源文件、ContentProvider
- 支持多种图片格式：JPEG、PNG、WebP、GIF、HEIF
- 支持图片变换：裁剪、缩放、圆角、高斯模糊等
- 支持占位图和错误图
- 支持图片加载进度回调
- 支持生命周期感知，自动取消请求

#### 非功能性需求
- **高性能**：三级缓存、采样压缩、硬件加速
- **低内存**：Bitmap 复用、及时回收
- **高可用**：降级策略、重试机制
- **可扩展**：支持自定义组件
- **易用性**：链式调用、简洁 API

### 1.2 架构设计

```
┌─────────────────────────────────────────────────────────────────┐
│                        API Layer (对外接口层)                     │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  ImageLoader.with(context).load(url).into(imageView)    │   │
│  └─────────────────────────────────────────────────────────┘   │
├─────────────────────────────────────────────────────────────────┤
│                     Engine Layer (引擎层)                        │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐      │
│  │ RequestManager│  │ RequestBuilder│  │ RequestTracker   │      │
│  │ (请求管理器)   │  │ (请求构建器)  │  │ (请求追踪器)     │      │
│  └──────────────┘  └──────────────┘  └──────────────────┘      │
├─────────────────────────────────────────────────────────────────┤
│                     Cache Layer (缓存层)                         │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐      │
│  │ MemoryCache  │  │ DiskCache    │  │ BitmapPool       │      │
│  │ (内存缓存)    │  │ (磁盘缓存)   │  │ (Bitmap复用池)   │      │
│  └──────────────┘  └──────────────┘  └──────────────────┘      │
├─────────────────────────────────────────────────────────────────┤
│                     Data Layer (数据层)                          │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐      │
│  │ HttpFetcher  │  │ LocalFetcher │  │ AssetFetcher     │      │
│  │ (网络获取)    │  │ (本地获取)   │  │ (资源获取)       │      │
│  └──────────────┘  └──────────────┘  └──────────────────┘      │
├─────────────────────────────────────────────────────────────────┤
│                   Decode Layer (解码层)                          │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐      │
│  │ BitmapDecoder│  │ GifDecoder   │  │ VideoDecoder     │      │
│  │ (位图解码)    │  │ (GIF解码)    │  │ (视频帧解码)     │      │
│  └──────────────┘  └──────────────┘  └──────────────────┘      │
└─────────────────────────────────────────────────────────────────┘
```

### 1.3 核心模块设计

#### 1.3.1 三级缓存设计

```
┌─────────────────────────────────────────────────────────────┐
│                      图片加载请求                            │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                   一级缓存：活动资源缓存                      │
│              (ActiveResources - 弱引用)                      │
│                 正在使用的图片，引用计数                      │
└─────────────────────────────────────────────────────────────┘
                              │ 未命中
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                   二级缓存：内存缓存                          │
│                (MemoryCache - LruCache)                      │
│              最近使用的图片，LRU淘汰策略                      │
└─────────────────────────────────────────────────────────────┘
                              │ 未命中
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                   三级缓存：磁盘缓存                          │
│                (DiskCache - DiskLruCache)                    │
│           原始数据缓存 + 变换后数据缓存                       │
└─────────────────────────────────────────────────────────────┘
                              │ 未命中
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                      网络/本地加载                            │
└─────────────────────────────────────────────────────────────┘
```

### 1.4 关键代码实现

#### 1.4.1 核心接口定义

```kotlin
/**
 * 图片加载框架核心入口
 * 采用建造者模式，支持链式调用
 */
class ImageLoader private constructor(
    private val context: Context,
    private val config: ImageLoaderConfig
) {
    companion object {
        @Volatile
        private var instance: ImageLoader? = null
        
        fun init(context: Context, config: ImageLoaderConfig = ImageLoaderConfig.default()) {
            if (instance == null) {
                synchronized(this) {
                    if (instance == null) {
                        instance = ImageLoader(context.applicationContext, config)
                    }
                }
            }
        }
        
        /**
         * 获取与生命周期绑定的RequestManager
         * 支持Activity、Fragment、View等不同生命周期宿主
         */
        fun with(context: Context): RequestManager {
            return when (context) {
                is FragmentActivity -> {
                    // 通过空Fragment感知生命周期
                    val fm = context.supportFragmentManager
                    getRequestManagerFragment(fm).requestManager
                }
                is Activity -> {
                    val fm = context.fragmentManager
                    getRequestManagerFragment(fm).requestManager
                }
                else -> {
                    // Application Context，使用全局生命周期
                    ApplicationLifecycleManager.requestManager
                }
            }
        }
        
        private fun getRequestManagerFragment(fm: FragmentManager): RequestManagerFragment {
            var fragment = fm.findFragmentByTag(TAG) as? RequestManagerFragment
            if (fragment == null) {
                fragment = RequestManagerFragment()
                fm.beginTransaction()
                    .add(fragment, TAG)
                    .commitAllowingStateLoss()
            }
            return fragment
        }
    }
}

/**
 * 请求管理器 - 管理特定生命周期内的所有请求
 */
class RequestManager(
    private val lifecycle: Lifecycle,
    private val requestTracker: RequestTracker,
    private val context: Context
) : LifecycleObserver {
    
    init {
        lifecycle.addObserver(this)
    }
    
    fun load(url: String): RequestBuilder {
        return RequestBuilder(this, context).load(url)
    }
    
    fun load(uri: Uri): RequestBuilder {
        return RequestBuilder(this, context).load(uri)
    }
    
    fun load(resourceId: Int): RequestBuilder {
        return RequestBuilder(this, context).load(resourceId)
    }
    
    @OnLifecycleEvent(Lifecycle.Event.ON_START)
    fun onStart() {
        requestTracker.resumeRequests()
    }
    
    @OnLifecycleEvent(Lifecycle.Event.ON_STOP)
    fun onStop() {
        requestTracker.pauseRequests()
    }
    
    @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)
    fun onDestroy() {
        requestTracker.clearRequests()
        lifecycle.removeObserver(this)
    }
    
    internal fun track(request: Request) {
        requestTracker.runRequest(request)
    }
}

/**
 * 请求构建器 - 建造者模式
 */
class RequestBuilder(
    private val requestManager: RequestManager,
    private val context: Context
) {
    private var model: Any? = null
    private var placeholderResId: Int = 0
    private var errorResId: Int = 0
    private var targetWidth: Int = Target.SIZE_ORIGINAL
    private var targetHeight: Int = Target.SIZE_ORIGINAL
    private var transformations: MutableList<Transformation> = mutableListOf()
    private var diskCacheStrategy: DiskCacheStrategy = DiskCacheStrategy.AUTOMATIC
    private var priority: Priority = Priority.NORMAL
    
    fun load(model: Any?): RequestBuilder {
        this.model = model
        return this
    }
    
    fun placeholder(@DrawableRes resId: Int): RequestBuilder {
        this.placeholderResId = resId
        return this
    }
    
    fun error(@DrawableRes resId: Int): RequestBuilder {
        this.errorResId = resId
        return this
    }
    
    fun override(width: Int, height: Int): RequestBuilder {
        this.targetWidth = width
        this.targetHeight = height
        return this
    }
    
    fun transform(vararg transformations: Transformation): RequestBuilder {
        this.transformations.addAll(transformations)
        return this
    }
    
    fun centerCrop(): RequestBuilder {
        return transform(CenterCrop())
    }
    
    fun circleCrop(): RequestBuilder {
        return transform(CircleCrop())
    }
    
    fun roundedCorners(radius: Int): RequestBuilder {
        return transform(RoundedCorners(radius))
    }
    
    fun diskCacheStrategy(strategy: DiskCacheStrategy): RequestBuilder {
        this.diskCacheStrategy = strategy
        return this
    }
    
    fun priority(priority: Priority): RequestBuilder {
        this.priority = priority
        return this
    }
    
    fun into(imageView: ImageView) {
        // 设置占位图
        if (placeholderResId != 0) {
            imageView.setImageResource(placeholderResId)
        }
        
        // 构建请求
        val request = SingleRequest(
            context = context,
            model = model,
            target = ImageViewTarget(imageView),
            requestOptions = buildRequestOptions(),
            engine = ImageLoader.getEngine(),
            requestListener = null
        )
        
        // 取消之前的请求
        val previousRequest = imageView.getTag(R.id.image_loader_request) as? Request
        previousRequest?.clear()
        
        // 绑定新请求
        imageView.setTag(R.id.image_loader_request, request)
        
        // 提交请求
        requestManager.track(request)
    }
    
    private fun buildRequestOptions(): RequestOptions {
        return RequestOptions(
            placeholderResId = placeholderResId,
            errorResId = errorResId,
            targetWidth = targetWidth,
            targetHeight = targetHeight,
            transformations = transformations,
            diskCacheStrategy = diskCacheStrategy,
            priority = priority
        )
    }
}
```

#### 1.4.2 缓存实现

```kotlin
/**
 * 内存缓存 - 基于LruCache实现
 */
class MemoryCache(maxSize: Int) : LruCache<String, BitmapWrapper>(maxSize) {
    
    override fun sizeOf(key: String, value: BitmapWrapper): Int {
        // 计算Bitmap占用内存大小
        return value.bitmap.allocationByteCount
    }
    
    override fun entryRemoved(
        evicted: Boolean,
        key: String,
        oldValue: BitmapWrapper,
        newValue: BitmapWrapper?
    ) {
        // 被移除的Bitmap放入复用池
        if (evicted && oldValue.isMutable) {
            BitmapPool.put(oldValue.bitmap)
        }
    }
    
    fun put(key: String, bitmap: Bitmap): BitmapWrapper? {
        return put(key, BitmapWrapper(bitmap, bitmap.isMutable))
    }
}

/**
 * Bitmap复用池 - 减少内存抖动
 */
object BitmapPool {
    // 按尺寸分组存储可复用的Bitmap
    private val pool = object : LruCache<String, LinkedList<Bitmap>>(
        (Runtime.getRuntime().maxMemory() / 8).toInt()
    ) {
        override fun sizeOf(key: String, value: LinkedList<Bitmap>): Int {
            return value.sumOf { it.allocationByteCount }
        }
    }
    
    /**
     * 获取可复用的Bitmap
     * Android 4.4+ 支持不同尺寸复用，只要内存大小足够
     */
    fun get(width: Int, height: Int, config: Bitmap.Config): Bitmap? {
        val key = generateKey(width, height, config)
        val bitmaps = pool.get(key) ?: return null
        
        synchronized(bitmaps) {
            return if (bitmaps.isNotEmpty()) {
                bitmaps.removeFirst()
            } else null
        }
    }
    
    /**
     * 回收Bitmap到复用池
     */
    fun put(bitmap: Bitmap) {
        if (!bitmap.isMutable || bitmap.isRecycled) return
        
        val key = generateKey(bitmap.width, bitmap.height, bitmap.config)
        var bitmaps = pool.get(key)
        
        if (bitmaps == null) {
            bitmaps = LinkedList()
            pool.put(key, bitmaps)
        }
        
        synchronized(bitmaps) {
            bitmaps.add(bitmap)
        }
    }
    
    private fun generateKey(width: Int, height: Int, config: Bitmap.Config): String {
        return "${width}_${height}_${config.name}"
    }
}

/**
 * 磁盘缓存 - 基于DiskLruCache
 */
class DiskCache(
    private val cacheDir: File,
    private val maxSize: Long = 250 * 1024 * 1024 // 250MB
) {
    private val diskLruCache: DiskLruCache by lazy {
        DiskLruCache.open(cacheDir, 1, 1, maxSize)
    }
    
    /**
     * 生成缓存Key - 使用SHA-256保证唯一性
     */
    fun generateKey(url: String, width: Int, height: Int, transformations: List<Transformation>): String {
        val sb = StringBuilder(url)
        sb.append("_${width}x${height}")
        transformations.forEach { sb.append("_${it.key()}") }
        return sha256(sb.toString())
    }
    
    fun get(key: String): InputStream? {
        return try {
            diskLruCache.get(key)?.getInputStream(0)
        } catch (e: IOException) {
            null
        }
    }
    
    fun put(key: String, inputStream: InputStream): Boolean {
        return try {
            val editor = diskLruCache.edit(key) ?: return false
            inputStream.copyTo(editor.newOutputStream(0))
            editor.commit()
            true
        } catch (e: IOException) {
            false
        }
    }
    
    fun remove(key: String): Boolean {
        return try {
            diskLruCache.remove(key)
        } catch (e: IOException) {
            false
        }
    }
    
    fun clear() {
        diskLruCache.delete()
    }
    
    private fun sha256(input: String): String {
        val digest = MessageDigest.getInstance("SHA-256")
        val hash = digest.digest(input.toByteArray())
        return hash.joinToString("") { "%02x".format(it) }
    }
}
```

#### 1.4.3 图片解码与采样

```kotlin
/**
 * Bitmap解码器 - 支持采样压缩和复用
 */
class BitmapDecoder(
    private val bitmapPool: BitmapPool
) {
    
    /**
     * 解码图片，支持采样压缩
     * @param source 数据源
     * @param targetWidth 目标宽度
     * @param targetHeight 目标高度
     */
    fun decode(
        source: DataSource,
        targetWidth: Int,
        targetHeight: Int
    ): Bitmap? {
        val inputStream = source.getInputStream() ?: return null
        
        // 第一次解码：只获取图片尺寸，不加载到内存
        val options = BitmapFactory.Options().apply {
            inJustDecodeBounds = true
        }
        BitmapFactory.decodeStream(inputStream, null, options)
        
        // 计算采样率
        options.inSampleSize = calculateInSampleSize(
            options.outWidth,
            options.outHeight,
            targetWidth,
            targetHeight
        )
        
        // 第二次解码：真正加载图片
        options.inJustDecodeBounds = false
        options.inMutable = true // 允许修改，支持复用
        options.inPreferredConfig = Bitmap.Config.ARGB_8888
        
        // 尝试从复用池获取Bitmap
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
            val reuseBitmap = bitmapPool.get(
                options.outWidth / options.inSampleSize,
                options.outHeight / options.inSampleSize,
                options.inPreferredConfig
            )
            options.inBitmap = reuseBitmap
        }
        
        // 重新获取输入流
        val newInputStream = source.getInputStream() ?: return null
        
        return try {
            BitmapFactory.decodeStream(newInputStream, null, options)
        } catch (e: IllegalArgumentException) {
            // inBitmap复用失败，清除后重试
            options.inBitmap = null
            source.getInputStream()?.let {
                BitmapFactory.decodeStream(it, null, options)
            }
        }
    }
    
    /**
     * 计算采样率 - 2的幂次方
     */
    private fun calculateInSampleSize(
        srcWidth: Int,
        srcHeight: Int,
        targetWidth: Int,
        targetHeight: Int
    ): Int {
        var inSampleSize = 1
        
        if (srcHeight > targetHeight || srcWidth > targetWidth) {
            val halfHeight = srcHeight / 2
            val halfWidth = srcWidth / 2
            
            // 计算最大的inSampleSize值，保证最终尺寸大于目标尺寸
            while ((halfHeight / inSampleSize) >= targetHeight
                && (halfWidth / inSampleSize) >= targetWidth
            ) {
                inSampleSize *= 2
            }
        }
        
        return inSampleSize
    }
}

/**
 * 图片变换接口
 */
interface Transformation {
    fun key(): String
    fun transform(bitmap: Bitmap, outWidth: Int, outHeight: Int): Bitmap
}

/**
 * 圆角变换
 */
class RoundedCorners(private val radius: Int) : Transformation {
    
    override fun key(): String = "RoundedCorners_$radius"
    
    override fun transform(bitmap: Bitmap, outWidth: Int, outHeight: Int): Bitmap {
        val output = Bitmap.createBitmap(
            bitmap.width,
            bitmap.height,
            Bitmap.Config.ARGB_8888
        )
        
        val canvas = Canvas(output)
        val paint = Paint(Paint.ANTI_ALIAS_FLAG)
        val rect = RectF(0f, 0f, bitmap.width.toFloat(), bitmap.height.toFloat())
        
        // 绘制圆角矩形
        canvas.drawRoundRect(rect, radius.toFloat(), radius.toFloat(), paint)
        
        // 设置混合模式，只保留交集部分
        paint.xfermode = PorterDuffXfermode(PorterDuff.Mode.SRC_IN)
        canvas.drawBitmap(bitmap, 0f, 0f, paint)
        
        return output
    }
}

/**
 * 圆形裁剪
 */
class CircleCrop : Transformation {
    
    override fun key(): String = "CircleCrop"
    
    override fun transform(bitmap: Bitmap, outWidth: Int, outHeight: Int): Bitmap {
        val size = minOf(bitmap.width, bitmap.height)
        val x = (bitmap.width - size) / 2
        val y = (bitmap.height - size) / 2
        
        // 裁剪为正方形
        val squared = Bitmap.createBitmap(bitmap, x, y, size, size)
        
        val output = Bitmap.createBitmap(size, size, Bitmap.Config.ARGB_8888)
        val canvas = Canvas(output)
        val paint = Paint(Paint.ANTI_ALIAS_FLAG)
        
        // 绘制圆形
        canvas.drawCircle(
            size / 2f,
            size / 2f,
            size / 2f,
            paint
        )
        
        paint.xfermode = PorterDuffXfermode(PorterDuff.Mode.SRC_IN)
        canvas.drawBitmap(squared, 0f, 0f, paint)
        
        if (squared != bitmap) {
            squared.recycle()
        }
        
        return output
    }
}
```

### 1.5 扩展性考虑

1. **自定义数据源**：通过 `ModelLoader` 接口支持自定义数据源
2. **自定义解码器**：通过 `ResourceDecoder` 接口支持新的图片格式
3. **自定义变换**：实现 `Transformation` 接口添加新的图片效果
4. **自定义缓存策略**：通过 `DiskCacheStrategy` 枚举控制缓存行为
5. **拦截器机制**：支持请求拦截，可用于添加签名、统计等

### 1.6 面试回答要点

1. **整体架构**：分层设计（API层、引擎层、缓存层、数据层、解码层）
2. **三级缓存**：活动资源缓存 → 内存缓存 → 磁盘缓存
3. **生命周期感知**：通过空Fragment监听Activity/Fragment生命周期
4. **内存优化**：Bitmap复用池、采样压缩、及时回收
5. **线程调度**：IO线程加载、主线程显示
6. **扩展性**：接口抽象、策略模式、建造者模式

---

## 二、设计网络请求框架

### 2.1 需求分析

#### 功能性需求
- 支持 HTTP/HTTPS 请求
- 支持 GET、POST、PUT、DELETE 等方法
- 支持文件上传/下载
- 支持请求/响应拦截器
- 支持自动序列化/反序列化
- 支持请求取消和超时控制

#### 非功能性需求
- **高性能**：连接复用、请求合并、缓存策略
- **可靠性**：重试机制、降级策略
- **安全性**：HTTPS、证书校验、数据加密
- **可扩展**：拦截器链、转换器、适配器
- **易用性**：注解配置、链式调用

### 2.2 架构设计

```
┌─────────────────────────────────────────────────────────────────┐
│                        API Layer (接口层)                        │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  @GET("/users/{id}")                                     │   │
│  │  suspend fun getUser(@Path("id") id: String): User       │   │
│  └─────────────────────────────────────────────────────────┘   │
├─────────────────────────────────────────────────────────────────┤
│                     Retrofit Layer (适配层)                      │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐      │
│  │ ServiceMethod │  │ CallAdapter  │  │ Converter        │      │
│  │ (方法解析)    │  │ (调用适配)   │  │ (数据转换)       │      │
│  └──────────────┘  └──────────────┘  └──────────────────┘      │
├─────────────────────────────────────────────────────────────────┤
│                   Interceptor Chain (拦截器链)                   │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐      │
│  │ Application  │  │ Retry        │  │ Bridge           │      │
│  │ Interceptor  │→ │ Interceptor  │→ │ Interceptor      │→     │
│  └──────────────┘  └──────────────┘  └──────────────────┘      │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐      │
│  │ Cache        │  │ Connect      │  │ CallServer       │      │
│  │ Interceptor  │→ │ Interceptor  │→ │ Interceptor      │      │
│  └──────────────┘  └──────────────┘  └──────────────────┘      │
├─────────────────────────────────────────────────────────────────┤
│                   Connection Layer (连接层)                      │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐      │
│  │ ConnectionPool│  │ Route        │  │ RealConnection   │      │
│  │ (连接池)      │  │ (路由选择)   │  │ (真实连接)       │      │
│  └──────────────┘  └──────────────┘  └──────────────────┘      │
├─────────────────────────────────────────────────────────────────┤
│                     Socket Layer (Socket层)                      │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐      │
│  │ Socket       │  │ SSLSocket    │  │ HTTP/2 Stream    │      │
│  │ (普通连接)    │  │ (安全连接)   │  │ (多路复用)       │      │
│  └──────────────┘  └──────────────┘  └──────────────────┘      │
└─────────────────────────────────────────────────────────────────┘
```

### 2.3 核心模块设计

#### 2.3.1 拦截器链设计（责任链模式）

```
请求 → [应用拦截器] → [重试拦截器] → [桥接拦截器] → [缓存拦截器] → [连接拦截器] → [网络拦截器] → 服务器
                                                                                              ↓
响应 ← [应用拦截器] ← [重试拦截器] ← [桥接拦截器] ← [缓存拦截器] ← [连接拦截器] ← [网络拦截器] ← 服务器
```

### 2.4 关键代码实现

#### 2.4.1 核心接口定义

```kotlin
/**
 * 网络请求框架核心类
 * 采用建造者模式配置
 */
class HttpClient private constructor(
    private val builder: Builder
) {
    val dispatcher: Dispatcher = builder.dispatcher
    val connectionPool: ConnectionPool = builder.connectionPool
    val interceptors: List<Interceptor> = builder.interceptors.toList()
    val networkInterceptors: List<Interceptor> = builder.networkInterceptors.toList()
    val connectTimeout: Long = builder.connectTimeout
    val readTimeout: Long = builder.readTimeout
    val writeTimeout: Long = builder.writeTimeout
    val cache: Cache? = builder.cache
    
    /**
     * 创建新的请求调用
     */
    fun newCall(request: Request): Call {
        return RealCall(this, request)
    }
    
    class Builder {
        internal var dispatcher = Dispatcher()
        internal var connectionPool = ConnectionPool()
        internal val interceptors = mutableListOf<Interceptor>()
        internal val networkInterceptors = mutableListOf<Interceptor>()
        internal var connectTimeout = 10_000L
        internal var readTimeout = 10_000L
        internal var writeTimeout = 10_000L
        internal var cache: Cache? = null
        
        fun dispatcher(dispatcher: Dispatcher) = apply { this.dispatcher = dispatcher }
        fun connectionPool(pool: ConnectionPool) = apply { this.connectionPool = pool }
        fun addInterceptor(interceptor: Interceptor) = apply { interceptors.add(interceptor) }
        fun addNetworkInterceptor(interceptor: Interceptor) = apply { networkInterceptors.add(interceptor) }
        fun connectTimeout(timeout: Long, unit: TimeUnit) = apply { 
            connectTimeout = unit.toMillis(timeout) 
        }
        fun readTimeout(timeout: Long, unit: TimeUnit) = apply { 
            readTimeout = unit.toMillis(timeout) 
        }
        fun writeTimeout(timeout: Long, unit: TimeUnit) = apply { 
            writeTimeout = unit.toMillis(timeout) 
        }
        fun cache(cache: Cache) = apply { this.cache = cache }
        
        fun build(): HttpClient = HttpClient(this)
    }
}

/**
 * 请求类
 */
class Request private constructor(
    val url: HttpUrl,
    val method: String,
    val headers: Headers,
    val body: RequestBody?
) {
    class Builder {
        private var url: HttpUrl? = null
        private var method = "GET"
        private val headers = Headers.Builder()
        private var body: RequestBody? = null
        
        fun url(url: String) = apply { this.url = HttpUrl.parse(url) }
        fun url(url: HttpUrl) = apply { this.url = url }
        
        fun header(name: String, value: String) = apply { 
            headers.set(name, value) 
        }
        
        fun addHeader(name: String, value: String) = apply { 
            headers.add(name, value) 
        }
        
        fun get() = apply { 
            method = "GET"
            body = null
        }
        
        fun post(body: RequestBody) = apply { 
            method = "POST"
            this.body = body
        }
        
        fun put(body: RequestBody) = apply { 
            method = "PUT"
            this.body = body
        }
        
        fun delete(body: RequestBody? = null) = apply { 
            method = "DELETE"
            this.body = body
        }
        
        fun build(): Request {
            return Request(
                url = url ?: throw IllegalStateException("url == null"),
                method = method,
                headers = headers.build(),
                body = body
            )
        }
    }
}

/**
 * 响应类
 */
class Response(
    val request: Request,
    val code: Int,
    val message: String,
    val headers: Headers,
    val body: ResponseBody?,
    val networkResponse: Response?,
    val cacheResponse: Response?
) {
    val isSuccessful: Boolean
        get() = code in 200..299
        
    val isRedirect: Boolean
        get() = code in 300..399
}
```

#### 2.4.2 拦截器链实现

```kotlin
/**
 * 拦截器接口 - 责任链模式核心
 */
interface Interceptor {
    /**
     * 拦截请求
     * @param chain 拦截器链，调用proceed继续传递
     */
    fun intercept(chain: Chain): Response
    
    interface Chain {
        fun request(): Request
        fun proceed(request: Request): Response
        fun connection(): Connection?
    }
}

/**
 * 真实拦截器链实现
 */
class RealInterceptorChain(
    private val interceptors: List<Interceptor>,
    private val index: Int,
    private val request: Request,
    private val connection: Connection?,
    private val connectTimeout: Int,
    private val readTimeout: Int,
    private val writeTimeout: Int
) : Interceptor.Chain {
    
    override fun request(): Request = request
    
    override fun connection(): Connection? = connection
    
    override fun proceed(request: Request): Response {
        // 检查是否还有拦截器
        if (index >= interceptors.size) {
            throw AssertionError("No interceptor to handle request")
        }
        
        // 创建下一个拦截器链
        val next = RealInterceptorChain(
            interceptors = interceptors,
            index = index + 1,
            request = request,
            connection = connection,
            connectTimeout = connectTimeout,
            readTimeout = readTimeout,
            writeTimeout = writeTimeout
        )
        
        // 获取当前拦截器并执行
        val interceptor = interceptors[index]
        val response = interceptor.intercept(next)
        
        // 校验响应
        checkNotNull(response.body) { "interceptor ${interceptor.javaClass.name} returned null" }
        
        return response
    }
}

/**
 * 重试与重定向拦截器
 */
class RetryAndFollowUpInterceptor(
    private val client: HttpClient
) : Interceptor {
    
    companion object {
        private const val MAX_FOLLOW_UPS = 20
    }
    
    override fun intercept(chain: Interceptor.Chain): Response {
        var request = chain.request()
        var followUpCount = 0
        var priorResponse: Response? = null
        
        while (true) {
            // 检查是否取消
            if (isCanceled()) {
                throw IOException("Canceled")
            }
            
            var response: Response
            try {
                response = chain.proceed(request)
            } catch (e: RouteException) {
                // 路由异常，尝试恢复
                if (!recover(e.lastConnectException, request)) {
                    throw e.firstConnectException
                }
                continue
            } catch (e: IOException) {
                // IO异常，尝试恢复
                if (!recover(e, request)) {
                    throw e
                }
                continue
            }
            
            // 处理重定向
            val followUp = followUpRequest(response)
            
            if (followUp == null) {
                return response
            }
            
            // 检查重定向次数
            if (++followUpCount > MAX_FOLLOW_UPS) {
                throw ProtocolException("Too many follow-up requests: $followUpCount")
            }
            
            request = followUp
            priorResponse = response
        }
    }
    
    private fun recover(e: IOException, request: Request): Boolean {
        // 判断是否可以重试
        if (!client.retryOnConnectionFailure) return false
        if (request.body is UnrepeatableRequestBody) return false
        if (e is ProtocolException) return false
        if (e is SSLHandshakeException) return false
        
        return true
    }
    
    private fun followUpRequest(response: Response): Request? {
        return when (response.code) {
            // 3xx 重定向
            301, 302, 303, 307, 308 -> {
                val location = response.header("Location") ?: return null
                val url = response.request.url.resolve(location) ?: return null
                
                Request.Builder()
                    .url(url)
                    .method(response.request.method, response.request.body)
                    .build()
            }
            // 401 需要认证
            401 -> {
                client.authenticator?.authenticate(response)
            }
            // 407 代理认证
            407 -> {
                client.proxyAuthenticator?.authenticate(response)
            }
            else -> null
        }
    }
}

/**
 * 桥接拦截器 - 补充请求头
 */
class BridgeInterceptor : Interceptor {
    
    override fun intercept(chain: Interceptor.Chain): Response {
        val userRequest = chain.request()
        val requestBuilder = userRequest.newBuilder()
        
        val body = userRequest.body
        if (body != null) {
            // 添加Content-Type
            body.contentType()?.let {
                requestBuilder.header("Content-Type", it.toString())
            }
            
            // 添加Content-Length
            val contentLength = body.contentLength()
            if (contentLength != -1L) {
                requestBuilder.header("Content-Length", contentLength.toString())
                requestBuilder.removeHeader("Transfer-Encoding")
            } else {
                requestBuilder.header("Transfer-Encoding", "chunked")
                requestBuilder.removeHeader("Content-Length")
            }
        }
        
        // 添加Host
        if (userRequest.header("Host") == null) {
            requestBuilder.header("Host", userRequest.url.host)
        }
        
        // 添加Connection
        if (userRequest.header("Connection") == null) {
            requestBuilder.header("Connection", "Keep-Alive")
        }
        
        // 添加Accept-Encoding
        var transparentGzip = false
        if (userRequest.header("Accept-Encoding") == null) {
            transparentGzip = true
            requestBuilder.header("Accept-Encoding", "gzip")
        }
        
        // 添加Cookie
        val cookies = client.cookieJar.loadForRequest(userRequest.url)
        if (cookies.isNotEmpty()) {
            requestBuilder.header("Cookie", cookies.joinToString("; "))
        }
        
        // 添加User-Agent
        if (userRequest.header("User-Agent") == null) {
            requestBuilder.header("User-Agent", "HttpClient/1.0")
        }
        
        // 执行请求
        val networkResponse = chain.proceed(requestBuilder.build())
        
        // 保存Cookie
        val responseHeaders = networkResponse.headers
        client.cookieJar.saveFromResponse(userRequest.url, Cookie.parseAll(userRequest.url, responseHeaders))
        
        // 处理Gzip解压
        val responseBuilder = networkResponse.newBuilder()
            .request(userRequest)
        
        if (transparentGzip 
            && "gzip".equals(networkResponse.header("Content-Encoding"), ignoreCase = true)
            && networkResponse.body != null
        ) {
            val gzipSource = GzipSource(networkResponse.body!!.source())
            val strippedHeaders = networkResponse.headers.newBuilder()
                .removeAll("Content-Encoding")
                .removeAll("Content-Length")
                .build()
            
            responseBuilder.headers(strippedHeaders)
            responseBuilder.body(RealResponseBody(
                networkResponse.body!!.contentType(),
                -1L,
                gzipSource.buffer()
            ))
        }
        
        return responseBuilder.build()
    }
}

/**
 * 缓存拦截器
 */
class CacheInterceptor(
    private val cache: Cache?
) : Interceptor {
    
    override fun intercept(chain: Interceptor.Chain): Response {
        val request = chain.request()
        
        // 尝试从缓存获取
        val cacheCandidate = cache?.get(request)
        
        val now = System.currentTimeMillis()
        
        // 缓存策略判断
        val strategy = CacheStrategy.Factory(now, request, cacheCandidate).compute()
        val networkRequest = strategy.networkRequest
        val cacheResponse = strategy.cacheResponse
        
        // 统计缓存命中
        cache?.trackResponse(strategy)
        
        // 缓存不可用，关闭
        if (cacheCandidate != null && cacheResponse == null) {
            cacheCandidate.body?.close()
        }
        
        // 禁止网络请求且无缓存，返回504
        if (networkRequest == null && cacheResponse == null) {
            return Response.Builder()
                .request(request)
                .code(504)
                .message("Unsatisfiable Request (only-if-cached)")
                .body(EMPTY_BODY)
                .build()
        }
        
        // 不需要网络请求，直接返回缓存
        if (networkRequest == null) {
            return cacheResponse!!.newBuilder()
                .cacheResponse(stripBody(cacheResponse))
                .build()
        }
        
        // 执行网络请求
        var networkResponse: Response? = null
        try {
            networkResponse = chain.proceed(networkRequest)
        } finally {
            if (networkResponse == null && cacheCandidate != null) {
                cacheCandidate.body?.close()
            }
        }
        
        // 有缓存，检查是否需要更新
        if (cacheResponse != null) {
            if (networkResponse?.code == 304) {
                // 304 Not Modified，使用缓存
                val response = cacheResponse.newBuilder()
                    .headers(combine(cacheResponse.headers, networkResponse.headers))
                    .cacheResponse(stripBody(cacheResponse))
                    .networkResponse(stripBody(networkResponse))
                    .build()
                
                networkResponse.body?.close()
                
                // 更新缓存
                cache?.update(cacheResponse, response)
                
                return response
            } else {
                cacheResponse.body?.close()
            }
        }
        
        // 构建响应
        val response = networkResponse!!.newBuilder()
            .cacheResponse(stripBody(cacheResponse))
            .networkResponse(stripBody(networkResponse))
            .build()
        
        // 缓存响应
        if (cache != null && response.isCacheable()) {
            cache.put(response)
        }
        
        return response
    }
}
```

#### 2.4.3 连接池实现

```kotlin
/**
 * 连接池 - 复用TCP连接
 */
class ConnectionPool(
    private val maxIdleConnections: Int = 5,
    private val keepAliveDuration: Long = 5,
    private val keepAliveUnit: TimeUnit = TimeUnit.MINUTES
) {
    // 连接队列
    private val connections = ArrayDeque<RealConnection>()
    
    // 清理任务
    private val cleanupRunnable = Runnable {
        while (true) {
            val waitNanos = cleanup(System.nanoTime())
            if (waitNanos == -1L) return@Runnable
            if (waitNanos > 0) {
                val waitMillis = waitNanos / 1_000_000L
                val waitNanosRemaining = waitNanos - waitMillis * 1_000_000L
                synchronized(this) {
                    try {
                        (this as Object).wait(waitMillis, waitNanosRemaining.toInt())
                    } catch (ignored: InterruptedException) {
                    }
                }
            }
        }
    }
    
    /**
     * 获取可复用的连接
     */
    fun get(
        address: Address,
        routes: List<Route>?
    ): RealConnection? {
        synchronized(this) {
            for (connection in connections) {
                // 检查连接是否可复用
                if (connection.isEligible(address, routes)) {
                    // 标记为正在使用
                    connection.acquire()
                    return connection
                }
            }
        }
        return null
    }
    
    /**
     * 放入连接
     */
    fun put(connection: RealConnection) {
        synchronized(this) {
            connections.add(connection)
            // 启动清理任务
            if (connections.size == 1) {
                executor.execute(cleanupRunnable)
            }
        }
    }
    
    /**
     * 释放连接
     */
    fun release(connection: RealConnection): Boolean {
        synchronized(this) {
            connection.release()
            
            // 如果没有引用，标记空闲时间
            if (connection.allocations.isEmpty()) {
                connection.idleAtNanos = System.nanoTime()
                // 通知清理线程
                (this as Object).notifyAll()
                return true
            }
            return false
        }
    }
    
    /**
     * 清理过期连接
     */
    private fun cleanup(now: Long): Long {
        var inUseConnectionCount = 0
        var idleConnectionCount = 0
        var longestIdleConnection: RealConnection? = null
        var longestIdleDurationNs = Long.MIN_VALUE
        
        synchronized(this) {
            val iterator = connections.iterator()
            while (iterator.hasNext()) {
                val connection = iterator.next()
                
                // 检查是否正在使用
                if (connection.allocations.isNotEmpty()) {
                    inUseConnectionCount++
                    continue
                }
                
                idleConnectionCount++
                
                // 计算空闲时间
                val idleDurationNs = now - connection.idleAtNanos
                if (idleDurationNs > longestIdleDurationNs) {
                    longestIdleDurationNs = idleDurationNs
                    longestIdleConnection = connection
                }
            }
            
            val keepAliveDurationNs = keepAliveUnit.toNanos(keepAliveDuration)
            
            when {
                // 超过最大空闲时间或空闲连接数过多，移除
                longestIdleDurationNs >= keepAliveDurationNs
                    || idleConnectionCount > maxIdleConnections -> {
                    connections.remove(longestIdleConnection)
                }
                // 有空闲连接，计算下次清理时间
                idleConnectionCount > 0 -> {
                    return keepAliveDurationNs - longestIdleDurationNs
                }
                // 有使用中的连接，等待
                inUseConnectionCount > 0 -> {
                    return keepAliveDurationNs
                }
                // 没有连接，停止清理
                else -> {
                    return -1
                }
            }
        }
        
        // 关闭移除的连接
        longestIdleConnection?.socket?.close()
        
        // 立即再次清理
        return 0
    }
    
    companion object {
        private val executor = ThreadPoolExecutor(
            0, Int.MAX_VALUE,
            60L, TimeUnit.SECONDS,
            SynchronousQueue(),
            ThreadFactory { Thread(it, "ConnectionPool") }
        )
    }
}
```

### 2.5 扩展性考虑

1. **拦截器机制**：支持应用拦截器和网络拦截器，可灵活添加功能
2. **转换器**：支持自定义数据转换器（JSON、XML、ProtoBuf等）
3. **调用适配器**：支持RxJava、协程等不同调用方式
4. **DNS解析**：支持自定义DNS解析器
5. **证书校验**：支持自定义证书校验逻辑

### 2.6 面试回答要点

1. **分层架构**：接口层、适配层、拦截器层、连接层、Socket层
2. **拦截器链**：责任链模式，请求和响应双向传递
3. **连接复用**：ConnectionPool管理TCP连接，减少握手开销
4. **缓存策略**：基于HTTP缓存头实现，支持强制缓存和协商缓存
5. **线程模型**：Dispatcher管理异步请求，支持并发控制
6. **HTTP/2支持**：多路复用、头部压缩、服务器推送

---

## 三、设计 EventBus

### 3.1 需求分析

#### 功能性需求
- 支持事件的发布和订阅
- 支持指定线程接收事件
- 支持粘性事件（Sticky Event）
- 支持事件优先级
- 支持订阅者继承

#### 非功能性需求
- **高性能**：快速的事件分发
- **低耦合**：发布者和订阅者完全解耦
- **类型安全**：编译期检查事件类型
- **内存安全**：防止内存泄漏
- **易用性**：注解配置、简洁API

### 3.2 架构设计

```
┌─────────────────────────────────────────────────────────────────┐
│                        Publisher (发布者)                        │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  EventBus.getDefault().post(MessageEvent("Hello"))      │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                      EventBus Core (核心)                        │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐      │
│  │SubscriberIndex│  │SubscriberInfo│  │ ThreadMode       │      │
│  │ (订阅者索引)  │  │ (订阅者信息) │  │ (线程模式)       │      │
│  └──────────────┘  └──────────────┘  └──────────────────┘      │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐      │
│  │ Poster       │  │ StickyEvents │  │ EventInheritance │      │
│  │ (事件投递器) │  │ (粘性事件)   │  │ (事件继承)       │      │
│  └──────────────┘  └──────────────┘  └──────────────────┘      │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                      Subscriber (订阅者)                         │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  @Subscribe(threadMode = ThreadMode.MAIN)               │   │
│  │  fun onMessageEvent(event: MessageEvent) { ... }        │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

### 3.3 核心模块设计

#### 3.3.1 线程模式

```
┌─────────────────────────────────────────────────────────────────┐
│                        ThreadMode                                │
├─────────────────────────────────────────────────────────────────┤
│  POSTING     │ 在发布事件的线程中执行                           │
├─────────────────────────────────────────────────────────────────┤
│  MAIN        │ 在主线程中执行，如果发布线程是主线程则直接执行    │
├─────────────────────────────────────────────────────────────────┤
│  MAIN_ORDERED│ 在主线程中执行，总是通过Handler排队执行          │
├─────────────────────────────────────────────────────────────────┤
│  BACKGROUND  │ 在后台线程执行，如果发布线程是后台则直接执行      │
├─────────────────────────────────────────────────────────────────┤
│  ASYNC       │ 总是在新的后台线程中执行                         │
└─────────────────────────────────────────────────────────────────┘
```

### 3.4 关键代码实现

#### 3.4.1 核心类实现

```kotlin
/**
 * EventBus 核心类
 * 单例模式 + 建造者模式
 */
class EventBus private constructor(
    private val builder: EventBusBuilder
) {
    // 订阅者方法映射：事件类型 -> 订阅列表
    private val subscriptionsByEventType = ConcurrentHashMap<Class<*>, CopyOnWriteArrayList<Subscription>>()
    
    // 订阅者的所有事件类型：订阅者 -> 事件类型列表
    private val typesBySubscriber = ConcurrentHashMap<Any, MutableList<Class<*>>>()
    
    // 粘性事件：事件类型 -> 最新事件
    private val stickyEvents = ConcurrentHashMap<Class<*>, Any>()
    
    // 当前发布状态（线程本地变量）
    private val currentPostingThreadState = object : ThreadLocal<PostingThreadState>() {
        override fun initialValue() = PostingThreadState()
    }
    
    // 主线程投递器
    private val mainThreadPoster: Poster = HandlerPoster(Looper.getMainLooper(), 10)
    
    // 后台线程投递器
    private val backgroundPoster: Poster = BackgroundPoster(this)
    
    // 异步投递器
    private val asyncPoster: Poster = AsyncPoster(this)
    
    // 订阅者方法查找器
    private val subscriberMethodFinder = SubscriberMethodFinder(builder.subscriberInfoIndexes)
    
    companion object {
        @Volatile
        private var defaultInstance: EventBus? = null
        
        fun getDefault(): EventBus {
            return defaultInstance ?: synchronized(this) {
                defaultInstance ?: EventBus(EventBusBuilder()).also {
                    defaultInstance = it
                }
            }
        }
        
        fun builder(): EventBusBuilder = EventBusBuilder()
    }
    
    /**
     * 注册订阅者
     */
    fun register(subscriber: Any) {
        val subscriberClass = subscriber.javaClass
        
        // 查找订阅方法
        val subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass)
        
        synchronized(this) {
            for (subscriberMethod in subscriberMethods) {
                subscribe(subscriber, subscriberMethod)
            }
        }
    }
    
    /**
     * 订阅单个方法
     */
    private fun subscribe(subscriber: Any, subscriberMethod: SubscriberMethod) {
        val eventType = subscriberMethod.eventType
        val newSubscription = Subscription(subscriber, subscriberMethod)
        
        // 获取该事件类型的订阅列表
        var subscriptions = subscriptionsByEventType[eventType]
        if (subscriptions == null) {
            subscriptions = CopyOnWriteArrayList()
            subscriptionsByEventType[eventType] = subscriptions
        } else {
            // 检查是否重复注册
            if (subscriptions.contains(newSubscription)) {
                throw EventBusException("Subscriber ${subscriber.javaClass} already registered to event $eventType")
            }
        }
        
        // 按优先级插入
        val size = subscriptions.size
        for (i in 0..size) {
            if (i == size || subscriberMethod.priority > subscriptions[i].subscriberMethod.priority) {
                subscriptions.add(i, newSubscription)
                break
            }
        }
        
        // 记录订阅者的事件类型
        var subscribedEvents = typesBySubscriber[subscriber]
        if (subscribedEvents == null) {
            subscribedEvents = mutableListOf()
            typesBySubscriber[subscriber] = subscribedEvents
        }
        subscribedEvents.add(eventType)
        
        // 处理粘性事件
        if (subscriberMethod.sticky) {
            if (builder.eventInheritance) {
                // 考虑事件继承
                val stickyEventEntries = stickyEvents.entries
                for ((stickyEventType, stickyEvent) in stickyEventEntries) {
                    if (eventType.isAssignableFrom(stickyEventType)) {
                        checkPostStickyEventToSubscription(newSubscription, stickyEvent)
                    }
                }
            } else {
                val stickyEvent = stickyEvents[eventType]
                if (stickyEvent != null) {
                    checkPostStickyEventToSubscription(newSubscription, stickyEvent)
                }
            }
        }
    }
    
    /**
     * 取消注册
     */
    fun unregister(subscriber: Any) {
        val subscribedTypes = typesBySubscriber[subscriber]
        if (subscribedTypes != null) {
            for (eventType in subscribedTypes) {
                unsubscribeByEventType(subscriber, eventType)
            }
            typesBySubscriber.remove(subscriber)
        }
    }
    
    private fun unsubscribeByEventType(subscriber: Any, eventType: Class<*>) {
        val subscriptions = subscriptionsByEventType[eventType]
        if (subscriptions != null) {
            val iterator = subscriptions.iterator()
            while (iterator.hasNext()) {
                val subscription = iterator.next()
                if (subscription.subscriber === subscriber) {
                    subscription.active = false
                    subscriptions.remove(subscription)
                }
            }
        }
    }
    
    /**
     * 发布事件
     */
    fun post(event: Any) {
        val postingState = currentPostingThreadState.get()!!
        val eventQueue = postingState.eventQueue
        eventQueue.add(event)
        
        if (!postingState.isPosting) {
            postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper()
            postingState.isPosting = true
            
            try {
                while (eventQueue.isNotEmpty()) {
                    postSingleEvent(eventQueue.removeFirst(), postingState)
                }
            } finally {
                postingState.isPosting = false
                postingState.isMainThread = false
            }
        }
    }
    
    /**
     * 发布粘性事件
     */
    fun postSticky(event: Any) {
        synchronized(stickyEvents) {
            stickyEvents[event.javaClass] = event
        }
        post(event)
    }
    
    /**
     * 发布单个事件
     */
    private fun postSingleEvent(event: Any, postingState: PostingThreadState) {
        val eventClass = event.javaClass
        var subscriptionFound = false
        
        if (builder.eventInheritance) {
            // 查找所有父类和接口
            val eventTypes = lookupAllEventTypes(eventClass)
            for (clazz in eventTypes) {
                subscriptionFound = subscriptionFound or postSingleEventForEventType(event, postingState, clazz)
            }
        } else {
            subscriptionFound = postSingleEventForEventType(event, postingState, eventClass)
        }
        
        if (!subscriptionFound) {
            if (builder.logNoSubscriberMessages) {
                Log.d(TAG, "No subscribers registered for event ${eventClass.simpleName}")
            }
            if (builder.sendNoSubscriberEvent && eventClass != NoSubscriberEvent::class.java) {
                post(NoSubscriberEvent(this, event))
            }
        }
    }
    
    private fun postSingleEventForEventType(
        event: Any,
        postingState: PostingThreadState,
        eventClass: Class<*>
    ): Boolean {
        val subscriptions = subscriptionsByEventType[eventClass] ?: return false
        
        for (subscription in subscriptions) {
            postingState.event = event
            postingState.subscription = subscription
            
            var aborted = false
            try {
                postToSubscription(subscription, event, postingState.isMainThread)
                aborted = postingState.canceled
            } finally {
                postingState.event = null
                postingState.subscription = null
                postingState.canceled = false
            }
            
            if (aborted) break
        }
        
        return true
    }
    
    /**
     * 根据线程模式投递事件
     */
    private fun postToSubscription(subscription: Subscription, event: Any, isMainThread: Boolean) {
        when (subscription.subscriberMethod.threadMode) {
            ThreadMode.POSTING -> {
                // 直接在当前线程调用
                invokeSubscriber(subscription, event)
            }
            ThreadMode.MAIN -> {
                if (isMainThread) {
                    invokeSubscriber(subscription, event)
                } else {
                    mainThreadPoster.enqueue(subscription, event)
                }
            }
            ThreadMode.MAIN_ORDERED -> {
                mainThreadPoster.enqueue(subscription, event)
            }
            ThreadMode.BACKGROUND -> {
                if (isMainThread) {
                    backgroundPoster.enqueue(subscription, event)
                } else {
                    invokeSubscriber(subscription, event)
                }
            }
            ThreadMode.ASYNC -> {
                asyncPoster.enqueue(subscription, event)
            }
        }
    }
    
    /**
     * 反射调用订阅方法
     */
    internal fun invokeSubscriber(subscription: Subscription, event: Any) {
        try {
            subscription.subscriberMethod.method.invoke(subscription.subscriber, event)
        } catch (e: InvocationTargetException) {
            handleSubscriberException(subscription, event, e.cause)
        }
    }
    
    /**
     * 查找事件的所有父类和接口
     */
    private fun lookupAllEventTypes(eventClass: Class<*>): List<Class<*>> {
        val eventTypes = mutableListOf<Class<*>>()
        var clazz: Class<*>? = eventClass
        
        while (clazz != null) {
            eventTypes.add(clazz)
            addInterfaces(eventTypes, clazz.interfaces)
            clazz = clazz.superclass
        }
        
        return eventTypes
    }
    
    private fun addInterfaces(eventTypes: MutableList<Class<*>>, interfaces: Array<Class<*>>) {
        for (interfaceClass in interfaces) {
            if (!eventTypes.contains(interfaceClass)) {
                eventTypes.add(interfaceClass)
                addInterfaces(eventTypes, interfaceClass.interfaces)
            }
        }
    }
}

/**
 * 订阅方法注解
 */
@Target(AnnotationTarget.FUNCTION)
@Retention(AnnotationRetention.RUNTIME)
annotation class Subscribe(
    val threadMode: ThreadMode = ThreadMode.POSTING,
    val sticky: Boolean = false,
    val priority: Int = 0
)

/**
 * 线程模式枚举
 */
enum class ThreadMode {
    POSTING,      // 发布线程
    MAIN,         // 主线程
    MAIN_ORDERED, // 主线程（排队）
    BACKGROUND,   // 后台线程
    ASYNC         // 异步线程
}

/**
 * 订阅信息
 */
data class Subscription(
    val subscriber: Any,
    val subscriberMethod: SubscriberMethod,
    @Volatile var active: Boolean = true
)

/**
 * 订阅方法信息
 */
data class SubscriberMethod(
    val method: Method,
    val eventType: Class<*>,
    val threadMode: ThreadMode,
    val priority: Int,
    val sticky: Boolean
)

/**
 * 发布状态（线程本地）
 */
class PostingThreadState {
    val eventQueue = ArrayDeque<Any>()
    var isPosting = false
    var isMainThread = false
    var subscription: Subscription? = null
    var event: Any? = null
    var canceled = false
}
```

#### 3.4.2 订阅方法查找器

```kotlin
/**
 * 订阅方法查找器
 * 支持运行时反射和编译时索引两种方式
 */
class SubscriberMethodFinder(
    private val subscriberInfoIndexes: List<SubscriberInfoIndex>?
) {
    // 方法缓存
    private val methodCache = ConcurrentHashMap<Class<*>, List<SubscriberMethod>>()
    
    companion object {
        private const val MODIFIERS_IGNORE = Modifier.ABSTRACT or Modifier.STATIC
    }
    
    fun findSubscriberMethods(subscriberClass: Class<*>): List<SubscriberMethod> {
        // 先从缓存获取
        var subscriberMethods = methodCache[subscriberClass]
        if (subscriberMethods != null) {
            return subscriberMethods
        }
        
        // 优先使用编译时索引
        subscriberMethods = if (subscriberInfoIndexes != null) {
            findUsingInfo(subscriberClass)
        } else {
            findUsingReflection(subscriberClass)
        }
        
        if (subscriberMethods.isEmpty()) {
            throw EventBusException("Subscriber ${subscriberClass.name} has no public methods with @Subscribe annotation")
        }
        
        methodCache[subscriberClass] = subscriberMethods
        return subscriberMethods
    }
    
    /**
     * 使用编译时索引查找（APT生成）
     */
    private fun findUsingInfo(subscriberClass: Class<*>): List<SubscriberMethod> {
        val findState = FindState()
        findState.initForSubscriber(subscriberClass)
        
        while (findState.clazz != null) {
            findState.subscriberInfo = getSubscriberInfo(findState)
            
            if (findState.subscriberInfo != null) {
                val array = findState.subscriberInfo!!.subscriberMethods
                for (subscriberMethod in array) {
                    if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) {
                        findState.subscriberMethods.add(subscriberMethod)
                    }
                }
            } else {
                // 索引中没有，使用反射
                findUsingReflectionInSingleClass(findState)
            }
            
            findState.moveToSuperclass()
        }
        
        return findState.subscriberMethods
    }
    
    /**
     * 使用反射查找
     */
    private fun findUsingReflection(subscriberClass: Class<*>): List<SubscriberMethod> {
        val findState = FindState()
        findState.initForSubscriber(subscriberClass)
        
        while (findState.clazz != null) {
            findUsingReflectionInSingleClass(findState)
            findState.moveToSuperclass()
        }
        
        return findState.subscriberMethods
    }
    
    /**
     * 在单个类中使用反射查找
     */
    private fun findUsingReflectionInSingleClass(findState: FindState) {
        val methods: Array<Method>
        try {
            // 使用getDeclaredMethods比getMethods更快
            methods = findState.clazz!!.declaredMethods
        } catch (th: Throwable) {
            // 某些设备可能抛出异常
            methods = findState.clazz!!.methods
            findState.skipSuperClasses = true
        }
        
        for (method in methods) {
            val modifiers = method.modifiers
            
            // 必须是public且非static、非abstract
            if (modifiers and Modifier.PUBLIC != 0 && modifiers and MODIFIERS_IGNORE == 0) {
                val parameterTypes = method.parameterTypes
                
                // 必须只有一个参数
                if (parameterTypes.size == 1) {
                    val subscribeAnnotation = method.getAnnotation(Subscribe::class.java)
                    
                    if (subscribeAnnotation != null) {
                        val eventType = parameterTypes[0]
                        
                        if (findState.checkAdd(method, eventType)) {
                            val threadMode = subscribeAnnotation.threadMode
                            findState.subscriberMethods.add(
                                SubscriberMethod(
                                    method = method,
                                    eventType = eventType,
                                    threadMode = threadMode,
                                    priority = subscribeAnnotation.priority,
                                    sticky = subscribeAnnotation.sticky
                                )
                            )
                        }
                    }
                }
            }
        }
    }
    
    private fun getSubscriberInfo(findState: FindState): SubscriberInfo? {
        if (subscriberInfoIndexes != null) {
            for (index in subscriberInfoIndexes) {
                val info = index.getSubscriberInfo(findState.clazz!!)
                if (info != null) {
                    return info
                }
            }
        }
        return null
    }
    
    /**
     * 查找状态
     */
    class FindState {
        val subscriberMethods = mutableListOf<SubscriberMethod>()
        val anyMethodByEventType = HashMap<Class<*>, Any>()
        val subscriberClassByMethodKey = HashMap<String, Class<*>>()
        
        var subscriberClass: Class<*>? = null
        var clazz: Class<*>? = null
        var skipSuperClasses = false
        var subscriberInfo: SubscriberInfo? = null
        
        fun initForSubscriber(subscriberClass: Class<*>) {
            this.subscriberClass = subscriberClass
            this.clazz = subscriberClass
            skipSuperClasses = false
            subscriberInfo = null
        }
        
        fun checkAdd(method: Method, eventType: Class<*>): Boolean {
            val existing = anyMethodByEventType.put(eventType, method)
            if (existing == null) {
                return true
            }
            
            // 检查方法签名
            if (existing is Method) {
                if (!checkAddWithMethodSignature(existing, eventType)) {
                    throw IllegalStateException()
                }
                anyMethodByEventType[eventType] = FindState::class.java
            }
            
            return checkAddWithMethodSignature(method, eventType)
        }
        
        private fun checkAddWithMethodSignature(method: Method, eventType: Class<*>): Boolean {
            val methodKey = "${method.name}>${eventType.name}"
            val methodClass = method.declaringClass
            val methodClassOld = subscriberClassByMethodKey.put(methodKey, methodClass)
            
            return methodClassOld == null || methodClassOld.isAssignableFrom(methodClass)
        }
        
        fun moveToSuperclass() {
            if (skipSuperClasses) {
                clazz = null
            } else {
                clazz = clazz?.superclass
                val name = clazz?.name
                
                // 跳过系统类
                if (name == null || name.startsWith("java.") || name.startsWith("javax.") || name.startsWith("android.")) {
                    clazz = null
                }
            }
        }
    }
}
```

#### 3.4.3 线程投递器实现

```kotlin
/**
 * 投递器接口
 */
interface Poster {
    fun enqueue(subscription: Subscription, event: Any)
}

/**
 * 主线程投递器 - 基于Handler
 */
class HandlerPoster(
    looper: Looper,
    private val maxMillisInsideHandleMessage: Int
) : Handler(looper), Poster {
    
    private val queue = PendingPostQueue()
    private var handlerActive = false
    
    override fun enqueue(subscription: Subscription, event: Any) {
        val pendingPost = PendingPost.obtainPendingPost(subscription, event)
        synchronized(this) {
            queue.enqueue(pendingPost)
            if (!handlerActive) {
                handlerActive = true
                if (!sendMessage(obtainMessage())) {
                    throw EventBusException("Could not send handler message")
                }
            }
        }
    }
    
    override fun handleMessage(msg: Message) {
        var rescheduled = false
        try {
            val started = SystemClock.uptimeMillis()
            while (true) {
                val pendingPost = queue.poll() ?: break
                
                EventBus.getDefault().invokeSubscriber(
                    pendingPost.subscription!!,
                    pendingPost.event!!
                )
                pendingPost.recycle()
                
                // 检查是否超时，避免阻塞主线程
                val timeInMethod = SystemClock.uptimeMillis() - started
                if (timeInMethod >= maxMillisInsideHandleMessage) {
                    if (!sendMessage(obtainMessage())) {
                        throw EventBusException("Could not send handler message")
                    }
                    rescheduled = true
                    return
                }
            }
        } finally {
            handlerActive = rescheduled
        }
    }
}

/**
 * 后台线程投递器
 */
class BackgroundPoster(
    private val eventBus: EventBus
) : Poster, Runnable {
    
    private val queue = PendingPostQueue()
    @Volatile
    private var executorRunning = false
    
    override fun enqueue(subscription: Subscription, event: Any) {
        val pendingPost = PendingPost.obtainPendingPost(subscription, event)
        synchronized(this) {
            queue.enqueue(pendingPost)
            if (!executorRunning) {
                executorRunning = true
                eventBus.executorService.execute(this)
            }
        }
    }
    
    override fun run() {
        try {
            while (true) {
                var pendingPost = queue.poll(1000)
                if (pendingPost == null) {
                    synchronized(this) {
                        pendingPost = queue.poll()
                        if (pendingPost == null) {
                            executorRunning = false
                            return
                        }
                    }
                }
                eventBus.invokeSubscriber(pendingPost.subscription!!, pendingPost.event!!)
                pendingPost.recycle()
            }
        } finally {
            executorRunning = false
        }
    }
}

/**
 * 异步投递器 - 每个事件一个线程
 */
class AsyncPoster(
    private val eventBus: EventBus
) : Poster, Runnable {
    
    private val queue = PendingPostQueue()
    
    override fun enqueue(subscription: Subscription, event: Any) {
        val pendingPost = PendingPost.obtainPendingPost(subscription, event)
        queue.enqueue(pendingPost)
        eventBus.executorService.execute(this)
    }
    
    override fun run() {
        val pendingPost = queue.poll() ?: throw IllegalStateException("No pending post available")
        eventBus.invokeSubscriber(pendingPost.subscription!!, pendingPost.event!!)
        pendingPost.recycle()
    }
}

/**
 * 待处理事件 - 对象池复用
 */
class PendingPost private constructor() {
    var event: Any? = null
    var subscription: Subscription? = null
    var next: PendingPost? = null
    
    fun recycle() {
        event = null
        subscription = null
        synchronized(pendingPostPool) {
            if (pendingPostPool.size < 10000) {
                next = pendingPostPool.firstOrNull()
                pendingPostPool.add(0, this)
            }
        }
    }
    
    companion object {
        private val pendingPostPool = mutableListOf<PendingPost>()
        
        fun obtainPendingPost(subscription: Subscription, event: Any): PendingPost {
            synchronized(pendingPostPool) {
                val pendingPost = if (pendingPostPool.isNotEmpty()) {
                    pendingPostPool.removeAt(0)
                } else {
                    PendingPost()
                }
                pendingPost.event = event
                pendingPost.subscription = subscription
                pendingPost.next = null
                return pendingPost
            }
        }
    }
}
```

### 3.5 扩展性考虑

1. **编译时索引**：通过APT生成订阅者索引，避免运行时反射
2. **自定义线程池**：支持配置自定义ExecutorService
3. **事件继承**：支持配置是否处理事件的父类
4. **异常处理**：支持自定义异常处理器
5. **日志输出**：支持配置日志级别和输出方式

### 3.6 面试回答要点

1. **核心数据结构**：subscriptionsByEventType（事件类型→订阅列表）、typesBySubscriber（订阅者→事件类型）
2. **线程切换**：通过Handler（主线程）和ExecutorService（后台线程）实现
3. **粘性事件**：使用Map存储最新事件，新订阅者注册时立即分发
4. **性能优化**：编译时索引避免反射、对象池复用PendingPost
5. **内存安全**：必须成对调用register/unregister，否则内存泄漏
6. **事件继承**：支持向父类事件的订阅者分发

---

## 四、设计路由框架

### 4.1 需求分析

#### 功能性需求
- 支持页面路由跳转
- 支持参数传递和解析
- 支持拦截器机制
- 支持服务发现和调用
- 支持降级处理
- 支持多模块解耦

#### 非功能性需求
- **编译时处理**：APT生成路由表，避免运行时反射
- **类型安全**：编译期检查参数类型
- **高性能**：快速的路由查找
- **可扩展**：支持自定义拦截器和降级策略
- **易用性**：注解配置、链式调用

### 4.2 架构设计

```
┌─────────────────────────────────────────────────────────────────┐
│                        API Layer (接口层)                        │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Router.build("/user/detail")                           │   │
│  │        .withString("userId", "123")                     │   │
│  │        .navigation()                                    │   │
│  └─────────────────────────────────────────────────────────┘   │
├─────────────────────────────────────────────────────────────────┤
│                     Core Layer (核心层)                          │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐      │
│  │ Router       │  │ Postcard     │  │ LogisticsCenter  │      │
│  │ (路由入口)   │  │ (路由信息)   │  │ (物流中心)       │      │
│  └──────────────┘  └──────────────┘  └──────────────────┘      │
├─────────────────────────────────────────────────────────────────┤
│                  Interceptor Layer (拦截器层)                    │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐      │
│  │ LoginIntercept│  │ PermIntercept│  │ CustomIntercept  │      │
│  │ (登录拦截)   │  │ (权限拦截)   │  │ (自定义拦截)     │      │
│  └──────────────┘  └──────────────┘  └──────────────────┘      │
├─────────────────────────────────────────────────────────────────┤
│                   Route Table (路由表)                           │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐      │
│  │ ActivityRoute│  │ ServiceRoute │  │ FragmentRoute    │      │
│  │ (Activity路由)│  │ (服务路由)   │  │ (Fragment路由)   │      │
│  └──────────────┘  └──────────────┘  └──────────────────┘      │
├─────────────────────────────────────────────────────────────────┤
│                     APT Layer (编译时处理)                       │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐      │
│  │ RouteProcessor│  │ AutowiredProc│  │ InterceptorProc  │      │
│  │ (路由处理器) │  │ (自动注入)   │  │ (拦截器处理)     │      │
│  └──────────────┘  └──────────────┘  └──────────────────┘      │
└─────────────────────────────────────────────────────────────────┘
```

### 4.3 核心模块设计

#### 4.3.1 路由流程

```
┌─────────────────────────────────────────────────────────────────┐
│                      Router.navigation()                         │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    1. 构建Postcard（路由信息）                    │
│                    解析path、提取参数                            │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    2. 完善Postcard信息                           │
│                    从路由表查找目标类、类型等                     │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    3. 执行拦截器链                               │
│                    登录检查、权限检查等                          │
└─────────────────────────────────────────────────────────────────┘
                              │
                    ┌─────────┴─────────┐
                    │                   │
                    ▼                   ▼
            ┌───────────────┐   ┌───────────────┐
            │   拦截成功     │   │   拦截失败     │
            │   继续路由     │   │   回调失败     │
            └───────────────┘   └───────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────────────────────────┐
│                    4. 执行路由                                   │
│                    Activity跳转/Fragment获取/服务调用            │
└─────────────────────────────────────────────────────────────────┘
```

### 4.4 关键代码实现

#### 4.4.1 核心注解定义

```kotlin
/**
 * 路由注解 - 标记可路由的组件
 */
@Target(AnnotationTarget.CLASS)
@Retention(AnnotationRetention.BINARY)
annotation class Route(
    val path: String,                    // 路由路径
    val group: String = "",              // 分组（默认取path第一段）
    val name: String = "",               // 路由名称（用于生成文档）
    val extras: Int = Int.MIN_VALUE,     // 额外标记
    val priority: Int = -1               // 优先级
)

/**
 * 自动注入注解 - 标记需要自动注入的字段
 */
@Target(AnnotationTarget.FIELD)
@Retention(AnnotationRetention.BINARY)
annotation class Autowired(
    val name: String = "",               // 参数名（默认取字段名）
    val required: Boolean = false,       // 是否必须
    val desc: String = ""                // 描述
)

/**
 * 拦截器注解
 */
@Target(AnnotationTarget.CLASS)
@Retention(AnnotationRetention.BINARY)
annotation class Interceptor(
    val priority: Int,                   // 优先级，数字越小优先级越高
    val name: String = ""                // 拦截器名称
)
```

#### 4.4.2 路由核心类

```kotlin
/**
 * 路由入口类
 */
object Router {
    private const val TAG = "Router"
    
    // 路由表：group -> (path -> RouteMeta)
    private val routeGroups = ConcurrentHashMap<String, Class<out IRouteGroup>>()
    private val routes = ConcurrentHashMap<String, RouteMeta>()
    
    // 服务表
    private val services = ConcurrentHashMap<Class<*>, IProvider>()
    
    // 拦截器
    private val interceptors = mutableListOf<IInterceptor>()
    
    // 拦截器服务
    private var interceptorService: InterceptorService? = null
    
    /**
     * 初始化
     */
    fun init(application: Application) {
        // 加载路由表
        loadRouteTable()
        // 初始化拦截器
        initInterceptors()
    }
    
    /**
     * 加载路由表
     * 通过APT生成的类加载
     */
    private fun loadRouteTable() {
        try {
            // 扫描APT生成的路由表类
            val routerMap = ClassUtils.getFileNameByPackageName(
                "com.router.routes"
            )
            
            for (className in routerMap) {
                when {
                    className.startsWith("Router$$Root") -> {
                        // 加载根路由表
                        val rootClass = Class.forName(className)
                        val root = rootClass.newInstance() as IRouteRoot
                        root.loadInto(routeGroups)
                    }
                    className.startsWith("Router$$Interceptors") -> {
                        // 加载拦截器
                        val interceptorClass = Class.forName(className)
                        val interceptorGroup = interceptorClass.newInstance() as IInterceptorGroup
                        interceptorGroup.loadInto(interceptors)
                    }
                    className.startsWith("Router$$Providers") -> {
                        // 加载服务提供者
                        val providerClass = Class.forName(className)
                        val providerGroup = providerClass.newInstance() as IProviderGroup
                        providerGroup.loadInto(services)
                    }
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Load route table failed", e)
        }
    }
    
    /**
     * 构建路由
     */
    fun build(path: String): Postcard {
        return build(path, extractGroup(path))
    }
    
    fun build(path: String, group: String): Postcard {
        return Postcard(path, group)
    }
    
    /**
     * 构建URI路由
     */
    fun build(uri: Uri): Postcard {
        return Postcard(uri.path ?: "", extractGroup(uri.path ?: "")).apply {
            // 解析URI参数
            uri.queryParameterNames.forEach { key ->
                uri.getQueryParameter(key)?.let { value ->
                    withString(key, value)
                }
            }
        }
    }
    
    /**
     * 提取分组
     */
    private fun extractGroup(path: String): String {
        require(path.isNotEmpty() && path.startsWith("/")) {
            "Invalid path: $path"
        }
        
        val defaultGroup = path.substring(1).substringBefore("/")
        require(defaultGroup.isNotEmpty()) {
            "Invalid path: $path, can't extract group"
        }
        
        return defaultGroup
    }
    
    /**
     * 执行路由
     */
    internal fun navigation(
        context: Context?,
        postcard: Postcard,
        requestCode: Int,
        callback: NavigationCallback?
    ): Any? {
        try {
            // 1. 完善Postcard信息
            LogisticsCenter.completion(postcard)
        } catch (e: NoRouteFoundException) {
            Log.e(TAG, "Route not found: ${postcard.path}")
            callback?.onLost(postcard)
            
            // 降级处理
            return handleDegradeService(postcard)
        }
        
        callback?.onFound(postcard)
        
        // 2. 检查是否需要拦截
        if (!postcard.isGreenChannel) {
            // 执行拦截器
            interceptorService?.doInterceptions(postcard, object : InterceptorCallback {
                override fun onContinue(postcard: Postcard) {
                    // 拦截通过，继续路由
                    _navigation(context, postcard, requestCode, callback)
                }
                
                override fun onInterrupt(exception: Throwable?) {
                    callback?.onInterrupt(postcard)
                }
            })
            return null
        } else {
            // 绿色通道，直接路由
            return _navigation(context, postcard, requestCode, callback)
        }
    }
    
    /**
     * 实际执行路由
     */
    private fun _navigation(
        context: Context?,
        postcard: Postcard,
        requestCode: Int,
        callback: NavigationCallback?
    ): Any? {
        val currentContext = context ?: Router.context
        
        return when (postcard.type) {
            RouteType.ACTIVITY -> {
                // Activity跳转
                val intent = Intent(currentContext, postcard.destination).apply {
                    putExtras(postcard.extras)
                    flags = postcard.flags
                    
                    // 非Activity Context需要添加FLAG
                    if (currentContext !is Activity) {
                        addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                    }
                }
                
                // 执行跳转
                if (requestCode >= 0 && currentContext is Activity) {
                    currentContext.startActivityForResult(intent, requestCode)
                } else {
                    currentContext.startActivity(intent)
                }
                
                // 转场动画
                if (postcard.enterAnim != -1 && postcard.exitAnim != -1 && currentContext is Activity) {
                    currentContext.overridePendingTransition(postcard.enterAnim, postcard.exitAnim)
                }
                
                callback?.onArrival(postcard)
                null
            }
            
            RouteType.FRAGMENT -> {
                // 返回Fragment实例
                val fragmentClass = postcard.destination
                val fragment = fragmentClass.newInstance() as Fragment
                fragment.arguments = postcard.extras
                callback?.onArrival(postcard)
                fragment
            }
            
            RouteType.PROVIDER -> {
                // 返回服务实例
                callback?.onArrival(postcard)
                postcard.provider
            }
            
            else -> null
        }
    }
    
    /**
     * 获取服务
     */
    fun <T> navigation(service: Class<T>): T? {
        return try {
            val postcard = LogisticsCenter.buildProvider(service.name)
            LogisticsCenter.completion(postcard)
            @Suppress("UNCHECKED_CAST")
            postcard.provider as? T
        } catch (e: Exception) {
            null
        }
    }
    
    /**
     * 注入参数
     */
    fun inject(target: Any) {
        AutowiredService.autowire(target)
    }
}

/**
 * 路由信息类（明信片）
 */
class Postcard(
    val path: String,
    val group: String
) {
    // 目标类
    var destination: Class<*>? = null
    
    // 路由类型
    var type: RouteType = RouteType.UNKNOWN
    
    // 参数
    val extras = Bundle()
    
    // Intent flags
    var flags = 0
    
    // 转场动画
    var enterAnim = -1
    var exitAnim = -1
    
    // 是否绿色通道（跳过拦截器）
    var isGreenChannel = false
    
    // 服务提供者
    var provider: IProvider? = null
    
    // 超时时间
    var timeout = 300L
    
    // 链式调用方法
    fun withString(key: String, value: String?): Postcard {
        extras.putString(key, value)
        return this
    }
    
    fun withInt(key: String, value: Int): Postcard {
        extras.putInt(key, value)
        return this
    }
    
    fun withLong(key: String, value: Long): Postcard {
        extras.putLong(key, value)
        return this
    }
    
    fun withBoolean(key: String, value: Boolean): Postcard {
        extras.putBoolean(key, value)
        return this
    }
    
    fun withSerializable(key: String, value: Serializable?): Postcard {
        extras.putSerializable(key, value)
        return this
    }
    
    fun withParcelable(key: String, value: Parcelable?): Postcard {
        extras.putParcelable(key, value)
        return this
    }
    
    fun withObject(key: String, value: Any?): Postcard {
        // 使用JSON序列化
        extras.putString(key, SerializationService.toJson(value))
        return this
    }
    
    fun withFlags(flags: Int): Postcard {
        this.flags = flags
        return this
    }
    
    fun withTransition(enterAnim: Int, exitAnim: Int): Postcard {
        this.enterAnim = enterAnim
        this.exitAnim = exitAnim
        return this
    }
    
    fun greenChannel(): Postcard {
        this.isGreenChannel = true
        return this
    }
    
    fun setTimeout(timeout: Long): Postcard {
        this.timeout = timeout
        return this
    }
    
    /**
     * 执行路由
     */
    fun navigation(): Any? {
        return navigation(null)
    }
    
    fun navigation(context: Context?): Any? {
        return navigation(context, null)
    }
    
    fun navigation(context: Context?, callback: NavigationCallback?): Any? {
        return Router.navigation(context, this, -1, callback)
    }
    
    fun navigation(activity: Activity, requestCode: Int): Any? {
        return Router.navigation(activity, this, requestCode, null)
    }
}
```

#### 4.4.3 拦截器实现

```kotlin
/**
 * 拦截器接口
 */
interface IInterceptor : IProvider {
    fun process(postcard: Postcard, callback: InterceptorCallback)
}

/**
 * 拦截器回调
 */
interface InterceptorCallback {
    fun onContinue(postcard: Postcard)
    fun onInterrupt(exception: Throwable?)
}

/**
 * 拦截器服务 - 管理拦截器链
 */
class InterceptorServiceImpl : InterceptorService {
    
    private val interceptors = mutableListOf<IInterceptor>()
    
    override fun init(context: Context) {
        // 按优先级排序拦截器
        interceptors.sortBy { it.priority }
    }
    
    override fun doInterceptions(postcard: Postcard, callback: InterceptorCallback) {
        if (interceptors.isEmpty()) {
            callback.onContinue(postcard)
            return
        }
        
        // 在子线程执行拦截器
        LogisticsCenter.executor.execute {
            val interceptorCounter = CancelableCountDownLatch(interceptors.size)
            
            try {
                executeInterceptor(0, interceptorCounter, postcard, callback)
                
                // 等待拦截器执行完成
                interceptorCounter.await(postcard.timeout, TimeUnit.SECONDS)
                
                if (interceptorCounter.count > 0) {
                    // 超时
                    callback.onInterrupt(TimeoutException("Interceptor timeout"))
                }
            } catch (e: Exception) {
                callback.onInterrupt(e)
            }
        }
    }
    
    private fun executeInterceptor(
        index: Int,
        counter: CancelableCountDownLatch,
        postcard: Postcard,
        callback: InterceptorCallback
    ) {
        if (index >= interceptors.size) {
            // 所有拦截器执行完成
            callback.onContinue(postcard)
            return
        }
        
        val interceptor = interceptors[index]
        
        interceptor.process(postcard, object : InterceptorCallback {
            override fun onContinue(postcard: Postcard) {
                counter.countDown()
                // 执行下一个拦截器
                executeInterceptor(index + 1, counter, postcard, callback)
            }
            
            override fun onInterrupt(exception: Throwable?) {
                // 拦截，取消后续执行
                counter.cancel()
                callback.onInterrupt(exception)
            }
        })
    }
}

/**
 * 登录拦截器示例
 */
@Interceptor(priority = 1, name = "登录拦截器")
class LoginInterceptor : IInterceptor {
    
    override fun process(postcard: Postcard, callback: InterceptorCallback) {
        // 检查是否需要登录
        if (postcard.extras.getBoolean("needLogin", false)) {
            if (UserManager.isLoggedIn()) {
                // 已登录，继续
                callback.onContinue(postcard)
            } else {
                // 未登录，跳转登录页
                Router.build("/login/main")
                    .withString("redirect", postcard.path)
                    .navigation()
                callback.onInterrupt(UnauthorizedException("Need login"))
            }
        } else {
            callback.onContinue(postcard)
        }
    }
    
    override fun init(context: Context) {}
}

/**
 * 权限拦截器示例
 */
@Interceptor(priority = 2, name = "权限拦截器")
class PermissionInterceptor : IInterceptor {
    
    override fun process(postcard: Postcard, callback: InterceptorCallback) {
        val requiredPermissions = postcard.extras.getStringArray("permissions")
        
        if (requiredPermissions.isNullOrEmpty()) {
            callback.onContinue(postcard)
            return
        }
        
        // 检查权限
        val deniedPermissions = requiredPermissions.filter {
            ContextCompat.checkSelfPermission(Router.context, it) != PackageManager.PERMISSION_GRANTED
        }
        
        if (deniedPermissions.isEmpty()) {
            callback.onContinue(postcard)
        } else {
            // 请求权限
            PermissionHelper.requestPermissions(deniedPermissions) { granted ->
                if (granted) {
                    callback.onContinue(postcard)
                } else {
                    callback.onInterrupt(PermissionDeniedException("Permission denied"))
                }
            }
        }
    }
    
    override fun init(context: Context) {}
}
```

### 4.5 扩展性考虑

1. **APT编译时处理**：生成路由表，避免运行时反射扫描
2. **分组加载**：按需加载路由表，减少初始化时间
3. **自定义拦截器**：支持添加任意数量的拦截器
4. **降级服务**：路由失败时的降级处理
5. **多进程支持**：支持跨进程路由

### 4.6 面试回答要点

1. **核心流程**：构建Postcard → 完善信息 → 执行拦截器 → 执行路由
2. **APT原理**：编译时扫描注解，生成路由表类
3. **拦截器链**：责任链模式，支持登录、权限等拦截
4. **参数注入**：通过APT生成注入代码，避免反射
5. **分组加载**：按需加载，优化启动性能
6. **降级策略**：路由失败时的兜底处理

---

## 五、设计日志系统

### 5.1 需求分析

#### 功能性需求
- 支持多级别日志（VERBOSE、DEBUG、INFO、WARN、ERROR）
- 支持多种输出目标（控制台、文件、网络）
- 支持日志格式化
- 支持日志过滤
- 支持日志文件管理（大小限制、过期清理）

#### 非功能性需求
- **高性能**：异步写入、批量处理
- **低内存**：内存映射、压缩存储
- **可靠性**：崩溃时不丢失日志
- **安全性**：日志加密、脱敏处理
- **可扩展**：支持自定义输出器和格式化器

### 5.2 架构设计

```
┌─────────────────────────────────────────────────────────────────┐
│                        API Layer (接口层)                        │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Logger.d(TAG, "message")                               │   │
│  │  Logger.e(TAG, "error", exception)                      │   │
│  └─────────────────────────────────────────────────────────┘   │
├─────────────────────────────────────────────────────────────────┤
│                     Core Layer (核心层)                          │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐      │
│  │ LogManager   │  │ LogConfig    │  │ LogDispatcher    │      │
│  │ (日志管理器) │  │ (配置管理)   │  │ (日志分发器)     │      │
│  └──────────────┘  └──────────────┘  └──────────────────┘      │
├─────────────────────────────────────────────────────────────────┤
│                   Format Layer (格式化层)                        │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐      │
│  │ JsonFormatter│  │ TextFormatter│  │ CustomFormatter  │      │
│  │ (JSON格式)   │  │ (文本格式)   │  │ (自定义格式)     │      │
│  └──────────────┘  └──────────────┘  └──────────────────┘      │
├─────────────────────────────────────────────────────────────────┤
│                   Output Layer (输出层)                          │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐      │
│  │ ConsolePrinter│  │ FilePrinter │  │ NetworkPrinter   │      │
│  │ (控制台输出) │  │ (文件输出)   │  │ (网络上报)       │      │
│  └──────────────┘  └──────────────┘  └──────────────────┘      │
├─────────────────────────────────────────────────────────────────┤
│                   Storage Layer (存储层)                         │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐      │
│  │ MmapWriter   │  │ FileManager  │  │ Compressor       │      │
│  │ (内存映射)   │  │ (文件管理)   │  │ (压缩处理)       │      │
│  └──────────────┘  └──────────────┘  └──────────────────┘      │
└─────────────────────────────────────────────────────────────────┘
```

### 5.3 核心模块设计

#### 5.3.1 日志写入流程

```
┌─────────────────────────────────────────────────────────────────┐
│                      Logger.d(TAG, msg)                          │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    1. 级别过滤                                   │
│                    检查是否需要输出                              │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    2. 构建LogRecord                              │
│                    时间戳、线程、堆栈等                          │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    3. 格式化                                     │
│                    JSON/文本/自定义格式                          │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    4. 分发到各输出器                             │
│                    控制台/文件/网络                              │
└─────────────────────────────────────────────────────────────────┘
                              │
              ┌───────────────┼───────────────┐
              ▼               ▼               ▼
      ┌───────────┐   ┌───────────┐   ┌───────────┐
      │  Console  │   │   File    │   │  Network  │
      │  (同步)   │   │  (异步)   │   │  (异步)   │
      └───────────┘   └───────────┘   └───────────┘
```

### 5.4 关键代码实现

#### 5.4.1 核心接口定义

```kotlin
/**
 * 日志系统入口
 */
object Logger {
    private lateinit var config: LogConfig
    private lateinit var dispatcher: LogDispatcher
    
    fun init(config: LogConfig) {
        this.config = config
        this.dispatcher = LogDispatcher(config)
    }
    
    fun v(tag: String, message: String) = log(LogLevel.VERBOSE, tag, message)
    fun d(tag: String, message: String) = log(LogLevel.DEBUG, tag, message)
    fun i(tag: String, message: String) = log(LogLevel.INFO, tag, message)
    fun w(tag: String, message: String) = log(LogLevel.WARN, tag, message)
    fun e(tag: String, message: String, throwable: Throwable? = null) = 
        log(LogLevel.ERROR, tag, message, throwable)
    
    private fun log(level: LogLevel, tag: String, message: String, throwable: Throwable? = null) {
        // 级别过滤
        if (level.priority < config.minLevel.priority) return
        
        // 构建日志记录
        val record = LogRecord(
            level = level,
            tag = tag,
            message = message,
            throwable = throwable,
            timestamp = System.currentTimeMillis(),
            threadName = Thread.currentThread().name,
            threadId = Thread.currentThread().id,
            stackTrace = if (config.showStackTrace) getStackTrace() else null
        )
        
        // 分发日志
        dispatcher.dispatch(record)
    }
    
    private fun getStackTrace(): String {
        val stackTrace = Thread.currentThread().stackTrace
        // 跳过Logger内部调用栈
        val relevantTrace = stackTrace.drop(6).take(5)
        return relevantTrace.joinToString("\n") { 
            "    at ${it.className}.${it.methodName}(${it.fileName}:${it.lineNumber})"
        }
    }
}

/**
 * 日志级别
 */
enum class LogLevel(val priority: Int, val tag: String) {
    VERBOSE(2, "V"),
    DEBUG(3, "D"),
    INFO(4, "I"),
    WARN(5, "W"),
    ERROR(6, "E")
}

/**
 * 日志记录
 */
data class LogRecord(
    val level: LogLevel,
    val tag: String,
    val message: String,
    val throwable: Throwable?,
    val timestamp: Long,
    val threadName: String,
    val threadId: Long,
    val stackTrace: String?
)

/**
 * 日志配置
 */
class LogConfig private constructor(
    val minLevel: LogLevel,
    val showStackTrace: Boolean,
    val printers: List<LogPrinter>,
    val formatter: LogFormatter,
    val filters: List<LogFilter>
) {
    class Builder {
        private var minLevel = LogLevel.DEBUG
        private var showStackTrace = false
        private val printers = mutableListOf<LogPrinter>()
        private var formatter: LogFormatter = DefaultFormatter()
        private val filters = mutableListOf<LogFilter>()
        
        fun minLevel(level: LogLevel) = apply { minLevel = level }
        fun showStackTrace(show: Boolean) = apply { showStackTrace = show }
        fun addPrinter(printer: LogPrinter) = apply { printers.add(printer) }
        fun formatter(formatter: LogFormatter) = apply { this.formatter = formatter }
        fun addFilter(filter: LogFilter) = apply { filters.add(filter) }
        
        fun build(): LogConfig {
            if (printers.isEmpty()) {
                printers.add(ConsolePrinter())
            }
            return LogConfig(minLevel, showStackTrace, printers, formatter, filters)
        }
    }
}
```

#### 5.4.2 日志分发器

```kotlin
/**
 * 日志分发器
 */
class LogDispatcher(private val config: LogConfig) {
    
    fun dispatch(record: LogRecord) {
        // 应用过滤器
        for (filter in config.filters) {
            if (!filter.accept(record)) return
        }
        
        // 格式化
        val formattedLog = config.formatter.format(record)
        
        // 分发到各输出器
        for (printer in config.printers) {
            printer.print(record.level, record.tag, formattedLog)
        }
    }
}

/**
 * 日志格式化器接口
 */
interface LogFormatter {
    fun format(record: LogRecord): String
}

/**
 * 默认格式化器
 */
class DefaultFormatter : LogFormatter {
    private val dateFormat = SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS", Locale.getDefault())
    
    override fun format(record: LogRecord): String {
        val sb = StringBuilder()
        
        // 时间
        sb.append(dateFormat.format(Date(record.timestamp)))
        sb.append(" ")
        
        // 级别
        sb.append("[${record.level.tag}]")
        sb.append(" ")
        
        // 线程
        sb.append("[${record.threadName}]")
        sb.append(" ")
        
        // Tag
        sb.append("[${record.tag}]")
        sb.append(" ")
        
        // 消息
        sb.append(record.message)
        
        // 堆栈
        record.stackTrace?.let {
            sb.append("\n")
            sb.append(it)
        }
        
        // 异常
        record.throwable?.let {
            sb.append("\n")
            sb.append(Log.getStackTraceString(it))
        }
        
        return sb.toString()
    }
}

/**
 * JSON格式化器
 */
class JsonFormatter : LogFormatter {
    private val gson = Gson()
    
    override fun format(record: LogRecord): String {
        val map = mapOf(
            "timestamp" to record.timestamp,
            "level" to record.level.name,
            "tag" to record.tag,
            "message" to record.message,
            "thread" to record.threadName,
            "threadId" to record.threadId,
            "stackTrace" to record.stackTrace,
            "exception" to record.throwable?.let { Log.getStackTraceString(it) }
        )
        return gson.toJson(map)
    }
}

/**
 * 日志过滤器接口
 */
interface LogFilter {
    fun accept(record: LogRecord): Boolean
}

/**
 * Tag过滤器
 */
class TagFilter(private val allowedTags: Set<String>) : LogFilter {
    override fun accept(record: LogRecord): Boolean {
        return allowedTags.isEmpty() || record.tag in allowedTags
    }
}
```

#### 5.4.3 日志输出器

```kotlin
/**
 * 日志输出器接口
 */
interface LogPrinter {
    fun print(level: LogLevel, tag: String, message: String)
}

/**
 * 控制台输出器
 */
class ConsolePrinter : LogPrinter {
    override fun print(level: LogLevel, tag: String, message: String) {
        when (level) {
            LogLevel.VERBOSE -> Log.v(tag, message)
            LogLevel.DEBUG -> Log.d(tag, message)
            LogLevel.INFO -> Log.i(tag, message)
            LogLevel.WARN -> Log.w(tag, message)
            LogLevel.ERROR -> Log.e(tag, message)
        }
    }
}

/**
 * 文件输出器 - 基于mmap实现高性能写入
 */
class FilePrinter(
    private val logDir: String,
    private val maxFileSize: Long = 10 * 1024 * 1024, // 10MB
    private val maxFileCount: Int = 10
) : LogPrinter {
    
    private val writeExecutor = Executors.newSingleThreadExecutor()
    private var mmapWriter: MmapWriter? = null
    private val dateFormat = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())
    
    init {
        initWriter()
    }
    
    private fun initWriter() {
        val fileName = "log_${dateFormat.format(Date())}.log"
        val file = File(logDir, fileName)
        file.parentFile?.mkdirs()
        mmapWriter = MmapWriter(file, maxFileSize)
    }
    
    override fun print(level: LogLevel, tag: String, message: String) {
        writeExecutor.execute {
            try {
                // 检查是否需要滚动文件
                checkRollover()
                
                // 写入日志
                mmapWriter?.write("$message\n")
            } catch (e: Exception) {
                Log.e("FilePrinter", "Write log failed", e)
            }
        }
    }
    
    private fun checkRollover() {
        val writer = mmapWriter ?: return
        
        // 检查文件大小
        if (writer.position >= maxFileSize) {
            writer.close()
            initWriter()
            cleanOldFiles()
        }
        
        // 检查日期变化
        val currentDate = dateFormat.format(Date())
        if (!writer.file.name.contains(currentDate)) {
            writer.close()
            initWriter()
        }
    }
    
    private fun cleanOldFiles() {
        val dir = File(logDir)
        val files = dir.listFiles { file -> file.name.startsWith("log_") }
            ?.sortedByDescending { it.lastModified() }
            ?: return
        
        // 删除超出数量的旧文件
        files.drop(maxFileCount).forEach { it.delete() }
    }
    
    fun flush() {
        mmapWriter?.flush()
    }
    
    fun close() {
        writeExecutor.shutdown()
        mmapWriter?.close()
    }
}

/**
 * Mmap写入器 - 高性能日志写入
 */
class MmapWriter(
    val file: File,
    private val maxSize: Long
) {
    private val randomAccessFile = RandomAccessFile(file, "rw")
    private val channel = randomAccessFile.channel
    private var buffer: MappedByteBuffer
    var position = 0L
        private set
    
    init {
        // 创建内存映射
        buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, maxSize)
        
        // 恢复写入位置
        position = findWritePosition()
        buffer.position(position.toInt())
    }
    
    private fun findWritePosition(): Long {
        // 查找文件末尾位置
        val fileSize = file.length()
        if (fileSize == 0L) return 0
        
        // 从末尾向前查找最后一个换行符
        for (i in minOf(fileSize, maxSize) - 1 downTo 0) {
            buffer.position(i.toInt())
            if (buffer.get() == '\n'.code.toByte()) {
                return i + 1
            }
        }
        return 0
    }
    
    fun write(data: String) {
        val bytes = data.toByteArray(Charsets.UTF_8)
        if (position + bytes.size > maxSize) {
            // 文件已满
            return
        }
        
        buffer.put(bytes)
        position += bytes.size
    }
    
    fun flush() {
        buffer.force()
    }
    
    fun close() {
        flush()
        channel.close()
        randomAccessFile.close()
    }
}
```

### 5.5 扩展性考虑

1. **自定义输出器**：实现LogPrinter接口添加新的输出目标
2. **自定义格式化器**：实现LogFormatter接口自定义日志格式
3. **自定义过滤器**：实现LogFilter接口添加过滤规则
4. **日志加密**：在FilePrinter中添加加密逻辑
5. **日志压缩**：支持gzip压缩存储

### 5.6 面试回答要点

1. **分层架构**：接口层、核心层、格式化层、输出层、存储层
2. **高性能写入**：mmap内存映射，避免频繁IO
3. **异步处理**：文件写入和网络上报使用异步线程
4. **文件管理**：大小限制、日期滚动、过期清理
5. **崩溃保护**：mmap保证崩溃时数据不丢失
6. **扩展性**：策略模式支持自定义组件

---

## 六、设计埋点系统

### 6.1 需求分析

#### 功能性需求
- 支持多种埋点类型（页面、点击、曝光、自定义）
- 支持自动埋点和手动埋点
- 支持埋点参数配置
- 支持埋点数据上报
- 支持埋点数据本地存储

#### 非功能性需求
- **高性能**：不影响主线程、批量上报
- **低功耗**：智能上报策略
- **可靠性**：数据不丢失、重试机制
- **准确性**：去重、时序保证
- **可扩展**：支持多种上报通道

### 6.2 架构设计

```
┌─────────────────────────────────────────────────────────────────┐
│                        API Layer (接口层)                        │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Tracker.trackEvent("click", mapOf("button" to "buy"))  │   │
│  │  Tracker.trackPageView("HomePage")                      │   │
│  └─────────────────────────────────────────────────────────┘   │
├─────────────────────────────────────────────────────────────────┤
│                     Core Layer (核心层)                          │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐      │
│  │ TrackManager │  │ EventBuilder │  │ SessionManager   │      │
│  │ (埋点管理器) │  │ (事件构建)   │  │ (会话管理)       │      │
│  └──────────────┘  └──────────────┘  └──────────────────┘      │
├─────────────────────────────────────────────────────────────────┤
│                   Auto Track Layer (自动埋点层)                  │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐      │
│  │ PageTracker  │  │ ClickTracker │  │ ExposureTracker  │      │
│  │ (页面埋点)   │  │ (点击埋点)   │  │ (曝光埋点)       │      │
│  └──────────────┘  └──────────────┘  └──────────────────┘      │
├─────────────────────────────────────────────────────────────────┤
│                   Storage Layer (存储层)                         │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐      │
│  │ EventQueue   │  │ EventDB      │  │ EventCache       │      │
│  │ (事件队列)   │  │ (持久化)     │  │ (内存缓存)       │      │
│  └──────────────┘  └──────────────┘  └──────────────────┘      │
├─────────────────────────────────────────────────────────────────┤
│                   Upload Layer (上报层)                          │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐      │
│  │ UploadPolicy │  │ Uploader     │  │ RetryManager     │      │
│  │ (上报策略)   │  │ (上报器)     │  │ (重试管理)       │      │
│  └──────────────┘  └──────────────┘  └──────────────────┘      │
└─────────────────────────────────────────────────────────────────┘
```

### 6.3 核心模块设计

#### 6.3.1 埋点数据流

```
┌─────────────────────────────────────────────────────────────────┐
│                      埋点触发                                    │
│              (手动埋点 / 自动埋点)                               │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    1. 构建Event                                  │
│                    添加公共参数、设备信息                        │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    2. 入队列                                     │
│                    内存队列 + 持久化存储                         │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    3. 上报策略判断                               │
│                    实时/定时/条件触发                            │
└─────────────────────────────────────────────────────────────────┘
                              │
              ┌───────────────┼───────────────┐
              ▼               ▼               ▼
      ┌───────────┐   ┌───────────┐   ┌───────────┐
      │  实时上报  │   │  定时上报  │   │  条件上报  │
      │ (重要事件) │   │ (批量)    │   │ (网络/电量)│
      └───────────┘   └───────────┘   └───────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    4. 网络上报                                   │
│                    压缩、加密、重试                              │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    5. 上报结果处理                               │
│                    成功删除 / 失败重试                           │
└─────────────────────────────────────────────────────────────────┘
```

### 6.4 关键代码实现

#### 6.4.1 核心接口定义

```kotlin
/**
 * 埋点系统入口
 */
object Tracker {
    private lateinit var config: TrackerConfig
    private lateinit var trackManager: TrackManager
    private lateinit var sessionManager: SessionManager
    
    fun init(context: Context, config: TrackerConfig) {
        this.config = config
        this.sessionManager = SessionManager(context)
        this.trackManager = TrackManager(context, config, sessionManager)
        
        // 初始化自动埋点
        if (config.enableAutoTrack) {
            AutoTracker.init(context, config)
        }
    }
    
    /**
     * 页面浏览埋点
     */
    fun trackPageView(pageName: String, params: Map<String, Any?> = emptyMap()) {
        val event = TrackEvent(
            eventType = EventType.PAGE_VIEW,
            eventName = "page_view",
            params = params.toMutableMap().apply {
                put("page_name", pageName)
            }
        )
        trackManager.track(event)
    }
    
    /**
     * 页面离开埋点
     */
    fun trackPageLeave(pageName: String, duration: Long) {
        val event = TrackEvent(
            eventType = EventType.PAGE_LEAVE,
            eventName = "page_leave",
            params = mutableMapOf(
                "page_name" to pageName,
                "duration" to duration
            )
        )
        trackManager.track(event)
    }
    
    /**
     * 点击埋点
     */
    fun trackClick(elementId: String, params: Map<String, Any?> = emptyMap()) {
        val event = TrackEvent(
            eventType = EventType.CLICK,
            eventName = "click",
            params = params.toMutableMap().apply {
                put("element_id", elementId)
            }
        )
        trackManager.track(event)
    }
    
    /**
     * 曝光埋点
     */
    fun trackExposure(elementId: String, params: Map<String, Any?> = emptyMap()) {
        val event = TrackEvent(
            eventType = EventType.EXPOSURE,
            eventName = "exposure",
            params = params.toMutableMap().apply {
                put("element_id", elementId)
            }
        )
        trackManager.track(event)
    }
    
    /**
     * 自定义埋点
     */
    fun trackEvent(eventName: String, params: Map<String, Any?> = emptyMap()) {
        val event = TrackEvent(
            eventType = EventType.CUSTOM,
            eventName = eventName,
            params = params.toMutableMap()
        )
        trackManager.track(event)
    }
    
    /**
     * 设置用户ID
     */
    fun setUserId(userId: String) {
        trackManager.setUserId(userId)
    }
    
    /**
     * 设置公共参数
     */
    fun setCommonParams(params: Map<String, Any?>) {
        trackManager.setCommonParams(params)
    }
    
    /**
     * 立即上报
     */
    fun flush() {
        trackManager.flush()
    }
}

/**
 * 事件类型
 */
enum class EventType {
    PAGE_VIEW,    // 页面浏览
    PAGE_LEAVE,   // 页面离开
    CLICK,        // 点击
    EXPOSURE,     // 曝光
    CUSTOM        // 自定义
}

/**
 * 埋点事件
 */
data class TrackEvent(
    val eventId: String = UUID.randomUUID().toString(),
    val eventType: EventType,
    val eventName: String,
    val params: MutableMap<String, Any?>,
    val timestamp: Long = System.currentTimeMillis()
)

/**
 * 埋点配置
 */
class TrackerConfig private constructor(
    val appId: String,
    val appVersion: String,
    val channel: String,
    val uploadUrl: String,
    val enableAutoTrack: Boolean,
    val autoTrackOptions: AutoTrackOptions,
    val uploadPolicy: UploadPolicy,
    val maxCacheSize: Int,
    val maxBatchSize: Int,
    val uploadInterval: Long,
    val enableEncrypt: Boolean,
    val enableCompress: Boolean
) {
    class Builder {
        private var appId = ""
        private var appVersion = ""
        private var channel = ""
        private var uploadUrl = ""
        private var enableAutoTrack = true
        private var autoTrackOptions = AutoTrackOptions()
        private var uploadPolicy = UploadPolicy.BATCH
        private var maxCacheSize = 10000
        private var maxBatchSize = 100
        private var uploadInterval = 30_000L
        private var enableEncrypt = true
        private var enableCompress = true
        
        fun appId(appId: String) = apply { this.appId = appId }
        fun appVersion(version: String) = apply { this.appVersion = version }
        fun channel(channel: String) = apply { this.channel = channel }
        fun uploadUrl(url: String) = apply { this.uploadUrl = url }
        fun enableAutoTrack(enable: Boolean) = apply { this.enableAutoTrack = enable }
        fun autoTrackOptions(options: AutoTrackOptions) = apply { this.autoTrackOptions = options }
        fun uploadPolicy(policy: UploadPolicy) = apply { this.uploadPolicy = policy }
        fun maxCacheSize(size: Int) = apply { this.maxCacheSize = size }
        fun maxBatchSize(size: Int) = apply { this.maxBatchSize = size }
        fun uploadInterval(interval: Long) = apply { this.uploadInterval = interval }
        fun enableEncrypt(enable: Boolean) = apply { this.enableEncrypt = enable }
        fun enableCompress(enable: Boolean) = apply { this.enableCompress = enable }
        
        fun build(): TrackerConfig {
            require(appId.isNotEmpty()) { "appId is required" }
            require(uploadUrl.isNotEmpty()) { "uploadUrl is required" }
            return TrackerConfig(
                appId, appVersion, channel, uploadUrl, enableAutoTrack,
                autoTrackOptions, uploadPolicy, maxCacheSize, maxBatchSize,
                uploadInterval, enableEncrypt, enableCompress
            )
        }
    }
}

/**
 * 自动埋点选项
 */
data class AutoTrackOptions(
    val enablePageView: Boolean = true,
    val enableClick: Boolean = true,
    val enableExposure: Boolean = true
)

/**
 * 上报策略
 */
enum class UploadPolicy {
    REALTIME,     // 实时上报
    BATCH,        // 批量上报
    SMART         // 智能上报（根据网络、电量等）
}
```

#### 6.4.2 埋点管理器

```kotlin
/**
 * 埋点管理器
 */
class TrackManager(
    private val context: Context,
    private val config: TrackerConfig,
    private val sessionManager: SessionManager
) {
    // 事件队列
    private val eventQueue = ConcurrentLinkedQueue<TrackEvent>()
    
    // 事件存储
    private val eventStorage = EventStorage(context)
    
    // 上报器
    private val uploader = EventUploader(config)
    
    // 公共参数
    private val commonParams = ConcurrentHashMap<String, Any?>()
    
    // 设备信息
    private val deviceInfo = DeviceInfo(context)
    
    // 用户ID
    @Volatile
    private var userId: String? = null
    
    // 上报线程
    private val uploadExecutor = Executors.newSingleThreadScheduledExecutor()
    
    init {
        // 恢复未上报的事件
        restoreEvents()
        
        // 启动定时上报
        if (config.uploadPolicy == UploadPolicy.BATCH) {
            startScheduledUpload()
        }
    }
    
    /**
     * 记录埋点
     */
    fun track(event: TrackEvent) {
        // 添加公共参数
        enrichEvent(event)
        
        // 入队列
        eventQueue.offer(event)
        
        // 持久化
        eventStorage.save(event)
        
        // 根据策略上报
        when (config.uploadPolicy) {
            UploadPolicy.REALTIME -> uploadImmediate()
            UploadPolicy.BATCH -> checkBatchUpload()
            UploadPolicy.SMART -> smartUpload()
        }
    }
    
    /**
     * 丰富事件参数
     */
    private fun enrichEvent(event: TrackEvent) {
        event.params.apply {
            // 添加公共参数
            putAll(commonParams)
            
            // 添加设备信息
            put("device_id", deviceInfo.deviceId)
            put("device_model", deviceInfo.model)
            put("os_version", deviceInfo.osVersion)
            put("app_version", config.appVersion)
            put("channel", config.channel)
            
            // 添加会话信息
            put("session_id", sessionManager.sessionId)
            
            // 添加用户信息
            userId?.let { put("user_id", it) }
            
            // 添加网络信息
            put("network_type", NetworkUtils.getNetworkType(context))
        }
    }
    
    /**
     * 立即上报
     */
    private fun uploadImmediate() {
        uploadExecutor.execute {
            doUpload()
        }
    }
    
    /**
     * 检查批量上报
     */
    private fun checkBatchUpload() {
        if (eventQueue.size >= config.maxBatchSize) {
            uploadImmediate()
        }
    }
    
    /**
     * 智能上报
     */
    private fun smartUpload() {
        // 检查网络状态
        if (!NetworkUtils.isWifi(context)) {
            return
        }
        
        // 检查电量
        if (BatteryUtils.getBatteryLevel(context) < 20) {
            return
        }
        
        // 检查队列大小
        if (eventQueue.size >= config.maxBatchSize / 2) {
            uploadImmediate()
        }
    }
    
    /**
     * 启动定时上报
     */
    private fun startScheduledUpload() {
        uploadExecutor.scheduleAtFixedRate(
            { doUpload() },
            config.uploadInterval,
            config.uploadInterval,
            TimeUnit.MILLISECONDS
        )
    }
    
    /**
     * 执行上报
     */
    private fun doUpload() {
        if (eventQueue.isEmpty()) return
        
        // 取出一批事件
        val batch = mutableListOf<TrackEvent>()
        repeat(config.maxBatchSize) {
            eventQueue.poll()?.let { batch.add(it) } ?: return@repeat
        }
        
        if (batch.isEmpty()) return
        
        // 上报
        val success = uploader.upload(batch)
        
        if (success) {
            // 删除已上报的事件
            batch.forEach { eventStorage.delete(it.eventId) }
        } else {
            // 上报失败，重新入队
            batch.forEach { eventQueue.offer(it) }
        }
    }
    
    /**
     * 恢复未上报的事件
     */
    private fun restoreEvents() {
        val events = eventStorage.loadAll()
        events.forEach { eventQueue.offer(it) }
    }
    
    fun setUserId(userId: String) {
        this.userId = userId
    }
    
    fun setCommonParams(params: Map<String, Any?>) {
        commonParams.putAll(params)
    }
    
    fun flush() {
        uploadImmediate()
    }
}

/**
 * 会话管理器
 */
class SessionManager(context: Context) {
    private val prefs = context.getSharedPreferences("tracker_session", Context.MODE_PRIVATE)
    
    var sessionId: String = ""
        private set
    
    private var lastActiveTime = 0L
    
    companion object {
        private const val SESSION_TIMEOUT = 30 * 60 * 1000L // 30分钟
    }
    
    init {
        checkSession()
    }
    
    fun checkSession() {
        val now = System.currentTimeMillis()
        val savedSessionId = prefs.getString("session_id", null)
        val savedLastActive = prefs.getLong("last_active", 0)
        
        if (savedSessionId == null || now - savedLastActive > SESSION_TIMEOUT) {
            // 创建新会话
            sessionId = UUID.randomUUID().toString()
        } else {
            sessionId = savedSessionId
        }
        
        lastActiveTime = now
        saveSession()
    }
    
    fun updateActiveTime() {
        lastActiveTime = System.currentTimeMillis()
        saveSession()
    }
    
    private fun saveSession() {
        prefs.edit()
            .putString("session_id", sessionId)
            .putLong("last_active", lastActiveTime)
            .apply()
    }
}
```

#### 6.4.3 自动埋点实现

```kotlin
/**
 * 自动埋点管理器
 */
object AutoTracker {
    private lateinit var config: TrackerConfig
    
    fun init(context: Context, config: TrackerConfig) {
        this.config = config
        
        val app = context.applicationContext as Application
        
        // 注册Activity生命周期回调
        app.registerActivityLifecycleCallbacks(object : Application.ActivityLifecycleCallbacks {
            private val pageStartTimes = mutableMapOf<String, Long>()
            
            override fun onActivityCreated(activity: Activity, savedInstanceState: Bundle?) {}
            
            override fun onActivityStarted(activity: Activity) {}
            
            override fun onActivityResumed(activity: Activity) {
                if (config.autoTrackOptions.enablePageView) {
                    val pageName = getPageName(activity)
                    pageStartTimes[pageName] = System.currentTimeMillis()
                    Tracker.trackPageView(pageName, getPageParams(activity))
                }
                
                // 初始化点击埋点
                if (config.autoTrackOptions.enableClick) {
                    setupClickTracker(activity)
                }
                
                // 初始化曝光埋点
                if (config.autoTrackOptions.enableExposure) {
                    setupExposureTracker(activity)
                }
            }
            
            override fun onActivityPaused(activity: Activity) {
                if (config.autoTrackOptions.enablePageView) {
                    val pageName = getPageName(activity)
                    val startTime = pageStartTimes.remove(pageName) ?: return
                    val duration = System.currentTimeMillis() - startTime
                    Tracker.trackPageLeave(pageName, duration)
                }
            }
            
            override fun onActivityStopped(activity: Activity) {}
            
            override fun onActivitySaveInstanceState(activity: Activity, outState: Bundle) {}
            
            override fun onActivityDestroyed(activity: Activity) {}
        })
    }
    
    private fun getPageName(activity: Activity): String {
        // 优先使用注解配置的页面名
        val annotation = activity.javaClass.getAnnotation(TrackPage::class.java)
        return annotation?.pageName ?: activity.javaClass.simpleName
    }
    
    private fun getPageParams(activity: Activity): Map<String, Any?> {
        val params = mutableMapOf<String, Any?>()
        
        // 获取Intent参数
        activity.intent?.extras?.let { bundle ->
            for (key in bundle.keySet()) {
                params["intent_$key"] = bundle.get(key)
            }
        }
        
        return params
    }
    
    /**
     * 设置点击埋点
     */
    private fun setupClickTracker(activity: Activity) {
        val rootView = activity.window.decorView
        
        // 遍历View树，为可点击的View添加监听
        traverseViewTree(rootView) { view ->
            if (view.isClickable && view.getTag(R.id.track_click_listener) == null) {
                val originalListener = getOnClickListener(view)
                
                view.setOnClickListener { v ->
                    // 记录点击埋点
                    trackClick(v)
                    // 调用原始监听器
                    originalListener?.onClick(v)
                }
                
                view.setTag(R.id.track_click_listener, true)
            }
        }
    }
    
    private fun trackClick(view: View) {
        val elementId = getElementId(view)
        val params = mutableMapOf<String, Any?>(
            "view_class" to view.javaClass.simpleName,
            "view_id_name" to getViewIdName(view)
        )
        
        // 获取View上的埋点参数
        (view.getTag(R.id.track_params) as? Map<String, Any?>)?.let {
            params.putAll(it)
        }
        
        Tracker.trackClick(elementId, params)
    }
    
    /**
     * 设置曝光埋点
     */
    private fun setupExposureTracker(activity: Activity) {
        val rootView = activity.window.decorView as ViewGroup
        
        // 使用ViewTreeObserver监听布局变化
        rootView.viewTreeObserver.addOnGlobalLayoutListener {
            checkExposure(rootView)
        }
        
        // 监听滚动
        traverseViewTree(rootView) { view ->
            if (view is RecyclerView) {
                view.addOnScrollListener(object : RecyclerView.OnScrollListener() {
                    override fun onScrollStateChanged(recyclerView: RecyclerView, newState: Int) {
                        if (newState == RecyclerView.SCROLL_STATE_IDLE) {
                            checkExposure(recyclerView)
                        }
                    }
                })
            }
        }
    }
    
    private val exposedViews = mutableSetOf<String>()
    
    private fun checkExposure(viewGroup: ViewGroup) {
        traverseViewTree(viewGroup) { view ->
            val trackExposure = view.getTag(R.id.track_exposure) as? Boolean ?: false
            if (trackExposure && isViewVisible(view)) {
                val elementId = getElementId(view)
                if (elementId !in exposedViews) {
                    exposedViews.add(elementId)
                    trackExposure(view)
                }
            }
        }
    }
    
    private fun trackExposure(view: View) {
        val elementId = getElementId(view)
        val params = mutableMapOf<String, Any?>(
            "view_class" to view.javaClass.simpleName
        )
        
        (view.getTag(R.id.track_params) as? Map<String, Any?>)?.let {
            params.putAll(it)
        }
        
        Tracker.trackExposure(elementId, params)
    }
    
    private fun isViewVisible(view: View): Boolean {
        if (!view.isShown) return false
        
        val rect = Rect()
        val isVisible = view.getGlobalVisibleRect(rect)
        
        if (!isVisible) return false
        
        // 检查可见面积是否超过50%
        val visibleArea = rect.width() * rect.height()
        val totalArea = view.width * view.height
        
        return visibleArea >= totalArea * 0.5
    }
    
    private fun traverseViewTree(view: View, action: (View) -> Unit) {
        action(view)
        if (view is ViewGroup) {
            for (i in 0 until view.childCount) {
                traverseViewTree(view.getChildAt(i), action)
            }
        }
    }
    
    private fun getElementId(view: View): String {
        return "${view.javaClass.simpleName}_${view.id}_${view.hashCode()}"
    }
    
    private fun getViewIdName(view: View): String {
        return try {
            if (view.id != View.NO_ID) {
                view.resources.getResourceEntryName(view.id)
            } else {
                "no_id"
            }
        } catch (e: Exception) {
            "unknown"
        }
    }
    
    private fun getOnClickListener(view: View): View.OnClickListener? {
        return try {
            val listenerInfoField = View::class.java.getDeclaredField("mListenerInfo")
            listenerInfoField.isAccessible = true
            val listenerInfo = listenerInfoField.get(view) ?: return null
            
            val onClickListenerField = listenerInfo.javaClass.getDeclaredField("mOnClickListener")
            onClickListenerField.isAccessible = true
            onClickListenerField.get(listenerInfo) as? View.OnClickListener
        } catch (e: Exception) {
            null
        }
    }
}

/**
 * 页面埋点注解
 */
@Target(AnnotationTarget.CLASS)
@Retention(AnnotationRetention.RUNTIME)
annotation class TrackPage(
    val pageName: String
)
```

### 6.5 扩展性考虑

1. **多通道上报**：支持配置多个上报地址
2. **自定义上报策略**：实现UploadPolicy接口
3. **数据加密**：支持自定义加密算法
4. **数据压缩**：支持gzip等压缩方式
5. **AB测试集成**：支持与AB测试系统联动

### 6.6 面试回答要点

1. **分层架构**：接口层、核心层、自动埋点层、存储层、上报层
2. **自动埋点**：通过ActivityLifecycleCallbacks和View遍历实现
3. **数据可靠性**：本地持久化 + 重试机制
4. **上报策略**：实时、批量、智能三种策略
5. **性能优化**：异步处理、批量上报、智能触发
6. **曝光去重**：使用Set记录已曝光元素

---

## 七、常见面试题

### 7.1 图片加载框架相关

**问题1：Glide的三级缓存是如何设计的？**

答案要点：
- **活动资源缓存（ActiveResources）**：使用弱引用存储正在使用的图片，引用计数管理
- **内存缓存（MemoryCache）**：基于LruCache实现，存储最近使用的图片
- **磁盘缓存（DiskCache）**：基于DiskLruCache，分为原始数据缓存和变换后数据缓存
- 查找顺序：活动资源 → 内存缓存 → 磁盘缓存 → 网络
- 活动资源使用弱引用的原因：避免与内存缓存重复存储，减少内存占用

**问题2：如何实现Bitmap复用？**

答案要点：
- 使用BitmapPool管理可复用的Bitmap
- 设置BitmapFactory.Options.inBitmap指定复用的Bitmap
- Android 4.4+支持不同尺寸复用，只要内存大小足够
- 复用条件：Bitmap必须是mutable的，且未被回收
- 复用失败时需要捕获IllegalArgumentException并重试

**问题3：Glide如何感知生命周期？**

答案要点：
- 通过添加空Fragment（RequestManagerFragment）到Activity/Fragment
- Fragment的生命周期回调会通知RequestManager
- onStart时恢复请求，onStop时暂停请求，onDestroy时取消请求
- Application Context使用全局生命周期，不会自动取消
- 这种设计避免了内存泄漏和无效请求

### 7.2 网络请求框架相关

**问题4：OkHttp的拦截器链是如何工作的？**

答案要点：
- 采用责任链模式，每个拦截器处理请求和响应
- 拦截器顺序：应用拦截器 → 重试拦截器 → 桥接拦截器 → 缓存拦截器 → 连接拦截器 → 网络拦截器
- 调用chain.proceed()传递给下一个拦截器
- 请求从前向后传递，响应从后向前返回
- 应用拦截器和网络拦截器的区别：应用拦截器只调用一次，网络拦截器可能因重定向多次调用

**问题5：OkHttp的连接池是如何实现的？**

答案要点：
- ConnectionPool管理TCP连接的复用
- 默认最多5个空闲连接，存活5分钟
- 使用引用计数管理连接的使用状态
- 后台线程定期清理过期连接
- 连接复用条件：相同的Address（host、port、协议等）
- HTTP/2支持多路复用，一个连接可以并发多个请求

**问题6：Retrofit是如何将接口方法转换为HTTP请求的？**

答案要点：
- 使用动态代理拦截接口方法调用
- ServiceMethod解析方法注解，提取HTTP方法、URL、参数等
- CallAdapter将Call转换为其他类型（如Observable、Deferred）
- Converter处理请求体和响应体的序列化/反序列化
- 方法解析结果会被缓存，避免重复解析

### 7.3 EventBus相关

**问题7：EventBus是如何实现线程切换的？**

答案要点：
- POSTING：直接在发布线程调用
- MAIN：通过Handler切换到主线程
- MAIN_ORDERED：总是通过Handler排队执行
- BACKGROUND：如果是主线程则切换到后台线程池
- ASYNC：总是在新的后台线程执行
- HandlerPoster有超时机制，避免阻塞主线程

**问题8：EventBus的粘性事件是如何实现的？**

答案要点：
- 使用ConcurrentHashMap存储最新的粘性事件
- 发布粘性事件时，先存储再发布
- 新订阅者注册时，检查是否有匹配的粘性事件
- 如果有，立即分发给新订阅者
- 支持事件继承，父类事件也会分发给子类订阅者

### 7.4 路由框架相关

**问题9：ARouter是如何实现编译时路由表生成的？**

答案要点：
- 使用APT（Annotation Processing Tool）处理@Route注解
- 编译时扫描所有标注的类，生成路由表类
- 路由表按group分组，支持按需加载
- 生成的类实现IRouteGroup接口，loadInto方法注册路由
- 初始化时通过反射加载生成的类

**问题10：ARouter的拦截器是如何工作的？**

答案要点：
- 拦截器实现IInterceptor接口
- 使用@Interceptor注解标记，指定优先级
- 拦截器按优先级排序，数字越小优先级越高
- 采用责任链模式，调用callback.onContinue()继续
- 支持异步拦截，有超时机制
- 绿色通道可以跳过所有拦截器

### 7.5 日志系统相关

**问题11：如何设计一个高性能的日志系统？**

答案要点：
- 使用mmap内存映射，避免频繁IO
- 异步写入，不阻塞主线程
- 批量写入，减少系统调用
- 文件滚动策略，按大小或日期切分
- 崩溃保护，mmap保证数据不丢失
- 日志压缩，减少存储空间

**问题12：mmap相比普通文件IO有什么优势？**

答案要点：
- 减少数据拷贝，直接操作内存
- 内核自动管理脏页刷新
- 崩溃时数据不会丢失（已写入的部分）
- 支持随机访问，不需要seek
- 适合频繁小量写入的场景
- 缺点：需要预分配文件大小

### 7.6 埋点系统相关

**问题13：如何实现无侵入的自动埋点？**

答案要点：
- 页面埋点：通过ActivityLifecycleCallbacks监听
- 点击埋点：遍历View树，Hook OnClickListener
- 曝光埋点：监听ViewTreeObserver和滚动事件
- 使用ASM字节码插桩实现更彻底的无侵入
- 通过注解配置埋点参数
- 曝光去重，避免重复上报

**问题14：埋点数据如何保证不丢失？**

答案要点：
- 本地持久化存储（SQLite/文件）
- 上报成功后才删除本地数据
- 失败重试机制，指数退避
- 应用启动时恢复未上报数据
- 智能上报策略，避免频繁失败
- 数据过期清理，避免无限积累

**问题15：如何设计埋点系统的上报策略？**

答案要点：
- **实时上报**：重要事件立即上报
- **批量上报**：积累一定数量后批量上报
- **定时上报**：固定间隔上报
- **智能上报**：根据网络、电量等条件决定
- 优先级队列，重要事件优先上报
- 压缩和加密，减少流量和保护隐私

**问题16：如何处理埋点数据的准确性问题？**

答案要点：
- 事件去重：使用唯一ID标识
- 时序保证：使用本地时间戳+服务器校准
- 会话管理：30分钟无活动创建新会话
- 数据校验：上报前校验必填字段
- 采样策略：高频事件可以采样上报
- 数据对账：定期与服务端数据对比

---

## 八、总结

设计题是考察候选人综合能力的重要环节，需要从以下几个维度展示：

### 8.1 架构设计能力
- 分层设计，职责清晰
- 高内聚、低耦合
- 可扩展、可维护

### 8.2 技术深度
- 理解底层原理
- 掌握关键技术点
- 了解性能优化手段

### 8.3 工程思维
- 考虑边界情况
- 关注性能和稳定性
- 重视可测试性

### 8.4 表达能力
- 先整体后细节
- 配合图示说明
- 突出设计亮点

### 8.5 面试技巧
1. **先问清需求**：确认功能范围和非功能需求
2. **先画架构图**：展示整体设计思路
3. **分模块讲解**：逐个模块深入讲解
4. **突出亮点**：强调设计中的创新点
5. **主动延伸**：提及可能的优化方向
