# 系统设计

## 1. 概述

系统设计是 Android 高级开发面试中的核心考察点，主要评估候选人的架构思维、技术视野和解决复杂问题的能力。本章节涵盖大型 App 架构设计、性能监控体系设计、灰度发布与 AB 测试、动态化方案设计四大核心主题。

### 1.1 系统设计面试的考察维度

```
┌─────────────────────────────────────────────────────────────────┐
│                    系统设计面试考察维度                           │
├─────────────────────────────────────────────────────────────────┤
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐ │
│  │  需求分析    │  │  架构设计    │  │  技术选型    │  │ 扩展性  │ │
│  │  - 功能需求  │  │  - 分层设计  │  │  - 框架选择  │  │ - 可扩展│ │
│  │  - 非功能需求│  │  - 模块划分  │  │  - 技术对比  │  │ - 可维护│ │
│  │  - 约束条件  │  │  - 接口定义  │  │  - 方案权衡  │  │ - 可测试│ │
│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘ │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐ │
│  │  性能考量    │  │  稳定性保障  │  │  安全设计    │  │ 成本控制│ │
│  │  - 响应时间  │  │  - 容错机制  │  │  - 数据安全  │  │ - 开发成│ │
│  │  - 资源消耗  │  │  - 降级策略  │  │  - 传输安全  │  │ - 维护成│ │
│  │  - 并发处理  │  │  - 监控告警  │  │  - 权限控制  │  │ - 运营成│ │
│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘ │
└─────────────────────────────────────────────────────────────────┘
```

### 1.2 系统设计回答框架（STAR-T 法则）

```
┌────────────────────────────────────────────────────────────────┐
│                     STAR-T 回答框架                             │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  S - Scenario（场景）                                          │
│      明确业务场景、用户规模、技术约束                            │
│                         ↓                                      │
│  T - Target（目标）                                            │
│      定义设计目标、性能指标、成功标准                            │
│                         ↓                                      │
│  A - Architecture（架构）                                      │
│      整体架构设计、模块划分、技术选型                            │
│                         ↓                                      │
│  R - Realization（实现）                                       │
│      核心模块实现、关键代码、难点解决                            │
│                         ↓                                      │
│  T - Tradeoff（权衡）                                          │
│      方案对比、优缺点分析、扩展性考虑                            │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## 2. 大型 App 架构设计

### 2.1 设计目标与约束

#### 2.1.1 设计目标

```
┌─────────────────────────────────────────────────────────────────┐
│                    大型 App 架构设计目标                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  【可扩展性】                    【可维护性】                     │
│  • 支持业务快速迭代              • 代码结构清晰                   │
│  • 模块独立开发部署              • 职责边界明确                   │
│  • 新功能低成本接入              • 技术债务可控                   │
│                                                                 │
│  【高性能】                      【高稳定性】                     │
│  • 启动时间 < 2s                 • Crash 率 < 0.1%               │
│  • 页面渲染 < 16ms               • ANR 率 < 0.01%                │
│  • 内存占用合理                  • 异常可追溯                     │
│                                                                 │
│  【团队协作】                    【技术演进】                     │
│  • 多团队并行开发                • 技术栈可升级                   │
│  • 代码冲突最小化                • 架构可演进                     │
│  • 编译速度可接受                • 兼容历史代码                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 2.1.2 约束条件

| 约束类型 | 具体约束 | 应对策略 |
|---------|---------|---------|
| 团队规模 | 50+ 开发人员 | 模块化、组件化拆分 |
| 代码规模 | 100万+ 行代码 | 分层架构、依赖管理 |
| 业务复杂度 | 20+ 业务线 | 业务隔离、统一规范 |
| 发版频率 | 每周发版 | CI/CD、自动化测试 |
| 兼容性 | Android 5.0+ | 兼容层、适配策略 |

### 2.2 整体架构设计

#### 2.2.1 分层架构图

```
┌─────────────────────────────────────────────────────────────────────────┐
│                              应用层 (App Shell)                          │
│  ┌─────────────────────────────────────────────────────────────────────┐│
│  │                        主工程 (App Module)                          ││
│  │  • 应用入口 (Application)    • 路由配置    • 初始化管理              ││
│  └─────────────────────────────────────────────────────────────────────┘│
├─────────────────────────────────────────────────────────────────────────┤
│                              业务层 (Business Layer)                     │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐      │
│  │  首页模块 │ │  商城模块 │ │  消息模块 │ │  我的模块 │ │  直播模块 │      │
│  │  :home   │ │  :mall   │ │  :msg    │ │  :mine   │ │  :live   │      │
│  └────┬─────┘ └────┬─────┘ └────┬─────┘ └────┬─────┘ └────┬─────┘      │
│       │            │            │            │            │             │
│       └────────────┴────────────┴────────────┴────────────┘             │
│                                  │                                      │
├──────────────────────────────────┼──────────────────────────────────────┤
│                              功能层 (Feature Layer)                      │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐      │
│  │  分享组件 │ │  支付组件 │ │  播放器  │ │  IM组件  │ │  扫码组件 │      │
│  │ :share   │ │ :pay     │ │ :player  │ │ :im      │ │ :scan    │      │
│  └──────────┘ └──────────┘ └──────────┘ └──────────┘ └──────────┘      │
├─────────────────────────────────────────────────────────────────────────┤
│                              基础层 (Base Layer)                         │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐      │
│  │  网络库  │ │  图片库  │ │  日志库  │ │  存储库  │ │  路由库  │      │
│  │ :network │ │ :image   │ │ :log     │ │ :storage │ │ :router  │      │
│  └──────────┘ └──────────┘ └──────────┘ └──────────┘ └──────────┘      │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐      │
│  │  埋点库  │ │  性能监控 │ │  安全库  │ │  工具库  │ │  UI组件库│      │
│  │ :track   │ │ :apm     │ │ :security│ │ :utils   │ │ :uikit   │      │
│  └──────────┘ └──────────┘ └──────────┘ └──────────┘ └──────────┘      │
├─────────────────────────────────────────────────────────────────────────┤
│                              公共层 (Common Layer)                       │
│  ┌─────────────────────────────────────────────────────────────────────┐│
│  │  :common-api (接口定义)  :common-model (数据模型)  :common-res (资源) ││
│  └─────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────┘
```

#### 2.2.2 模块依赖关系

```
┌─────────────────────────────────────────────────────────────────┐
│                        模块依赖原则                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  【依赖方向】上层依赖下层，禁止反向依赖                           │
│                                                                 │
│       App Shell                                                 │
│           │                                                     │
│           ▼                                                     │
│    ┌──────────────┐                                             │
│    │  业务模块 A   │ ←──────┐                                    │
│    └──────┬───────┘        │                                    │
│           │          禁止横向依赖                                │
│           ▼                │                                    │
│    ┌──────────────┐        │                                    │
│    │  业务模块 B   │ ───────┘                                    │
│    └──────┬───────┘                                             │
│           │                                                     │
│           ▼                                                     │
│    ┌──────────────┐                                             │
│    │   功能组件    │                                             │
│    └──────┬───────┘                                             │
│           │                                                     │
│           ▼                                                     │
│    ┌──────────────┐                                             │
│    │   基础组件    │                                             │
│    └──────┬───────┘                                             │
│           │                                                     │
│           ▼                                                     │
│    ┌──────────────┐                                             │
│    │   公共定义    │                                             │
│    └──────────────┘                                             │
│                                                                 │
│  【业务模块通信】通过路由 + 接口下沉实现                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2.3 核心模块设计

#### 2.3.1 路由框架设计

```kotlin
/**
 * 路由框架核心设计
 * 支持：页面跳转、服务发现、拦截器、降级处理
 */

// ==================== 路由注解定义 ====================
@Target(AnnotationTarget.CLASS)
@Retention(AnnotationRetention.RUNTIME)
annotation class Route(
    val path: String,           // 路由路径
    val group: String = "",     // 分组
    val name: String = "",      // 名称
    val extras: Int = 0         // 额外标记
)

@Target(AnnotationTarget.CLASS)
@Retention(AnnotationRetention.RUNTIME)
annotation class Service(
    val name: String            // 服务名称
)

// ==================== 路由核心类 ====================
object AppRouter {
    
    private val routeTable = ConcurrentHashMap<String, RouteMetadata>()
    private val serviceTable = ConcurrentHashMap<String, Any>()
    private val interceptors = mutableListOf<RouteInterceptor>()
    private val globalDegradeHandler: DegradeHandler? = null
    
    /**
     * 初始化路由表
     * 通过 APT 生成的代码自动注册
     */
    fun init(context: Context) {
        // 加载 APT 生成的路由表
        loadRouteTable()
        // 注册全局拦截器
        registerGlobalInterceptors()
    }
    
    /**
     * 页面跳转
     */
    fun navigate(path: String): NavigationBuilder {
        return NavigationBuilder(path)
    }
    
    /**
     * 获取服务实例
     */
    @Suppress("UNCHECKED_CAST")
    fun <T> getService(serviceClass: Class<T>): T? {
        val serviceName = serviceClass.canonicalName ?: return null
        return serviceTable[serviceName] as? T
    }
    
    /**
     * 路由跳转构建器
     */
    class NavigationBuilder(private val path: String) {
        private val params = Bundle()
        private var requestCode = -1
        private var flags = 0
        private var enterAnim = 0
        private var exitAnim = 0
        private var callback: NavigationCallback? = null
        
        fun withString(key: String, value: String): NavigationBuilder {
            params.putString(key, value)
            return this
        }
        
        fun withInt(key: String, value: Int): NavigationBuilder {
            params.putInt(key, value)
            return this
        }
        
        fun withParcelable(key: String, value: Parcelable): NavigationBuilder {
            params.putParcelable(key, value)
            return this
        }
        
        fun withFlags(flags: Int): NavigationBuilder {
            this.flags = flags
            return this
        }
        
        fun withTransition(enterAnim: Int, exitAnim: Int): NavigationBuilder {
            this.enterAnim = enterAnim
            this.exitAnim = exitAnim
            return this
        }
        
        fun forResult(requestCode: Int): NavigationBuilder {
            this.requestCode = requestCode
            return this
        }
        
        fun callback(callback: NavigationCallback): NavigationBuilder {
            this.callback = callback
            return this
        }
        
        /**
         * 执行跳转
         */
        fun go(context: Context) {
            // 1. 查找路由
            val metadata = routeTable[path]
            if (metadata == null) {
                handleDegrade(context, path, "Route not found")
                return
            }
            
            // 2. 执行拦截器链
            val interceptorChain = InterceptorChain(
                interceptors = interceptors,
                index = 0,
                path = path,
                params = params,
                metadata = metadata
            )
            
            interceptorChain.proceed(object : InterceptorCallback {
                override fun onContinue() {
                    // 3. 执行跳转
                    performNavigation(context, metadata)
                }
                
                override fun onInterrupt(reason: String) {
                    callback?.onInterrupt(reason)
                }
            })
        }
        
        private fun performNavigation(context: Context, metadata: RouteMetadata) {
            when (metadata.type) {
                RouteType.ACTIVITY -> {
                    val intent = Intent(context, metadata.destination).apply {
                        putExtras(params)
                        addFlags(flags)
                    }
                    
                    if (context is Activity && requestCode >= 0) {
                        context.startActivityForResult(intent, requestCode)
                    } else {
                        if (context !is Activity) {
                            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                        }
                        context.startActivity(intent)
                    }
                    
                    // 转场动画
                    if (context is Activity && enterAnim != 0) {
                        context.overridePendingTransition(enterAnim, exitAnim)
                    }
                    
                    callback?.onArrival()
                }
                
                RouteType.FRAGMENT -> {
                    // Fragment 路由处理
                    val fragment = metadata.destination.newInstance() as Fragment
                    fragment.arguments = params
                    callback?.onArrival()
                }
                
                RouteType.SERVICE -> {
                    // 服务路由处理
                }
            }
        }
        
        private fun handleDegrade(context: Context, path: String, reason: String) {
            globalDegradeHandler?.onDegrade(context, path, reason)
            callback?.onLost()
        }
    }
}

// ==================== 拦截器定义 ====================
interface RouteInterceptor {
    fun intercept(chain: InterceptorChain, callback: InterceptorCallback)
    fun priority(): Int = 0
}

/**
 * 登录拦截器示例
 */
class LoginInterceptor : RouteInterceptor {
    
    override fun intercept(chain: InterceptorChain, callback: InterceptorCallback) {
        val metadata = chain.metadata
        
        // 检查是否需要登录
        if (metadata.extras and NEED_LOGIN != 0) {
            if (!UserManager.isLoggedIn()) {
                // 跳转登录页
                AppRouter.navigate("/user/login")
                    .withString("redirect", chain.path)
                    .go(AppContext.get())
                callback.onInterrupt("Need login")
                return
            }
        }
        
        chain.proceed(callback)
    }
    
    override fun priority(): Int = 100
    
    companion object {
        const val NEED_LOGIN = 1
    }
}

/**
 * 降级处理器
 */
interface DegradeHandler {
    fun onDegrade(context: Context, path: String, reason: String)
}

/**
 * 默认降级处理 - 跳转 H5
 */
class DefaultDegradeHandler : DegradeHandler {
    override fun onDegrade(context: Context, path: String, reason: String) {
        // 尝试跳转对应的 H5 页面
        val h5Url = "https://m.example.com$path"
        AppRouter.navigate("/webview/common")
            .withString("url", h5Url)
            .go(context)
    }
}
```

#### 2.3.2 模块通信设计

```kotlin
/**
 * 模块间通信方案
 * 基于接口下沉 + 服务发现
 */

// ==================== 接口定义层 (common-api) ====================

/**
 * 用户模块对外暴露的服务接口
 * 定义在 common-api 模块，所有模块可见
 */
interface IUserService {
    fun isLoggedIn(): Boolean
    fun getUserId(): String?
    fun getUserInfo(): UserInfo?
    fun login(callback: LoginCallback)
    fun logout()
}

/**
 * 支付模块对外暴露的服务接口
 */
interface IPayService {
    fun pay(orderInfo: OrderInfo, callback: PayCallback)
    fun queryPayResult(orderId: String): PayResult
}

/**
 * 分享模块对外暴露的服务接口
 */
interface IShareService {
    fun share(content: ShareContent, callback: ShareCallback)
    fun getSharePlatforms(): List<SharePlatform>
}

// ==================== 服务实现层 (业务模块) ====================

/**
 * 用户服务实现
 * 在 user 模块中实现
 */
@Service(name = "IUserService")
class UserServiceImpl : IUserService {
    
    override fun isLoggedIn(): Boolean {
        return UserManager.isLoggedIn()
    }
    
    override fun getUserId(): String? {
        return UserManager.getUserId()
    }
    
    override fun getUserInfo(): UserInfo? {
        return UserManager.getUserInfo()
    }
    
    override fun login(callback: LoginCallback) {
        // 跳转登录页面
        AppRouter.navigate("/user/login")
            .callback(object : NavigationCallback {
                override fun onArrival() {
                    // 监听登录结果
                    LoginResultBus.observe { result ->
                        if (result.success) {
                            callback.onSuccess(result.userInfo)
                        } else {
                            callback.onFailed(result.errorCode, result.errorMsg)
                        }
                    }
                }
            })
            .go(AppContext.get())
    }
    
    override fun logout() {
        UserManager.logout()
        // 发送登出事件
        EventBus.post(LogoutEvent())
    }
}

// ==================== 服务调用示例 ====================

/**
 * 在商城模块中调用用户服务
 */
class MallViewModel : ViewModel() {
    
    // 通过服务发现获取用户服务
    private val userService: IUserService? by lazy {
        AppRouter.getService(IUserService::class.java)
    }
    
    fun addToCart(productId: String) {
        // 检查登录状态
        if (userService?.isLoggedIn() != true) {
            userService?.login(object : LoginCallback {
                override fun onSuccess(userInfo: UserInfo) {
                    // 登录成功，继续添加购物车
                    doAddToCart(productId)
                }
                
                override fun onFailed(code: Int, msg: String) {
                    // 登录失败
                    showToast("请先登录")
                }
            })
            return
        }
        
        doAddToCart(productId)
    }
    
    private fun doAddToCart(productId: String) {
        viewModelScope.launch {
            val userId = userService?.getUserId() ?: return@launch
            cartRepository.addToCart(userId, productId)
        }
    }
}
```


#### 2.3.3 初始化框架设计

```kotlin
/**
 * 应用初始化框架
 * 支持：依赖管理、异步初始化、优先级控制、性能监控
 */

// ==================== 初始化任务定义 ====================

/**
 * 初始化任务接口
 */
interface InitTask {
    /**
     * 任务名称
     */
    fun name(): String
    
    /**
     * 执行初始化
     */
    fun init(context: Context)
    
    /**
     * 是否在主线程执行
     */
    fun runOnMainThread(): Boolean = true
    
    /**
     * 优先级（数值越大优先级越高）
     */
    fun priority(): Int = 0
    
    /**
     * 依赖的任务
     */
    fun dependencies(): List<String> = emptyList()
    
    /**
     * 是否需要等待完成才能进入首页
     */
    fun needWait(): Boolean = false
}

// ==================== 初始化调度器 ====================

/**
 * 初始化任务调度器
 * 基于有向无环图(DAG)实现任务依赖管理
 */
class InitTaskDispatcher private constructor() {
    
    private val tasks = mutableListOf<InitTask>()
    private val taskMap = mutableMapOf<String, InitTask>()
    private val mainThreadTasks = mutableListOf<InitTask>()
    private val asyncTasks = mutableListOf<InitTask>()
    private val waitTasks = mutableListOf<InitTask>()
    
    private val mainHandler = Handler(Looper.getMainLooper())
    private val executor = Executors.newFixedThreadPool(
        Runtime.getRuntime().availableProcessors()
    )
    
    private val taskLatch = CountDownLatch(0)
    private val taskFinishSet = ConcurrentHashMap.newKeySet<String>()
    
    companion object {
        @Volatile
        private var instance: InitTaskDispatcher? = null
        
        fun getInstance(): InitTaskDispatcher {
            return instance ?: synchronized(this) {
                instance ?: InitTaskDispatcher().also { instance = it }
            }
        }
    }
    
    /**
     * 添加初始化任务
     */
    fun addTask(task: InitTask): InitTaskDispatcher {
        tasks.add(task)
        taskMap[task.name()] = task
        
        if (task.runOnMainThread()) {
            mainThreadTasks.add(task)
        } else {
            asyncTasks.add(task)
        }
        
        if (task.needWait()) {
            waitTasks.add(task)
        }
        
        return this
    }
    
    /**
     * 开始执行初始化
     */
    fun start(context: Context) {
        // 1. 拓扑排序
        val sortedTasks = topologicalSort()
        
        // 2. 记录开始时间
        val startTime = SystemClock.elapsedRealtime()
        
        // 3. 执行异步任务
        val asyncLatch = CountDownLatch(asyncTasks.size)
        for (task in sortedTasks.filter { !it.runOnMainThread() }) {
            executor.execute {
                waitForDependencies(task)
                executeTask(context, task)
                asyncLatch.countDown()
            }
        }
        
        // 4. 执行主线程任务
        for (task in sortedTasks.filter { it.runOnMainThread() }) {
            waitForDependencies(task)
            executeTask(context, task)
        }
        
        // 5. 等待必须完成的任务
        val waitLatch = CountDownLatch(waitTasks.size)
        // ... 等待逻辑
        
        // 6. 记录初始化耗时
        val costTime = SystemClock.elapsedRealtime() - startTime
        AppLog.i("InitTaskDispatcher", "Init completed in ${costTime}ms")
    }
    
    /**
     * 拓扑排序
     */
    private fun topologicalSort(): List<InitTask> {
        val result = mutableListOf<InitTask>()
        val inDegree = mutableMapOf<String, Int>()
        val graph = mutableMapOf<String, MutableList<String>>()
        
        // 初始化入度和邻接表
        for (task in tasks) {
            inDegree[task.name()] = task.dependencies().size
            for (dep in task.dependencies()) {
                graph.getOrPut(dep) { mutableListOf() }.add(task.name())
            }
        }
        
        // BFS 拓扑排序
        val queue: Queue<String> = LinkedList()
        for ((name, degree) in inDegree) {
            if (degree == 0) {
                queue.offer(name)
            }
        }
        
        while (queue.isNotEmpty()) {
            val name = queue.poll()
            taskMap[name]?.let { result.add(it) }
            
            graph[name]?.forEach { next ->
                inDegree[next] = (inDegree[next] ?: 0) - 1
                if (inDegree[next] == 0) {
                    queue.offer(next)
                }
            }
        }
        
        // 检查是否有环
        if (result.size != tasks.size) {
            throw IllegalStateException("Circular dependency detected!")
        }
        
        // 按优先级排序
        return result.sortedByDescending { it.priority() }
    }
    
    /**
     * 等待依赖任务完成
     */
    private fun waitForDependencies(task: InitTask) {
        for (dep in task.dependencies()) {
            while (!taskFinishSet.contains(dep)) {
                Thread.sleep(10)
            }
        }
    }
    
    /**
     * 执行任务
     */
    private fun executeTask(context: Context, task: InitTask) {
        val startTime = SystemClock.elapsedRealtime()
        try {
            task.init(context)
        } catch (e: Exception) {
            AppLog.e("InitTaskDispatcher", "Task ${task.name()} failed", e)
        } finally {
            val costTime = SystemClock.elapsedRealtime() - startTime
            AppLog.i("InitTaskDispatcher", "Task ${task.name()} cost ${costTime}ms")
            taskFinishSet.add(task.name())
        }
    }
}

// ==================== 具体初始化任务示例 ====================

/**
 * 网络库初始化
 */
class NetworkInitTask : InitTask {
    override fun name() = "NetworkInit"
    
    override fun init(context: Context) {
        NetworkManager.init(context)
    }
    
    override fun runOnMainThread() = false
    override fun priority() = 100
    override fun needWait() = true
}

/**
 * 图片库初始化
 */
class ImageInitTask : InitTask {
    override fun name() = "ImageInit"
    
    override fun init(context: Context) {
        ImageLoader.init(context)
    }
    
    override fun runOnMainThread() = false
    override fun priority() = 90
    override fun dependencies() = listOf("NetworkInit")
}

/**
 * 埋点初始化
 */
class TrackInitTask : InitTask {
    override fun name() = "TrackInit"
    
    override fun init(context: Context) {
        TrackManager.init(context)
    }
    
    override fun runOnMainThread() = false
    override fun priority() = 80
}

/**
 * Application 中使用
 */
class MyApplication : Application() {
    
    override fun onCreate() {
        super.onCreate()
        
        InitTaskDispatcher.getInstance()
            .addTask(NetworkInitTask())
            .addTask(ImageInitTask())
            .addTask(TrackInitTask())
            .addTask(RouterInitTask())
            .addTask(PushInitTask())
            .start(this)
    }
}
```

### 2.4 扩展性考虑

```
┌─────────────────────────────────────────────────────────────────┐
│                        架构扩展性设计                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  【横向扩展】                                                    │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │  • 新业务模块接入：遵循模块规范，独立开发部署                  ││
│  │  • 新功能组件接入：实现标准接口，注册到服务中心                ││
│  │  • 新基础能力接入：封装统一 API，提供给上层使用                ││
│  └─────────────────────────────────────────────────────────────┘│
│                                                                 │
│  【纵向扩展】                                                    │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │  • 架构演进：支持渐进式重构，兼容历史代码                      ││
│  │  • 技术升级：基础层可替换，业务层无感知                        ││
│  │  • 性能优化：关键路径可插拔，支持 A/B 测试                     ││
│  └─────────────────────────────────────────────────────────────┘│
│                                                                 │
│  【多端复用】                                                    │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │  • 业务逻辑复用：KMM 跨平台共享                               ││
│  │  • UI 组件复用：Compose Multiplatform                        ││
│  │  • 协议复用：统一数据模型和接口定义                            ││
│  └─────────────────────────────────────────────────────────────┘│
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 3. 性能监控体系设计

### 3.1 设计目标与约束

#### 3.1.1 设计目标

```
┌─────────────────────────────────────────────────────────────────┐
│                    性能监控体系设计目标                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  【全面性】                      【实时性】                       │
│  • 覆盖所有性能指标              • 秒级数据上报                   │
│  • 端到端链路追踪                • 分钟级告警                     │
│  • 多维度数据分析                • 实时大盘展示                   │
│                                                                 │
│  【准确性】                      【低侵入】                       │
│  • 数据采集准确                  • 对业务代码无侵入               │
│  • 指标计算正确                  • 性能损耗 < 1%                  │
│  • 归因分析精准                  • 包体积增量 < 500KB             │
│                                                                 │
│  【可用性】                      【可扩展】                       │
│  • 问题快速定位                  • 支持自定义指标                 │
│  • 数据可视化                    • 支持插件扩展                   │
│  • 告警可配置                    • 支持多端复用                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 3.2 整体架构设计

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          性能监控体系架构                                │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                        展示层 (Dashboard)                        │   │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐           │   │
│  │  │ 实时大盘  │ │ 告警中心  │ │ 问题分析  │ │ 报表统计  │           │   │
│  │  └──────────┘ └──────────┘ └──────────┘ └──────────┘           │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                    ↑                                    │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                        服务层 (Backend)                          │   │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐           │   │
│  │  │ 数据接收  │ │ 数据处理  │ │ 数据存储  │ │ 告警服务  │           │   │
│  │  │  Kafka   │ │  Flink   │ │ ClickHouse│ │ AlertMgr │           │   │
│  │  └──────────┘ └──────────┘ └──────────┘ └──────────┘           │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                    ↑                                    │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                        传输层 (Transport)                        │   │
│  │  ┌──────────────────────────────────────────────────────────┐  │   │
│  │  │  数据压缩  →  批量上报  →  断点续传  →  流量控制           │  │   │
│  │  └──────────────────────────────────────────────────────────┘  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                    ↑                                    │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                        采集层 (Collection)                       │   │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐           │   │
│  │  │ 启动监控  │ │ 页面监控  │ │ 网络监控  │ │ 崩溃监控  │           │   │
│  │  └──────────┘ └──────────┘ └──────────┘ └──────────┘           │   │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐           │   │
│  │  │ 内存监控  │ │ 卡顿监控  │ │ 电量监控  │ │ 自定义监控 │           │   │
│  │  └──────────┘ └──────────┘ └──────────┘ └──────────┘           │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 3.3 核心模块设计

#### 3.3.1 启动监控

```kotlin
/**
 * 启动性能监控
 * 监控冷启动、热启动、温启动各阶段耗时
 */
object LaunchMonitor {
    
    // 启动阶段定义
    enum class LaunchStage {
        PROCESS_START,      // 进程创建
        APP_ATTACH,         // Application attachBaseContext
        APP_CREATE,         // Application onCreate
        ACTIVITY_CREATE,    // 首页 Activity onCreate
        ACTIVITY_RESUME,    // 首页 Activity onResume
        FIRST_FRAME,        // 首帧渲染完成
        DATA_READY          // 首屏数据加载完成
    }
    
    private val stageTimestamps = mutableMapOf<LaunchStage, Long>()
    private var launchType: LaunchType = LaunchType.COLD
    private var isLaunching = false
    
    /**
     * 记录进程启动时间
     * 在 ContentProvider 中调用
     */
    fun recordProcessStart() {
        stageTimestamps[LaunchStage.PROCESS_START] = SystemClock.elapsedRealtime()
        isLaunching = true
    }
    
    /**
     * 记录各阶段时间点
     */
    fun recordStage(stage: LaunchStage) {
        if (!isLaunching) return
        stageTimestamps[stage] = SystemClock.elapsedRealtime()
        
        if (stage == LaunchStage.FIRST_FRAME) {
            // 首帧渲染完成，计算启动耗时
            calculateAndReport()
        }
    }
    
    /**
     * 计算并上报启动数据
     */
    private fun calculateAndReport() {
        val processStart = stageTimestamps[LaunchStage.PROCESS_START] ?: return
        val firstFrame = stageTimestamps[LaunchStage.FIRST_FRAME] ?: return
        
        val launchData = LaunchData(
            launchType = launchType,
            totalTime = firstFrame - processStart,
            appAttachTime = getStageTime(LaunchStage.APP_ATTACH, processStart),
            appCreateTime = getStageTime(LaunchStage.APP_CREATE, LaunchStage.APP_ATTACH),
            activityCreateTime = getStageTime(LaunchStage.ACTIVITY_CREATE, LaunchStage.APP_CREATE),
            activityResumeTime = getStageTime(LaunchStage.ACTIVITY_RESUME, LaunchStage.ACTIVITY_CREATE),
            firstFrameTime = getStageTime(LaunchStage.FIRST_FRAME, LaunchStage.ACTIVITY_RESUME)
        )
        
        // 上报数据
        APMReporter.report(launchData)
        
        // 重置状态
        isLaunching = false
        stageTimestamps.clear()
    }
    
    private fun getStageTime(current: LaunchStage, previous: LaunchStage): Long {
        val currentTime = stageTimestamps[current] ?: return 0
        val previousTime = stageTimestamps[previous] ?: return 0
        return currentTime - previousTime
    }
    
    private fun getStageTime(current: LaunchStage, previousTime: Long): Long {
        val currentTime = stageTimestamps[current] ?: return 0
        return currentTime - previousTime
    }
}

/**
 * 首帧监控
 * 通过 Choreographer 监控首帧渲染完成
 */
class FirstFrameMonitor {
    
    fun startMonitor(activity: Activity) {
        activity.window.decorView.post {
            // DecorView post 执行时，首帧已经渲染完成
            Choreographer.getInstance().postFrameCallback {
                LaunchMonitor.recordStage(LaunchMonitor.LaunchStage.FIRST_FRAME)
            }
        }
    }
}
```

#### 3.3.2 页面性能监控

```kotlin
/**
 * 页面性能监控
 * 监控页面加载、渲染、交互性能
 */
class PagePerformanceMonitor {
    
    private val pageMetrics = mutableMapOf<String, PageMetrics>()
    
    /**
     * 页面性能指标
     */
    data class PageMetrics(
        val pageName: String,
        var createTime: Long = 0,           // onCreate 耗时
        var startTime: Long = 0,            // onStart 耗时
        var resumeTime: Long = 0,           // onResume 耗时
        var firstFrameTime: Long = 0,       // 首帧耗时
        var dataLoadTime: Long = 0,         // 数据加载耗时
        var fullLoadTime: Long = 0,         // 完全加载耗时
        var fps: Float = 0f,                // 页面帧率
        var slowFrameCount: Int = 0,        // 慢帧数量
        var frozenFrameCount: Int = 0       // 冻帧数量
    )
    
    /**
     * Activity 生命周期监控
     */
    fun registerActivityLifecycle(application: Application) {
        application.registerActivityLifecycleCallbacks(
            object : Application.ActivityLifecycleCallbacks {
                
                private val createTimestamps = mutableMapOf<String, Long>()
                
                override fun onActivityCreated(activity: Activity, savedInstanceState: Bundle?) {
                    val pageName = activity.javaClass.simpleName
                    createTimestamps[pageName] = SystemClock.elapsedRealtime()
                    
                    // 开始监控首帧
                    monitorFirstFrame(activity, pageName)
                }
                
                override fun onActivityStarted(activity: Activity) {
                    val pageName = activity.javaClass.simpleName
                    val createTime = createTimestamps[pageName] ?: return
                    
                    pageMetrics.getOrPut(pageName) { PageMetrics(pageName) }.apply {
                        this.createTime = SystemClock.elapsedRealtime() - createTime
                    }
                }
                
                override fun onActivityResumed(activity: Activity) {
                    val pageName = activity.javaClass.simpleName
                    
                    // 开始帧率监控
                    startFPSMonitor(activity, pageName)
                }
                
                override fun onActivityPaused(activity: Activity) {
                    val pageName = activity.javaClass.simpleName
                    
                    // 停止帧率监控并上报
                    stopFPSMonitor(pageName)
                }
                
                override fun onActivityStopped(activity: Activity) {}
                override fun onActivitySaveInstanceState(activity: Activity, outState: Bundle) {}
                override fun onActivityDestroyed(activity: Activity) {
                    val pageName = activity.javaClass.simpleName
                    createTimestamps.remove(pageName)
                    
                    // 上报页面性能数据
                    pageMetrics[pageName]?.let { metrics ->
                        APMReporter.reportPageMetrics(metrics)
                    }
                    pageMetrics.remove(pageName)
                }
            }
        )
    }
    
    /**
     * 首帧监控
     */
    private fun monitorFirstFrame(activity: Activity, pageName: String) {
        val startTime = SystemClock.elapsedRealtime()
        
        activity.window.decorView.viewTreeObserver.addOnPreDrawListener(
            object : ViewTreeObserver.OnPreDrawListener {
                override fun onPreDraw(): Boolean {
                    activity.window.decorView.viewTreeObserver.removeOnPreDrawListener(this)
                    
                    val firstFrameTime = SystemClock.elapsedRealtime() - startTime
                    pageMetrics.getOrPut(pageName) { PageMetrics(pageName) }.apply {
                        this.firstFrameTime = firstFrameTime
                    }
                    
                    return true
                }
            }
        )
    }
    
    /**
     * 帧率监控
     */
    private val frameMonitors = mutableMapOf<String, FrameMonitor>()
    
    private fun startFPSMonitor(activity: Activity, pageName: String) {
        val monitor = FrameMonitor(pageName)
        frameMonitors[pageName] = monitor
        monitor.start()
    }
    
    private fun stopFPSMonitor(pageName: String) {
        frameMonitors[pageName]?.let { monitor ->
            monitor.stop()
            
            pageMetrics[pageName]?.apply {
                fps = monitor.getAverageFPS()
                slowFrameCount = monitor.getSlowFrameCount()
                frozenFrameCount = monitor.getFrozenFrameCount()
            }
        }
        frameMonitors.remove(pageName)
    }
}

/**
 * 帧率监控器
 */
class FrameMonitor(private val pageName: String) {
    
    private var isMonitoring = false
    private var frameCount = 0
    private var slowFrameCount = 0      // > 16ms
    private var frozenFrameCount = 0    // > 700ms
    private var startTime = 0L
    private var lastFrameTime = 0L
    
    private val frameCallback = object : Choreographer.FrameCallback {
        override fun doFrame(frameTimeNanos: Long) {
            if (!isMonitoring) return
            
            val currentTime = frameTimeNanos / 1_000_000
            
            if (lastFrameTime > 0) {
                val frameDuration = currentTime - lastFrameTime
                
                when {
                    frameDuration > 700 -> frozenFrameCount++
                    frameDuration > 16 -> slowFrameCount++
                }
            }
            
            frameCount++
            lastFrameTime = currentTime
            
            Choreographer.getInstance().postFrameCallback(this)
        }
    }
    
    fun start() {
        isMonitoring = true
        frameCount = 0
        slowFrameCount = 0
        frozenFrameCount = 0
        startTime = SystemClock.elapsedRealtime()
        lastFrameTime = 0
        
        Choreographer.getInstance().postFrameCallback(frameCallback)
    }
    
    fun stop() {
        isMonitoring = false
    }
    
    fun getAverageFPS(): Float {
        val duration = SystemClock.elapsedRealtime() - startTime
        return if (duration > 0) {
            frameCount * 1000f / duration
        } else {
            0f
        }
    }
    
    fun getSlowFrameCount() = slowFrameCount
    fun getFrozenFrameCount() = frozenFrameCount
}
```


#### 3.3.3 卡顿监控

```kotlin
/**
 * 卡顿监控
 * 基于 Looper Printer 和 Choreographer 双重检测
 */
class BlockMonitor private constructor() {
    
    companion object {
        private const val BLOCK_THRESHOLD = 100L      // 卡顿阈值 100ms
        private const val ANR_THRESHOLD = 5000L       // ANR 阈值 5s
        
        @Volatile
        private var instance: BlockMonitor? = null
        
        fun getInstance(): BlockMonitor {
            return instance ?: synchronized(this) {
                instance ?: BlockMonitor().also { instance = it }
            }
        }
    }
    
    private var isMonitoring = false
    private val stackCollector = StackCollector()
    
    /**
     * 开始监控
     */
    fun start() {
        if (isMonitoring) return
        isMonitoring = true
        
        // 方案一：Looper Printer 监控
        startLooperMonitor()
        
        // 方案二：Choreographer 监控
        startChoreographerMonitor()
    }
    
    /**
     * Looper Printer 监控方案
     */
    private fun startLooperMonitor() {
        Looper.getMainLooper().setMessageLogging(object : Printer {
            
            private var startTime = 0L
            private var startThreadTime = 0L
            
            override fun println(x: String?) {
                if (x == null) return
                
                if (x.startsWith(">>>>> Dispatching")) {
                    // 消息开始处理
                    startTime = SystemClock.elapsedRealtime()
                    startThreadTime = SystemClock.currentThreadTimeMillis()
                    
                    // 开始采集堆栈
                    stackCollector.start()
                    
                } else if (x.startsWith("<<<<< Finished")) {
                    // 消息处理完成
                    val wallTime = SystemClock.elapsedRealtime() - startTime
                    val cpuTime = SystemClock.currentThreadTimeMillis() - startThreadTime
                    
                    // 停止采集堆栈
                    stackCollector.stop()
                    
                    if (wallTime >= BLOCK_THRESHOLD) {
                        // 发生卡顿
                        val blockInfo = BlockInfo(
                            wallTime = wallTime,
                            cpuTime = cpuTime,
                            stacks = stackCollector.getStacks(),
                            blockType = when {
                                wallTime >= ANR_THRESHOLD -> BlockType.ANR
                                wallTime >= 500 -> BlockType.FROZEN
                                else -> BlockType.SLOW
                            }
                        )
                        
                        reportBlock(blockInfo)
                    }
                }
            }
        })
    }
    
    /**
     * Choreographer 监控方案
     */
    private fun startChoreographerMonitor() {
        var lastFrameTime = 0L
        
        Choreographer.getInstance().postFrameCallback(object : Choreographer.FrameCallback {
            override fun doFrame(frameTimeNanos: Long) {
                if (!isMonitoring) return
                
                val currentTime = frameTimeNanos / 1_000_000
                
                if (lastFrameTime > 0) {
                    val frameDuration = currentTime - lastFrameTime
                    
                    if (frameDuration > BLOCK_THRESHOLD) {
                        // 检测到掉帧
                        val droppedFrames = (frameDuration / 16.67).toInt()
                        
                        APMReporter.reportDroppedFrames(
                            droppedFrames = droppedFrames,
                            duration = frameDuration
                        )
                    }
                }
                
                lastFrameTime = currentTime
                Choreographer.getInstance().postFrameCallback(this)
            }
        })
    }
    
    private fun reportBlock(blockInfo: BlockInfo) {
        APMReporter.reportBlock(blockInfo)
    }
}

/**
 * 堆栈采集器
 * 定时采集主线程堆栈
 */
class StackCollector {
    
    private val handler = HandlerThread("StackCollector").apply { start() }
        .let { Handler(it.looper) }
    
    private val stacks = mutableListOf<String>()
    private var isCollecting = false
    
    private val collectRunnable = object : Runnable {
        override fun run() {
            if (!isCollecting) return
            
            // 采集主线程堆栈
            val mainThread = Looper.getMainLooper().thread
            val stackTrace = mainThread.stackTrace
            val stackString = stackTrace.joinToString("\n") { 
                "    at ${it.className}.${it.methodName}(${it.fileName}:${it.lineNumber})"
            }
            
            synchronized(stacks) {
                stacks.add(stackString)
            }
            
            // 每 50ms 采集一次
            handler.postDelayed(this, 50)
        }
    }
    
    fun start() {
        synchronized(stacks) {
            stacks.clear()
        }
        isCollecting = true
        handler.post(collectRunnable)
    }
    
    fun stop() {
        isCollecting = false
        handler.removeCallbacks(collectRunnable)
    }
    
    fun getStacks(): List<String> {
        synchronized(stacks) {
            return stacks.toList()
        }
    }
}

/**
 * 卡顿信息
 */
data class BlockInfo(
    val wallTime: Long,
    val cpuTime: Long,
    val stacks: List<String>,
    val blockType: BlockType
)

enum class BlockType {
    SLOW,       // 慢操作 100-500ms
    FROZEN,     // 冻帧 500-5000ms
    ANR         // ANR > 5000ms
}
```

#### 3.3.4 内存监控

```kotlin
/**
 * 内存监控
 * 监控内存使用、泄漏、OOM
 */
object MemoryMonitor {
    
    private const val MEMORY_CHECK_INTERVAL = 30_000L  // 30秒检查一次
    private const val LOW_MEMORY_THRESHOLD = 0.85f     // 内存使用超过 85% 告警
    
    private val handler = Handler(Looper.getMainLooper())
    private var isMonitoring = false
    
    /**
     * 开始监控
     */
    fun start() {
        if (isMonitoring) return
        isMonitoring = true
        
        // 定时检查内存
        handler.post(memoryCheckRunnable)
        
        // 监听系统内存警告
        registerComponentCallbacks()
        
        // 监听 Activity 泄漏
        registerLeakDetection()
    }
    
    private val memoryCheckRunnable = object : Runnable {
        override fun run() {
            if (!isMonitoring) return
            
            val memoryInfo = collectMemoryInfo()
            
            // 检查内存水位
            if (memoryInfo.usedRatio > LOW_MEMORY_THRESHOLD) {
                // 内存告警
                APMReporter.reportMemoryWarning(memoryInfo)
                
                // 触发内存回收
                triggerMemoryRelease()
            }
            
            // 定期上报内存数据
            APMReporter.reportMemoryInfo(memoryInfo)
            
            handler.postDelayed(this, MEMORY_CHECK_INTERVAL)
        }
    }
    
    /**
     * 采集内存信息
     */
    private fun collectMemoryInfo(): MemoryInfo {
        val runtime = Runtime.getRuntime()
        val activityManager = AppContext.get()
            .getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager
        
        // Java 堆内存
        val javaMax = runtime.maxMemory()
        val javaTotal = runtime.totalMemory()
        val javaFree = runtime.freeMemory()
        val javaUsed = javaTotal - javaFree
        
        // Native 内存
        val nativeHeap = Debug.getNativeHeapAllocatedSize()
        
        // PSS 内存
        val memInfo = Debug.MemoryInfo()
        Debug.getMemoryInfo(memInfo)
        val totalPss = memInfo.totalPss * 1024L
        
        // 系统可用内存
        val systemMemInfo = ActivityManager.MemoryInfo()
        activityManager.getMemoryInfo(systemMemInfo)
        
        return MemoryInfo(
            javaMax = javaMax,
            javaUsed = javaUsed,
            javaFree = javaFree,
            nativeHeap = nativeHeap,
            totalPss = totalPss,
            systemAvailable = systemMemInfo.availMem,
            systemTotal = systemMemInfo.totalMem,
            usedRatio = javaUsed.toFloat() / javaMax,
            isLowMemory = systemMemInfo.lowMemory
        )
    }
    
    /**
     * 注册系统内存回调
     */
    private fun registerComponentCallbacks() {
        AppContext.get().registerComponentCallbacks(object : ComponentCallbacks2 {
            override fun onConfigurationChanged(newConfig: Configuration) {}
            
            override fun onLowMemory() {
                APMReporter.reportLowMemory()
                triggerMemoryRelease()
            }
            
            override fun onTrimMemory(level: Int) {
                APMReporter.reportTrimMemory(level)
                
                when (level) {
                    ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL,
                    ComponentCallbacks2.TRIM_MEMORY_COMPLETE -> {
                        triggerMemoryRelease()
                    }
                }
            }
        })
    }
    
    /**
     * Activity 泄漏检测
     */
    private fun registerLeakDetection() {
        val activityRefs = mutableMapOf<String, WeakReference<Activity>>()
        
        AppContext.get().registerActivityLifecycleCallbacks(
            object : Application.ActivityLifecycleCallbacks {
                override fun onActivityCreated(activity: Activity, savedInstanceState: Bundle?) {
                    activityRefs[activity.toString()] = WeakReference(activity)
                }
                
                override fun onActivityDestroyed(activity: Activity) {
                    val key = activity.toString()
                    
                    // 延迟检查是否泄漏
                    handler.postDelayed({
                        System.gc()
                        
                        activityRefs[key]?.get()?.let { leakedActivity ->
                            // Activity 未被回收，可能泄漏
                            APMReporter.reportActivityLeak(
                                activityName = leakedActivity.javaClass.simpleName,
                                retainedSize = estimateRetainedSize(leakedActivity)
                            )
                        }
                        
                        activityRefs.remove(key)
                    }, 5000)
                }
                
                override fun onActivityStarted(activity: Activity) {}
                override fun onActivityResumed(activity: Activity) {}
                override fun onActivityPaused(activity: Activity) {}
                override fun onActivityStopped(activity: Activity) {}
                override fun onActivitySaveInstanceState(activity: Activity, outState: Bundle) {}
            }
        )
    }
    
    /**
     * 触发内存释放
     */
    private fun triggerMemoryRelease() {
        // 清理图片缓存
        ImageLoader.clearMemoryCache()
        
        // 清理其他缓存
        CacheManager.trimMemory()
        
        // 通知业务模块释放内存
        EventBus.post(LowMemoryEvent())
    }
    
    private fun estimateRetainedSize(activity: Activity): Long {
        // 简单估算，实际可使用 HAHA 库分析
        return 0L
    }
}

/**
 * 内存信息
 */
data class MemoryInfo(
    val javaMax: Long,
    val javaUsed: Long,
    val javaFree: Long,
    val nativeHeap: Long,
    val totalPss: Long,
    val systemAvailable: Long,
    val systemTotal: Long,
    val usedRatio: Float,
    val isLowMemory: Boolean
)
```

#### 3.3.5 网络监控

```kotlin
/**
 * 网络性能监控
 * 监控请求耗时、成功率、流量
 */
class NetworkMonitor {
    
    /**
     * OkHttp 拦截器实现网络监控
     */
    class MonitorInterceptor : Interceptor {
        
        override fun intercept(chain: Interceptor.Chain): Response {
            val request = chain.request()
            val startTime = SystemClock.elapsedRealtime()
            
            // 请求信息
            val requestInfo = NetworkRequestInfo(
                url = request.url.toString(),
                method = request.method,
                requestSize = request.body?.contentLength() ?: 0,
                startTime = System.currentTimeMillis()
            )
            
            var response: Response? = null
            var exception: Exception? = null
            
            try {
                response = chain.proceed(request)
                return response
            } catch (e: Exception) {
                exception = e
                throw e
            } finally {
                val endTime = SystemClock.elapsedRealtime()
                val duration = endTime - startTime
                
                // 构建监控数据
                val networkMetrics = NetworkMetrics(
                    url = simplifyUrl(request.url.toString()),
                    method = request.method,
                    statusCode = response?.code ?: -1,
                    duration = duration,
                    dnsTime = getDnsTime(response),
                    connectTime = getConnectTime(response),
                    tlsTime = getTlsTime(response),
                    requestTime = getRequestTime(response),
                    responseTime = getResponseTime(response),
                    requestSize = request.body?.contentLength() ?: 0,
                    responseSize = response?.body?.contentLength() ?: 0,
                    success = response?.isSuccessful == true,
                    errorType = getErrorType(exception),
                    errorMessage = exception?.message
                )
                
                // 上报数据
                APMReporter.reportNetworkMetrics(networkMetrics)
            }
        }
        
        /**
         * 简化 URL，去除参数
         */
        private fun simplifyUrl(url: String): String {
            return url.substringBefore("?")
        }
        
        /**
         * 获取 DNS 耗时
         */
        private fun getDnsTime(response: Response?): Long {
            // 从 EventListener 获取
            return 0L
        }
        
        private fun getConnectTime(response: Response?): Long = 0L
        private fun getTlsTime(response: Response?): Long = 0L
        private fun getRequestTime(response: Response?): Long = 0L
        private fun getResponseTime(response: Response?): Long = 0L
        
        private fun getErrorType(e: Exception?): String? {
            return when (e) {
                null -> null
                is java.net.UnknownHostException -> "DNS_ERROR"
                is java.net.SocketTimeoutException -> "TIMEOUT"
                is javax.net.ssl.SSLException -> "SSL_ERROR"
                is java.io.IOException -> "IO_ERROR"
                else -> "UNKNOWN"
            }
        }
    }
    
    /**
     * 详细的网络事件监听
     */
    class DetailedEventListener : EventListener() {
        
        private var dnsStart = 0L
        private var connectStart = 0L
        private var secureConnectStart = 0L
        private var requestStart = 0L
        private var responseStart = 0L
        
        private val metrics = NetworkDetailMetrics()
        
        override fun dnsStart(call: Call, domainName: String) {
            dnsStart = SystemClock.elapsedRealtime()
        }
        
        override fun dnsEnd(call: Call, domainName: String, inetAddressList: List<InetAddress>) {
            metrics.dnsTime = SystemClock.elapsedRealtime() - dnsStart
        }
        
        override fun connectStart(call: Call, inetSocketAddress: InetSocketAddress, proxy: Proxy) {
            connectStart = SystemClock.elapsedRealtime()
        }
        
        override fun connectEnd(
            call: Call,
            inetSocketAddress: InetSocketAddress,
            proxy: Proxy,
            protocol: Protocol?
        ) {
            metrics.connectTime = SystemClock.elapsedRealtime() - connectStart
        }
        
        override fun secureConnectStart(call: Call) {
            secureConnectStart = SystemClock.elapsedRealtime()
        }
        
        override fun secureConnectEnd(call: Call, handshake: Handshake?) {
            metrics.tlsTime = SystemClock.elapsedRealtime() - secureConnectStart
        }
        
        override fun requestHeadersStart(call: Call) {
            requestStart = SystemClock.elapsedRealtime()
        }
        
        override fun requestBodyEnd(call: Call, byteCount: Long) {
            metrics.requestTime = SystemClock.elapsedRealtime() - requestStart
            metrics.requestSize = byteCount
        }
        
        override fun responseHeadersStart(call: Call) {
            responseStart = SystemClock.elapsedRealtime()
        }
        
        override fun responseBodyEnd(call: Call, byteCount: Long) {
            metrics.responseTime = SystemClock.elapsedRealtime() - responseStart
            metrics.responseSize = byteCount
        }
        
        override fun callEnd(call: Call) {
            // 上报详细指标
            APMReporter.reportNetworkDetailMetrics(metrics)
        }
        
        override fun callFailed(call: Call, ioe: IOException) {
            metrics.errorType = ioe.javaClass.simpleName
            metrics.errorMessage = ioe.message
            APMReporter.reportNetworkDetailMetrics(metrics)
        }
    }
}

/**
 * 网络指标
 */
data class NetworkMetrics(
    val url: String,
    val method: String,
    val statusCode: Int,
    val duration: Long,
    val dnsTime: Long,
    val connectTime: Long,
    val tlsTime: Long,
    val requestTime: Long,
    val responseTime: Long,
    val requestSize: Long,
    val responseSize: Long,
    val success: Boolean,
    val errorType: String?,
    val errorMessage: String?
)
```

### 3.4 数据上报设计

```kotlin
/**
 * APM 数据上报器
 * 支持批量上报、压缩、断点续传
 */
object APMReporter {
    
    private val reportQueue = LinkedBlockingQueue<APMEvent>(1000)
    private val executor = Executors.newSingleThreadExecutor()
    private val handler = Handler(Looper.getMainLooper())
    
    private const val BATCH_SIZE = 50
    private const val BATCH_INTERVAL = 10_000L  // 10秒
    
    init {
        // 定时批量上报
        handler.postDelayed(object : Runnable {
            override fun run() {
                flushEvents()
                handler.postDelayed(this, BATCH_INTERVAL)
            }
        }, BATCH_INTERVAL)
    }
    
    /**
     * 上报事件
     */
    fun report(event: APMEvent) {
        if (!reportQueue.offer(event)) {
            // 队列满，丢弃最旧的数据
            reportQueue.poll()
            reportQueue.offer(event)
        }
        
        // 达到批量大小，立即上报
        if (reportQueue.size >= BATCH_SIZE) {
            flushEvents()
        }
    }
    
    /**
     * 批量上报
     */
    private fun flushEvents() {
        if (reportQueue.isEmpty()) return
        
        executor.execute {
            val events = mutableListOf<APMEvent>()
            reportQueue.drainTo(events, BATCH_SIZE)
            
            if (events.isEmpty()) return@execute
            
            try {
                // 压缩数据
                val compressedData = compressEvents(events)
                
                // 上报到服务器
                val success = uploadToServer(compressedData)
                
                if (!success) {
                    // 上报失败，保存到本地
                    saveToLocal(events)
                }
            } catch (e: Exception) {
                // 异常处理
                saveToLocal(events)
            }
        }
    }
    
    private fun compressEvents(events: List<APMEvent>): ByteArray {
        val json = Gson().toJson(events)
        return GZIPOutputStream(ByteArrayOutputStream()).use { gzip ->
            gzip.write(json.toByteArray())
            gzip.finish()
            (gzip.out as ByteArrayOutputStream).toByteArray()
        }
    }
    
    private fun uploadToServer(data: ByteArray): Boolean {
        // 实际上报逻辑
        return true
    }
    
    private fun saveToLocal(events: List<APMEvent>) {
        // 保存到本地数据库，下次启动重试
    }
    
    // 便捷方法
    fun reportLaunch(data: LaunchData) = report(APMEvent.Launch(data))
    fun reportPageMetrics(metrics: PagePerformanceMonitor.PageMetrics) = 
        report(APMEvent.Page(metrics))
    fun reportBlock(info: BlockInfo) = report(APMEvent.Block(info))
    fun reportMemoryInfo(info: MemoryInfo) = report(APMEvent.Memory(info))
    fun reportNetworkMetrics(metrics: NetworkMetrics) = report(APMEvent.Network(metrics))
    fun reportMemoryWarning(info: MemoryInfo) = report(APMEvent.MemoryWarning(info))
    fun reportLowMemory() = report(APMEvent.LowMemory)
    fun reportTrimMemory(level: Int) = report(APMEvent.TrimMemory(level))
    fun reportActivityLeak(activityName: String, retainedSize: Long) = 
        report(APMEvent.ActivityLeak(activityName, retainedSize))
    fun reportDroppedFrames(droppedFrames: Int, duration: Long) = 
        report(APMEvent.DroppedFrames(droppedFrames, duration))
    fun reportNetworkDetailMetrics(metrics: NetworkDetailMetrics) = 
        report(APMEvent.NetworkDetail(metrics))
}
```

---

## 4. 灰度发布与 AB 测试

### 4.1 设计目标与约束

```
┌─────────────────────────────────────────────────────────────────┐
│                  灰度发布与 AB 测试设计目标                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  【精准投放】                    【快速响应】                     │
│  • 多维度用户分群                • 配置秒级下发                   │
│  • 精确流量控制                  • 实时生效                       │
│  • 灵活的实验设计                • 紧急回滚能力                   │
│                                                                 │
│  【数据驱动】                    【安全可控】                     │
│  • 实验效果可量化                • 灰度范围可控                   │
│  • 统计显著性分析                • 异常自动熔断                   │
│  • 多指标综合评估                • 完整审计日志                   │
│                                                                 │
│  【低成本】                      【高可用】                       │
│  • 接入成本低                    • 服务高可用                     │
│  • 维护成本低                    • 本地缓存兜底                   │
│  • 对业务无侵入                  • 降级策略完善                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 4.2 整体架构设计

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        灰度发布与 AB 测试架构                            │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                        管理平台 (Admin Portal)                   │   │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐           │   │
│  │  │ 实验管理  │ │ 流量配置  │ │ 数据分析  │ │ 权限管理  │           │   │
│  │  └──────────┘ └──────────┘ └──────────┘ └──────────┘           │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                    │                                    │
│                                    ▼                                    │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                        服务层 (Backend Service)                  │   │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐           │   │
│  │  │ 配置中心  │ │ 分流服务  │ │ 数据服务  │ │ 推送服务  │           │   │
│  │  │ (Apollo) │ │ (Router) │ │(ClickHouse)│ │  (Push)  │           │   │
│  │  └──────────┘ └──────────┘ └──────────┘ └──────────┘           │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                    │                                    │
│                                    ▼                                    │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                        客户端 SDK (Client SDK)                   │   │
│  │  ┌──────────────────────────────────────────────────────────┐  │   │
│  │  │                                                          │  │   │
│  │  │  ┌──────────┐    ┌──────────┐    ┌──────────┐           │  │   │
│  │  │  │ 配置拉取  │ →  │ 分流计算  │ →  │ 实验曝光  │           │  │   │
│  │  │  └──────────┘    └──────────┘    └──────────┘           │  │   │
│  │  │        ↓                                                 │  │   │
│  │  │  ┌──────────┐    ┌──────────┐    ┌──────────┐           │  │   │
│  │  │  │ 本地缓存  │    │ 降级策略  │    │ 数据上报  │           │  │   │
│  │  │  └──────────┘    └──────────┘    └──────────┘           │  │   │
│  │  │                                                          │  │   │
│  │  └──────────────────────────────────────────────────────────┘  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 4.3 核心模块设计

#### 4.3.1 实验配置模型

```kotlin
/**
 * AB 测试实验配置模型
 */

/**
 * 实验定义
 */
data class Experiment(
    val experimentId: String,           // 实验 ID
    val experimentName: String,         // 实验名称
    val description: String,            // 实验描述
    val status: ExperimentStatus,       // 实验状态
    val startTime: Long,                // 开始时间
    val endTime: Long,                  // 结束时间
    val trafficRatio: Float,            // 总流量占比 (0-1)
    val groups: List<ExperimentGroup>,  // 实验分组
    val targetRules: List<TargetRule>,  // 目标用户规则
    val mutexGroups: List<String>,      // 互斥实验组
    val layerId: String,                // 实验层 ID
    val priority: Int,                  // 优先级
    val owner: String,                  // 负责人
    val version: Long                   // 配置版本
)

/**
 * 实验状态
 */
enum class ExperimentStatus {
    DRAFT,      // 草稿
    RUNNING,    // 运行中
    PAUSED,     // 已暂停
    FINISHED,   // 已结束
    ARCHIVED    // 已归档
}

/**
 * 实验分组
 */
data class ExperimentGroup(
    val groupId: String,                // 分组 ID
    val groupName: String,              // 分组名称
    val trafficRatio: Float,            // 组内流量占比
    val isControl: Boolean,             // 是否对照组
    val params: Map<String, Any>        // 实验参数
)

/**
 * 目标用户规则
 */
data class TargetRule(
    val field: String,                  // 字段名
    val operator: RuleOperator,         // 操作符
    val values: List<String>            // 值列表
)

enum class RuleOperator {
    EQUALS,         // 等于
    NOT_EQUALS,     // 不等于
    IN,             // 在列表中
    NOT_IN,         // 不在列表中
    GREATER_THAN,   // 大于
    LESS_THAN,      // 小于
    REGEX,          // 正则匹配
    VERSION_GT,     // 版本大于
    VERSION_LT      // 版本小于
}

/**
 * 实验层（用于流量隔离）
 */
data class ExperimentLayer(
    val layerId: String,
    val layerName: String,
    val trafficRatio: Float,            // 该层占总流量比例
    val experiments: List<String>       // 该层包含的实验
)
```

#### 4.3.2 分流算法实现

```kotlin
/**
 * AB 测试分流引擎
 * 支持多层实验、互斥实验、流量隔离
 */
class ABTestEngine private constructor() {
    
    companion object {
        @Volatile
        private var instance: ABTestEngine? = null
        
        fun getInstance(): ABTestEngine {
            return instance ?: synchronized(this) {
                instance ?: ABTestEngine().also { instance = it }
            }
        }
    }
    
    private var experiments = listOf<Experiment>()
    private var layers = listOf<ExperimentLayer>()
    private val exposureCache = mutableMapOf<String, ExperimentGroup?>()
    
    /**
     * 更新实验配置
     */
    fun updateConfig(config: ABTestConfig) {
        this.experiments = config.experiments
        this.layers = config.layers
        // 清除曝光缓存
        exposureCache.clear()
    }
    
    /**
     * 获取实验分组
     * @param experimentId 实验 ID
     * @param userId 用户 ID
     * @param context 用户上下文（用于规则匹配）
     * @return 命中的实验分组，null 表示未命中
     */
    fun getExperimentGroup(
        experimentId: String,
        userId: String,
        context: UserContext
    ): ExperimentGroup? {
        // 1. 检查缓存
        val cacheKey = "$experimentId:$userId"
        exposureCache[cacheKey]?.let { return it }
        
        // 2. 查找实验
        val experiment = experiments.find { it.experimentId == experimentId }
            ?: return null
        
        // 3. 检查实验状态
        if (!isExperimentActive(experiment)) {
            return null
        }
        
        // 4. 检查目标用户规则
        if (!matchTargetRules(experiment.targetRules, context)) {
            return null
        }
        
        // 5. 检查互斥实验
        if (!checkMutexExperiments(experiment, userId, context)) {
            return null
        }
        
        // 6. 分流计算
        val group = calculateGroup(experiment, userId)
        
        // 7. 缓存结果
        exposureCache[cacheKey] = group
        
        // 8. 上报曝光
        if (group != null) {
            reportExposure(experiment, group, userId)
        }
        
        return group
    }
    
    /**
     * 获取实验参数值
     */
    @Suppress("UNCHECKED_CAST")
    fun <T> getParam(
        experimentId: String,
        paramKey: String,
        defaultValue: T,
        userId: String,
        context: UserContext
    ): T {
        val group = getExperimentGroup(experimentId, userId, context)
            ?: return defaultValue
        
        return (group.params[paramKey] as? T) ?: defaultValue
    }
    
    /**
     * 检查实验是否激活
     */
    private fun isExperimentActive(experiment: Experiment): Boolean {
        val now = System.currentTimeMillis()
        return experiment.status == ExperimentStatus.RUNNING &&
                now >= experiment.startTime &&
                now <= experiment.endTime
    }
    
    /**
     * 匹配目标用户规则
     */
    private fun matchTargetRules(rules: List<TargetRule>, context: UserContext): Boolean {
        if (rules.isEmpty()) return true
        
        return rules.all { rule ->
            val fieldValue = context.getField(rule.field) ?: return@all false
            
            when (rule.operator) {
                RuleOperator.EQUALS -> fieldValue == rule.values.firstOrNull()
                RuleOperator.NOT_EQUALS -> fieldValue != rule.values.firstOrNull()
                RuleOperator.IN -> fieldValue in rule.values
                RuleOperator.NOT_IN -> fieldValue !in rule.values
                RuleOperator.GREATER_THAN -> {
                    val value = fieldValue.toDoubleOrNull() ?: return@all false
                    val target = rule.values.firstOrNull()?.toDoubleOrNull() ?: return@all false
                    value > target
                }
                RuleOperator.LESS_THAN -> {
                    val value = fieldValue.toDoubleOrNull() ?: return@all false
                    val target = rule.values.firstOrNull()?.toDoubleOrNull() ?: return@all false
                    value < target
                }
                RuleOperator.REGEX -> {
                    val pattern = rule.values.firstOrNull() ?: return@all false
                    fieldValue.matches(Regex(pattern))
                }
                RuleOperator.VERSION_GT -> {
                    compareVersion(fieldValue, rule.values.firstOrNull() ?: "") > 0
                }
                RuleOperator.VERSION_LT -> {
                    compareVersion(fieldValue, rule.values.firstOrNull() ?: "") < 0
                }
            }
        }
    }
    
    /**
     * 检查互斥实验
     */
    private fun checkMutexExperiments(
        experiment: Experiment,
        userId: String,
        context: UserContext
    ): Boolean {
        if (experiment.mutexGroups.isEmpty()) return true
        
        // 检查是否已经命中互斥实验
        for (mutexExpId in experiment.mutexGroups) {
            val cacheKey = "$mutexExpId:$userId"
            if (exposureCache.containsKey(cacheKey) && exposureCache[cacheKey] != null) {
                return false
            }
        }
        
        return true
    }
    
    /**
     * 分流计算
     * 使用一致性哈希保证同一用户始终命中同一分组
     */
    private fun calculateGroup(experiment: Experiment, userId: String): ExperimentGroup? {
        // 1. 计算用户哈希值
        val hashKey = "${experiment.experimentId}:$userId"
        val hashValue = murmurHash(hashKey)
        val normalizedHash = (hashValue and 0x7FFFFFFF) / Int.MAX_VALUE.toFloat()
        
        // 2. 检查是否在实验流量范围内
        if (normalizedHash > experiment.trafficRatio) {
            return null
        }
        
        // 3. 在实验流量内，计算命中的分组
        val groupHash = normalizedHash / experiment.trafficRatio
        var accumulatedRatio = 0f
        
        for (group in experiment.groups) {
            accumulatedRatio += group.trafficRatio
            if (groupHash <= accumulatedRatio) {
                return group
            }
        }
        
        return experiment.groups.lastOrNull()
    }
    
    /**
     * MurmurHash 算法
     */
    private fun murmurHash(key: String): Int {
        val data = key.toByteArray()
        val length = data.size
        val seed = 0x1234ABCD
        val m = 0x5bd1e995
        val r = 24
        
        var h = seed xor length
        var i = 0
        
        while (i + 4 <= length) {
            var k = (data[i].toInt() and 0xFF) or
                    ((data[i + 1].toInt() and 0xFF) shl 8) or
                    ((data[i + 2].toInt() and 0xFF) shl 16) or
                    ((data[i + 3].toInt() and 0xFF) shl 24)
            
            k *= m
            k = k xor (k ushr r)
            k *= m
            
            h *= m
            h = h xor k
            
            i += 4
        }
        
        when (length - i) {
            3 -> {
                h = h xor ((data[i + 2].toInt() and 0xFF) shl 16)
                h = h xor ((data[i + 1].toInt() and 0xFF) shl 8)
                h = h xor (data[i].toInt() and 0xFF)
                h *= m
            }
            2 -> {
                h = h xor ((data[i + 1].toInt() and 0xFF) shl 8)
                h = h xor (data[i].toInt() and 0xFF)
                h *= m
            }
            1 -> {
                h = h xor (data[i].toInt() and 0xFF)
                h *= m
            }
        }
        
        h = h xor (h ushr 13)
        h *= m
        h = h xor (h ushr 15)
        
        return h
    }
    
    /**
     * 版本号比较
     */
    private fun compareVersion(v1: String, v2: String): Int {
        val parts1 = v1.split(".").map { it.toIntOrNull() ?: 0 }
        val parts2 = v2.split(".").map { it.toIntOrNull() ?: 0 }
        
        val maxLength = maxOf(parts1.size, parts2.size)
        
        for (i in 0 until maxLength) {
            val p1 = parts1.getOrElse(i) { 0 }
            val p2 = parts2.getOrElse(i) { 0 }
            
            if (p1 != p2) {
                return p1.compareTo(p2)
            }
        }
        
        return 0
    }
    
    /**
     * 上报实验曝光
     */
    private fun reportExposure(
        experiment: Experiment,
        group: ExperimentGroup,
        userId: String
    ) {
        val exposureEvent = ExposureEvent(
            experimentId = experiment.experimentId,
            experimentName = experiment.experimentName,
            groupId = group.groupId,
            groupName = group.groupName,
            userId = userId,
            timestamp = System.currentTimeMillis()
        )
        
        ABTestReporter.reportExposure(exposureEvent)
    }
}

/**
 * 用户上下文
 */
class UserContext(
    private val properties: Map<String, String>
) {
    fun getField(field: String): String? = properties[field]
    
    companion object {
        fun build(): Builder = Builder()
    }
    
    class Builder {
        private val properties = mutableMapOf<String, String>()
        
        fun userId(userId: String) = apply { properties["userId"] = userId }
        fun deviceId(deviceId: String) = apply { properties["deviceId"] = deviceId }
        fun appVersion(version: String) = apply { properties["appVersion"] = version }
        fun osVersion(version: String) = apply { properties["osVersion"] = version }
        fun channel(channel: String) = apply { properties["channel"] = channel }
        fun city(city: String) = apply { properties["city"] = city }
        fun isVip(isVip: Boolean) = apply { properties["isVip"] = isVip.toString() }
        fun custom(key: String, value: String) = apply { properties[key] = value }
        
        fun build() = UserContext(properties.toMap())
    }
}
```


#### 4.3.3 配置管理与同步

```kotlin
/**
 * AB 测试配置管理器
 * 负责配置拉取、缓存、同步
 */
class ABTestConfigManager private constructor(private val context: Context) {
    
    companion object {
        private const val PREFS_NAME = "ab_test_config"
        private const val KEY_CONFIG = "config"
        private const val KEY_VERSION = "version"
        private const val SYNC_INTERVAL = 5 * 60 * 1000L  // 5分钟同步一次
        
        @Volatile
        private var instance: ABTestConfigManager? = null
        
        fun getInstance(context: Context): ABTestConfigManager {
            return instance ?: synchronized(this) {
                instance ?: ABTestConfigManager(context.applicationContext)
                    .also { instance = it }
            }
        }
    }
    
    private val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
    private val handler = Handler(Looper.getMainLooper())
    private var currentConfig: ABTestConfig? = null
    
    /**
     * 初始化
     */
    fun init() {
        // 1. 加载本地缓存
        loadLocalConfig()
        
        // 2. 异步拉取最新配置
        fetchRemoteConfig()
        
        // 3. 启动定时同步
        startPeriodicSync()
        
        // 4. 监听推送更新
        registerPushListener()
    }
    
    /**
     * 加载本地缓存配置
     */
    private fun loadLocalConfig() {
        val configJson = prefs.getString(KEY_CONFIG, null)
        if (configJson != null) {
            try {
                currentConfig = Gson().fromJson(configJson, ABTestConfig::class.java)
                ABTestEngine.getInstance().updateConfig(currentConfig!!)
            } catch (e: Exception) {
                AppLog.e("ABTestConfigManager", "Load local config failed", e)
            }
        }
    }
    
    /**
     * 拉取远程配置
     */
    private fun fetchRemoteConfig() {
        GlobalScope.launch(Dispatchers.IO) {
            try {
                val localVersion = prefs.getLong(KEY_VERSION, 0)
                
                // 请求服务器
                val response = ABTestApi.fetchConfig(
                    userId = UserManager.getUserId(),
                    deviceId = DeviceUtils.getDeviceId(),
                    appVersion = AppUtils.getVersionName(),
                    localVersion = localVersion
                )
                
                if (response.isSuccess && response.data != null) {
                    val newConfig = response.data
                    
                    // 版本号更新才处理
                    if (newConfig.version > localVersion) {
                        // 保存到本地
                        saveLocalConfig(newConfig)
                        
                        // 更新引擎
                        withContext(Dispatchers.Main) {
                            currentConfig = newConfig
                            ABTestEngine.getInstance().updateConfig(newConfig)
                        }
                    }
                }
            } catch (e: Exception) {
                AppLog.e("ABTestConfigManager", "Fetch remote config failed", e)
            }
        }
    }
    
    /**
     * 保存配置到本地
     */
    private fun saveLocalConfig(config: ABTestConfig) {
        prefs.edit()
            .putString(KEY_CONFIG, Gson().toJson(config))
            .putLong(KEY_VERSION, config.version)
            .apply()
    }
    
    /**
     * 定时同步
     */
    private fun startPeriodicSync() {
        handler.postDelayed(object : Runnable {
            override fun run() {
                fetchRemoteConfig()
                handler.postDelayed(this, SYNC_INTERVAL)
            }
        }, SYNC_INTERVAL)
    }
    
    /**
     * 监听推送更新
     */
    private fun registerPushListener() {
        PushManager.registerListener("ab_test_config") { message ->
            // 收到配置更新推送，立即拉取
            fetchRemoteConfig()
        }
    }
    
    /**
     * 获取当前配置
     */
    fun getConfig(): ABTestConfig? = currentConfig
}

/**
 * AB 测试配置
 */
data class ABTestConfig(
    val version: Long,
    val experiments: List<Experiment>,
    val layers: List<ExperimentLayer>,
    val globalParams: Map<String, Any>
)
```

#### 4.3.4 灰度发布实现

```kotlin
/**
 * 灰度发布管理器
 * 支持功能灰度、版本灰度、配置灰度
 */
object GrayReleaseManager {
    
    private val featureFlags = mutableMapOf<String, FeatureFlag>()
    private val configValues = mutableMapOf<String, Any>()
    
    /**
     * 功能开关定义
     */
    data class FeatureFlag(
        val key: String,
        val defaultValue: Boolean,
        val grayRules: List<GrayRule>,
        val whiteList: List<String>,    // 白名单用户
        val blackList: List<String>,    // 黑名单用户
        val grayRatio: Float            // 灰度比例
    )
    
    /**
     * 灰度规则
     */
    data class GrayRule(
        val field: String,
        val operator: RuleOperator,
        val values: List<String>,
        val enabled: Boolean
    )
    
    /**
     * 检查功能是否开启
     */
    fun isFeatureEnabled(
        featureKey: String,
        userId: String,
        context: UserContext
    ): Boolean {
        val flag = featureFlags[featureKey] ?: return false
        
        // 1. 检查黑名单
        if (userId in flag.blackList) {
            return false
        }
        
        // 2. 检查白名单
        if (userId in flag.whiteList) {
            return true
        }
        
        // 3. 检查灰度规则
        for (rule in flag.grayRules) {
            if (!rule.enabled) continue
            
            val fieldValue = context.getField(rule.field) ?: continue
            val matched = when (rule.operator) {
                RuleOperator.EQUALS -> fieldValue == rule.values.firstOrNull()
                RuleOperator.IN -> fieldValue in rule.values
                RuleOperator.VERSION_GT -> {
                    compareVersion(fieldValue, rule.values.firstOrNull() ?: "") > 0
                }
                else -> false
            }
            
            if (matched) {
                return true
            }
        }
        
        // 4. 按比例灰度
        if (flag.grayRatio > 0) {
            val hash = murmurHash("$featureKey:$userId")
            val ratio = (hash and 0x7FFFFFFF) / Int.MAX_VALUE.toFloat()
            return ratio <= flag.grayRatio
        }
        
        return flag.defaultValue
    }
    
    /**
     * 获取灰度配置值
     */
    @Suppress("UNCHECKED_CAST")
    fun <T> getConfigValue(key: String, defaultValue: T): T {
        return (configValues[key] as? T) ?: defaultValue
    }
    
    /**
     * 更新功能开关
     */
    fun updateFeatureFlags(flags: List<FeatureFlag>) {
        featureFlags.clear()
        flags.forEach { flag ->
            featureFlags[flag.key] = flag
        }
    }
    
    /**
     * 更新配置值
     */
    fun updateConfigValues(values: Map<String, Any>) {
        configValues.clear()
        configValues.putAll(values)
    }
    
    private fun murmurHash(key: String): Int {
        // 同 ABTestEngine 中的实现
        return key.hashCode()
    }
    
    private fun compareVersion(v1: String, v2: String): Int {
        // 同 ABTestEngine 中的实现
        return 0
    }
}

/**
 * 灰度发布使用示例
 */
class FeatureUsageExample {
    
    fun showNewFeature() {
        val userId = UserManager.getUserId() ?: return
        val context = UserContext.build()
            .userId(userId)
            .appVersion(AppUtils.getVersionName())
            .channel(AppUtils.getChannel())
            .build()
        
        // 检查新功能是否开启
        if (GrayReleaseManager.isFeatureEnabled("new_home_page", userId, context)) {
            // 显示新首页
            showNewHomePage()
        } else {
            // 显示旧首页
            showOldHomePage()
        }
    }
    
    fun getServerConfig() {
        // 获取灰度配置的服务器地址
        val serverUrl = GrayReleaseManager.getConfigValue(
            "api_server_url",
            "https://api.example.com"
        )
        
        // 获取灰度配置的超时时间
        val timeout = GrayReleaseManager.getConfigValue(
            "request_timeout",
            30000
        )
    }
    
    private fun showNewHomePage() {}
    private fun showOldHomePage() {}
}
```

---

## 5. 动态化方案设计

### 5.1 设计目标与约束

```
┌─────────────────────────────────────────────────────────────────┐
│                      动态化方案设计目标                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  【快速迭代】                    【用户体验】                     │
│  • 绕过应用商店审核              • 接近原生性能                   │
│  • 实时更新能力                  • 流畅的交互体验                 │
│  • 热修复线上问题                • 一致的 UI 表现                 │
│                                                                 │
│  【开发效率】                    【安全可控】                     │
│  • 跨平台复用                    • 代码安全校验                   │
│  • 降低开发成本                  • 灰度发布能力                   │
│  • 统一技术栈                    • 回滚机制完善                   │
│                                                                 │
│  【稳定性】                      【可维护性】                     │
│  • 降级兜底方案                  • 版本管理清晰                   │
│  • 异常监控告警                  • 调试能力完善                   │
│  • 资源加载可靠                  • 文档规范完整                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 5.2 动态化方案对比

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          动态化方案对比                                  │
├──────────┬──────────┬──────────┬──────────┬──────────┬─────────────────┤
│   方案    │   性能   │  开发效率 │  动态性  │  包大小  │    适用场景      │
├──────────┼──────────┼──────────┼──────────┼──────────┼─────────────────┤
│  H5      │   ★★☆   │   ★★★★  │  ★★★★★ │   ★★★★  │ 运营活动页面     │
├──────────┼──────────┼──────────┼──────────┼──────────┼─────────────────┤
│  RN      │   ★★★   │   ★★★★  │  ★★★★  │   ★★★   │ 业务功能模块     │
├──────────┼──────────┼──────────┼──────────┼──────────┼─────────────────┤
│  Flutter │   ★★★★  │   ★★★★  │  ★★★   │   ★★    │ 独立业务模块     │
├──────────┼──────────┼──────────┼──────────┼──────────┼─────────────────┤
│  小程序   │   ★★★   │   ★★★★  │  ★★★★  │   ★★★★  │ 轻量级功能      │
├──────────┼──────────┼──────────┼──────────┼──────────┼─────────────────┤
│  插件化   │   ★★★★★ │   ★★★   │  ★★★★  │   ★★★   │ 大型功能模块     │
├──────────┼──────────┼──────────┼──────────┼──────────┼─────────────────┤
│  热修复   │   ★★★★★ │   ★★    │  ★★★   │   ★★★★★ │ Bug 修复        │
└──────────┴──────────┴──────────┴──────────┴──────────┴─────────────────┘
```

### 5.3 整体架构设计

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          动态化整体架构                                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                        发布平台 (Release Platform)               │   │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐           │   │
│  │  │ 资源管理  │ │ 版本管理  │ │ 灰度发布  │ │ 数据统计  │           │   │
│  │  └──────────┘ └──────────┘ └──────────┘ └──────────┘           │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                    │                                    │
│                                    ▼                                    │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                        下发服务 (Delivery Service)               │   │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐           │   │
│  │  │  CDN     │ │ 差分服务  │ │ 校验服务  │ │ 配置中心  │           │   │
│  │  └──────────┘ └──────────┘ └──────────┘ └──────────┘           │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                    │                                    │
│                                    ▼                                    │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                        客户端 SDK (Client SDK)                   │   │
│  │                                                                 │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │                    资源管理层                             │   │   │
│  │  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐   │   │   │
│  │  │  │ 版本检查  │ │ 资源下载  │ │ 差分合并  │ │ 安全校验  │   │   │   │
│  │  │  └──────────┘ └──────────┘ └──────────┘ └──────────┘   │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │                              │                                  │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │                    容器层                                 │   │   │
│  │  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐   │   │   │
│  │  │  │ H5 容器  │ │ RN 容器  │ │ 小程序容器 │ │ 插件容器  │   │   │   │
│  │  │  └──────────┘ └──────────┘ └──────────┘ └──────────┘   │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │                              │                                  │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │                    桥接层 (Bridge)                        │   │   │
│  │  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐   │   │   │
│  │  │  │ 网络桥接  │ │ 存储桥接  │ │ UI 桥接  │ │ 设备桥接  │   │   │   │
│  │  │  └──────────┘ └──────────┘ └──────────┘ └──────────┘   │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```


### 5.4 核心模块设计

#### 5.4.1 资源管理器

```kotlin
/**
 * 动态资源管理器
 * 负责资源的下载、校验、存储、加载
 */
class DynamicResourceManager private constructor(private val context: Context) {
    
    companion object {
        private const val RESOURCE_DIR = "dynamic_resources"
        private const val META_FILE = "resource_meta.json"
        
        @Volatile
        private var instance: DynamicResourceManager? = null
        
        fun getInstance(context: Context): DynamicResourceManager {
            return instance ?: synchronized(this) {
                instance ?: DynamicResourceManager(context.applicationContext)
                    .also { instance = it }
            }
        }
    }
    
    private val resourceDir = File(context.filesDir, RESOURCE_DIR)
    private val metaFile = File(resourceDir, META_FILE)
    private val resourceMeta = mutableMapOf<String, ResourceInfo>()
    private val downloadingResources = ConcurrentHashMap<String, Job>()
    
    init {
        if (!resourceDir.exists()) {
            resourceDir.mkdirs()
        }
        loadResourceMeta()
    }
    
    /**
     * 资源信息
     */
    data class ResourceInfo(
        val resourceId: String,
        val version: Long,
        val url: String,
        val md5: String,
        val size: Long,
        val localPath: String?,
        val status: ResourceStatus,
        val downloadTime: Long
    )
    
    enum class ResourceStatus {
        NOT_DOWNLOADED,
        DOWNLOADING,
        DOWNLOADED,
        VERIFIED,
        FAILED
    }
    
    /**
     * 检查资源更新
     */
    suspend fun checkUpdate(resourceId: String): UpdateResult {
        return withContext(Dispatchers.IO) {
            try {
                val localInfo = resourceMeta[resourceId]
                val localVersion = localInfo?.version ?: 0
                
                // 请求服务器获取最新版本信息
                val response = ResourceApi.checkUpdate(
                    resourceId = resourceId,
                    localVersion = localVersion,
                    appVersion = AppUtils.getVersionName(),
                    deviceId = DeviceUtils.getDeviceId()
                )
                
                if (response.isSuccess && response.data != null) {
                    val remoteInfo = response.data
                    
                    if (remoteInfo.version > localVersion) {
                        UpdateResult.HasUpdate(remoteInfo)
                    } else {
                        UpdateResult.NoUpdate
                    }
                } else {
                    UpdateResult.Error(response.message ?: "Unknown error")
                }
            } catch (e: Exception) {
                UpdateResult.Error(e.message ?: "Network error")
            }
        }
    }
    
    /**
     * 下载资源
     */
    suspend fun downloadResource(
        resourceInfo: ResourceInfo,
        progressCallback: ((Float) -> Unit)? = null
    ): DownloadResult {
        // 检查是否正在下载
        if (downloadingResources.containsKey(resourceInfo.resourceId)) {
            return DownloadResult.Downloading
        }
        
        return withContext(Dispatchers.IO) {
            val job = coroutineContext[Job]
            downloadingResources[resourceInfo.resourceId] = job!!
            
            try {
                // 1. 创建临时文件
                val tempFile = File(resourceDir, "${resourceInfo.resourceId}.tmp")
                val targetFile = File(resourceDir, "${resourceInfo.resourceId}.zip")
                
                // 2. 下载文件
                val downloadSuccess = downloadFile(
                    url = resourceInfo.url,
                    targetFile = tempFile,
                    progressCallback = progressCallback
                )
                
                if (!downloadSuccess) {
                    return@withContext DownloadResult.Failed("Download failed")
                }
                
                // 3. 校验 MD5
                val fileMd5 = calculateMD5(tempFile)
                if (fileMd5 != resourceInfo.md5) {
                    tempFile.delete()
                    return@withContext DownloadResult.Failed("MD5 verification failed")
                }
                
                // 4. 重命名文件
                tempFile.renameTo(targetFile)
                
                // 5. 解压资源
                val extractDir = File(resourceDir, resourceInfo.resourceId)
                unzipFile(targetFile, extractDir)
                
                // 6. 更新元数据
                val updatedInfo = resourceInfo.copy(
                    localPath = extractDir.absolutePath,
                    status = ResourceStatus.VERIFIED,
                    downloadTime = System.currentTimeMillis()
                )
                resourceMeta[resourceInfo.resourceId] = updatedInfo
                saveResourceMeta()
                
                // 7. 删除压缩包
                targetFile.delete()
                
                DownloadResult.Success(extractDir.absolutePath)
                
            } catch (e: Exception) {
                DownloadResult.Failed(e.message ?: "Unknown error")
            } finally {
                downloadingResources.remove(resourceInfo.resourceId)
            }
        }
    }
    
    /**
     * 获取资源本地路径
     */
    fun getResourcePath(resourceId: String): String? {
        val info = resourceMeta[resourceId]
        return if (info?.status == ResourceStatus.VERIFIED) {
            info.localPath
        } else {
            null
        }
    }
    
    /**
     * 删除资源
     */
    fun deleteResource(resourceId: String) {
        resourceMeta[resourceId]?.localPath?.let { path ->
            File(path).deleteRecursively()
        }
        resourceMeta.remove(resourceId)
        saveResourceMeta()
    }
    
    /**
     * 清理过期资源
     */
    fun cleanExpiredResources(maxAge: Long = 30 * 24 * 60 * 60 * 1000L) {
        val now = System.currentTimeMillis()
        val expiredResources = resourceMeta.filter { (_, info) ->
            now - info.downloadTime > maxAge
        }
        
        expiredResources.forEach { (resourceId, _) ->
            deleteResource(resourceId)
        }
    }
    
    private fun loadResourceMeta() {
        if (metaFile.exists()) {
            try {
                val json = metaFile.readText()
                val type = object : TypeToken<Map<String, ResourceInfo>>() {}.type
                val meta: Map<String, ResourceInfo> = Gson().fromJson(json, type)
                resourceMeta.putAll(meta)
            } catch (e: Exception) {
                AppLog.e("DynamicResourceManager", "Load meta failed", e)
            }
        }
    }
    
    private fun saveResourceMeta() {
        try {
            val json = Gson().toJson(resourceMeta)
            metaFile.writeText(json)
        } catch (e: Exception) {
            AppLog.e("DynamicResourceManager", "Save meta failed", e)
        }
    }
    
    private suspend fun downloadFile(
        url: String,
        targetFile: File,
        progressCallback: ((Float) -> Unit)?
    ): Boolean {
        // 实际下载逻辑
        return true
    }
    
    private fun calculateMD5(file: File): String {
        val md = MessageDigest.getInstance("MD5")
        file.inputStream().use { input ->
            val buffer = ByteArray(8192)
            var read: Int
            while (input.read(buffer).also { read = it } > 0) {
                md.update(buffer, 0, read)
            }
        }
        return md.digest().joinToString("") { "%02x".format(it) }
    }
    
    private fun unzipFile(zipFile: File, targetDir: File) {
        if (!targetDir.exists()) {
            targetDir.mkdirs()
        }
        
        ZipInputStream(FileInputStream(zipFile)).use { zis ->
            var entry = zis.nextEntry
            while (entry != null) {
                val file = File(targetDir, entry.name)
                if (entry.isDirectory) {
                    file.mkdirs()
                } else {
                    file.parentFile?.mkdirs()
                    FileOutputStream(file).use { fos ->
                        zis.copyTo(fos)
                    }
                }
                entry = zis.nextEntry
            }
        }
    }
}

sealed class UpdateResult {
    data class HasUpdate(val info: DynamicResourceManager.ResourceInfo) : UpdateResult()
    object NoUpdate : UpdateResult()
    data class Error(val message: String) : UpdateResult()
}

sealed class DownloadResult {
    data class Success(val path: String) : DownloadResult()
    object Downloading : DownloadResult()
    data class Failed(val message: String) : DownloadResult()
}
```

#### 5.4.2 H5 容器设计

```kotlin
/**
 * H5 容器
 * 提供增强的 WebView 能力
 */
class H5Container(context: Context) : FrameLayout(context) {
    
    private val webView: WebView
    private val bridgeManager: JsBridgeManager
    private val offlineManager: H5OfflineManager
    
    init {
        webView = createWebView()
        bridgeManager = JsBridgeManager(webView)
        offlineManager = H5OfflineManager(context)
        
        addView(webView, LayoutParams(
            LayoutParams.MATCH_PARENT,
            LayoutParams.MATCH_PARENT
        ))
        
        setupWebView()
    }
    
    private fun createWebView(): WebView {
        return WebView(context).apply {
            settings.apply {
                javaScriptEnabled = true
                domStorageEnabled = true
                databaseEnabled = true
                cacheMode = WebSettings.LOAD_DEFAULT
                mixedContentMode = WebSettings.MIXED_CONTENT_ALWAYS_ALLOW
                allowFileAccess = true
                allowContentAccess = true
                useWideViewPort = true
                loadWithOverviewMode = true
            }
        }
    }
    
    private fun setupWebView() {
        webView.webViewClient = object : WebViewClient() {
            
            override fun shouldInterceptRequest(
                view: WebView?,
                request: WebResourceRequest?
            ): WebResourceResponse? {
                val url = request?.url?.toString() ?: return null
                
                // 尝试从离线包加载
                val offlineResponse = offlineManager.getOfflineResource(url)
                if (offlineResponse != null) {
                    return offlineResponse
                }
                
                return super.shouldInterceptRequest(view, request)
            }
            
            override fun onPageStarted(view: WebView?, url: String?, favicon: Bitmap?) {
                super.onPageStarted(view, url, favicon)
                // 注入 JS Bridge
                bridgeManager.injectBridge()
            }
            
            override fun onPageFinished(view: WebView?, url: String?) {
                super.onPageFinished(view, url)
                // 页面加载完成回调
            }
            
            override fun onReceivedError(
                view: WebView?,
                request: WebResourceRequest?,
                error: WebResourceError?
            ) {
                super.onReceivedError(view, request, error)
                // 错误处理
                if (request?.isForMainFrame == true) {
                    showErrorPage()
                }
            }
        }
        
        webView.webChromeClient = object : WebChromeClient() {
            override fun onProgressChanged(view: WebView?, newProgress: Int) {
                super.onProgressChanged(view, newProgress)
                // 进度更新
            }
            
            override fun onConsoleMessage(consoleMessage: ConsoleMessage?): Boolean {
                // 捕获 JS 日志
                AppLog.d("H5Container", "JS: ${consoleMessage?.message()}")
                return super.onConsoleMessage(consoleMessage)
            }
        }
    }
    
    /**
     * 加载 URL
     */
    fun loadUrl(url: String, params: Map<String, String>? = null) {
        val finalUrl = if (params.isNullOrEmpty()) {
            url
        } else {
            val queryString = params.entries.joinToString("&") { 
                "${it.key}=${URLEncoder.encode(it.value, "UTF-8")}"
            }
            if (url.contains("?")) "$url&$queryString" else "$url?$queryString"
        }
        
        webView.loadUrl(finalUrl)
    }
    
    /**
     * 调用 JS 方法
     */
    fun callJs(method: String, params: String?, callback: ((String) -> Unit)? = null) {
        val script = if (params.isNullOrEmpty()) {
            "javascript:$method()"
        } else {
            "javascript:$method($params)"
        }
        
        webView.evaluateJavascript(script) { result ->
            callback?.invoke(result)
        }
    }
    
    /**
     * 注册原生方法供 JS 调用
     */
    fun registerNativeMethod(name: String, handler: (String) -> String) {
        bridgeManager.registerMethod(name, handler)
    }
    
    private fun showErrorPage() {
        // 显示错误页面
    }
    
    fun onBackPressed(): Boolean {
        return if (webView.canGoBack()) {
            webView.goBack()
            true
        } else {
            false
        }
    }
    
    fun destroy() {
        webView.destroy()
    }
}

/**
 * JS Bridge 管理器
 */
class JsBridgeManager(private val webView: WebView) {
    
    private val methods = mutableMapOf<String, (String) -> String>()
    
    /**
     * 注入 Bridge
     */
    fun injectBridge() {
        val bridgeScript = """
            window.NativeBridge = {
                call: function(method, params, callback) {
                    var callbackId = 'cb_' + Date.now() + '_' + Math.random();
                    window.NativeBridge._callbacks[callbackId] = callback;
                    
                    var message = JSON.stringify({
                        method: method,
                        params: params,
                        callbackId: callbackId
                    });
                    
                    window.NativeBridge._postMessage(message);
                },
                _callbacks: {},
                _handleCallback: function(callbackId, result) {
                    var callback = window.NativeBridge._callbacks[callbackId];
                    if (callback) {
                        callback(result);
                        delete window.NativeBridge._callbacks[callbackId];
                    }
                },
                _postMessage: function(message) {
                    window.prompt('NativeBridge:' + message);
                }
            };
        """.trimIndent()
        
        webView.evaluateJavascript(bridgeScript, null)
    }
    
    /**
     * 注册方法
     */
    fun registerMethod(name: String, handler: (String) -> String) {
        methods[name] = handler
    }
    
    /**
     * 处理 JS 调用
     */
    fun handleJsCall(message: String): String? {
        try {
            val json = JSONObject(message)
            val method = json.getString("method")
            val params = json.optString("params", "")
            val callbackId = json.optString("callbackId", "")
            
            val handler = methods[method] ?: return null
            val result = handler(params)
            
            // 回调 JS
            if (callbackId.isNotEmpty()) {
                val callbackScript = "window.NativeBridge._handleCallback('$callbackId', $result)"
                webView.post {
                    webView.evaluateJavascript(callbackScript, null)
                }
            }
            
            return result
        } catch (e: Exception) {
            AppLog.e("JsBridgeManager", "Handle JS call failed", e)
            return null
        }
    }
}

/**
 * H5 离线包管理器
 */
class H5OfflineManager(private val context: Context) {
    
    private val offlineDir = File(context.filesDir, "h5_offline")
    private val resourceMap = mutableMapOf<String, File>()
    
    init {
        loadOfflineResources()
    }
    
    /**
     * 加载离线资源映射
     */
    private fun loadOfflineResources() {
        if (!offlineDir.exists()) return
        
        offlineDir.listFiles()?.forEach { dir ->
            if (dir.isDirectory) {
                val manifestFile = File(dir, "manifest.json")
                if (manifestFile.exists()) {
                    try {
                        val manifest = Gson().fromJson(
                            manifestFile.readText(),
                            OfflineManifest::class.java
                        )
                        
                        manifest.resources.forEach { resource ->
                            val file = File(dir, resource.localPath)
                            if (file.exists()) {
                                resourceMap[resource.url] = file
                            }
                        }
                    } catch (e: Exception) {
                        AppLog.e("H5OfflineManager", "Load manifest failed", e)
                    }
                }
            }
        }
    }
    
    /**
     * 获取离线资源
     */
    fun getOfflineResource(url: String): WebResourceResponse? {
        val file = resourceMap[url] ?: return null
        
        if (!file.exists()) {
            resourceMap.remove(url)
            return null
        }
        
        val mimeType = getMimeType(file.name)
        val encoding = "UTF-8"
        
        return WebResourceResponse(
            mimeType,
            encoding,
            file.inputStream()
        )
    }
    
    private fun getMimeType(fileName: String): String {
        return when {
            fileName.endsWith(".html") -> "text/html"
            fileName.endsWith(".js") -> "application/javascript"
            fileName.endsWith(".css") -> "text/css"
            fileName.endsWith(".png") -> "image/png"
            fileName.endsWith(".jpg") || fileName.endsWith(".jpeg") -> "image/jpeg"
            fileName.endsWith(".gif") -> "image/gif"
            fileName.endsWith(".svg") -> "image/svg+xml"
            fileName.endsWith(".json") -> "application/json"
            else -> "application/octet-stream"
        }
    }
    
    data class OfflineManifest(
        val version: Long,
        val resources: List<OfflineResource>
    )
    
    data class OfflineResource(
        val url: String,
        val localPath: String,
        val md5: String
    )
}
```


#### 5.4.3 热修复方案设计

```kotlin
/**
 * 热修复管理器
 * 基于类加载方案实现
 */
object HotfixManager {
    
    private const val PATCH_DIR = "hotfix_patches"
    private const val PATCH_DEX = "patch.dex"
    
    private lateinit var context: Context
    private var patchInfo: PatchInfo? = null
    
    /**
     * 补丁信息
     */
    data class PatchInfo(
        val patchId: String,
        val version: Long,
        val targetVersion: String,      // 目标 App 版本
        val url: String,
        val md5: String,
        val size: Long,
        val description: String,
        val forceApply: Boolean         // 是否强制应用
    )
    
    /**
     * 初始化
     */
    fun init(context: Context) {
        this.context = context.applicationContext
        
        // 检查并应用本地补丁
        applyLocalPatch()
        
        // 异步检查补丁更新
        checkPatchUpdate()
    }
    
    /**
     * 应用本地补丁
     */
    private fun applyLocalPatch() {
        val patchDir = File(context.filesDir, PATCH_DIR)
        val patchFile = File(patchDir, PATCH_DEX)
        
        if (!patchFile.exists()) return
        
        try {
            // 加载补丁 DEX
            loadPatchDex(patchFile)
            AppLog.i("HotfixManager", "Local patch applied successfully")
        } catch (e: Exception) {
            AppLog.e("HotfixManager", "Apply local patch failed", e)
            // 删除损坏的补丁
            patchFile.delete()
        }
    }
    
    /**
     * 加载补丁 DEX
     * 通过反射修改 ClassLoader 的 dexElements
     */
    private fun loadPatchDex(patchFile: File) {
        val classLoader = context.classLoader
        val optimizedDir = File(context.filesDir, "hotfix_opt")
        if (!optimizedDir.exists()) {
            optimizedDir.mkdirs()
        }
        
        // 创建补丁的 DexClassLoader
        val patchClassLoader = DexClassLoader(
            patchFile.absolutePath,
            optimizedDir.absolutePath,
            null,
            classLoader
        )
        
        // 获取补丁的 dexElements
        val patchDexElements = getDexElements(patchClassLoader)
        
        // 获取原始的 dexElements
        val originalDexElements = getDexElements(classLoader)
        
        // 合并 dexElements，补丁在前
        val combinedDexElements = combineArrays(patchDexElements, originalDexElements)
        
        // 设置合并后的 dexElements
        setDexElements(classLoader, combinedDexElements)
    }
    
    /**
     * 获取 ClassLoader 的 dexElements
     */
    private fun getDexElements(classLoader: ClassLoader): Array<Any> {
        val pathListField = findField(classLoader.javaClass, "pathList")
        pathListField.isAccessible = true
        val pathList = pathListField.get(classLoader)
        
        val dexElementsField = findField(pathList.javaClass, "dexElements")
        dexElementsField.isAccessible = true
        
        @Suppress("UNCHECKED_CAST")
        return dexElementsField.get(pathList) as Array<Any>
    }
    
    /**
     * 设置 ClassLoader 的 dexElements
     */
    private fun setDexElements(classLoader: ClassLoader, dexElements: Array<Any>) {
        val pathListField = findField(classLoader.javaClass, "pathList")
        pathListField.isAccessible = true
        val pathList = pathListField.get(classLoader)
        
        val dexElementsField = findField(pathList.javaClass, "dexElements")
        dexElementsField.isAccessible = true
        dexElementsField.set(pathList, dexElements)
    }
    
    /**
     * 合并数组
     */
    private fun combineArrays(first: Array<Any>, second: Array<Any>): Array<Any> {
        val combined = java.lang.reflect.Array.newInstance(
            first.javaClass.componentType,
            first.size + second.size
        ) as Array<Any>
        
        System.arraycopy(first, 0, combined, 0, first.size)
        System.arraycopy(second, 0, combined, first.size, second.size)
        
        return combined
    }
    
    /**
     * 查找字段
     */
    private fun findField(clazz: Class<*>, fieldName: String): Field {
        var currentClass: Class<*>? = clazz
        while (currentClass != null) {
            try {
                return currentClass.getDeclaredField(fieldName)
            } catch (e: NoSuchFieldException) {
                currentClass = currentClass.superclass
            }
        }
        throw NoSuchFieldException("Field $fieldName not found in $clazz")
    }
    
    /**
     * 检查补丁更新
     */
    private fun checkPatchUpdate() {
        GlobalScope.launch(Dispatchers.IO) {
            try {
                val response = HotfixApi.checkPatch(
                    appVersion = AppUtils.getVersionName(),
                    patchVersion = patchInfo?.version ?: 0,
                    deviceId = DeviceUtils.getDeviceId()
                )
                
                if (response.isSuccess && response.data != null) {
                    val newPatch = response.data
                    
                    // 检查是否需要下载新补丁
                    if (shouldDownloadPatch(newPatch)) {
                        downloadAndApplyPatch(newPatch)
                    }
                }
            } catch (e: Exception) {
                AppLog.e("HotfixManager", "Check patch update failed", e)
            }
        }
    }
    
    /**
     * 判断是否需要下载补丁
     */
    private fun shouldDownloadPatch(patch: PatchInfo): Boolean {
        // 检查目标版本是否匹配
        if (patch.targetVersion != AppUtils.getVersionName()) {
            return false
        }
        
        // 检查补丁版本
        val currentVersion = patchInfo?.version ?: 0
        return patch.version > currentVersion
    }
    
    /**
     * 下载并应用补丁
     */
    private suspend fun downloadAndApplyPatch(patch: PatchInfo) {
        withContext(Dispatchers.IO) {
            try {
                val patchDir = File(context.filesDir, PATCH_DIR)
                if (!patchDir.exists()) {
                    patchDir.mkdirs()
                }
                
                val tempFile = File(patchDir, "patch_temp.dex")
                val patchFile = File(patchDir, PATCH_DEX)
                
                // 1. 下载补丁
                val downloadSuccess = downloadFile(patch.url, tempFile)
                if (!downloadSuccess) {
                    AppLog.e("HotfixManager", "Download patch failed")
                    return@withContext
                }
                
                // 2. 校验 MD5
                val fileMd5 = calculateMD5(tempFile)
                if (fileMd5 != patch.md5) {
                    AppLog.e("HotfixManager", "Patch MD5 verification failed")
                    tempFile.delete()
                    return@withContext
                }
                
                // 3. 替换补丁文件
                if (patchFile.exists()) {
                    patchFile.delete()
                }
                tempFile.renameTo(patchFile)
                
                // 4. 保存补丁信息
                patchInfo = patch
                savePatchInfo(patch)
                
                // 5. 如果强制应用，立即加载
                if (patch.forceApply) {
                    withContext(Dispatchers.Main) {
                        loadPatchDex(patchFile)
                    }
                }
                
                AppLog.i("HotfixManager", "Patch downloaded and saved, will apply on next launch")
                
            } catch (e: Exception) {
                AppLog.e("HotfixManager", "Download and apply patch failed", e)
            }
        }
    }
    
    private suspend fun downloadFile(url: String, targetFile: File): Boolean {
        // 实际下载逻辑
        return true
    }
    
    private fun calculateMD5(file: File): String {
        val md = MessageDigest.getInstance("MD5")
        file.inputStream().use { input ->
            val buffer = ByteArray(8192)
            var read: Int
            while (input.read(buffer).also { read = it } > 0) {
                md.update(buffer, 0, read)
            }
        }
        return md.digest().joinToString("") { "%02x".format(it) }
    }
    
    private fun savePatchInfo(patch: PatchInfo) {
        val prefs = context.getSharedPreferences("hotfix", Context.MODE_PRIVATE)
        prefs.edit().putString("patch_info", Gson().toJson(patch)).apply()
    }
}
```

### 5.5 扩展性考虑

```
┌─────────────────────────────────────────────────────────────────┐
│                      动态化方案扩展性设计                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  【多容器支持】                                                  │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │  • 统一容器接口：定义标准的容器生命周期和通信协议              ││
│  │  • 容器注册机制：支持动态注册新的容器类型                      ││
│  │  • 容器路由：根据 URL scheme 自动选择合适的容器                ││
│  └─────────────────────────────────────────────────────────────┘│
│                                                                 │
│  【Bridge 扩展】                                                 │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │  • 模块化 Bridge：按功能模块拆分 Bridge 实现                  ││
│  │  • 插件化 Bridge：支持动态加载新的 Bridge 模块                ││
│  │  • 版本兼容：Bridge 接口版本管理和兼容处理                    ││
│  └─────────────────────────────────────────────────────────────┘│
│                                                                 │
│  【资源管理扩展】                                                │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │  • 差分更新：支持增量更新减少下载量                           ││
│  │  • 预加载策略：智能预测和预加载资源                           ││
│  │  • 多级缓存：内存 → 磁盘 → 网络的多级缓存策略                 ││
│  └─────────────────────────────────────────────────────────────┘│
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 6. 常见面试题

### 6.1 大型 App 架构设计

**问题1：如何设计一个支持 50+ 开发人员协作的大型 App 架构？**

**答案要点：**
- **分层架构**：应用层 → 业务层 → 功能层 → 基础层 → 公共层
- **模块化设计**：按业务域拆分独立模块，每个模块可独立编译、测试、发布
- **依赖管理**：上层依赖下层，禁止反向依赖和横向依赖
- **通信机制**：通过路由 + 接口下沉实现模块间解耦通信
- **统一规范**：制定代码规范、接口规范、发布规范
- **CI/CD**：自动化构建、测试、发布流程

**问题2：模块化架构中如何解决模块间通信问题？**

**答案要点：**
- **接口下沉**：将模块对外暴露的接口定义在公共层
- **服务发现**：通过 ServiceLoader 或自定义注册机制发现服务实现
- **路由跳转**：使用 ARouter 等路由框架实现页面跳转
- **事件总线**：使用 EventBus 或 LiveData 实现跨模块事件通知
- **依赖注入**：使用 Hilt/Dagger 管理跨模块依赖

**问题3：如何优化大型项目的编译速度？**

**答案要点：**
- **模块 AAR 化**：将稳定模块打包成 AAR，减少编译范围
- **增量编译**：合理配置 Gradle，利用增量编译能力
- **并行编译**：配置 `org.gradle.parallel=true`
- **构建缓存**：启用 Gradle Build Cache
- **依赖优化**：减少不必要的依赖，使用 api/implementation 合理声明
- **Kotlin 编译优化**：使用 KAPT 增量编译，考虑迁移到 KSP

### 6.2 性能监控体系

**问题4：如何设计一个完整的 APM 性能监控体系？**

**答案要点：**
- **采集层**：启动监控、页面监控、网络监控、卡顿监控、内存监控、崩溃监控
- **传输层**：数据压缩、批量上报、断点续传、流量控制
- **服务层**：数据接收(Kafka)、数据处理(Flink)、数据存储(ClickHouse)、告警服务
- **展示层**：实时大盘、告警中心、问题分析、报表统计
- **关键指标**：启动时间、页面帧率、网络成功率、Crash 率、ANR 率

**问题5：如何实现卡顿监控？有哪些方案？**

**答案要点：**
- **Looper Printer 方案**：
  - 通过 `Looper.setMessageLogging()` 监控消息处理耗时
  - 优点：实现简单，能获取精确的消息处理时间
  - 缺点：无法获取具体卡顿堆栈
- **Choreographer 方案**：
  - 通过 `Choreographer.postFrameCallback()` 监控帧间隔
  - 优点：能检测掉帧情况
  - 缺点：只能检测 UI 线程卡顿
- **堆栈采样方案**：
  - 开启子线程定时采集主线程堆栈
  - 优点：能获取卡顿时的堆栈信息
  - 缺点：有一定性能开销
- **综合方案**：Looper Printer + 堆栈采样，检测到卡顿时上报采集的堆栈

### 6.3 灰度发布与 AB 测试

**问题6：如何设计一个 AB 测试分流系统？**

**答案要点：**
- **分流算法**：使用一致性哈希保证同一用户始终命中同一分组
- **实验配置**：支持多分组、流量比例、目标用户规则、互斥实验
- **实验层**：支持多层实验，实现流量隔离
- **配置下发**：支持实时下发、本地缓存、降级策略
- **数据上报**：曝光上报、转化上报、统计分析
- **安全机制**：紧急回滚、异常熔断

**问题7：AB 测试中如何保证分流的均匀性和稳定性？**

**答案要点：**
- **均匀性**：
  - 使用 MurmurHash 等高质量哈希算法
  - 哈希值归一化后按比例分配
  - 定期验证分流比例是否符合预期
- **稳定性**：
  - 使用 `实验ID + 用户ID` 作为哈希 key
  - 同一用户多次访问命中同一分组
  - 配置版本变更不影响已分流用户
- **隔离性**：
  - 实验层机制隔离不同实验的流量
  - 互斥实验配置避免冲突

### 6.4 动态化方案

**问题8：对比 H5、RN、Flutter、小程序等动态化方案的优缺点？**

**答案要点：**

| 方案 | 优点 | 缺点 | 适用场景 |
|-----|------|------|---------|
| H5 | 开发快、动态性强、跨平台 | 性能差、体验一般 | 运营活动、轻量页面 |
| RN | 性能较好、动态性强、生态成熟 | 包体积大、版本兼容问题 | 业务功能模块 |
| Flutter | 性能好、UI 一致性强 | 动态性受限、包体积大 | 独立业务模块 |
| 小程序 | 开发快、体验好、动态性强 | 能力受限、需要容器支持 | 轻量级功能 |
| 插件化 | 原生性能、功能完整 | 开发复杂、兼容性问题 | 大型功能模块 |
| 热修复 | 原生性能、修复快 | 只能修复代码、有限制 | Bug 修复 |

**问题9：如何设计一个 H5 离线包方案？**

**答案要点：**
- **离线包结构**：HTML + JS + CSS + 资源文件 + manifest.json
- **版本管理**：服务端管理版本，客户端检查更新
- **下载策略**：WiFi 下自动下载、4G 下用户确认
- **资源拦截**：WebViewClient.shouldInterceptRequest 拦截请求
- **资源匹配**：根据 URL 匹配本地资源
- **降级策略**：离线资源不存在时走网络请求
- **增量更新**：支持差分包减少下载量

**问题10：热修复的原理是什么？有哪些方案？**

**答案要点：**
- **类加载方案（Tinker、QZone）**：
  - 原理：将补丁 DEX 插入到 ClassLoader 的 dexElements 数组前面
  - 优点：兼容性好，支持修复类
  - 缺点：需要重启生效
- **底层替换方案（AndFix、Sophix）**：
  - 原理：直接修改 ArtMethod 结构体，替换方法实现
  - 优点：即时生效，无需重启
  - 缺点：兼容性问题，只能修复方法
- **Instant Run 方案**：
  - 原理：在每个方法前插入代理代码，运行时判断是否执行补丁
  - 优点：即时生效
  - 缺点：性能开销，包体积增大

### 6.5 综合设计题

**问题11：设计一个支持千万级 DAU 的 App 架构，需要考虑哪些方面？**

**答案要点：**
- **架构设计**：分层架构、模块化、组件化
- **性能优化**：启动优化、渲染优化、内存优化、网络优化
- **稳定性保障**：Crash 监控、ANR 监控、异常上报、自动恢复
- **动态化能力**：热修复、动态配置、AB 测试、灰度发布
- **安全防护**：代码混淆、数据加密、防篡改、防调试
- **监控体系**：APM 监控、业务监控、告警系统
- **发布流程**：CI/CD、自动化测试、灰度发布、回滚机制

**问题12：如何设计一个高可用的配置下发系统？**

**答案要点：**
- **多级缓存**：服务端缓存 → CDN → 客户端内存 → 客户端磁盘
- **推拉结合**：定时拉取 + 推送更新
- **版本管理**：增量更新、版本回滚
- **降级策略**：网络异常时使用本地缓存、内置默认配置
- **灰度发布**：按用户、设备、地域等维度灰度
- **监控告警**：配置下发成功率、生效率监控

---

## 7. 面试回答技巧

### 7.1 系统设计题回答框架

```
┌─────────────────────────────────────────────────────────────────┐
│                    系统设计题回答框架                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. 需求澄清（2-3分钟）                                          │
│     • 明确功能需求和非功能需求                                   │
│     • 确认用户规模、性能指标                                     │
│     • 了解技术约束和限制条件                                     │
│                                                                 │
│  2. 整体设计（5-8分钟）                                          │
│     • 画出整体架构图                                             │
│     • 说明各模块职责和交互                                       │
│     • 解释技术选型理由                                           │
│                                                                 │
│  3. 核心模块（10-15分钟）                                        │
│     • 深入讲解 1-2 个核心模块                                    │
│     • 说明关键算法和数据结构                                     │
│     • 展示关键代码实现                                           │
│                                                                 │
│  4. 扩展讨论（5分钟）                                            │
│     • 讨论方案的优缺点                                           │
│     • 说明扩展性和演进方向                                       │
│     • 回答面试官的追问                                           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 7.2 常见追问及应对

| 追问类型 | 示例问题 | 应对策略 |
|---------|---------|---------|
| 性能追问 | 这个方案的性能瓶颈在哪？ | 分析关键路径，给出优化方向 |
| 扩展追问 | 如果用户量增长10倍怎么办？ | 说明水平扩展和垂直扩展策略 |
| 异常追问 | 如果某个服务挂了怎么办？ | 说明降级、熔断、重试策略 |
| 对比追问 | 为什么不用 XXX 方案？ | 客观对比优缺点，说明选择理由 |
| 细节追问 | 这个算法的时间复杂度是多少？ | 准确回答，必要时推导 |

---

## 8. 总结

系统设计是 Android 高级开发面试的核心考察点，需要掌握：

1. **大型 App 架构设计**：分层架构、模块化、路由通信、初始化框架
2. **性能监控体系**：启动监控、页面监控、卡顿监控、内存监控、网络监控
3. **灰度发布与 AB 测试**：分流算法、配置管理、实验设计
4. **动态化方案**：H5 容器、热修复、资源管理

面试时要注意：
- 先理解需求，再设计方案
- 从整体到局部，层层深入
- 关注性能、稳定性、扩展性
- 准备好应对各种追问
