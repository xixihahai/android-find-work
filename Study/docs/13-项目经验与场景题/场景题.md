# Android 高级开发场景题

## 1. 概述

场景题是 Android 高级开发面试中最能体现候选人实战能力的环节。与理论知识不同，场景题考察的是候选人在真实项目中遇到问题时的排查思路、解决方案和优化效果。本文档涵盖了字节、美团、快手、OPPO、vivo 等大厂面试中高频出现的场景题，包括：

- **列表页面优化**：RecyclerView 性能优化的完整方案
- **OOM 问题排查**：内存溢出的定位与解决
- **ANR 问题排查**：应用无响应的分析与治理
- **启动优化实战**：冷启动、热启动的优化策略
- **内存泄漏排查**：泄漏检测与修复
- **Crash 分析**：崩溃日志分析与稳定性治理
- **卡顿优化**：流畅度提升的系统方案

每个场景题都包含问题背景、排查思路、具体步骤、解决方案和量化效果，帮助你在面试中展现专业的问题解决能力。

---

## 2. 列表页面优化

### 2.1 问题背景描述

**场景描述**：
电商 App 首页 Feed 流列表，包含多种复杂卡片类型（商品卡、直播卡、活动卡、视频卡等），用户反馈滑动时明显卡顿，尤其在中低端机型上更为严重。

**问题表现**：
- 快速滑动时帧率下降到 30fps 以下
- 首次加载列表白屏时间长
- 滑动过程中偶发卡顿
- 内存占用持续增长

**业务复杂度**：
- 10+ 种卡片类型
- 每个卡片包含图片、视频、动画等富媒体内容
- 支持曝光埋点、点击埋点
- 支持预加载、懒加载


### 2.2 排查思路与工具

```
┌─────────────────────────────────────────────────────────────────┐
│                    列表卡顿排查流程                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐  │
│  │ 现象收集  │───▶│ 数据采集  │───▶│ 问题定位  │───▶│ 方案验证  │  │
│  └──────────┘    └──────────┘    └──────────┘    └──────────┘  │
│       │              │              │              │           │
│       ▼              ▼              ▼              ▼           │
│  ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐  │
│  │ 用户反馈  │    │ Systrace │    │ 布局层级  │    │ A/B测试   │  │
│  │ 帧率监控  │    │ Profiler │    │ 绑定耗时  │    │ 灰度发布  │  │
│  │ 线上埋点  │    │ Layout   │    │ 内存分配  │    │ 效果对比  │  │
│  └──────────┘    │ Inspector│    │ GC频率   │    └──────────┘  │
│                  └──────────┘    └──────────┘                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**核心排查工具**：

| 工具 | 用途 | 关键指标 |
|------|------|----------|
| Android Profiler | CPU/内存/网络分析 | 方法耗时、内存分配 |
| Systrace | 系统级性能分析 | 帧渲染时间、主线程阻塞 |
| Layout Inspector | 布局层级分析 | 嵌套深度、过度绘制 |
| GPU 呈现模式 | 渲染性能分析 | 每帧渲染时间分布 |
| LeakCanary | 内存泄漏检测 | 泄漏对象、引用链 |
| BlockCanary | 卡顿检测 | 卡顿堆栈、耗时方法 |

### 2.3 具体排查步骤

#### 步骤一：帧率监控与数据采集

```kotlin
/**
 * 帧率监控工具类
 * 通过 Choreographer 监控每帧渲染时间
 */
class FPSMonitor private constructor() {
    
    private var frameCount = 0
    private var lastTime = 0L
    private var fps = 60
    private val frameCallback = object : Choreographer.FrameCallback {
        override fun doFrame(frameTimeNanos: Long) {
            if (lastTime == 0L) {
                lastTime = frameTimeNanos
            }
            frameCount++
            
            val diffMs = (frameTimeNanos - lastTime) / 1_000_000
            if (diffMs >= 1000) {
                fps = (frameCount * 1000 / diffMs).toInt()
                frameCount = 0
                lastTime = frameTimeNanos
                
                // 上报帧率数据
                if (fps < 50) {
                    reportLowFPS(fps)
                }
            }
            
            // 继续监控下一帧
            Choreographer.getInstance().postFrameCallback(this)
        }
    }
    
    fun start() {
        Choreographer.getInstance().postFrameCallback(frameCallback)
    }
    
    fun stop() {
        Choreographer.getInstance().removeFrameCallback(frameCallback)
    }
    
    private fun reportLowFPS(fps: Int) {
        // 采集当前页面信息、可见卡片类型等
        val pageInfo = PageTracker.getCurrentPageInfo()
        val visibleItems = RecyclerViewTracker.getVisibleItemTypes()
        
        Analytics.report("low_fps", mapOf(
            "fps" to fps,
            "page" to pageInfo,
            "visible_items" to visibleItems,
            "memory" to Runtime.getRuntime().totalMemory()
        ))
    }
    
    companion object {
        val instance by lazy { FPSMonitor() }
    }
}
```


#### 步骤二：Systrace 分析主线程耗时

```bash
# 抓取 Systrace
python systrace.py -t 5 -o trace.html \
    sched freq idle am wm gfx view binder_driver hal \
    dalvik camera input res

# 或使用 Android Studio Profiler
# Record -> System Trace -> 操作列表滑动 -> Stop
```

**Systrace 分析要点**：

```
┌─────────────────────────────────────────────────────────────────┐
│                    Systrace 关键指标                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Frame Timeline:                                                │
│  ├── 绿色帧：< 16.6ms，流畅                                      │
│  ├── 黄色帧：16.6ms ~ 33ms，轻微卡顿                             │
│  └── 红色帧：> 33ms，明显卡顿                                    │
│                                                                 │
│  主线程分析：                                                    │
│  ├── Choreographer#doFrame：帧回调总耗时                         │
│  ├── traversal：measure/layout/draw 耗时                        │
│  ├── input：输入事件处理耗时                                     │
│  ├── animation：动画计算耗时                                     │
│  └── RV onBindViewHolder：列表绑定耗时                           │
│                                                                 │
│  渲染线程分析：                                                  │
│  ├── DrawFrame：GPU 绘制耗时                                    │
│  ├── syncFrameState：同步状态耗时                                │
│  └── flush drawing commands：绘制命令刷新                        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 步骤三：onBindViewHolder 耗时分析

```kotlin
/**
 * RecyclerView 绑定耗时监控
 */
abstract class MonitoredAdapter<VH : RecyclerView.ViewHolder> : 
    RecyclerView.Adapter<VH>() {
    
    // 绑定耗时阈值（毫秒）
    private val bindThreshold = 8L
    
    final override fun onBindViewHolder(holder: VH, position: Int) {
        val startTime = System.nanoTime()
        
        // 执行实际绑定逻辑
        onBindViewHolderInternal(holder, position)
        
        val costMs = (System.nanoTime() - startTime) / 1_000_000
        if (costMs > bindThreshold) {
            // 记录慢绑定
            logSlowBind(holder, position, costMs)
        }
    }
    
    abstract fun onBindViewHolderInternal(holder: VH, position: Int)
    
    private fun logSlowBind(holder: VH, position: Int, costMs: Long) {
        Log.w("SlowBind", """
            |Slow bind detected:
            |  ViewType: ${holder.itemViewType}
            |  Position: $position
            |  Cost: ${costMs}ms
            |  Holder: ${holder.javaClass.simpleName}
        """.trimMargin())
        
        // 上报到监控平台
        PerformanceMonitor.reportSlowBind(
            viewType = holder.itemViewType,
            position = position,
            costMs = costMs
        )
    }
}
```

#### 步骤四：布局层级分析

```kotlin
/**
 * 布局层级检测工具
 */
object LayoutDepthChecker {
    
    private const val MAX_DEPTH = 10
    
    fun checkViewHierarchy(root: View): LayoutReport {
        val report = LayoutReport()
        traverseView(root, 0, report)
        return report
    }
    
    private fun traverseView(view: View, depth: Int, report: LayoutReport) {
        report.maxDepth = maxOf(report.maxDepth, depth)
        report.totalViews++
        
        if (depth > MAX_DEPTH) {
            report.deepViews.add(ViewInfo(
                className = view.javaClass.simpleName,
                id = view.id,
                depth = depth
            ))
        }
        
        // 检测过度绘制风险
        if (view.background != null && view is ViewGroup) {
            report.overdrawRisks.add(view.javaClass.simpleName)
        }
        
        if (view is ViewGroup) {
            for (i in 0 until view.childCount) {
                traverseView(view.getChildAt(i), depth + 1, report)
            }
        }
    }
    
    data class LayoutReport(
        var maxDepth: Int = 0,
        var totalViews: Int = 0,
        val deepViews: MutableList<ViewInfo> = mutableListOf(),
        val overdrawRisks: MutableList<String> = mutableListOf()
    )
    
    data class ViewInfo(
        val className: String,
        val id: Int,
        val depth: Int
    )
}
```


### 2.4 解决方案

#### 方案一：ViewHolder 复用优化

```kotlin
/**
 * 优化后的多类型 Adapter
 * 核心优化点：
 * 1. 合理拆分 ViewType，避免过多类型
 * 2. 使用 ViewHolder 缓存池
 * 3. 延迟初始化非必要 View
 */
class OptimizedFeedAdapter : RecyclerView.Adapter<BaseViewHolder>() {
    
    private val items = mutableListOf<FeedItem>()
    
    // 优化1：合并相似 ViewType
    override fun getItemViewType(position: Int): Int {
        return when (val item = items[position]) {
            is ProductItem -> VIEW_TYPE_PRODUCT
            is LiveItem -> VIEW_TYPE_LIVE
            is VideoItem -> VIEW_TYPE_VIDEO
            // 合并相似类型，减少 ViewType 数量
            is BannerItem, is ActivityItem -> VIEW_TYPE_BANNER
            else -> VIEW_TYPE_DEFAULT
        }
    }
    
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): BaseViewHolder {
        // 优化2：使用 ViewStub 延迟加载复杂布局
        val layoutId = when (viewType) {
            VIEW_TYPE_PRODUCT -> R.layout.item_product_optimized
            VIEW_TYPE_LIVE -> R.layout.item_live_optimized
            VIEW_TYPE_VIDEO -> R.layout.item_video_optimized
            VIEW_TYPE_BANNER -> R.layout.item_banner_optimized
            else -> R.layout.item_default
        }
        
        val view = LayoutInflater.from(parent.context)
            .inflate(layoutId, parent, false)
        
        return createViewHolder(viewType, view)
    }
    
    override fun onBindViewHolder(holder: BaseViewHolder, position: Int) {
        val item = items[position]
        
        // 优化3：分离必要绑定和延迟绑定
        holder.bindEssential(item)  // 立即绑定：文字、基础布局
        holder.bindDeferred(item)   // 延迟绑定：图片、动画
    }
    
    // 优化4：预取数据
    override fun onViewAttachedToWindow(holder: BaseViewHolder) {
        super.onViewAttachedToWindow(holder)
        holder.onAttached()
    }
    
    override fun onViewDetachedFromWindow(holder: BaseViewHolder) {
        super.onViewDetachedFromWindow(holder)
        holder.onDetached()
    }
    
    // 优化5：回收时清理资源
    override fun onViewRecycled(holder: BaseViewHolder) {
        super.onViewRecycled(holder)
        holder.onRecycled()
    }
    
    companion object {
        const val VIEW_TYPE_PRODUCT = 1
        const val VIEW_TYPE_LIVE = 2
        const val VIEW_TYPE_VIDEO = 3
        const val VIEW_TYPE_BANNER = 4
        const val VIEW_TYPE_DEFAULT = 0
    }
}

/**
 * 优化后的 ViewHolder 基类
 */
abstract class BaseViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
    
    // 延迟初始化的 View
    protected var deferredViewsInitialized = false
    
    /**
     * 必要绑定：文字、基础状态
     * 要求：< 2ms
     */
    abstract fun bindEssential(item: FeedItem)
    
    /**
     * 延迟绑定：图片加载、复杂计算
     * 在下一帧执行
     */
    open fun bindDeferred(item: FeedItem) {
        itemView.post {
            bindDeferredInternal(item)
        }
    }
    
    protected open fun bindDeferredInternal(item: FeedItem) {}
    
    open fun onAttached() {
        // 恢复动画、开始播放等
    }
    
    open fun onDetached() {
        // 暂停动画、停止播放等
    }
    
    open fun onRecycled() {
        // 清理图片引用、取消请求等
        deferredViewsInitialized = false
    }
}
```

#### 方案二：RecyclerView 配置优化

```kotlin
/**
 * RecyclerView 性能优化配置
 */
fun RecyclerView.applyPerformanceOptimizations() {
    // 1. 设置固定大小（如果 item 大小固定）
    setHasFixedSize(true)
    
    // 2. 优化缓存池大小
    recycledViewPool.apply {
        setMaxRecycledViews(OptimizedFeedAdapter.VIEW_TYPE_PRODUCT, 15)
        setMaxRecycledViews(OptimizedFeedAdapter.VIEW_TYPE_LIVE, 5)
        setMaxRecycledViews(OptimizedFeedAdapter.VIEW_TYPE_VIDEO, 5)
        setMaxRecycledViews(OptimizedFeedAdapter.VIEW_TYPE_BANNER, 3)
    }
    
    // 3. 设置预取数量
    (layoutManager as? LinearLayoutManager)?.apply {
        initialPrefetchItemCount = 4
    }
    
    // 4. 关闭默认动画（如果不需要）
    itemAnimator = null
    
    // 5. 设置缓存大小
    setItemViewCacheSize(10)
    
    // 6. 开启绘制缓存
    setDrawingCacheEnabled(true)
    drawingCacheQuality = View.DRAWING_CACHE_QUALITY_HIGH
}

/**
 * 共享 RecycledViewPool
 * 适用于多个 RecyclerView 使用相同 ViewType 的场景
 */
object SharedRecycledViewPool {
    
    private val pool = RecyclerView.RecycledViewPool().apply {
        setMaxRecycledViews(0, 20)
        setMaxRecycledViews(1, 10)
        setMaxRecycledViews(2, 10)
    }
    
    fun get(): RecyclerView.RecycledViewPool = pool
}
```


#### 方案三：图片加载优化

```kotlin
/**
 * 列表图片加载优化策略
 */
class ListImageLoader(private val recyclerView: RecyclerView) {
    
    private var isScrolling = false
    private val pendingRequests = mutableListOf<ImageRequest>()
    
    init {
        setupScrollListener()
    }
    
    private fun setupScrollListener() {
        recyclerView.addOnScrollListener(object : RecyclerView.OnScrollListener() {
            override fun onScrollStateChanged(recyclerView: RecyclerView, newState: Int) {
                when (newState) {
                    RecyclerView.SCROLL_STATE_IDLE -> {
                        isScrolling = false
                        // 滑动停止，加载待处理的图片
                        processPendingRequests()
                    }
                    RecyclerView.SCROLL_STATE_DRAGGING,
                    RecyclerView.SCROLL_STATE_SETTLING -> {
                        isScrolling = true
                    }
                }
            }
        })
    }
    
    /**
     * 智能图片加载
     * - 滑动中：只加载小图/缩略图
     * - 滑动停止：加载高清图
     */
    fun loadImage(imageView: ImageView, url: String, options: ImageOptions) {
        if (isScrolling && options.loadDuringScroll.not()) {
            // 滑动中，加入待处理队列
            pendingRequests.add(ImageRequest(imageView, url, options))
            // 先加载缩略图
            loadThumbnail(imageView, url)
        } else {
            // 直接加载
            loadImageInternal(imageView, url, options)
        }
    }
    
    private fun loadThumbnail(imageView: ImageView, url: String) {
        Glide.with(imageView)
            .load(url)
            .override(100, 100)  // 小尺寸
            .placeholder(R.drawable.placeholder)
            .into(imageView)
    }
    
    private fun loadImageInternal(imageView: ImageView, url: String, options: ImageOptions) {
        Glide.with(imageView)
            .load(url)
            .apply(RequestOptions().apply {
                // 根据 ImageView 大小自动调整
                if (options.autoSize) {
                    override(Target.SIZE_ORIGINAL)
                }
                // 磁盘缓存策略
                diskCacheStrategy(DiskCacheStrategy.AUTOMATIC)
                // 内存缓存
                skipMemoryCache(false)
                // 渐变动画
                if (options.crossFade) {
                    transition(DrawableTransitionOptions.withCrossFade(200))
                }
            })
            .placeholder(R.drawable.placeholder)
            .error(R.drawable.error)
            .into(imageView)
    }
    
    private fun processPendingRequests() {
        pendingRequests.forEach { request ->
            // 检查 ImageView 是否仍然可见
            if (request.imageView.isAttachedToWindow) {
                loadImageInternal(request.imageView, request.url, request.options)
            }
        }
        pendingRequests.clear()
    }
    
    data class ImageRequest(
        val imageView: ImageView,
        val url: String,
        val options: ImageOptions
    )
    
    data class ImageOptions(
        val autoSize: Boolean = true,
        val crossFade: Boolean = true,
        val loadDuringScroll: Boolean = false
    )
}
```

#### 方案四：布局优化

```xml
<!-- 优化前：多层嵌套 -->
<LinearLayout>
    <RelativeLayout>
        <FrameLayout>
            <LinearLayout>
                <ImageView />
                <TextView />
            </LinearLayout>
        </FrameLayout>
    </RelativeLayout>
</LinearLayout>

<!-- 优化后：使用 ConstraintLayout 扁平化 -->
<androidx.constraintlayout.widget.ConstraintLayout
    android:layout_width="match_parent"
    android:layout_height="wrap_content">
    
    <ImageView
        android:id="@+id/iv_cover"
        android:layout_width="120dp"
        android:layout_height="90dp"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />
    
    <TextView
        android:id="@+id/tv_title"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:maxLines="2"
        android:ellipsize="end"
        app:layout_constraintStart_toEndOf="@id/iv_cover"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        android:layout_marginStart="12dp" />
    
    <!-- 使用 ViewStub 延迟加载不常用的视图 -->
    <ViewStub
        android:id="@+id/stub_extra_info"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout="@layout/layout_extra_info"
        app:layout_constraintTop_toBottomOf="@id/tv_title" />
        
</androidx.constraintlayout.widget.ConstraintLayout>
```

```kotlin
/**
 * ViewStub 延迟加载示例
 */
class ProductViewHolder(itemView: View) : BaseViewHolder(itemView) {
    
    private val ivCover: ImageView = itemView.findViewById(R.id.iv_cover)
    private val tvTitle: TextView = itemView.findViewById(R.id.tv_title)
    private val stubExtraInfo: ViewStub = itemView.findViewById(R.id.stub_extra_info)
    
    // 延迟初始化的视图
    private var extraInfoView: View? = null
    
    override fun bindEssential(item: FeedItem) {
        val product = item as ProductItem
        tvTitle.text = product.title
    }
    
    override fun bindDeferredInternal(item: FeedItem) {
        val product = item as ProductItem
        
        // 加载图片
        Glide.with(ivCover)
            .load(product.coverUrl)
            .into(ivCover)
        
        // 按需加载额外信息
        if (product.hasExtraInfo && extraInfoView == null) {
            extraInfoView = stubExtraInfo.inflate()
        }
        extraInfoView?.let { bindExtraInfo(it, product) }
    }
    
    private fun bindExtraInfo(view: View, product: ProductItem) {
        // 绑定额外信息
    }
}
```


### 2.5 优化效果量化

| 优化项 | 优化前 | 优化后 | 提升幅度 |
|--------|--------|--------|----------|
| 平均帧率 | 42 fps | 58 fps | +38% |
| 掉帧率 | 15% | 3% | -80% |
| onBindViewHolder 平均耗时 | 12ms | 3ms | -75% |
| 布局层级深度 | 12层 | 5层 | -58% |
| 内存占用 | 180MB | 120MB | -33% |
| 首屏加载时间 | 800ms | 400ms | -50% |

### 2.6 面试回答要点

1. **问题定位**：通过 Systrace 和 Profiler 定位到 onBindViewHolder 耗时过长
2. **布局优化**：使用 ConstraintLayout 减少嵌套层级，ViewStub 延迟加载
3. **绑定优化**：分离必要绑定和延迟绑定，减少主线程压力
4. **图片优化**：滑动时加载缩略图，停止后加载高清图
5. **缓存优化**：合理配置 RecycledViewPool 和 ItemViewCache
6. **量化效果**：帧率提升 38%，掉帧率降低 80%

---

## 3. OOM 问题排查

### 3.1 问题背景描述

**场景描述**：
社交 App 在用户浏览图片详情页时，频繁出现 OOM 崩溃，尤其是连续查看多张高清大图后。线上 Crash 率达到 0.5%，主要集中在 2GB 内存以下的设备。

**问题表现**：
- 查看 10+ 张大图后必现崩溃
- Crash 堆栈指向 BitmapFactory.decodeStream
- 崩溃前内存占用持续增长
- 低端机型崩溃率是高端机型的 5 倍

**Crash 日志**：
```
java.lang.OutOfMemoryError: Failed to allocate a 25165824 byte allocation 
    with 16777216 free bytes and 16MB until OOM
    at dalvik.system.VMRuntime.newNonMovableArray(Native Method)
    at android.graphics.BitmapFactory.nativeDecodeStream(Native Method)
    at android.graphics.BitmapFactory.decodeStreamInternal(BitmapFactory.java:882)
    at android.graphics.BitmapFactory.decodeStream(BitmapFactory.java:858)
    at com.example.app.ImageLoader.loadBitmap(ImageLoader.java:156)
```

### 3.2 排查思路与工具

```
┌─────────────────────────────────────────────────────────────────┐
│                    OOM 排查流程                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │                    1. 收集 Crash 信息                      │  │
│  │  - 崩溃堆栈、设备信息、内存状态                              │  │
│  │  - 崩溃前用户操作路径                                       │  │
│  └──────────────────────────────────────────────────────────┘  │
│                            │                                    │
│                            ▼                                    │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │                    2. 本地复现                             │  │
│  │  - 模拟低内存环境                                          │  │
│  │  - 按照用户路径操作                                         │  │
│  └──────────────────────────────────────────────────────────┘  │
│                            │                                    │
│                            ▼                                    │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │                    3. 内存分析                             │  │
│  │  - Dump hprof 文件                                        │  │
│  │  - MAT/Android Studio 分析                                │  │
│  │  - 定位大对象、泄漏对象                                     │  │
│  └──────────────────────────────────────────────────────────┘  │
│                            │                                    │
│                            ▼                                    │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │                    4. 制定方案                             │  │
│  │  - 图片压缩、缓存策略                                       │  │
│  │  - 内存监控、主动回收                                       │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**核心排查工具**：

| 工具 | 用途 | 关键功能 |
|------|------|----------|
| Android Studio Memory Profiler | 实时内存监控 | 内存分配追踪、Heap Dump |
| MAT (Memory Analyzer Tool) | hprof 分析 | 支配树、泄漏嫌疑报告 |
| LeakCanary | 自动泄漏检测 | 泄漏引用链、通知提醒 |
| KOOM | 线上 OOM 监控 | 自动 Dump、镜像分析 |
| adb shell dumpsys meminfo | 内存信息查看 | 各进程内存占用详情 |

### 3.3 具体排查步骤

#### 步骤一：收集内存信息

```bash
# 查看应用内存信息
adb shell dumpsys meminfo com.example.app

# 输出示例：
# Applications Memory Usage (in Kilobytes):
# Uptime: 123456789 Realtime: 123456789
#
# ** MEMINFO in pid 12345 [com.example.app] **
#                    Pss  Private  Private  SwapPss     Heap     Heap     Heap
#                  Total    Dirty    Clean    Dirty     Size    Alloc     Free
#                 ------   ------   ------   ------   ------   ------   ------
#   Native Heap    45678    45678        0        0    65536    45678    19858
#   Dalvik Heap    89012    89012        0        0   120000    89012    30988
#        ...
```

```kotlin
/**
 * 内存信息采集工具
 */
object MemoryInfoCollector {
    
    fun collectMemoryInfo(): MemoryInfo {
        val runtime = Runtime.getRuntime()
        val activityManager = App.context.getSystemService(Context.ACTIVITY_SERVICE) 
            as ActivityManager
        
        val memoryInfo = ActivityManager.MemoryInfo()
        activityManager.getMemoryInfo(memoryInfo)
        
        return MemoryInfo(
            // Java 堆内存
            javaHeapMax = runtime.maxMemory(),
            javaHeapTotal = runtime.totalMemory(),
            javaHeapFree = runtime.freeMemory(),
            javaHeapUsed = runtime.totalMemory() - runtime.freeMemory(),
            
            // 系统内存
            systemAvailable = memoryInfo.availMem,
            systemTotal = memoryInfo.totalMem,
            lowMemory = memoryInfo.lowMemory,
            threshold = memoryInfo.threshold,
            
            // Native 内存
            nativeHeap = Debug.getNativeHeapSize(),
            nativeAllocated = Debug.getNativeHeapAllocatedSize(),
            nativeFree = Debug.getNativeHeapFreeSize()
        )
    }
    
    fun isMemoryLow(): Boolean {
        val info = collectMemoryInfo()
        // Java 堆使用率超过 85% 或系统内存不足
        return info.javaHeapUsed > info.javaHeapMax * 0.85 || info.lowMemory
    }
    
    data class MemoryInfo(
        val javaHeapMax: Long,
        val javaHeapTotal: Long,
        val javaHeapFree: Long,
        val javaHeapUsed: Long,
        val systemAvailable: Long,
        val systemTotal: Long,
        val lowMemory: Boolean,
        val threshold: Long,
        val nativeHeap: Long,
        val nativeAllocated: Long,
        val nativeFree: Long
    )
}
```


#### 步骤二：Dump 并分析 hprof 文件

```kotlin
/**
 * 主动 Dump hprof 文件
 * 用于 OOM 前的内存快照
 */
object HeapDumper {
    
    private const val DUMP_DIR = "heap_dumps"
    
    /**
     * 在内存紧张时主动 Dump
     */
    fun dumpIfNeeded() {
        if (MemoryInfoCollector.isMemoryLow()) {
            dumpHeap("low_memory")
        }
    }
    
    /**
     * Dump 堆内存到文件
     */
    fun dumpHeap(tag: String): File? {
        return try {
            val dir = File(App.context.cacheDir, DUMP_DIR)
            if (!dir.exists()) dir.mkdirs()
            
            val file = File(dir, "heap_${tag}_${System.currentTimeMillis()}.hprof")
            Debug.dumpHprofData(file.absolutePath)
            
            Log.i("HeapDumper", "Heap dumped to: ${file.absolutePath}")
            file
        } catch (e: Exception) {
            Log.e("HeapDumper", "Failed to dump heap", e)
            null
        }
    }
    
    /**
     * 使用 KOOM 进行线上 OOM 监控
     */
    fun setupKOOM() {
        // KOOM 配置
        val config = OOMMonitorConfig.Builder()
            .setThreadThreshold(50)           // 线程数阈值
            .setFdThreshold(300)              // FD 数阈值
            .setHeapThreshold(0.85f)          // 堆内存阈值
            .setLoopInterval(5000)            // 检测间隔
            .setEnableHprofDump(true)         // 开启 hprof dump
            .setHprofUploader { file ->       // 上传回调
                uploadHprofFile(file)
            }
            .build()
        
        OOMMonitor.init(config)
        OOMMonitor.start()
    }
    
    private fun uploadHprofFile(file: File) {
        // 压缩并上传到服务器
        // 注意：hprof 文件可能很大，需要压缩处理
    }
}
```

#### 步骤三：MAT 分析 hprof 文件

```
┌─────────────────────────────────────────────────────────────────┐
│                    MAT 分析步骤                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. 转换 hprof 格式（Android 格式 -> 标准格式）                   │
│     hprof-conv heap.hprof heap-conv.hprof                       │
│                                                                 │
│  2. 打开 MAT，加载 hprof 文件                                    │
│                                                                 │
│  3. 查看 Leak Suspects Report（泄漏嫌疑报告）                    │
│     - 自动分析可能的内存泄漏                                     │
│     - 显示占用内存最大的对象                                     │
│                                                                 │
│  4. 查看 Dominator Tree（支配树）                                │
│     - 按 Retained Heap 排序                                     │
│     - 找出占用内存最大的对象                                     │
│                                                                 │
│  5. 使用 OQL 查询特定对象                                        │
│     SELECT * FROM android.graphics.Bitmap                       │
│     SELECT * FROM byte[] WHERE @retainedHeapSize > 1000000     │
│                                                                 │
│  6. 分析 GC Roots 引用链                                         │
│     - 右键对象 -> Path to GC Roots                              │
│     - 找出阻止对象被回收的引用                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**MAT 分析结果示例**：

```
Leak Suspects Report:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Problem Suspect 1:
  One instance of "com.example.app.ImageCache" loaded by 
  "dalvik.system.PathClassLoader" occupies 89,456,320 (42.5%) bytes.
  
  The memory is accumulated in one instance of "java.util.HashMap" 
  loaded by "<system class loader>".
  
  Keywords: java.util.HashMap, android.graphics.Bitmap

Problem Suspect 2:
  45 instances of "android.graphics.Bitmap", loaded by 
  "<system class loader>" occupy 67,108,864 (31.9%) bytes.
  
  Biggest instances:
  - android.graphics.Bitmap @ 0x12c00000 - 8,294,400 bytes
  - android.graphics.Bitmap @ 0x12d00000 - 8,294,400 bytes
  ...

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

#### 步骤四：定位问题代码

```kotlin
/**
 * 问题代码：图片缓存没有大小限制
 */
class ProblematicImageCache {
    // 问题1：使用强引用 HashMap，没有大小限制
    private val cache = HashMap<String, Bitmap>()
    
    fun put(key: String, bitmap: Bitmap) {
        // 问题2：没有检查内存状态
        cache[key] = bitmap
    }
    
    fun get(key: String): Bitmap? {
        return cache[key]
    }
    
    // 问题3：没有清理机制
}

/**
 * 问题代码：图片加载没有采样
 */
fun loadBitmapProblematic(path: String): Bitmap {
    // 问题：直接加载原图，没有采样压缩
    return BitmapFactory.decodeFile(path)
}
```


### 3.4 解决方案

#### 方案一：优化图片缓存策略

```kotlin
/**
 * 优化后的图片缓存
 * 使用 LruCache + 软引用二级缓存
 */
class OptimizedImageCache private constructor() {
    
    // 一级缓存：LruCache，强引用，有大小限制
    private val lruCache: LruCache<String, Bitmap>
    
    // 二级缓存：软引用，内存不足时自动回收
    private val softCache = ConcurrentHashMap<String, SoftReference<Bitmap>>()
    
    init {
        // 计算缓存大小：可用内存的 1/8
        val maxMemory = Runtime.getRuntime().maxMemory() / 1024
        val cacheSize = (maxMemory / 8).toInt()
        
        lruCache = object : LruCache<String, Bitmap>(cacheSize) {
            override fun sizeOf(key: String, bitmap: Bitmap): Int {
                // 返回 Bitmap 占用的内存大小（KB）
                return bitmap.byteCount / 1024
            }
            
            override fun entryRemoved(
                evicted: Boolean,
                key: String,
                oldValue: Bitmap,
                newValue: Bitmap?
            ) {
                if (evicted && !oldValue.isRecycled) {
                    // 被移除的 Bitmap 放入软引用缓存
                    softCache[key] = SoftReference(oldValue)
                }
            }
        }
    }
    
    fun put(key: String, bitmap: Bitmap) {
        lruCache.put(key, bitmap)
    }
    
    fun get(key: String): Bitmap? {
        // 先从 LruCache 获取
        var bitmap = lruCache.get(key)
        if (bitmap != null) {
            return bitmap
        }
        
        // 再从软引用缓存获取
        val softRef = softCache[key]
        if (softRef != null) {
            bitmap = softRef.get()
            if (bitmap != null && !bitmap.isRecycled) {
                // 重新放入 LruCache
                lruCache.put(key, bitmap)
                return bitmap
            } else {
                // 已被回收，移除软引用
                softCache.remove(key)
            }
        }
        
        return null
    }
    
    fun clear() {
        lruCache.evictAll()
        softCache.clear()
    }
    
    fun trimMemory(level: Int) {
        when {
            level >= ComponentCallbacks2.TRIM_MEMORY_COMPLETE -> {
                // 内存极度紧张，清空所有缓存
                clear()
            }
            level >= ComponentCallbacks2.TRIM_MEMORY_MODERATE -> {
                // 内存中度紧张，清空一半缓存
                lruCache.trimToSize(lruCache.maxSize() / 2)
            }
            level >= ComponentCallbacks2.TRIM_MEMORY_BACKGROUND -> {
                // 应用进入后台，清空软引用缓存
                softCache.clear()
            }
        }
    }
    
    companion object {
        val instance by lazy { OptimizedImageCache() }
    }
}
```

#### 方案二：图片采样压缩

```kotlin
/**
 * 图片采样加载工具
 * 根据目标尺寸计算采样率，避免加载过大的 Bitmap
 */
object BitmapSampler {
    
    /**
     * 从文件加载采样后的 Bitmap
     */
    fun decodeSampledBitmapFromFile(
        filePath: String,
        reqWidth: Int,
        reqHeight: Int
    ): Bitmap? {
        // 第一次解码：只获取尺寸，不加载像素
        val options = BitmapFactory.Options().apply {
            inJustDecodeBounds = true
        }
        BitmapFactory.decodeFile(filePath, options)
        
        // 计算采样率
        options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight)
        
        // 第二次解码：加载采样后的 Bitmap
        options.inJustDecodeBounds = false
        options.inPreferredConfig = Bitmap.Config.RGB_565  // 使用 RGB_565 减少内存
        
        return BitmapFactory.decodeFile(filePath, options)
    }
    
    /**
     * 从资源加载采样后的 Bitmap
     */
    fun decodeSampledBitmapFromResource(
        res: Resources,
        resId: Int,
        reqWidth: Int,
        reqHeight: Int
    ): Bitmap? {
        val options = BitmapFactory.Options().apply {
            inJustDecodeBounds = true
        }
        BitmapFactory.decodeResource(res, resId, options)
        
        options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight)
        options.inJustDecodeBounds = false
        options.inPreferredConfig = Bitmap.Config.RGB_565
        
        return BitmapFactory.decodeResource(res, resId, options)
    }
    
    /**
     * 计算采样率
     * 采样率必须是 2 的幂次方
     */
    private fun calculateInSampleSize(
        options: BitmapFactory.Options,
        reqWidth: Int,
        reqHeight: Int
    ): Int {
        val (height, width) = options.outHeight to options.outWidth
        var inSampleSize = 1
        
        if (height > reqHeight || width > reqWidth) {
            val halfHeight = height / 2
            val halfWidth = width / 2
            
            // 计算最大的 inSampleSize 值，使得宽高都大于请求的尺寸
            while (halfHeight / inSampleSize >= reqHeight 
                   && halfWidth / inSampleSize >= reqWidth) {
                inSampleSize *= 2
            }
        }
        
        return inSampleSize
    }
    
    /**
     * 计算 Bitmap 内存占用
     */
    fun calculateBitmapMemory(width: Int, height: Int, config: Bitmap.Config): Long {
        val bytesPerPixel = when (config) {
            Bitmap.Config.ARGB_8888 -> 4
            Bitmap.Config.RGB_565 -> 2
            Bitmap.Config.ARGB_4444 -> 2
            Bitmap.Config.ALPHA_8 -> 1
            else -> 4
        }
        return (width * height * bytesPerPixel).toLong()
    }
}
```

#### 方案三：Bitmap 复用池

```kotlin
/**
 * Bitmap 复用池
 * 复用已分配的 Bitmap 内存，减少内存分配和 GC
 */
class BitmapPool(private val maxSize: Int) {
    
    // 按尺寸分组存储可复用的 Bitmap
    private val pool = ConcurrentHashMap<String, LinkedList<SoftReference<Bitmap>>>()
    private var currentSize = 0
    
    /**
     * 获取可复用的 Bitmap
     */
    fun get(width: Int, height: Int, config: Bitmap.Config): Bitmap? {
        val key = generateKey(width, height, config)
        val list = pool[key] ?: return null
        
        synchronized(list) {
            while (list.isNotEmpty()) {
                val ref = list.removeFirst()
                val bitmap = ref.get()
                if (bitmap != null && !bitmap.isRecycled) {
                    currentSize -= bitmap.byteCount
                    return bitmap
                }
            }
        }
        return null
    }
    
    /**
     * 回收 Bitmap 到复用池
     */
    fun put(bitmap: Bitmap) {
        if (bitmap.isRecycled || !bitmap.isMutable) {
            return
        }
        
        val size = bitmap.byteCount
        if (size > maxSize / 4) {
            // 单个 Bitmap 太大，不放入复用池
            return
        }
        
        // 如果池已满，先清理
        while (currentSize + size > maxSize) {
            if (!evictOne()) break
        }
        
        val key = generateKey(bitmap.width, bitmap.height, bitmap.config)
        val list = pool.getOrPut(key) { LinkedList() }
        
        synchronized(list) {
            list.add(SoftReference(bitmap))
            currentSize += size
        }
    }
    
    /**
     * 配合 BitmapFactory.Options 使用
     */
    fun getBitmapOptions(width: Int, height: Int, config: Bitmap.Config): BitmapFactory.Options {
        return BitmapFactory.Options().apply {
            inMutable = true
            inPreferredConfig = config
            
            // 尝试获取可复用的 Bitmap
            val reusable = get(width, height, config)
            if (reusable != null) {
                inBitmap = reusable
            }
        }
    }
    
    private fun generateKey(width: Int, height: Int, config: Bitmap.Config): String {
        return "${width}_${height}_${config.name}"
    }
    
    private fun evictOne(): Boolean {
        for ((_, list) in pool) {
            synchronized(list) {
                if (list.isNotEmpty()) {
                    val ref = list.removeFirst()
                    val bitmap = ref.get()
                    if (bitmap != null) {
                        currentSize -= bitmap.byteCount
                        return true
                    }
                }
            }
        }
        return false
    }
    
    fun clear() {
        pool.clear()
        currentSize = 0
    }
}
```


#### 方案四：内存监控与主动回收

```kotlin
/**
 * 内存监控管理器
 * 监控内存状态，在内存紧张时主动释放资源
 */
class MemoryMonitor private constructor(private val app: Application) {
    
    private val listeners = mutableListOf<OnMemoryWarningListener>()
    private val handler = Handler(Looper.getMainLooper())
    
    // 内存检测任务
    private val memoryCheckRunnable = object : Runnable {
        override fun run() {
            checkMemoryStatus()
            handler.postDelayed(this, CHECK_INTERVAL)
        }
    }
    
    init {
        // 注册系统内存回调
        app.registerComponentCallbacks(object : ComponentCallbacks2 {
            override fun onConfigurationChanged(newConfig: Configuration) {}
            
            override fun onLowMemory() {
                notifyMemoryWarning(MemoryWarningLevel.CRITICAL)
            }
            
            override fun onTrimMemory(level: Int) {
                val warningLevel = when {
                    level >= ComponentCallbacks2.TRIM_MEMORY_COMPLETE -> 
                        MemoryWarningLevel.CRITICAL
                    level >= ComponentCallbacks2.TRIM_MEMORY_MODERATE -> 
                        MemoryWarningLevel.HIGH
                    level >= ComponentCallbacks2.TRIM_MEMORY_BACKGROUND -> 
                        MemoryWarningLevel.MEDIUM
                    level >= ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN -> 
                        MemoryWarningLevel.LOW
                    else -> null
                }
                warningLevel?.let { notifyMemoryWarning(it) }
            }
        })
    }
    
    fun start() {
        handler.post(memoryCheckRunnable)
    }
    
    fun stop() {
        handler.removeCallbacks(memoryCheckRunnable)
    }
    
    private fun checkMemoryStatus() {
        val info = MemoryInfoCollector.collectMemoryInfo()
        val usageRatio = info.javaHeapUsed.toFloat() / info.javaHeapMax
        
        val warningLevel = when {
            usageRatio > 0.9f -> MemoryWarningLevel.CRITICAL
            usageRatio > 0.8f -> MemoryWarningLevel.HIGH
            usageRatio > 0.7f -> MemoryWarningLevel.MEDIUM
            else -> null
        }
        
        warningLevel?.let { 
            notifyMemoryWarning(it)
            
            // 记录内存状态
            logMemoryStatus(info, it)
        }
    }
    
    private fun notifyMemoryWarning(level: MemoryWarningLevel) {
        listeners.forEach { it.onMemoryWarning(level) }
    }
    
    private fun logMemoryStatus(info: MemoryInfoCollector.MemoryInfo, level: MemoryWarningLevel) {
        Log.w("MemoryMonitor", """
            |Memory Warning: $level
            |  Java Heap: ${info.javaHeapUsed / 1024 / 1024}MB / ${info.javaHeapMax / 1024 / 1024}MB
            |  Native Heap: ${info.nativeAllocated / 1024 / 1024}MB
            |  System Available: ${info.systemAvailable / 1024 / 1024}MB
        """.trimMargin())
    }
    
    fun addListener(listener: OnMemoryWarningListener) {
        listeners.add(listener)
    }
    
    fun removeListener(listener: OnMemoryWarningListener) {
        listeners.remove(listener)
    }
    
    interface OnMemoryWarningListener {
        fun onMemoryWarning(level: MemoryWarningLevel)
    }
    
    enum class MemoryWarningLevel {
        LOW, MEDIUM, HIGH, CRITICAL
    }
    
    companion object {
        private const val CHECK_INTERVAL = 5000L
        
        @Volatile
        private var instance: MemoryMonitor? = null
        
        fun init(app: Application) {
            if (instance == null) {
                synchronized(this) {
                    if (instance == null) {
                        instance = MemoryMonitor(app)
                    }
                }
            }
        }
        
        fun getInstance(): MemoryMonitor = instance 
            ?: throw IllegalStateException("MemoryMonitor not initialized")
    }
}

/**
 * 图片详情页内存优化示例
 */
class ImageDetailActivity : AppCompatActivity(), 
    MemoryMonitor.OnMemoryWarningListener {
    
    private lateinit var viewPager: ViewPager2
    private lateinit var adapter: ImagePagerAdapter
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_image_detail)
        
        // 注册内存监听
        MemoryMonitor.getInstance().addListener(this)
        
        setupViewPager()
    }
    
    override fun onDestroy() {
        super.onDestroy()
        MemoryMonitor.getInstance().removeListener(this)
        
        // 清理资源
        adapter.clearCache()
    }
    
    override fun onMemoryWarning(level: MemoryMonitor.MemoryWarningLevel) {
        when (level) {
            MemoryMonitor.MemoryWarningLevel.CRITICAL -> {
                // 内存极度紧张，只保留当前页
                adapter.trimToCurrentPage(viewPager.currentItem)
            }
            MemoryMonitor.MemoryWarningLevel.HIGH -> {
                // 内存紧张，清理非相邻页面
                adapter.trimToNearbyPages(viewPager.currentItem, 1)
            }
            MemoryMonitor.MemoryWarningLevel.MEDIUM -> {
                // 内存中度紧张，清理远离的页面
                adapter.trimToNearbyPages(viewPager.currentItem, 2)
            }
            else -> {}
        }
    }
    
    private fun setupViewPager() {
        // 限制预加载页数
        viewPager.offscreenPageLimit = 1
    }
}
```

### 3.5 优化效果量化

| 优化项 | 优化前 | 优化后 | 提升幅度 |
|--------|--------|--------|----------|
| OOM Crash 率 | 0.5% | 0.02% | -96% |
| 图片内存占用峰值 | 200MB | 80MB | -60% |
| 图片加载内存分配 | 每张 8MB | 每张 2MB | -75% |
| GC 频率 | 每秒 3 次 | 每秒 0.5 次 | -83% |
| 低端机崩溃率 | 2.5% | 0.1% | -96% |

### 3.6 面试回答要点

1. **问题定位**：通过 MAT 分析 hprof 文件，发现图片缓存无限增长
2. **缓存优化**：使用 LruCache + 软引用二级缓存，限制缓存大小
3. **采样压缩**：根据目标尺寸计算采样率，使用 RGB_565 格式
4. **Bitmap 复用**：实现 Bitmap 复用池，减少内存分配
5. **主动回收**：监控内存状态，在内存紧张时主动释放资源
6. **量化效果**：OOM 率从 0.5% 降到 0.02%，降低 96%

---

## 4. ANR 问题排查

### 4.1 问题背景描述

**场景描述**：
新闻 App 在用户点击文章详情时，偶发出现 ANR（Application Not Responding），用户反馈点击后无响应，需要等待 5 秒以上才能进入详情页。

**问题表现**：
- 点击文章后界面卡住
- 系统弹出 ANR 对话框
- 线上 ANR 率达到 0.3%
- 主要发生在网络较差的环境

**ANR 类型**：
```
┌─────────────────────────────────────────────────────────────────┐
│                    ANR 类型与超时时间                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  类型                          超时时间        触发场景          │
│  ─────────────────────────────────────────────────────────────  │
│  Input dispatching timed out   5s            输入事件无响应      │
│  Service timeout               前台 20s       Service 执行超时   │
│                                后台 200s                        │
│  Broadcast timeout             前台 10s       广播处理超时       │
│                                后台 60s                         │
│  ContentProvider timeout       10s           Provider 操作超时   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```


### 4.2 排查思路与工具

```
┌─────────────────────────────────────────────────────────────────┐
│                    ANR 排查流程                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐  │
│  │ 获取日志  │───▶│ 分析堆栈  │───▶│ 定位原因  │───▶│ 修复验证  │  │
│  └──────────┘    └──────────┘    └──────────┘    └──────────┘  │
│       │              │              │              │           │
│       ▼              ▼              ▼              ▼           │
│  ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐  │
│  │ traces   │    │ 主线程   │    │ 锁等待   │    │ 异步化   │  │
│  │ logcat   │    │ 状态分析  │    │ IO阻塞   │    │ 优化锁   │  │
│  │ bugreport│    │ 锁分析   │    │ 死锁     │    │ 线程池   │  │
│  └──────────┘    └──────────┘    │ Binder   │    └──────────┘  │
│                                  └──────────┘                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**核心排查工具**：

| 工具 | 用途 | 获取方式 |
|------|------|----------|
| traces.txt | ANR 时的线程堆栈 | /data/anr/traces.txt |
| logcat | 系统日志 | adb logcat |
| bugreport | 完整系统报告 | adb bugreport |
| Systrace | 系统级性能分析 | Android Studio |
| StrictMode | 主线程违规检测 | 代码配置 |
| BlockCanary | 卡顿检测 | 第三方库 |

### 4.3 具体排查步骤

#### 步骤一：获取 ANR 日志

```bash
# 获取 ANR traces 文件
adb pull /data/anr/traces.txt

# 获取 logcat 中的 ANR 信息
adb logcat -d | grep -i anr

# 获取完整 bugreport
adb bugreport > bugreport.zip
```

**traces.txt 分析示例**：

```
----- pid 12345 at 2024-01-15 10:30:45 -----
Cmd line: com.example.app
Build fingerprint: 'google/redfin/redfin:12/SQ1A.220205.002/8151327:user/release-keys'

DALVIK THREADS (25):
"main" prio=5 tid=1 Blocked
  | group="main" sCount=1 dsCount=0 flags=1 obj=0x72a4e0a0 self=0xb4000078d7c0e010
  | sysTid=12345 nice=-10 cgrp=default sched=0/0 handle=0x79e5c4f4f8
  | state=S schedstat=( 1234567890 234567890 12345 ) utm=100 stm=23 core=4 HZ=100
  | stack=0x7ffc123000-0x7ffc125000 stackSize=8192KB
  | held mutexes=
  at com.example.app.ArticleRepository.loadArticle(ArticleRepository.java:45)
  - waiting to lock <0x0a1b2c3d> (a java.lang.Object) held by thread 15
  at com.example.app.ArticleDetailActivity.onCreate(ArticleDetailActivity.java:32)
  at android.app.Activity.performCreate(Activity.java:8000)
  ...

"OkHttp Dispatcher" prio=5 tid=15 Native
  | group="main" sCount=1 dsCount=0 flags=1 obj=0x12c45678 self=0xb4000078d7c12340
  | sysTid=12360 nice=0 cgrp=default sched=0/0 handle=0x79e1234560
  | state=S schedstat=( 567890123 67890123 5678 ) utm=50 stm=10 core=2 HZ=100
  | stack=0x79e0000000-0x79e0002000 stackSize=1040KB
  | held mutexes=
  - locked <0x0a1b2c3d> (a java.lang.Object)
  at java.net.SocketInputStream.socketRead0(Native Method)
  at java.net.SocketInputStream.read(SocketInputStream.java:152)
  at okio.InputStreamSource.read(JvmOkio.kt:90)
  ...
```

#### 步骤二：分析 ANR 堆栈

```kotlin
/**
 * ANR 堆栈分析工具
 */
object ANRAnalyzer {
    
    /**
     * 分析 traces.txt 文件
     */
    fun analyzeTraces(tracesContent: String): ANRReport {
        val report = ANRReport()
        
        // 解析主线程状态
        val mainThreadPattern = """"main".*?tid=1\s+(\w+)""".toRegex()
        val mainThreadMatch = mainThreadPattern.find(tracesContent)
        report.mainThreadState = mainThreadMatch?.groupValues?.get(1) ?: "Unknown"
        
        // 检查是否有锁等待
        if (tracesContent.contains("waiting to lock")) {
            report.hasLockContention = true
            report.lockInfo = extractLockInfo(tracesContent)
        }
        
        // 检查是否有 IO 操作
        if (tracesContent.contains("SocketInputStream") || 
            tracesContent.contains("FileInputStream")) {
            report.hasIOBlocking = true
        }
        
        // 检查是否有 Binder 调用
        if (tracesContent.contains("Binder.transact")) {
            report.hasBinderBlocking = true
        }
        
        // 提取关键堆栈
        report.keyStack = extractKeyStack(tracesContent)
        
        return report
    }
    
    private fun extractLockInfo(content: String): LockInfo {
        val waitingPattern = """waiting to lock <(0x[0-9a-f]+)>.*?held by thread (\d+)""".toRegex()
        val match = waitingPattern.find(content)
        
        return LockInfo(
            lockAddress = match?.groupValues?.get(1) ?: "",
            holdingThread = match?.groupValues?.get(2)?.toIntOrNull() ?: -1
        )
    }
    
    private fun extractKeyStack(content: String): List<String> {
        // 提取主线程的关键堆栈帧
        val stackPattern = """at (com\.example\.app\.[^\n]+)""".toRegex()
        return stackPattern.findAll(content)
            .map { it.groupValues[1] }
            .take(10)
            .toList()
    }
    
    data class ANRReport(
        var mainThreadState: String = "",
        var hasLockContention: Boolean = false,
        var lockInfo: LockInfo? = null,
        var hasIOBlocking: Boolean = false,
        var hasBinderBlocking: Boolean = false,
        var keyStack: List<String> = emptyList()
    )
    
    data class LockInfo(
        val lockAddress: String,
        val holdingThread: Int
    )
}
```

#### 步骤三：使用 StrictMode 检测

```kotlin
/**
 * StrictMode 配置
 * 在 Debug 模式下检测主线程违规操作
 */
object StrictModeHelper {
    
    fun enable() {
        if (BuildConfig.DEBUG) {
            // 线程策略：检测主线程的违规操作
            StrictMode.setThreadPolicy(
                StrictMode.ThreadPolicy.Builder()
                    .detectDiskReads()      // 检测磁盘读取
                    .detectDiskWrites()     // 检测磁盘写入
                    .detectNetwork()        // 检测网络操作
                    .detectCustomSlowCalls() // 检测自定义慢调用
                    .penaltyLog()           // 违规时打印日志
                    .penaltyFlashScreen()   // 违规时闪屏提示
                    .build()
            )
            
            // VM 策略：检测内存泄漏等问题
            StrictMode.setVmPolicy(
                StrictMode.VmPolicy.Builder()
                    .detectLeakedSqlLiteObjects()    // 检测 SQLite 泄漏
                    .detectLeakedClosableObjects()   // 检测未关闭的对象
                    .detectActivityLeaks()           // 检测 Activity 泄漏
                    .detectLeakedRegistrationObjects() // 检测未注销的监听器
                    .penaltyLog()
                    .build()
            )
        }
    }
    
    /**
     * 标记自定义慢调用
     */
    fun noteSlowCall(name: String) {
        if (BuildConfig.DEBUG) {
            StrictMode.noteSlowCall(name)
        }
    }
}
```

#### 步骤四：ANR 监控上报

```kotlin
/**
 * ANR 监控器
 * 通过 Watchdog 机制检测主线程卡顿
 */
class ANRWatchdog : Thread("ANR-Watchdog") {
    
    private val handler = Handler(Looper.getMainLooper())
    private val checkInterval = 5000L  // 检测间隔
    private val anrThreshold = 5000L   // ANR 阈值
    
    @Volatile
    private var tick = 0L
    
    @Volatile
    private var reported = false
    
    private val ticker = Runnable {
        tick = System.currentTimeMillis()
        reported = false
    }
    
    override fun run() {
        while (!isInterrupted) {
            // 重置 tick
            tick = 0
            handler.post(ticker)
            
            try {
                sleep(checkInterval)
            } catch (e: InterruptedException) {
                break
            }
            
            // 检查主线程是否响应
            if (tick == 0L && !reported) {
                // 主线程未响应，可能发生 ANR
                reported = true
                reportPotentialANR()
            } else if (tick != 0L) {
                val blockTime = System.currentTimeMillis() - tick
                if (blockTime > anrThreshold && !reported) {
                    reported = true
                    reportPotentialANR()
                }
            }
        }
    }
    
    private fun reportPotentialANR() {
        // 获取主线程堆栈
        val mainThread = Looper.getMainLooper().thread
        val stackTrace = mainThread.stackTrace
        
        val stackString = stackTrace.joinToString("\n") { 
            "    at ${it.className}.${it.methodName}(${it.fileName}:${it.lineNumber})"
        }
        
        Log.e("ANRWatchdog", "Potential ANR detected!\n$stackString")
        
        // 上报到监控平台
        ANRReporter.report(
            stackTrace = stackString,
            timestamp = System.currentTimeMillis(),
            memoryInfo = MemoryInfoCollector.collectMemoryInfo()
        )
    }
}
```


### 4.4 解决方案

#### 方案一：异步化耗时操作

```kotlin
/**
 * 问题代码：主线程同步加载数据
 */
class ProblematicArticleDetailActivity : AppCompatActivity() {
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        // 问题：主线程同步网络请求
        val article = articleRepository.loadArticle(articleId)  // 阻塞主线程
        displayArticle(article)
    }
}

/**
 * 优化后：使用协程异步加载
 */
class OptimizedArticleDetailActivity : AppCompatActivity() {
    
    private val viewModel: ArticleViewModel by viewModels()
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_article_detail)
        
        // 显示加载状态
        showLoading()
        
        // 观察数据变化
        viewModel.article.observe(this) { result ->
            when (result) {
                is Result.Success -> {
                    hideLoading()
                    displayArticle(result.data)
                }
                is Result.Error -> {
                    hideLoading()
                    showError(result.exception)
                }
                is Result.Loading -> showLoading()
            }
        }
        
        // 异步加载数据
        viewModel.loadArticle(articleId)
    }
}

/**
 * ViewModel：使用协程处理异步操作
 */
class ArticleViewModel(
    private val repository: ArticleRepository
) : ViewModel() {
    
    private val _article = MutableLiveData<Result<Article>>()
    val article: LiveData<Result<Article>> = _article
    
    fun loadArticle(id: String) {
        viewModelScope.launch {
            _article.value = Result.Loading
            
            try {
                // 在 IO 线程执行网络请求
                val article = withContext(Dispatchers.IO) {
                    repository.loadArticle(id)
                }
                _article.value = Result.Success(article)
            } catch (e: Exception) {
                _article.value = Result.Error(e)
            }
        }
    }
}

/**
 * Repository：提供挂起函数
 */
class ArticleRepository(
    private val api: ArticleApi,
    private val cache: ArticleCache
) {
    
    suspend fun loadArticle(id: String): Article {
        // 先从缓存获取
        cache.get(id)?.let { return it }
        
        // 缓存未命中，从网络获取
        val article = api.getArticle(id)
        cache.put(id, article)
        
        return article
    }
}
```

#### 方案二：优化锁竞争

```kotlin
/**
 * 问题代码：粗粒度锁导致竞争
 */
class ProblematicCache {
    private val cache = mutableMapOf<String, Any>()
    
    // 问题：整个方法加锁，锁粒度太大
    @Synchronized
    fun get(key: String): Any? {
        return cache[key]
    }
    
    @Synchronized
    fun put(key: String, value: Any) {
        cache[key] = value
    }
}

/**
 * 优化后：使用细粒度锁或无锁数据结构
 */
class OptimizedCache {
    // 方案1：使用 ConcurrentHashMap
    private val cache = ConcurrentHashMap<String, Any>()
    
    fun get(key: String): Any? = cache[key]
    
    fun put(key: String, value: Any) {
        cache[key] = value
    }
}

/**
 * 优化后：使用读写锁
 */
class ReadWriteLockCache {
    private val cache = mutableMapOf<String, Any>()
    private val lock = ReentrantReadWriteLock()
    
    fun get(key: String): Any? {
        lock.readLock().lock()
        try {
            return cache[key]
        } finally {
            lock.readLock().unlock()
        }
    }
    
    fun put(key: String, value: Any) {
        lock.writeLock().lock()
        try {
            cache[key] = value
        } finally {
            lock.writeLock().unlock()
        }
    }
}

/**
 * 优化后：使用分段锁
 */
class SegmentedCache(private val segmentCount: Int = 16) {
    
    private val segments = Array(segmentCount) { Segment() }
    
    private fun getSegment(key: String): Segment {
        val hash = key.hashCode()
        val index = (hash and 0x7FFFFFFF) % segmentCount
        return segments[index]
    }
    
    fun get(key: String): Any? {
        return getSegment(key).get(key)
    }
    
    fun put(key: String, value: Any) {
        getSegment(key).put(key, value)
    }
    
    private class Segment {
        private val map = mutableMapOf<String, Any>()
        private val lock = ReentrantLock()
        
        fun get(key: String): Any? {
            lock.lock()
            try {
                return map[key]
            } finally {
                lock.unlock()
            }
        }
        
        fun put(key: String, value: Any) {
            lock.lock()
            try {
                map[key] = value
            } finally {
                lock.unlock()
            }
        }
    }
}
```

#### 方案三：优化 SharedPreferences

```kotlin
/**
 * 问题代码：主线程同步读写 SP
 */
class ProblematicSettings {
    
    private val sp = context.getSharedPreferences("settings", Context.MODE_PRIVATE)
    
    // 问题1：主线程同步读取
    fun getTheme(): String {
        return sp.getString("theme", "light") ?: "light"
    }
    
    // 问题2：使用 commit() 同步写入
    fun setTheme(theme: String) {
        sp.edit().putString("theme", theme).commit()  // 阻塞主线程
    }
}

/**
 * 优化后：异步读写 + MMKV
 */
class OptimizedSettings {
    
    // 方案1：使用 apply() 替代 commit()
    private val sp = context.getSharedPreferences("settings", Context.MODE_PRIVATE)
    
    fun setThemeAsync(theme: String) {
        sp.edit().putString("theme", theme).apply()  // 异步写入
    }
    
    // 方案2：使用 MMKV 替代 SharedPreferences
    private val mmkv = MMKV.defaultMMKV()
    
    fun getTheme(): String {
        return mmkv.decodeString("theme", "light") ?: "light"
    }
    
    fun setTheme(theme: String) {
        mmkv.encode("theme", theme)  // MMKV 写入非常快
    }
}

/**
 * 方案3：使用 DataStore
 */
class DataStoreSettings(private val context: Context) {
    
    private val Context.dataStore by preferencesDataStore(name = "settings")
    
    private val themeKey = stringPreferencesKey("theme")
    
    val themeFlow: Flow<String> = context.dataStore.data
        .map { preferences ->
            preferences[themeKey] ?: "light"
        }
    
    suspend fun setTheme(theme: String) {
        context.dataStore.edit { preferences ->
            preferences[themeKey] = theme
        }
    }
}
```

#### 方案四：Binder 调用优化

```kotlin
/**
 * 问题代码：主线程 Binder 调用
 */
class ProblematicService {
    
    fun checkPermission(): Boolean {
        // 问题：主线程调用系统服务，可能阻塞
        val pm = context.packageManager
        return pm.checkPermission(
            Manifest.permission.CAMERA,
            context.packageName
        ) == PackageManager.PERMISSION_GRANTED
    }
}

/**
 * 优化后：缓存 + 异步
 */
class OptimizedService {
    
    // 缓存权限状态
    private val permissionCache = ConcurrentHashMap<String, Boolean>()
    
    fun checkPermissionCached(permission: String): Boolean {
        return permissionCache.getOrPut(permission) {
            checkPermissionInternal(permission)
        }
    }
    
    private fun checkPermissionInternal(permission: String): Boolean {
        return ContextCompat.checkSelfPermission(
            context, permission
        ) == PackageManager.PERMISSION_GRANTED
    }
    
    // 异步检查权限
    suspend fun checkPermissionAsync(permission: String): Boolean {
        return withContext(Dispatchers.IO) {
            checkPermissionInternal(permission)
        }
    }
    
    // 清除缓存（权限变化时调用）
    fun clearCache() {
        permissionCache.clear()
    }
}
```

### 4.5 优化效果量化

| 优化项 | 优化前 | 优化后 | 提升幅度 |
|--------|--------|--------|----------|
| ANR 率 | 0.3% | 0.01% | -97% |
| 主线程阻塞时间 | 平均 800ms | 平均 50ms | -94% |
| 页面打开时间 | 2.5s | 0.8s | -68% |
| 锁等待次数 | 每分钟 50 次 | 每分钟 5 次 | -90% |

### 4.6 面试回答要点

1. **问题定位**：通过 traces.txt 分析，发现主线程在等待网络请求的锁
2. **异步化**：将网络请求移到 IO 线程，使用协程处理异步
3. **锁优化**：使用 ConcurrentHashMap 替代 synchronized
4. **SP 优化**：使用 apply() 替代 commit()，或迁移到 MMKV
5. **Binder 优化**：缓存系统服务调用结果，减少 Binder 调用
6. **量化效果**：ANR 率从 0.3% 降到 0.01%，降低 97%

---

## 5. 启动优化实战

### 5.1 问题背景描述

**场景描述**：
电商 App 冷启动时间过长，用户从点击图标到看到首页内容需要 4 秒以上，严重影响用户体验和留存率。

**问题表现**：
- 冷启动时间 > 4s
- 启动过程中白屏/黑屏时间长
- 首页内容加载慢
- 低端机型启动时间是高端机型的 2-3 倍

**启动阶段划分**：
```
┌─────────────────────────────────────────────────────────────────┐
│                    App 启动阶段                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  点击图标                                                        │
│     │                                                           │
│     ▼                                                           │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │ T1: 进程创建阶段                                           │  │
│  │     - fork 进程                                           │  │
│  │     - 加载 APK                                            │  │
│  │     - 创建 Application                                    │  │
│  └──────────────────────────────────────────────────────────┘  │
│     │                                                           │
│     ▼                                                           │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │ T2: Application 初始化阶段                                 │  │
│  │     - attachBaseContext()                                 │  │
│  │     - onCreate()                                          │  │
│  │     - 各种 SDK 初始化                                      │  │
│  └──────────────────────────────────────────────────────────┘  │
│     │                                                           │
│     ▼                                                           │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │ T3: Activity 创建阶段                                      │  │
│  │     - onCreate()                                          │  │
│  │     - onStart()                                           │  │
│  │     - onResume()                                          │  │
│  └──────────────────────────────────────────────────────────┘  │
│     │                                                           │
│     ▼                                                           │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │ T4: 首帧渲染阶段                                           │  │
│  │     - View 测量、布局、绘制                                 │  │
│  │     - 首帧数据加载                                         │  │
│  └──────────────────────────────────────────────────────────┘  │
│     │                                                           │
│     ▼                                                           │
│  首页可见                                                        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```
