# 稳定性优化

## 1. 概述

稳定性是衡量 App 质量的核心指标之一，直接影响用户体验和留存率。稳定性问题主要包括 **Crash（崩溃）** 和 **ANR（Application Not Responding）** 两大类。

**稳定性指标：**
- **Crash Rate（崩溃率）**：崩溃用户数 / 日活用户数（DAU），业界优秀标准 < 0.1%
- **ANR Rate（ANR 率）**：ANR 用户数 / DAU，业界优秀标准 < 0.01%
- **MTBF（平均无故障时间）**：两次崩溃之间的平均使用时长

**稳定性问题分类：**

```
┌─────────────────────────────────────────────────────────────────┐
│                        稳定性问题                                │
├─────────────────────────────┬───────────────────────────────────┤
│           Crash             │              ANR                  │
├─────────────────────────────┼───────────────────────────────────┤
│  • Java Crash               │  • Input ANR (5s)                 │
│  • Native Crash             │  • Service ANR (20s/200s)         │
│  • OOM                      │  • Broadcast ANR (10s/60s)        │
│  • 资源耗尽                  │  • ContentProvider ANR (10s)      │
└─────────────────────────────┴───────────────────────────────────┘
```

## 2. 核心原理

### 2.1 Java Crash 原理

Java Crash 是由未捕获的异常（Uncaught Exception）导致的应用崩溃。

**异常传播机制：**

```
┌─────────────────────────────────────────────────────────────────┐
│                     异常抛出                                     │
└───────────────────────────┬─────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────────┐
│              当前方法是否有 try-catch？                          │
├─────────────────────────────────────────────────────────────────┤
│     是 → 捕获处理                                                │
│     否 → 向上层调用栈传播                                        │
└───────────────────────────┬─────────────────────────────────────┘
                            │ 否
                            ▼
┌─────────────────────────────────────────────────────────────────┐
│              到达线程顶层（Thread.run）                          │
└───────────────────────────┬─────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────────┐
│     Thread.UncaughtExceptionHandler.uncaughtException()         │
└───────────────────────────┬─────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────────┐
│     ThreadGroup.uncaughtException()                             │
└───────────────────────────┬─────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────────┐
│     Thread.getDefaultUncaughtExceptionHandler()                 │
│     → RuntimeInit$KillApplicationHandler                        │
└───────────────────────────┬─────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────────┐
│                    Process.killProcess()                        │
│                    System.exit(10)                              │
└─────────────────────────────────────────────────────────────────┘
```


### 2.2 Native Crash 原理

Native Crash 是由 Native 代码（C/C++）中的错误导致的崩溃，通常是信号（Signal）触发。

**常见信号类型：**

| 信号 | 编号 | 说明 | 常见原因 |
|-----|------|------|---------|
| SIGSEGV | 11 | 段错误 | 空指针、野指针、数组越界 |
| SIGABRT | 6 | 异常终止 | abort() 调用、assert 失败 |
| SIGBUS | 7 | 总线错误 | 内存对齐问题 |
| SIGFPE | 8 | 浮点异常 | 除零错误 |
| SIGILL | 4 | 非法指令 | 执行非法 CPU 指令 |
| SIGPIPE | 13 | 管道破裂 | 向已关闭的 socket 写数据 |

**Native Crash 处理流程：**

```
┌─────────────────────────────────────────────────────────────────┐
│                    Native 代码异常                               │
│              (空指针、数组越界、栈溢出等)                         │
└───────────────────────────┬─────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────────┐
│                    内核发送信号                                  │
│              (SIGSEGV、SIGABRT 等)                               │
└───────────────────────────┬─────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────────┐
│                 信号处理器 (Signal Handler)                      │
│              debuggerd_signal_handler                           │
└───────────────────────────┬─────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────────┐
│                    debuggerd 守护进程                            │
│              收集崩溃信息、生成 tombstone                         │
└───────────────────────────┬─────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────────┐
│                 /data/tombstones/tombstone_XX                   │
│              包含寄存器、调用栈、内存映射等                       │
└─────────────────────────────────────────────────────────────────┘
```

### 2.3 ANR 原理

ANR（Application Not Responding）是指应用在规定时间内没有响应用户输入或完成特定操作。

**ANR 触发条件：**

| 类型 | 超时时间 | 触发条件 |
|-----|---------|---------|
| Input ANR | 5 秒 | 输入事件（触摸、按键）未在 5 秒内处理完成 |
| Service ANR | 前台 20 秒 / 后台 200 秒 | Service 生命周期方法执行超时 |
| Broadcast ANR | 前台 10 秒 / 后台 60 秒 | BroadcastReceiver.onReceive() 执行超时 |
| ContentProvider ANR | 10 秒 | ContentProvider 发布超时 |

**ANR 检测机制（以 Service 为例）：**

```
┌─────────────────────────────────────────────────────────────────┐
│                    AMS.realStartServiceLocked()                 │
└───────────────────────────┬─────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────────┐
│              bumpServiceExecutingLocked()                       │
│              发送 SERVICE_TIMEOUT_MSG 延迟消息                   │
│              前台服务: 20s, 后台服务: 200s                        │
└───────────────────────────┬─────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────────┐
│              App 进程执行 Service 生命周期                       │
│              onCreate() / onStartCommand() / onBind()           │
└───────────────────────────┬─────────────────────────────────────┘
                            │
              ┌─────────────┴─────────────┐
              │                           │
              ▼                           ▼
┌─────────────────────────┐   ┌─────────────────────────┐
│     执行完成             │   │     超时未完成           │
│  serviceDoneExecuting() │   │  SERVICE_TIMEOUT_MSG    │
│  移除超时消息            │   │  触发 ANR               │
└─────────────────────────┘   └─────────────────────────┘
```


## 3. 关键源码解析

### 3.1 Java Crash 捕获机制

#### 3.1.1 系统默认异常处理器

```java
// frameworks/base/core/java/com/android/internal/os/RuntimeInit.java
public class RuntimeInit {
    
    /**
     * 应用进程启动时设置默认异常处理器
     */
    protected static final void commonInit() {
        // 设置默认的未捕获异常处理器
        Thread.setDefaultUncaughtExceptionHandler(
            new KillApplicationHandler(loggingHandler));
    }
    
    /**
     * 默认异常处理器：杀死应用进程
     */
    private static class KillApplicationHandler 
            implements Thread.UncaughtExceptionHandler {
        
        private final LoggingHandler mLoggingHandler;
        
        @Override
        public void uncaughtException(Thread t, Throwable e) {
            try {
                // 1. 确保日志处理器先执行
                ensureLogging(t, e);
                
                // 2. 如果是 OnePlusException，特殊处理
                if (e instanceof OnePlusException) {
                    return;
                }
                
                // 3. 通知 AMS 应用崩溃
                ActivityManager.getService().handleApplicationCrash(
                        mApplicationObject,  // ApplicationThread
                        new ApplicationErrorReport.ParcelableCrashInfo(e));
                        
            } catch (Throwable t2) {
                // 忽略二次异常
            } finally {
                // 4. 杀死进程
                Process.killProcess(Process.myPid());
                System.exit(10);
            }
        }
    }
}
```

#### 3.1.2 自定义 Crash 捕获

```kotlin
/**
 * 自定义 Crash 处理器
 * 用于捕获 Java 层崩溃，上报到服务器
 */
class CrashHandler private constructor() : Thread.UncaughtExceptionHandler {
    
    // 系统默认的异常处理器
    private var defaultHandler: Thread.UncaughtExceptionHandler? = null
    private lateinit var context: Context
    
    companion object {
        val instance: CrashHandler by lazy(LazyThreadSafetyMode.SYNCHRONIZED) {
            CrashHandler()
        }
    }
    
    /**
     * 初始化，在 Application.onCreate() 中调用
     */
    fun init(context: Context) {
        this.context = context.applicationContext
        // 保存系统默认处理器
        defaultHandler = Thread.getDefaultUncaughtExceptionHandler()
        // 设置自定义处理器
        Thread.setDefaultUncaughtExceptionHandler(this)
    }
    
    override fun uncaughtException(thread: Thread, throwable: Throwable) {
        // 1. 收集崩溃信息
        val crashInfo = collectCrashInfo(thread, throwable)
        
        // 2. 保存到本地（异步上报可能来不及）
        saveCrashToLocal(crashInfo)
        
        // 3. 尝试上报到服务器
        reportCrashToServer(crashInfo)
        
        // 4. 交给系统默认处理器处理（弹出崩溃对话框）
        defaultHandler?.uncaughtException(thread, throwable)
    }
    
    /**
     * 收集崩溃信息
     */
    private fun collectCrashInfo(thread: Thread, throwable: Throwable): CrashInfo {
        return CrashInfo(
            // 基本信息
            timestamp = System.currentTimeMillis(),
            threadName = thread.name,
            threadId = thread.id,
            
            // 异常信息
            exceptionType = throwable.javaClass.name,
            exceptionMessage = throwable.message ?: "",
            stackTrace = Log.getStackTraceString(throwable),
            
            // 设备信息
            deviceModel = Build.MODEL,
            deviceBrand = Build.BRAND,
            sdkVersion = Build.VERSION.SDK_INT,
            
            // 应用信息
            appVersion = getAppVersion(),
            processName = getProcessName(),
            
            // 内存信息
            memoryInfo = getMemoryInfo(),
            
            // 其他上下文
            foregroundActivity = getForegroundActivity()
        )
    }
    
    /**
     * 保存崩溃信息到本地文件
     */
    private fun saveCrashToLocal(crashInfo: CrashInfo) {
        try {
            val fileName = "crash_${crashInfo.timestamp}.txt"
            val file = File(context.filesDir, "crash/$fileName")
            file.parentFile?.mkdirs()
            file.writeText(crashInfo.toJson())
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }
    
    /**
     * 上报崩溃信息到服务器
     */
    private fun reportCrashToServer(crashInfo: CrashInfo) {
        // 使用同步请求，因为进程即将被杀死
        // 或者保存到本地，下次启动时上报
        try {
            // 网络上报逻辑
        } catch (e: Exception) {
            // 上报失败，下次启动时重试
        }
    }
}

/**
 * 崩溃信息数据类
 */
data class CrashInfo(
    val timestamp: Long,
    val threadName: String,
    val threadId: Long,
    val exceptionType: String,
    val exceptionMessage: String,
    val stackTrace: String,
    val deviceModel: String,
    val deviceBrand: String,
    val sdkVersion: Int,
    val appVersion: String,
    val processName: String,
    val memoryInfo: String,
    val foregroundActivity: String?
) {
    fun toJson(): String = Gson().toJson(this)
}
```


### 3.2 Native Crash 捕获与分析

#### 3.2.1 信号处理机制

```c
// bionic/linker/debuggerd_handler.cpp
/**
 * debuggerd 信号处理器
 * 当 Native 代码发生崩溃时，内核会发送信号，由此处理器捕获
 */
static void debuggerd_signal_handler(int signal_number, 
                                      siginfo_t* info, 
                                      void* context) {
    // 1. 获取崩溃线程信息
    pid_t tid = gettid();
    pid_t pid = getpid();
    
    // 2. 创建管道与 debuggerd 通信
    int pipefds[2];
    pipe(pipefds);
    
    // 3. 连接 debuggerd 守护进程
    int fd = socket_local_client(DEBUGGERD_SOCKET_NAME,
                                  ANDROID_SOCKET_NAMESPACE_ABSTRACT,
                                  SOCK_STREAM);
    
    // 4. 发送崩溃信息
    debuggerd_msg_t msg;
    msg.action = DEBUGGER_ACTION_CRASH;
    msg.tid = tid;
    msg.abort_msg_address = reinterpret_cast<uintptr_t>(
        __android_log_abort_message());
    
    write(fd, &msg, sizeof(msg));
    
    // 5. 等待 debuggerd 处理完成
    // debuggerd 会生成 tombstone 文件
    read(pipefds[0], &dummy, 1);
    
    // 6. 重新发送信号，让进程终止
    signal(signal_number, SIG_DFL);
    raise(signal_number);
}

/**
 * 注册信号处理器
 */
void debuggerd_init(debuggerd_callbacks_t* callbacks) {
    struct sigaction action;
    memset(&action, 0, sizeof(action));
    
    // 设置信号处理函数
    action.sa_sigaction = debuggerd_signal_handler;
    action.sa_flags = SA_RESTART | SA_SIGINFO | SA_ONSTACK;
    
    // 注册需要捕获的信号
    sigaction(SIGABRT, &action, nullptr);  // 异常终止
    sigaction(SIGBUS, &action, nullptr);   // 总线错误
    sigaction(SIGFPE, &action, nullptr);   // 浮点异常
    sigaction(SIGILL, &action, nullptr);   // 非法指令
    sigaction(SIGSEGV, &action, nullptr);  // 段错误
    sigaction(SIGSTKFLT, &action, nullptr);// 栈错误
    sigaction(SIGSYS, &action, nullptr);   // 系统调用错误
    sigaction(SIGTRAP, &action, nullptr);  // 断点
}
```

#### 3.2.2 Breakpad 集成

Google Breakpad 是跨平台的崩溃收集框架，可以捕获 Native Crash 并生成 minidump 文件。

```cpp
// native-lib.cpp
#include "client/linux/handler/exception_handler.h"
#include "client/linux/handler/minidump_descriptor.h"

// 全局 ExceptionHandler 指针
static google_breakpad::ExceptionHandler* g_exception_handler = nullptr;

/**
 * Minidump 回调函数
 * 当崩溃发生时被调用
 */
static bool DumpCallback(const google_breakpad::MinidumpDescriptor& descriptor,
                         void* context,
                         bool succeeded) {
    // descriptor.path() 包含 minidump 文件路径
    // 可以在这里通知 Java 层进行上报
    
    if (succeeded) {
        // 通过 JNI 回调 Java 层
        JNIEnv* env = GetJNIEnv();
        if (env != nullptr) {
            jclass clazz = env->FindClass("com/example/CrashHandler");
            jmethodID method = env->GetStaticMethodID(clazz, 
                "onNativeCrash", "(Ljava/lang/String;)V");
            jstring path = env->NewStringUTF(descriptor.path());
            env->CallStaticVoidMethod(clazz, method, path);
        }
    }
    
    return succeeded;
}

/**
 * 初始化 Breakpad
 * 在 JNI_OnLoad 或 Application 初始化时调用
 */
extern "C" JNIEXPORT void JNICALL
Java_com_example_CrashHandler_initBreakpad(JNIEnv* env, 
                                            jclass clazz,
                                            jstring crash_dir) {
    const char* path = env->GetStringUTFChars(crash_dir, nullptr);
    
    // 创建 MinidumpDescriptor，指定 dump 文件存储目录
    google_breakpad::MinidumpDescriptor descriptor(path);
    
    // 创建 ExceptionHandler
    g_exception_handler = new google_breakpad::ExceptionHandler(
        descriptor,           // dump 文件描述符
        nullptr,              // FilterCallback（可选）
        DumpCallback,         // MinidumpCallback
        nullptr,              // callback_context
        true,                 // install_handler
        -1                    // server_fd（-1 表示不使用）
    );
    
    env->ReleaseStringUTFChars(crash_dir, path);
}

/**
 * 模拟 Native Crash（测试用）
 */
extern "C" JNIEXPORT void JNICALL
Java_com_example_CrashHandler_testNativeCrash(JNIEnv* env, jclass clazz) {
    // 空指针解引用，触发 SIGSEGV
    volatile int* ptr = nullptr;
    *ptr = 42;
}
```

#### 3.2.3 符号化（Symbolication）

Native Crash 的堆栈默认只有地址，需要通过符号表还原函数名和行号。

```bash
# 1. 使用 ndk-stack 工具（推荐）
# 直接解析 tombstone 或 logcat 输出
adb logcat | ndk-stack -sym /path/to/symbols

# 2. 使用 addr2line 工具
# 手动解析单个地址
arm-linux-androideabi-addr2line -C -f -e libapp.so 0x12345

# 3. 使用 objdump 查看符号表
arm-linux-androideabi-objdump -t libapp.so

# 4. Breakpad 符号化流程
# 4.1 生成符号文件
dump_syms libapp.so > libapp.so.sym

# 4.2 创建符号目录结构
# symbols/libapp.so/<BUILD_ID>/libapp.so.sym

# 4.3 使用 minidump_stackwalk 解析
minidump_stackwalk crash.dmp symbols/
```

**Tombstone 文件解析示例：**

```
*** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***
Build fingerprint: 'google/oriole/oriole:14/UP1A.231005.007/...'
Revision: 'MP1.0'
ABI: 'arm64'
Timestamp: 2024-01-15 10:30:45.123456789+0800
Process uptime: 125s

pid: 12345, tid: 12345, name: example.app  >>> com.example.app <<<
uid: 10123
signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0x0
    x0  0000000000000000  x1  0000007fd8a9e8f0  x2  0000000000000000
    x3  0000000000000001  x4  0000007fd8a9e8f0  x5  0000000000000000
    ...

backtrace:
    #00 pc 0000000000012345  /data/app/.../lib/arm64/libapp.so (crash_func+16)
    #01 pc 0000000000023456  /data/app/.../lib/arm64/libapp.so (caller_func+32)
    #02 pc 0000000000034567  /data/app/.../lib/arm64/libapp.so (main_func+48)
    #03 pc 00000000000789ab  /apex/com.android.runtime/lib64/libart.so
```


### 3.3 ANR 原理源码分析

#### 3.3.1 Service ANR 检测

```java
// frameworks/base/services/core/java/com/android/server/am/ActiveServices.java
public class ActiveServices {
    
    // Service 超时时间常量
    static final int SERVICE_TIMEOUT = 20 * 1000;      // 前台服务 20 秒
    static final int SERVICE_BACKGROUND_TIMEOUT = 200 * 1000; // 后台服务 200 秒
    
    /**
     * 启动 Service 时设置超时检测
     */
    private void realStartServiceLocked(ServiceRecord r, 
            ProcessRecord app, boolean execInFg) throws RemoteException {
        
        // 1. 设置超时炸弹
        bumpServiceExecutingLocked(r, execInFg, "create");
        
        // 2. 通知应用进程创建 Service
        app.thread.scheduleCreateService(r, r.serviceInfo,
                mAm.compatibilityInfoForPackage(r.serviceInfo.applicationInfo),
                app.getReportedProcState());
    }
    
    /**
     * 设置 Service 执行超时检测
     */
    private void bumpServiceExecutingLocked(ServiceRecord r, 
            boolean fg, String why) {
        
        // 计算超时时间
        long now = SystemClock.uptimeMillis();
        if (r.executeNesting == 0) {
            r.executeFg = fg;
            
            // 根据前台/后台选择超时时间
            long timeout = r.executeFg ? SERVICE_TIMEOUT : SERVICE_BACKGROUND_TIMEOUT;
            
            // 发送延迟消息，超时后触发 ANR
            Message msg = mAm.mHandler.obtainMessage(
                    ActivityManagerService.SERVICE_TIMEOUT_MSG);
            msg.obj = r.app;
            mAm.mHandler.sendMessageDelayed(msg, timeout);
            
            r.executingStart = now;
        }
        r.executeNesting++;
    }
    
    /**
     * Service 执行完成，移除超时检测
     */
    private void serviceDoneExecutingLocked(ServiceRecord r, 
            boolean inDestroying, boolean finishing) {
        
        r.executeNesting--;
        if (r.executeNesting == 0) {
            // 移除超时消息
            mAm.mHandler.removeMessages(
                    ActivityManagerService.SERVICE_TIMEOUT_MSG, r.app);
        }
    }
    
    /**
     * Service 超时处理
     */
    void serviceTimeout(ProcessRecord proc) {
        String anrMessage = null;
        
        synchronized(mAm) {
            // 检查是否真的超时
            final long now = SystemClock.uptimeMillis();
            final long maxTime = now - 
                    (proc.execServicesFg ? SERVICE_TIMEOUT : SERVICE_BACKGROUND_TIMEOUT);
            
            ServiceRecord timeout = null;
            for (int i = proc.executingServices.size() - 1; i >= 0; i--) {
                ServiceRecord sr = proc.executingServices.valueAt(i);
                if (sr.executingStart < maxTime) {
                    timeout = sr;
                    break;
                }
            }
            
            if (timeout != null) {
                anrMessage = "executing service " + timeout.shortInstanceName;
            }
        }
        
        if (anrMessage != null) {
            // 触发 ANR
            mAm.mAnrHelper.appNotResponding(proc, anrMessage);
        }
    }
}
```

#### 3.3.2 Broadcast ANR 检测

```java
// frameworks/base/services/core/java/com/android/server/am/BroadcastQueue.java
public class BroadcastQueue {
    
    // Broadcast 超时时间
    static final int BROADCAST_FG_TIMEOUT = 10 * 1000;  // 前台广播 10 秒
    static final int BROADCAST_BG_TIMEOUT = 60 * 1000;  // 后台广播 60 秒
    
    /**
     * 处理有序广播
     */
    final void processNextBroadcastLocked(boolean fromMsg, boolean skipOomAdj) {
        BroadcastRecord r;
        
        // 处理有序广播队列
        do {
            r = mDispatcher.getNextBroadcastLocked(now);
            
            if (r != null) {
                // 设置超时检测
                setBroadcastTimeoutLocked(
                    r.receiverTime + mConstants.TIMEOUT);
                
                // 分发广播给接收者
                deliverToRegisteredReceiverLocked(r, ...);
            }
        } while (r != null);
    }
    
    /**
     * 设置广播超时
     */
    final void setBroadcastTimeoutLocked(long timeoutTime) {
        if (!mPendingBroadcastTimeoutMessage) {
            Message msg = mHandler.obtainMessage(BROADCAST_TIMEOUT_MSG, this);
            mHandler.sendMessageAtTime(msg, timeoutTime);
            mPendingBroadcastTimeoutMessage = true;
        }
    }
    
    /**
     * 广播超时处理
     */
    final void broadcastTimeoutLocked(boolean fromMsg) {
        if (fromMsg) {
            mPendingBroadcastTimeoutMessage = false;
        }
        
        long now = SystemClock.uptimeMillis();
        BroadcastRecord r = mDispatcher.getActiveBroadcastLocked();
        
        if (r != null) {
            // 检查是否真的超时
            long timeoutTime = r.receiverTime + mConstants.TIMEOUT;
            if (timeoutTime > now) {
                // 还没超时，重新设置
                setBroadcastTimeoutLocked(timeoutTime);
                return;
            }
            
            // 触发 ANR
            if (r.curApp != null) {
                mService.mAnrHelper.appNotResponding(r.curApp,
                        "Broadcast of " + r.intent.toString());
            }
        }
    }
}
```

#### 3.3.3 Input ANR 检测

```java
// frameworks/native/services/inputflinger/dispatcher/InputDispatcher.cpp
/**
 * Input 事件分发超时检测
 * 当输入事件 5 秒内未被处理完成时触发 ANR
 */
void InputDispatcher::doNotifyAnrLockedInterruptible(
        const sp<Connection>& connection) {
    
    // 获取超时的应用窗口
    sp<IBinder> token = connection->inputChannel->getConnectionToken();
    
    // 通知 InputManagerService
    mPolicy->notifyAnr(token, 
            connection->inputChannel->getName());
}

/**
 * 检查是否有超时的输入事件
 */
nsecs_t InputDispatcher::processAnrsLocked() {
    const nsecs_t currentTime = now();
    nsecs_t nextAnrCheck = LONG_LONG_MAX;
    
    // 检查等待队列中的事件
    for (auto& [token, state] : mAnrTracker) {
        if (!state.waitQueue.empty()) {
            const DispatchEntry& entry = *state.waitQueue.front();
            const nsecs_t waitDuration = currentTime - entry.deliveryTime;
            
            // 超过 5 秒触发 ANR
            if (waitDuration > ANR_TIMEOUT) {
                doNotifyAnrLockedInterruptible(state.connection);
            }
        }
    }
    
    return nextAnrCheck;
}
```

```java
// frameworks/base/services/core/java/com/android/server/input/InputManagerService.java
public class InputManagerService {
    
    // Input ANR 超时时间：5 秒
    private static final long DEFAULT_INPUT_DISPATCHING_TIMEOUT_MILLIS = 5000;
    
    /**
     * Native 层回调，通知 Input ANR
     */
    private void notifyAnr(IBinder token, String reason) {
        // 获取对应的窗口
        final WindowState windowState = mWindowManagerService
                .getWindowStateForInputChannel(token);
        
        if (windowState != null) {
            // 通知 AMS 处理 ANR
            mActivityManagerService.inputDispatchingTimedOut(
                    windowState.mSession.mPid,
                    windowState.mAttrs.getTitle().toString(),
                    windowState.mInputChannel,
                    reason);
        }
    }
}
```

#### 3.3.4 ContentProvider ANR 检测

```java
// frameworks/base/services/core/java/com/android/server/am/ContentProviderHelper.java
public class ContentProviderHelper {
    
    // ContentProvider 发布超时：10 秒
    static final int CONTENT_PROVIDER_PUBLISH_TIMEOUT_MILLIS = 10 * 1000;
    
    /**
     * 等待 ContentProvider 发布
     */
    private ContentProviderHolder getContentProviderImpl(
            IApplicationThread caller, String name, ...) {
        
        ContentProviderRecord cpr;
        
        synchronized (mService) {
            // 如果 Provider 正在启动，等待其发布
            if (cpr.provider == null) {
                // 设置超时
                final long timeout = SystemClock.uptimeMillis() + 
                        CONTENT_PROVIDER_PUBLISH_TIMEOUT_MILLIS;
                
                // 等待 Provider 发布
                while (cpr.provider == null) {
                    try {
                        cpr.wait(timeout - SystemClock.uptimeMillis());
                    } catch (InterruptedException e) {
                    }
                    
                    // 检查是否超时
                    if (cpr.provider == null && 
                            SystemClock.uptimeMillis() >= timeout) {
                        // 触发 ANR
                        mService.mAnrHelper.appNotResponding(
                                cpr.launchingApp,
                                "ContentProvider " + cpr.name + " publish timeout");
                        return null;
                    }
                }
            }
        }
        
        return cpr.newHolder(conn, false);
    }
}
```


### 3.4 ANR 信息收集

```java
// frameworks/base/services/core/java/com/android/server/am/AnrHelper.java
public class AnrHelper {
    
    /**
     * ANR 处理入口
     */
    void appNotResponding(ProcessRecord app, String annotation) {
        // 异步处理 ANR，避免阻塞系统
        mAnrRecords.add(new AnrRecord(app, annotation));
        startAnrConsumerIfNeeded();
    }
    
    /**
     * ANR 消费者线程
     */
    private class AnrConsumerThread extends Thread {
        @Override
        public void run() {
            while (true) {
                AnrRecord record = mAnrRecords.take();
                processAnr(record);
            }
        }
    }
    
    /**
     * 处理 ANR
     */
    private void processAnr(AnrRecord record) {
        ProcessRecord app = record.mApp;
        
        // 1. 收集 ANR 信息
        StringBuilder info = new StringBuilder();
        info.append("ANR in ").append(app.processName);
        info.append("\nPID: ").append(app.pid);
        info.append("\nReason: ").append(record.mAnnotation);
        
        // 2. 收集 CPU 使用情况
        ProcessCpuTracker processCpuTracker = new ProcessCpuTracker(true);
        processCpuTracker.update();
        info.append("\n\nCPU usage:\n");
        info.append(processCpuTracker.printCurrentState(SystemClock.uptimeMillis()));
        
        // 3. 生成 traces.txt
        // 向所有相关进程发送 SIGQUIT 信号，收集堆栈
        dumpStackTraces(app.pid, tracesFile, ...);
        
        // 4. 写入 ANR 日志
        mService.addErrorToDropBox("anr", app, ...);
        
        // 5. 显示 ANR 对话框（如果是前台应用）
        if (app.isForeground()) {
            Message msg = Message.obtain();
            msg.what = ActivityManagerService.SHOW_NOT_RESPONDING_UI_MSG;
            msg.obj = new AppNotRespondingDialog.Data(app, ...);
            mService.mUiHandler.sendMessage(msg);
        }
    }
}
```

```java
// frameworks/base/services/core/java/com/android/server/am/StackTracesDumpHelper.java
public class StackTracesDumpHelper {
    
    /**
     * 收集进程堆栈信息
     * 通过发送 SIGQUIT 信号触发进程 dump 堆栈
     */
    public static File dumpStackTraces(int pid, File tracesFile, ...) {
        
        // 1. 确定需要 dump 的进程列表
        ArrayList<Integer> pids = new ArrayList<>();
        pids.add(pid);  // ANR 进程
        
        // 添加系统关键进程
        pids.add(Process.myPid());  // system_server
        
        // 2. 向每个进程发送 SIGQUIT 信号
        for (int i = 0; i < pids.size(); i++) {
            int targetPid = pids.get(i);
            
            // 发送信号
            Process.sendSignal(targetPid, Process.SIGNAL_QUIT);
            
            // 等待进程写入堆栈
            // ART 虚拟机收到 SIGQUIT 后会 dump 所有线程堆栈
            Thread.sleep(200);
        }
        
        // 3. 读取 /data/anr/traces.txt
        return tracesFile;
    }
}
```

**traces.txt 文件格式：**

```
----- pid 12345 at 2024-01-15 10:30:45 -----
Cmd line: com.example.app
Build fingerprint: 'google/oriole/oriole:14/UP1A.231005.007/...'
ABI: 'arm64'
Build type: optimized
Zygote loaded classes=12345 post zygote classes=1234

suspend all histogram:  Sum: 1.234ms 99% C.I. 0.001ms-0.500ms

DALVIK THREADS (50):
"main" prio=5 tid=1 Blocked
  | group="main" sCount=1 dsCount=0 flags=1 obj=0x12345678 self=0x87654321
  | sysTid=12345 nice=-10 cgrp=default sched=0/0 handle=0xabcdef00
  | state=S schedstat=( 123456789 234567890 1234 ) utm=100 stm=50 core=0 HZ=100
  | stack=0x7ff0000000-0x7ff0002000 stackSize=8192KB
  | held mutexes=
  at com.example.app.MainActivity.onClick(MainActivity.java:50)
  - waiting to lock <0x12345678> (a java.lang.Object) held by thread 15
  at android.view.View.performClick(View.java:7448)
  at android.view.View.performClickInternal(View.java:7425)
  at android.view.View.access$3600(View.java:810)
  at android.view.View$PerformClick.run(View.java:28305)
  at android.os.Handler.handleCallback(Handler.java:938)
  at android.os.Handler.dispatchMessage(Handler.java:99)
  at android.os.Looper.loop(Looper.java:223)
  at android.app.ActivityThread.main(ActivityThread.java:7656)
  at java.lang.reflect.Method.invoke(Native method)
  at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:592)
  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:947)

"Thread-15" prio=5 tid=15 Runnable
  | group="main" sCount=0 dsCount=0 flags=0 obj=0x23456789 self=0x98765432
  | sysTid=12360 nice=0 cgrp=default sched=0/0 handle=0xbcdef000
  | state=R schedstat=( 987654321 123456789 5678 ) utm=800 stm=100 core=2 HZ=100
  | stack=0x7fe0000000-0x7fe0002000 stackSize=1040KB
  | held mutexes= "mutator lock"(shared held)
  at com.example.app.DataProcessor.processData(DataProcessor.java:120)
  - locked <0x12345678> (a java.lang.Object)
  at com.example.app.DataProcessor.run(DataProcessor.java:80)
```


## 4. 实战应用

### 4.1 ANR 排查方法

#### 4.1.1 traces.txt 分析

```kotlin
/**
 * ANR 分析工具类
 * 解析 traces.txt 文件，提取关键信息
 */
object AnrAnalyzer {
    
    /**
     * 分析 traces.txt 文件
     */
    fun analyzeTraces(tracesContent: String): AnrAnalysisResult {
        val result = AnrAnalysisResult()
        
        // 1. 提取主线程状态
        val mainThreadPattern = """"main" prio=\d+ tid=1 (\w+)""".toRegex()
        val mainThreadMatch = mainThreadPattern.find(tracesContent)
        result.mainThreadState = mainThreadMatch?.groupValues?.get(1) ?: "Unknown"
        
        // 2. 检查是否有锁等待
        val lockPattern = """waiting to lock <(0x[0-9a-f]+)>.*held by thread (\d+)""".toRegex()
        val lockMatch = lockPattern.find(tracesContent)
        if (lockMatch != null) {
            result.isDeadlock = true
            result.lockAddress = lockMatch.groupValues[1]
            result.holdingThread = lockMatch.groupValues[2]
        }
        
        // 3. 提取主线程堆栈
        val stackPattern = """at (.+)\((.+):(\d+)\)""".toRegex()
        result.mainThreadStack = stackPattern.findAll(tracesContent)
            .take(20)
            .map { "${it.groupValues[1]} (${it.groupValues[2]}:${it.groupValues[3]})" }
            .toList()
        
        return result
    }
    
    /**
     * 常见 ANR 原因判断
     */
    fun diagnoseAnrCause(result: AnrAnalysisResult): String {
        return when {
            result.mainThreadState == "Blocked" && result.isDeadlock -> 
                "死锁：主线程等待锁 ${result.lockAddress}，被线程 ${result.holdingThread} 持有"
            
            result.mainThreadState == "Waiting" -> 
                "主线程等待：可能在等待 Binder 调用返回或等待锁"
            
            result.mainThreadState == "Sleeping" -> 
                "主线程休眠：可能调用了 Thread.sleep() 或 Object.wait()"
            
            result.mainThreadStack.any { it.contains("SharedPreferences") } ->
                "SharedPreferences 阻塞：SP 的 apply() 在 Activity onStop 时会同步等待"
            
            result.mainThreadStack.any { it.contains("SQLite") } ->
                "数据库操作阻塞：在主线程执行了耗时的数据库操作"
            
            result.mainThreadStack.any { it.contains("Binder") } ->
                "Binder 调用阻塞：跨进程调用耗时过长"
            
            else -> "需要进一步分析堆栈信息"
        }
    }
}

data class AnrAnalysisResult(
    var mainThreadState: String = "",
    var isDeadlock: Boolean = false,
    var lockAddress: String = "",
    var holdingThread: String = "",
    var mainThreadStack: List<String> = emptyList()
)
```

#### 4.1.2 使用 Perfetto/Systrace 分析 ANR

```bash
# 1. 抓取 Systrace
python systrace.py -o trace.html -t 10 \
    sched freq idle am wm gfx view binder_driver \
    hal dalvik camera input res

# 2. 使用 Perfetto 抓取（推荐）
# 配置文件 config.pbtx
cat > config.pbtx << EOF
buffers: {
    size_kb: 63488
    fill_policy: DISCARD
}
data_sources: {
    config {
        name: "linux.ftrace"
        ftrace_config {
            ftrace_events: "sched/sched_switch"
            ftrace_events: "sched/sched_wakeup"
            ftrace_events: "power/cpu_frequency"
            ftrace_events: "binder/binder_transaction"
            ftrace_events: "binder/binder_transaction_received"
        }
    }
}
data_sources: {
    config {
        name: "linux.process_stats"
        process_stats_config {
            scan_all_processes_on_start: true
        }
    }
}
duration_ms: 10000
EOF

# 抓取 trace
adb shell perfetto -c - --txt -o /data/misc/perfetto-traces/trace.perfetto-trace < config.pbtx
adb pull /data/misc/perfetto-traces/trace.perfetto-trace
```

**Perfetto 分析 ANR 关键点：**

```
┌─────────────────────────────────────────────────────────────────┐
│                    Perfetto ANR 分析要点                         │
├─────────────────────────────────────────────────────────────────┤
│ 1. 查看主线程状态                                                │
│    - 找到应用进程的主线程 (tid = pid)                            │
│    - 观察线程状态：Running / Sleeping / Blocked                  │
│                                                                 │
│ 2. 分析阻塞原因                                                  │
│    - Sleeping: 查看 wakeup 来源                                  │
│    - Blocked: 查看等待的锁或 Binder                              │
│    - Running: 查看执行的函数（可能是耗时计算）                    │
│                                                                 │
│ 3. 检查 Binder 调用                                              │
│    - binder_transaction: 发起调用                                │
│    - binder_transaction_received: 收到响应                       │
│    - 两者时间差即为 Binder 调用耗时                              │
│                                                                 │
│ 4. 检查锁竞争                                                    │
│    - 查看 futex 相关事件                                         │
│    - 分析锁持有者和等待者                                        │
└─────────────────────────────────────────────────────────────────┘
```

### 4.2 稳定性监控体系设计

```kotlin
/**
 * 稳定性监控 SDK 架构
 */
class StabilityMonitor private constructor(private val context: Context) {
    
    companion object {
        @Volatile
        private var instance: StabilityMonitor? = null
        
        fun getInstance(context: Context): StabilityMonitor {
            return instance ?: synchronized(this) {
                instance ?: StabilityMonitor(context.applicationContext).also {
                    instance = it
                }
            }
        }
    }
    
    private val crashHandler = CrashHandler()
    private val anrMonitor = AnrMonitor()
    private val reportManager = ReportManager()
    
    /**
     * 初始化监控
     */
    fun init(config: MonitorConfig) {
        // 1. 初始化 Java Crash 监控
        crashHandler.init(context, config)
        
        // 2. 初始化 Native Crash 监控
        if (config.enableNativeCrash) {
            NativeCrashHandler.init(context.filesDir.absolutePath + "/native_crash")
        }
        
        // 3. 初始化 ANR 监控
        if (config.enableAnrMonitor) {
            anrMonitor.start()
        }
        
        // 4. 上报上次崩溃信息
        reportManager.reportPendingCrashes()
    }
    
    /**
     * ANR 监控器
     * 通过 Watchdog 机制检测主线程卡顿
     */
    inner class AnrMonitor {
        
        private val mainHandler = Handler(Looper.getMainLooper())
        private val watchdogThread = HandlerThread("ANR-Watchdog")
        private lateinit var watchdogHandler: Handler
        
        @Volatile
        private var tick = 0
        @Volatile
        private var reported = false
        
        private val ANR_TIMEOUT = 5000L  // 5 秒
        
        fun start() {
            watchdogThread.start()
            watchdogHandler = Handler(watchdogThread.looper)
            
            // 开始监控
            postTick()
            scheduleCheck()
        }
        
        /**
         * 向主线程发送心跳
         */
        private fun postTick() {
            mainHandler.post {
                tick = (tick + 1) % Int.MAX_VALUE
                reported = false
            }
        }
        
        /**
         * 检查主线程是否响应
         */
        private fun scheduleCheck() {
            watchdogHandler.postDelayed({
                val currentTick = tick
                
                // 再次发送心跳
                postTick()
                
                // 延迟检查
                watchdogHandler.postDelayed({
                    if (tick == currentTick && !reported) {
                        // 主线程未响应，可能发生 ANR
                        reported = true
                        onAnrDetected()
                    }
                    
                    // 继续下一轮检查
                    scheduleCheck()
                }, ANR_TIMEOUT)
                
            }, 1000)
        }
        
        /**
         * ANR 检测回调
         */
        private fun onAnrDetected() {
            // 1. 收集主线程堆栈
            val mainThread = Looper.getMainLooper().thread
            val stackTrace = mainThread.stackTrace
            
            // 2. 收集系统信息
            val anrInfo = AnrInfo(
                timestamp = System.currentTimeMillis(),
                stackTrace = stackTrace.map { it.toString() },
                cpuUsage = getCpuUsage(),
                memoryInfo = getMemoryInfo()
            )
            
            // 3. 保存并上报
            reportManager.reportAnr(anrInfo)
        }
    }
}

/**
 * 监控配置
 */
data class MonitorConfig(
    val enableJavaCrash: Boolean = true,
    val enableNativeCrash: Boolean = true,
    val enableAnrMonitor: Boolean = true,
    val reportUrl: String = "",
    val appVersion: String = "",
    val channel: String = ""
)
```


### 4.3 Bugly 集成与使用

```kotlin
/**
 * Bugly 集成示例
 * Bugly 是腾讯提供的崩溃监控平台，支持 Java 和 Native Crash
 */
class BuglyInitializer {
    
    companion object {
        private const val BUGLY_APP_ID = "your_app_id"
    }
    
    /**
     * 在 Application 中初始化
     */
    fun init(application: Application) {
        // 1. 配置 Bugly
        val strategy = CrashReport.UserStrategy(application).apply {
            // 设置渠道
            appChannel = getChannel()
            // 设置版本
            appVersion = getAppVersion()
            // 设置包名
            appPackageName = application.packageName
            // 设置上报进程
            isUploadProcess = isMainProcess(application)
            // 设置设备 ID
            deviceIdentifier = getDeviceId()
            // 设置崩溃回调
            setCrashHandleCallback(object : CrashReport.CrashHandleCallback() {
                override fun onCrashHandleStart(
                    crashType: Int,
                    errorType: String?,
                    errorMessage: String?,
                    errorStack: String?
                ): Map<String, String> {
                    // 返回自定义数据
                    return mapOf(
                        "userId" to getUserId(),
                        "scene" to getCurrentScene()
                    )
                }
                
                override fun onCrashHandleStart2GetExtraDatas(
                    crashType: Int,
                    errorType: String?,
                    errorMessage: String?,
                    errorStack: String?
                ): ByteArray? {
                    // 返回额外的二进制数据
                    return null
                }
            })
        }
        
        // 2. 初始化 Bugly
        CrashReport.initCrashReport(application, BUGLY_APP_ID, BuildConfig.DEBUG, strategy)
        
        // 3. 设置用户 ID（用于追踪特定用户的崩溃）
        CrashReport.setUserId(getUserId())
        
        // 4. 设置自定义标签
        CrashReport.setUserSceneTag(application, getCurrentSceneTag())
    }
    
    /**
     * 主动上报异常（不会导致崩溃的异常）
     */
    fun reportException(throwable: Throwable, extraData: Map<String, String>? = null) {
        CrashReport.postCatchedException(throwable, extraData)
    }
    
    /**
     * 设置自定义日志
     */
    fun log(tag: String, message: String) {
        BuglyLog.i(tag, message)
    }
}
```

### 4.4 Crash 治理最佳实践

```kotlin
/**
 * Crash 治理策略
 */
object CrashGovernance {
    
    /**
     * 1. 空指针防护
     */
    fun nullSafetyExample() {
        // Bad: 可能 NPE
        // val length = str.length
        
        // Good: 使用 Kotlin 空安全
        val str: String? = getData()
        val length = str?.length ?: 0
        
        // Good: 使用 let
        str?.let { 
            processString(it)
        }
    }
    
    /**
     * 2. 数组越界防护
     */
    fun arrayBoundsExample() {
        val list = listOf(1, 2, 3)
        
        // Bad: 可能 IndexOutOfBoundsException
        // val item = list[5]
        
        // Good: 使用 getOrNull
        val item = list.getOrNull(5) ?: 0
        
        // Good: 使用 getOrElse
        val item2 = list.getOrElse(5) { -1 }
    }
    
    /**
     * 3. 类型转换防护
     */
    fun typeCastExample() {
        val obj: Any = getData()
        
        // Bad: 可能 ClassCastException
        // val str = obj as String
        
        // Good: 使用安全转换
        val str = obj as? String
        
        // Good: 使用 is 检查
        if (obj is String) {
            processString(obj)
        }
    }
    
    /**
     * 4. 并发安全
     */
    fun concurrencySafetyExample() {
        // Bad: 可能 ConcurrentModificationException
        // for (item in list) {
        //     if (condition) list.remove(item)
        // }
        
        // Good: 使用 Iterator
        val iterator = list.iterator()
        while (iterator.hasNext()) {
            if (condition(iterator.next())) {
                iterator.remove()
            }
        }
        
        // Good: 使用 filter
        val newList = list.filter { !condition(it) }
        
        // Good: 使用线程安全集合
        val safeList = CopyOnWriteArrayList<String>()
    }
    
    /**
     * 5. 资源释放
     */
    fun resourceReleaseExample() {
        // Good: 使用 use 自动关闭
        FileInputStream("file.txt").use { input ->
            BufferedReader(InputStreamReader(input)).use { reader ->
                reader.readLine()
            }
        }
        
        // Good: 使用 try-with-resources (Java)
        // try (FileInputStream fis = new FileInputStream("file.txt")) {
        //     // use fis
        // }
    }
    
    /**
     * 6. 全局异常兜底
     */
    fun globalExceptionHandler() {
        // 在关键入口添加 try-catch
        fun safeExecute(block: () -> Unit) {
            try {
                block()
            } catch (e: Exception) {
                // 记录日志
                Log.e("SafeExecute", "Exception caught", e)
                // 上报异常
                CrashReport.postCatchedException(e)
            }
        }
        
        // 使用示例
        safeExecute {
            riskyOperation()
        }
    }
}
```

### 4.5 ANR 治理最佳实践

```kotlin
/**
 * ANR 治理策略
 */
object AnrGovernance {
    
    /**
     * 1. 避免主线程 IO 操作
     */
    suspend fun avoidMainThreadIO() {
        // Bad: 主线程读取文件
        // val content = File("path").readText()
        
        // Good: 使用协程切换到 IO 线程
        val content = withContext(Dispatchers.IO) {
            File("path").readText()
        }
    }
    
    /**
     * 2. 避免主线程数据库操作
     */
    suspend fun avoidMainThreadDB() {
        // Good: Room 默认禁止主线程操作
        // 使用 suspend 函数
        val users = withContext(Dispatchers.IO) {
            userDao.getAllUsers()
        }
    }
    
    /**
     * 3. SharedPreferences 优化
     */
    fun sharedPreferencesOptimization(context: Context) {
        // Bad: SP 的 commit() 是同步的
        // prefs.edit().putString("key", "value").commit()
        
        // Good: 使用 apply() 异步写入
        val prefs = context.getSharedPreferences("config", Context.MODE_PRIVATE)
        prefs.edit().putString("key", "value").apply()
        
        // Better: 使用 MMKV 替代
        val mmkv = MMKV.defaultMMKV()
        mmkv.encode("key", "value")
        
        // Best: 使用 DataStore
        // dataStore.edit { it[KEY] = value }
    }
    
    /**
     * 4. Binder 调用优化
     */
    fun binderCallOptimization() {
        // Bad: 主线程同步 Binder 调用
        // val result = remoteService.heavyOperation()
        
        // Good: 异步调用
        CoroutineScope(Dispatchers.IO).launch {
            val result = remoteService.heavyOperation()
            withContext(Dispatchers.Main) {
                updateUI(result)
            }
        }
    }
    
    /**
     * 5. 避免死锁
     */
    fun avoidDeadlock() {
        // Bad: 可能死锁
        // synchronized(lockA) {
        //     synchronized(lockB) { ... }
        // }
        // synchronized(lockB) {
        //     synchronized(lockA) { ... }
        // }
        
        // Good: 统一锁顺序
        val locks = listOf(lockA, lockB).sortedBy { System.identityHashCode(it) }
        synchronized(locks[0]) {
            synchronized(locks[1]) {
                // 操作
            }
        }
        
        // Better: 使用 tryLock 带超时
        val lock = ReentrantLock()
        if (lock.tryLock(1, TimeUnit.SECONDS)) {
            try {
                // 操作
            } finally {
                lock.unlock()
            }
        }
    }
    
    /**
     * 6. BroadcastReceiver 优化
     */
    fun broadcastReceiverOptimization() {
        // Bad: onReceive 中执行耗时操作
        // override fun onReceive(context: Context, intent: Intent) {
        //     heavyOperation()  // 可能导致 ANR
        // }
        
        // Good: 使用 goAsync() 或启动 Service
        class MyReceiver : BroadcastReceiver() {
            override fun onReceive(context: Context, intent: Intent) {
                val pendingResult = goAsync()
                
                CoroutineScope(Dispatchers.IO).launch {
                    try {
                        heavyOperation()
                    } finally {
                        pendingResult.finish()
                    }
                }
            }
        }
    }
    
    /**
     * 7. ContentProvider 优化
     */
    fun contentProviderOptimization() {
        // ContentProvider 的 onCreate() 在主线程执行
        // 避免在 onCreate() 中执行耗时操作
        
        // Good: 延迟初始化
        class MyProvider : ContentProvider() {
            private val database by lazy {
                // 延迟创建数据库
                Room.databaseBuilder(context!!, AppDatabase::class.java, "db")
                    .build()
            }
            
            override fun onCreate(): Boolean {
                // 不要在这里初始化数据库
                return true
            }
        }
    }
}
```


## 5. 常见面试题

### 问题1：Java Crash 和 Native Crash 的区别是什么？如何分别捕获？

**答案要点：**

| 对比项 | Java Crash | Native Crash |
|-------|-----------|--------------|
| 发生层 | Java/Kotlin 代码 | C/C++ 代码 |
| 触发原因 | 未捕获的异常 | 信号（SIGSEGV、SIGABRT 等） |
| 捕获方式 | Thread.UncaughtExceptionHandler | Signal Handler |
| 堆栈信息 | 直接可读 | 需要符号化 |
| 常见工具 | 自定义 Handler、Bugly | Breakpad、Bugly |

**Java Crash 捕获：**
```kotlin
Thread.setDefaultUncaughtExceptionHandler { thread, throwable ->
    // 收集崩溃信息
    // 保存到本地
    // 上报服务器
    // 调用系统默认处理器
}
```

**Native Crash 捕获：**
- 使用 Google Breakpad 注册信号处理器
- 生成 minidump 文件
- 使用符号表进行符号化还原堆栈

---

### 问题2：ANR 的触发条件有哪些？请详细说明各类型的超时时间。

**答案要点：**

| ANR 类型 | 超时时间 | 触发场景 |
|---------|---------|---------|
| Input ANR | 5 秒 | 触摸、按键事件未在 5 秒内处理完成 |
| Service ANR | 前台 20 秒 / 后台 200 秒 | Service 生命周期方法（onCreate、onStartCommand、onBind）执行超时 |
| Broadcast ANR | 前台 10 秒 / 后台 60 秒 | BroadcastReceiver.onReceive() 执行超时 |
| ContentProvider ANR | 10 秒 | ContentProvider 发布超时 |

**源码层面：**
- Service ANR：AMS 通过 `SERVICE_TIMEOUT_MSG` 延迟消息检测
- Broadcast ANR：BroadcastQueue 通过 `BROADCAST_TIMEOUT_MSG` 检测
- Input ANR：InputDispatcher 在 Native 层检测事件处理超时
- ContentProvider ANR：等待 Provider 发布时设置超时

---

### 问题3：如何分析 traces.txt 文件？请说明关键信息的含义。

**答案要点：**

**traces.txt 关键信息：**

1. **线程状态**：
   - `Runnable`：正在执行
   - `Sleeping`：调用了 sleep() 或 wait()
   - `Blocked`：等待锁
   - `Waiting`：等待其他线程通知
   - `Native`：执行 Native 代码

2. **锁信息**：
   - `waiting to lock <0x...>`：等待获取锁
   - `locked <0x...>`：持有锁
   - `held by thread X`：锁被线程 X 持有

3. **调度信息**：
   - `utm`：用户态 CPU 时间
   - `stm`：内核态 CPU 时间
   - `core`：运行的 CPU 核心

**分析步骤：**
1. 找到主线程（tid=1）的状态
2. 查看主线程堆栈，定位阻塞位置
3. 如果是 Blocked，找到持有锁的线程
4. 分析是否存在死锁

---

### 问题4：Service ANR 的检测机制是怎样的？请从源码角度分析。

**答案要点：**

**检测流程：**

```
1. AMS.realStartServiceLocked()
   ↓
2. bumpServiceExecutingLocked()
   - 发送 SERVICE_TIMEOUT_MSG 延迟消息
   - 前台服务: 20s, 后台服务: 200s
   ↓
3. App 进程执行 Service 生命周期
   ↓
4a. 执行完成 → serviceDoneExecuting() → 移除超时消息
4b. 超时 → SERVICE_TIMEOUT_MSG 触发 → serviceTimeout() → ANR
```

**关键源码：**
```java
// ActiveServices.java
private void bumpServiceExecutingLocked(ServiceRecord r, boolean fg, String why) {
    long timeout = r.executeFg ? SERVICE_TIMEOUT : SERVICE_BACKGROUND_TIMEOUT;
    Message msg = mAm.mHandler.obtainMessage(SERVICE_TIMEOUT_MSG);
    msg.obj = r.app;
    mAm.mHandler.sendMessageDelayed(msg, timeout);
}
```

---

### 问题5：如何设计一个完整的稳定性监控体系？

**答案要点：**

**监控体系架构：**

```
┌─────────────────────────────────────────────────────────────────┐
│                        稳定性监控体系                            │
├─────────────────────────────────────────────────────────────────┤
│  采集层                                                          │
│  ├── Java Crash 采集（UncaughtExceptionHandler）                 │
│  ├── Native Crash 采集（Breakpad/Signal Handler）                │
│  ├── ANR 采集（Watchdog/FileObserver）                          │
│  └── 卡顿采集（Choreographer/Looper Printer）                   │
├─────────────────────────────────────────────────────────────────┤
│  处理层                                                          │
│  ├── 信息收集（堆栈、设备信息、内存、CPU）                        │
│  ├── 本地存储（崩溃文件、日志）                                  │
│  └── 符号化（Native 堆栈还原）                                   │
├─────────────────────────────────────────────────────────────────┤
│  上报层                                                          │
│  ├── 实时上报（崩溃时立即上报）                                  │
│  ├── 延迟上报（下次启动时上报）                                  │
│  └── 采样上报（高频问题采样）                                    │
├─────────────────────────────────────────────────────────────────┤
│  分析层                                                          │
│  ├── 聚合分析（相同堆栈聚合）                                    │
│  ├── 趋势分析（版本对比、时间趋势）                              │
│  └── 归因分析（设备、版本、渠道维度）                            │
├─────────────────────────────────────────────────────────────────┤
│  告警层                                                          │
│  ├── 阈值告警（崩溃率超标）                                      │
│  ├── 新增告警（新版本新增崩溃）                                  │
│  └── 突增告警（崩溃量突然增加）                                  │
└─────────────────────────────────────────────────────────────────┘
```

**关键指标：**
- Crash Rate < 0.1%
- ANR Rate < 0.01%
- 新版本 Crash 24 小时内修复

---

### 问题6：SharedPreferences 为什么会导致 ANR？如何解决？

**答案要点：**

**原因分析：**

1. **apply() 的隐患**：
   - apply() 虽然是异步写入，但会将写入任务加入 QueuedWork
   - Activity onStop() 时会调用 `QueuedWork.waitToFinish()` 同步等待所有任务完成
   - 如果有大量 apply() 未完成，会阻塞主线程

2. **源码分析**：
```java
// ActivityThread.java
private void handleStopActivity(IBinder token, ...) {
    // ...
    // 等待所有 QueuedWork 完成
    if (!r.isPreHoneycomb()) {
        QueuedWork.waitToFinish();
    }
    // ...
}
```

**解决方案：**

1. **使用 MMKV 替代**：
   - 基于 mmap，写入性能高
   - 不会阻塞主线程

2. **使用 DataStore**：
   - Jetpack 官方推荐
   - 基于协程，异步安全

3. **减少 SP 写入频率**：
   - 批量写入
   - 避免频繁调用 apply()

---

### 问题7：Native Crash 如何进行符号化？请说明完整流程。

**答案要点：**

**符号化流程：**

```
1. 编译时保留符号表
   - 编译 Release 版本时生成带符号的 so 文件
   - 或使用 dump_syms 生成 .sym 符号文件

2. 收集崩溃信息
   - Breakpad 生成 minidump 文件
   - 或从 tombstone 提取崩溃地址

3. 符号化还原
   - 使用 addr2line 或 ndk-stack 工具
   - 将地址转换为函数名和行号

4. 上传符号表
   - 将符号表上传到崩溃分析平台
   - 平台自动进行符号化
```

**工具使用：**
```bash
# ndk-stack（推荐）
adb logcat | ndk-stack -sym /path/to/symbols

# addr2line
arm-linux-androideabi-addr2line -C -f -e libapp.so 0x12345

# Breakpad
dump_syms libapp.so > libapp.so.sym
minidump_stackwalk crash.dmp symbols/
```

---

### 问题8：如何监控和治理 ANR？请说明监控方案和治理策略。

**答案要点：**

**监控方案：**

1. **Watchdog 方案**：
   - 子线程定期向主线程发送心跳
   - 检测主线程是否响应
   - 超时则收集堆栈信息

2. **FileObserver 方案**：
   - 监控 /data/anr/ 目录
   - 检测 traces.txt 文件变化
   - 读取并解析 ANR 信息

3. **SIGQUIT 信号方案**：
   - 注册 SIGQUIT 信号处理器
   - 系统发生 ANR 时会发送该信号
   - 在信号处理器中收集信息

**治理策略：**

1. **主线程优化**：
   - 避免主线程 IO、网络、数据库操作
   - 使用协程或线程池处理耗时任务

2. **锁优化**：
   - 减少锁粒度
   - 使用 tryLock 带超时
   - 避免死锁

3. **Binder 优化**：
   - 异步调用
   - 减少跨进程调用频率

4. **组件优化**：
   - BroadcastReceiver 使用 goAsync()
   - ContentProvider 延迟初始化
   - Service 避免耗时操作

---

### 问题9：Breakpad 的工作原理是什么？如何集成到 Android 项目中？

**答案要点：**

**工作原理：**

1. **信号注册**：
   - 注册 SIGSEGV、SIGABRT 等信号处理器
   - 当 Native 崩溃时，内核发送信号

2. **信息收集**：
   - 收集寄存器状态
   - 收集线程堆栈
   - 收集内存映射

3. **生成 Minidump**：
   - 将崩溃信息写入 .dmp 文件
   - 格式紧凑，便于传输

4. **符号化**：
   - 使用 minidump_stackwalk 解析
   - 结合符号表还原堆栈

**集成步骤：**

```kotlin
// 1. 添加 Breakpad 库到项目

// 2. JNI 初始化
external fun initBreakpad(crashDir: String)

// 3. Application 中调用
class MyApplication : Application() {
    override fun onCreate() {
        super.onCreate()
        val crashDir = filesDir.absolutePath + "/crash"
        File(crashDir).mkdirs()
        initBreakpad(crashDir)
    }
}

// 4. Native 层实现
// 见前文 Breakpad 集成代码
```

---

### 问题10：如何从 Framework 层面理解 Input ANR 的检测机制？

**答案要点：**

**检测流程：**

```
1. InputDispatcher 分发输入事件
   ↓
2. 记录事件分发时间
   ↓
3. 等待应用处理完成（finishInputEvent）
   ↓
4. 检测是否超时（5 秒）
   ↓
5a. 未超时 → 继续处理下一个事件
5b. 超时 → 通知 InputManagerService → AMS 处理 ANR
```

**关键源码（Native 层）：**

```cpp
// InputDispatcher.cpp
void InputDispatcher::doNotifyAnrLockedInterruptible(
        const sp<Connection>& connection) {
    // 通知 Java 层发生 ANR
    mPolicy->notifyAnr(connection->inputChannel->getConnectionToken(),
            connection->inputChannel->getName());
}

nsecs_t InputDispatcher::processAnrsLocked() {
    // 检查等待队列中的事件是否超时
    for (auto& [token, state] : mAnrTracker) {
        if (!state.waitQueue.empty()) {
            const nsecs_t waitDuration = currentTime - entry.deliveryTime;
            if (waitDuration > ANR_TIMEOUT) {  // 5 秒
                doNotifyAnrLockedInterruptible(state.connection);
            }
        }
    }
}
```

**Java 层处理：**

```java
// InputManagerService.java
private void notifyAnr(IBinder token, String reason) {
    // 获取窗口信息
    WindowState windowState = mWindowManagerService
            .getWindowStateForInputChannel(token);
    
    // 通知 AMS
    mActivityManagerService.inputDispatchingTimedOut(
            windowState.mSession.mPid,
            windowState.mAttrs.getTitle().toString(),
            reason);
}
```

**与其他 ANR 的区别：**
- Input ANR 在 Native 层检测，其他在 Java 层
- Input ANR 基于事件处理时间，其他基于延迟消息
- Input ANR 超时时间固定 5 秒，不区分前后台

