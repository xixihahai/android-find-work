# Android 启动优化

## 1. 概述

应用启动速度是用户体验的第一道门槛，也是各大厂面试的高频考点。启动优化涉及 Framework 层的启动流程理解、性能分析工具的使用、以及各种优化手段的实践。本文将从启动流程分析、耗时测量、优化手段等方面全面讲解 Android 启动优化。

### 1.1 启动优化的重要性

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        启动优化的价值                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  用户体验影响:                                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  • 启动时间每增加 1 秒，用户流失率增加 7%                       │   │
│  │  • 53% 用户会放弃启动超过 3 秒的应用                            │   │
│  │  • 启动速度直接影响应用商店评分                                 │   │
│  │  • Google Play 将启动时间作为应用质量指标                       │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  业务指标影响:                                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  • 启动速度提升 → 用户留存率提升                                │   │
│  │  • 启动速度提升 → DAU/MAU 提升                                  │   │
│  │  • 启动速度提升 → 转化率提升                                    │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  Google 推荐标准:                                                       │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  • 冷启动: < 5 秒 (理想 < 2 秒)                                  │   │
│  │  • 温启动: < 2 秒                                                │   │
│  │  • 热启动: < 1.5 秒                                              │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 1.2 启动类型定义

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        三种启动类型                                      │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  冷启动 (Cold Start):                                                   │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  定义: 应用进程不存在，需要从头创建进程                         │   │
│  │  触发: 设备重启后首次启动、应用被系统杀死后启动                 │   │
│  │  耗时: 最长，包含进程创建、Application 初始化、Activity 创建    │   │
│  │  优化重点: 主要优化目标                                         │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  温启动 (Warm Start):                                                   │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  定义: 进程存在，但 Activity 需要重新创建                       │   │
│  │  触发: 用户按返回键退出后重新进入、Activity 被系统回收后重建    │   │
│  │  耗时: 中等，跳过进程创建，但需要重新创建 Activity              │   │
│  │  特点: 可能需要重新执行 onCreate()                              │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  热启动 (Hot Start):                                                    │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  定义: 进程和 Activity 都存在，只需将 Activity 带到前台         │   │
│  │  触发: 用户按 Home 键后重新进入                                 │   │
│  │  耗时: 最短，只需执行 onRestart() → onStart() → onResume()      │   │
│  │  特点: 几乎无需优化                                             │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```


## 2. 核心原理

### 2.1 冷启动完整流程

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      冷启动完整流程图                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  用户点击图标                                                           │
│       │                                                                 │
│       ↓                                                                 │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                    Launcher 进程                                │   │
│  │  1. Launcher.onClick()                                          │   │
│  │  2. startActivity() → Binder IPC                                │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│       │                                                                 │
│       ↓ Binder IPC                                                      │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                    system_server 进程                           │   │
│  │  3. AMS.startActivity()                                         │   │
│  │  4. 检查进程是否存在                                            │   │
│  │  5. 进程不存在 → AMS.startProcessLocked()                       │   │
│  │  6. 通过 Socket 通知 Zygote fork 进程                           │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│       │                                                                 │
│       ↓ Socket                                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                    Zygote 进程                                  │   │
│  │  7. ZygoteInit.main()                                           │   │
│  │  8. fork() 创建 App 进程                                        │   │
│  │  9. 子进程执行 ActivityThread.main()                            │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│       │                                                                 │
│       ↓ fork                                                            │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                    App 进程                                     │   │
│  │  10. ActivityThread.main()                                      │   │
│  │  11. Looper.prepareMainLooper()                                 │   │
│  │  12. ActivityThread.attach()                                    │   │
│  │  13. → AMS.attachApplication() (Binder IPC)                     │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│       │                                                                 │
│       ↓ Binder IPC                                                      │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                    system_server 进程                           │   │
│  │  14. AMS.attachApplicationLocked()                              │   │
│  │  15. → ApplicationThread.bindApplication() (Binder IPC)         │   │
│  │  16. → ApplicationThread.scheduleLaunchActivity() (Binder IPC)  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│       │                                                                 │
│       ↓ Binder IPC                                                      │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                    App 进程                                     │   │
│  │  17. handleBindApplication()                                    │   │
│  │      - 创建 Application 对象                                    │   │
│  │      - 调用 Application.attachBaseContext()                     │   │
│  │      - 安装 ContentProvider                                     │   │
│  │      - 调用 Application.onCreate()                              │   │
│  │  18. handleLaunchActivity()                                     │   │
│  │      - 创建 Activity 对象                                       │   │
│  │      - 调用 Activity.onCreate()                                 │   │
│  │      - 调用 Activity.onStart()                                  │   │
│  │      - 调用 Activity.onResume()                                 │   │
│  │  19. 首帧绘制完成                                               │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.2 启动阶段划分

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      启动阶段时间线                                      │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  T0          T1              T2              T3              T4         │
│  │           │               │               │               │          │
│  │  进程创建 │  Application  │   Activity    │   首帧绘制    │          │
│  │           │    初始化     │    创建       │               │          │
│  │           │               │               │               │          │
│  ├───────────┼───────────────┼───────────────┼───────────────┤          │
│  │           │               │               │               │          │
│  │  Zygote   │ attachBase    │  onCreate     │  measure      │          │
│  │  fork     │ Context       │  onStart      │  layout       │          │
│  │           │               │  onResume     │  draw         │          │
│  │           │ ContentProvider│              │               │          │
│  │           │ install       │               │               │          │
│  │           │               │               │               │          │
│  │           │ Application   │               │               │          │
│  │           │ onCreate      │               │               │          │
│  │           │               │               │               │          │
│  └───────────┴───────────────┴───────────────┴───────────────┘          │
│                                                                         │
│  启动耗时 = T4 - T0 (从点击图标到首帧绘制完成)                          │
│                                                                         │
│  各阶段耗时占比 (典型值):                                               │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  进程创建:        ~200ms (系统控制，难以优化)                   │   │
│  │  Application:     ~300-500ms (优化重点)                         │   │
│  │  Activity 创建:   ~200-400ms (优化重点)                         │   │
│  │  首帧绘制:        ~100-200ms (布局优化)                         │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.3 Application 初始化流程

```
┌─────────────────────────────────────────────────────────────────────────┐
│                   Application 初始化详细流程                             │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  handleBindApplication()                                                │
│       │                                                                 │
│       ↓                                                                 │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  1. 创建 LoadedApk 对象                                         │   │
│  │     - 加载 APK 信息                                             │   │
│  │     - 创建 ClassLoader                                          │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│       │                                                                 │
│       ↓                                                                 │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  2. 创建 ContextImpl                                            │   │
│  │     - 应用上下文                                                │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│       │                                                                 │
│       ↓                                                                 │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  3. 创建 Instrumentation                                        │   │
│  │     - 用于监控应用与系统交互                                    │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│       │                                                                 │
│       ↓                                                                 │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  4. 创建 Application 对象                                       │   │
│  │     - 反射创建 Application 实例                                 │   │
│  │     - 调用 Application.attachBaseContext(context)  ← 优化点     │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│       │                                                                 │
│       ↓                                                                 │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  5. 安装 ContentProvider                          ← 优化点      │   │
│  │     - 遍历所有声明的 ContentProvider                            │   │
│  │     - 依次调用 ContentProvider.onCreate()                       │   │
│  │     - 注意: 在 Application.onCreate() 之前执行!                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│       │                                                                 │
│       ↓                                                                 │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  6. 调用 Application.onCreate()                   ← 优化重点    │   │
│  │     - 各种 SDK 初始化                                           │   │
│  │     - 业务模块初始化                                            │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```


## 3. 关键源码解析

### 3.1 ActivityThread.main() 源码分析

```java
/**
 * ActivityThread.main() - App 进程入口
 * 源码位置: frameworks/base/core/java/android/app/ActivityThread.java
 */
public static void main(String[] args) {
    // 1. 开启主线程 Trace 追踪
    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "ActivityThreadMain");
    
    // 2. 安装选择性系统调用拦截 (Android 10+)
    AndroidOs.install();
    
    // 3. 初始化主线程 Looper
    // 这是主线程消息循环的基础
    Looper.prepareMainLooper();
    
    // 4. 查找系统服务的 startSeq 参数
    long startSeq = 0;
    if (args != null) {
        for (int i = args.length - 1; i >= 0; --i) {
            if (args[i] != null && args[i].startsWith(PROC_START_SEQ_IDENT)) {
                startSeq = Long.parseLong(
                        args[i].substring(PROC_START_SEQ_IDENT.length()));
            }
        }
    }
    
    // 5. 创建 ActivityThread 实例
    ActivityThread thread = new ActivityThread();
    
    // 6. 关键步骤: attach 到系统进程
    // 这里会触发 Application 的创建和初始化
    thread.attach(false, startSeq);
    
    // 7. 获取主线程 Handler
    if (sMainThreadHandler == null) {
        sMainThreadHandler = thread.getHandler();
    }
    
    // 8. 结束 Trace
    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
    
    // 9. 开启消息循环 (永不返回)
    // 主线程在此无限循环处理消息
    Looper.loop();
    
    // 如果执行到这里，说明主线程 Looper 退出了，抛出异常
    throw new RuntimeException("Main thread loop unexpectedly exited");
}
```

### 3.2 handleBindApplication() 源码分析

```java
/**
 * handleBindApplication() - Application 绑定处理
 * 这是 Application 初始化的核心方法
 * 源码位置: frameworks/base/core/java/android/app/ActivityThread.java
 */
private void handleBindApplication(AppBindData data) {
    // 1. 记录进程启动时间
    mBoundApplication = data;
    mConfiguration = new Configuration(data.config);
    
    // 2. 开启 Trace 追踪
    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "bindApplication");
    
    // 3. 设置进程名称
    Process.setArgV0(data.processName);
    android.ddm.DdmHandleAppName.setAppName(data.processName,
            data.appInfo.packageName, UserHandle.myUserId());
    
    // 4. 设置时区和语言
    TimeZone.setDefault(null);
    LocaleList.setDefault(data.config.getLocales());
    
    // 5. 更新资源配置
    mResourcesManager.applyConfigurationToResourcesLocked(data.config, 
            data.compatInfo);
    
    // 6. 创建 LoadedApk 对象 (包含 ClassLoader)
    data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);
    
    // 7. 创建 Instrumentation
    final InstrumentationInfo ii;
    if (data.instrumentationName != null) {
        // 有测试 Instrumentation
        ii = prepareInstrumentation(data);
    } else {
        // 默认 Instrumentation
        mInstrumentation = new Instrumentation();
        mInstrumentation.basicInit(this);
    }
    
    // 8. 创建 Application 上下文
    final ContextImpl appContext = ContextImpl.createAppContext(this, data.info);
    
    // 9. 关键: 创建 Application 对象
    Application app;
    try {
        // 通过 LoadedApk.makeApplication() 创建 Application
        // 内部会调用 Application.attachBaseContext()
        app = data.info.makeApplication(data.restrictedBackupMode, null);
        
        // 保存 Application 引用
        mInitialApplication = app;
        
        // 10. 关键: 安装 ContentProvider (在 Application.onCreate 之前!)
        if (!data.restrictedBackupMode) {
            if (!ArrayUtils.isEmpty(data.providers)) {
                // 安装所有声明的 ContentProvider
                installContentProviders(app, data.providers);
            }
        }
        
        // 11. 关键: 调用 Application.onCreate()
        try {
            mInstrumentation.callApplicationOnCreate(app);
        } catch (Exception e) {
            // 处理异常
        }
        
    } finally {
        // 12. 结束 Trace
        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
    }
}
```

### 3.3 installContentProviders() 源码分析

```java
/**
 * installContentProviders() - 安装 ContentProvider
 * 注意: 这个方法在 Application.onCreate() 之前执行!
 * 很多三方 SDK 利用这个特性进行无侵入初始化
 */
private void installContentProviders(Context context, List<ProviderInfo> providers) {
    final ArrayList<ContentProviderHolder> results = new ArrayList<>();
    
    // 遍历所有声明的 ContentProvider
    for (ProviderInfo cpi : providers) {
        // 开启 Trace
        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, 
                "installProvider: " + cpi.name);
        
        // 安装单个 ContentProvider
        // 内部会调用 ContentProvider.onCreate()
        ContentProviderHolder cph = installProvider(context, null, cpi,
                false /*noisy*/, true /*noReleaseNeeded*/, true /*stable*/);
        
        if (cph != null) {
            results.add(cph);
        }
        
        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
    }
    
    // 发布 ContentProvider 到 AMS
    try {
        ActivityManager.getService().publishContentProviders(
                getApplicationThread(), results);
    } catch (RemoteException ex) {
        throw ex.rethrowFromSystemServer();
    }
}

/**
 * installProvider() - 安装单个 ContentProvider
 */
private ContentProviderHolder installProvider(Context context,
        ContentProviderHolder holder, ProviderInfo info,
        boolean noisy, boolean noReleaseNeeded, boolean stable) {
    
    ContentProvider localProvider = null;
    IContentProvider provider;
    
    if (holder == null || holder.provider == null) {
        // 需要创建新的 ContentProvider
        Context c = null;
        ApplicationInfo ai = info.applicationInfo;
        
        // 获取 ContentProvider 的 Context
        if (context.getPackageName().equals(ai.packageName)) {
            c = context;
        } else {
            // 跨进程的 ContentProvider
            c = context.createPackageContext(ai.packageName,
                    Context.CONTEXT_INCLUDE_CODE);
        }
        
        try {
            // 通过反射创建 ContentProvider 实例
            final java.lang.ClassLoader cl = c.getClassLoader();
            localProvider = (ContentProvider) cl.loadClass(info.name)
                    .getDeclaredConstructor().newInstance();
            
            // 获取 IContentProvider 接口
            provider = localProvider.getIContentProvider();
            
            // 关键: 调用 ContentProvider.attachInfo()
            // 内部会调用 ContentProvider.onCreate()
            localProvider.attachInfo(c, info);
            
        } catch (Exception e) {
            // 处理异常
        }
    }
    
    // 返回 ContentProviderHolder
    return retHolder;
}
```

### 3.4 Activity 启动流程源码

```java
/**
 * handleLaunchActivity() - Activity 启动处理
 * 源码位置: frameworks/base/core/java/android/app/ActivityThread.java
 */
public Activity handleLaunchActivity(ActivityClientRecord r,
        PendingTransactionActions pendingActions, Intent customIntent) {
    
    // 1. 开启 Trace
    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "activityStart");
    
    // 2. 初始化 WindowManagerGlobal
    WindowManagerGlobal.initialize();
    
    // 3. 创建 Activity 配置
    final Configuration config = new Configuration(mConfiguration);
    
    // 4. 关键: 执行 Activity 启动
    final Activity a = performLaunchActivity(r, customIntent);
    
    if (a != null) {
        // 5. 设置配置
        r.createdConfig = new Configuration(mConfiguration);
        reportSizeConfigurations(r);
        
        // 6. 检查是否需要调用 onNewIntent
        if (!r.activity.mFinished && pendingActions != null) {
            pendingActions.setOldState(r.state);
            pendingActions.setRestoreInstanceState(true);
            pendingActions.setCallOnPostCreate(true);
        }
    }
    
    // 7. 结束 Trace
    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
    
    return a;
}

/**
 * performLaunchActivity() - 执行 Activity 启动
 * 这里会调用 Activity 的生命周期方法
 */
private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {
    // 1. 获取 ActivityInfo
    ActivityInfo aInfo = r.activityInfo;
    
    // 2. 获取 LoadedApk
    if (r.packageInfo == null) {
        r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,
                Context.CONTEXT_INCLUDE_CODE);
    }
    
    // 3. 获取 ComponentName
    ComponentName component = r.intent.getComponent();
    
    // 4. 创建 Activity 上下文
    ContextImpl appContext = createBaseContextForActivity(r);
    
    Activity activity = null;
    try {
        // 5. 通过 Instrumentation 创建 Activity 实例
        java.lang.ClassLoader cl = appContext.getClassLoader();
        activity = mInstrumentation.newActivity(
                cl, component.getClassName(), r.intent);
        
        // 6. 设置 Activity 的 ClassLoader
        r.intent.setExtrasClassLoader(cl);
        r.intent.prepareToEnterProcess();
        
    } catch (Exception e) {
        // 处理异常
    }
    
    try {
        // 7. 获取 Application
        Application app = r.packageInfo.makeApplication(false, mInstrumentation);
        
        if (activity != null) {
            // 8. 创建 Activity 配置
            Configuration config = new Configuration(mCompatConfiguration);
            
            // 9. 关键: 调用 Activity.attach()
            // 这里会创建 PhoneWindow
            activity.attach(appContext, this, getInstrumentation(), r.token,
                    r.ident, app, r.intent, r.activityInfo, title, r.parent,
                    r.embeddedID, r.lastNonConfigurationInstances, config,
                    r.referrer, r.voiceInteractor, window, r.configCallback,
                    r.assistToken);
            
            // 10. 设置主题
            int theme = r.activityInfo.getThemeResource();
            if (theme != 0) {
                activity.setTheme(theme);
            }
            
            // 11. 关键: 调用 Activity.onCreate()
            if (r.isPersistable()) {
                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);
            } else {
                mInstrumentation.callActivityOnCreate(activity, r.state);
            }
            
            // 12. 设置 Activity 状态
            r.activity = activity;
        }
        
        // 13. 设置生命周期状态
        r.setState(ON_CREATE);
        
    } catch (Exception e) {
        // 处理异常
    }
    
    return activity;
}
```


## 4. 启动耗时测量

### 4.1 测量方法概览

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      启动耗时测量方法                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌────────────┬──────────────┬──────────────┬──────────────────────┐   │
│  │   方法     │    精度      │    侵入性    │       适用场景       │   │
│  ├────────────┼──────────────┼──────────────┼──────────────────────┤   │
│  │ adb 命令   │    低        │    无        │   快速验证           │   │
│  ├────────────┼──────────────┼──────────────┼──────────────────────┤   │
│  │ Logcat     │    中        │    无        │   日常开发           │   │
│  ├────────────┼──────────────┼──────────────┼──────────────────────┤   │
│  │ Systrace   │    高        │    无        │   详细分析           │   │
│  ├────────────┼──────────────┼──────────────┼──────────────────────┤   │
│  │ Perfetto   │    最高      │    无        │   深度分析(推荐)     │   │
│  ├────────────┼──────────────┼──────────────┼──────────────────────┤   │
│  │ 自定义埋点 │    高        │    有        │   线上监控           │   │
│  └────────────┴──────────────┴──────────────┴──────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 4.2 adb 命令测量

```bash
# 方法1: 使用 am start 命令测量冷启动时间
# -W: 等待启动完成
# -S: 先停止应用
# -n: 指定组件名
adb shell am start -W -S -n com.example.app/.MainActivity

# 输出示例:
# Starting: Intent { cmp=com.example.app/.MainActivity }
# Status: ok
# LaunchState: COLD
# Activity: com.example.app/.MainActivity
# TotalTime: 1523        # 总启动时间 (ms)
# WaitTime: 1545         # 等待时间 (ms)
# Complete

# TotalTime: 从 Activity 启动到首帧绘制完成的时间
# WaitTime: 从 startActivity 调用到首帧绘制完成的时间

# 方法2: 测量温启动
adb shell am start -W -n com.example.app/.MainActivity
# 不加 -S 参数，如果进程存在则为温启动

# 方法3: 使用 ActivityTaskManager 日志
adb logcat -s ActivityTaskManager:I | grep "Displayed"
# 输出: ActivityTaskManager: Displayed com.example.app/.MainActivity: +1s523ms

# 方法4: 批量测试脚本
#!/bin/bash
for i in {1..10}; do
    adb shell am force-stop com.example.app
    sleep 2
    adb shell am start -W -n com.example.app/.MainActivity | grep TotalTime
done
```

### 4.3 Logcat 日志分析

```kotlin
/**
 * 系统自动输出的启动日志
 * 无需任何代码修改
 */

// 1. ActivityTaskManager 日志 (Android 10+)
// 格式: Displayed <package>/<activity>: +<time>
// 示例: Displayed com.example.app/.MainActivity: +1s523ms

// 2. 查看启动日志命令
// adb logcat -s ActivityTaskManager:I

// 3. 日志含义解析
/*
 * Displayed 时间包含:
 * - Activity 创建时间
 * - 布局加载时间
 * - 首帧绘制时间
 * 
 * 不包含:
 * - 进程创建时间 (冷启动)
 * - Application 初始化时间
 */

// 4. 完整启动日志示例
/*
ActivityTaskManager: START u0 {act=android.intent.action.MAIN 
    cat=[android.intent.category.LAUNCHER] 
    cmp=com.example.app/.MainActivity} from uid 10123
    
ActivityTaskManager: Displayed com.example.app/.MainActivity: +1s523ms
    (total +2s100ms)  // 如果有 total，表示包含进程创建时间
*/
```

### 4.4 Systrace/Perfetto 分析

```bash
# ==================== Systrace (传统方式) ====================

# 1. 抓取 Systrace
python systrace.py -t 10 -o trace.html \
    sched freq idle am wm gfx view binder_driver \
    -a com.example.app

# 参数说明:
# -t 10: 抓取 10 秒
# -o trace.html: 输出文件
# sched: CPU 调度
# freq: CPU 频率
# idle: CPU 空闲
# am: ActivityManager
# wm: WindowManager
# gfx: 图形
# view: View 系统
# binder_driver: Binder 调用
# -a: 指定应用包名

# 2. 分析 Systrace
# 打开 trace.html，查看以下关键点:
# - bindApplication: Application 绑定
# - activityStart: Activity 启动
# - inflate: 布局加载
# - measure/layout/draw: 绑制流程

# ==================== Perfetto (推荐方式) ====================

# 1. 使用 Perfetto 命令行抓取
adb shell perfetto \
    -c - --txt \
    -o /data/misc/perfetto-traces/trace.perfetto-trace \
    <<EOF
buffers: {
    size_kb: 63488
    fill_policy: DISCARD
}
buffers: {
    size_kb: 2048
    fill_policy: DISCARD
}
data_sources: {
    config {
        name: "linux.ftrace"
        ftrace_config {
            ftrace_events: "sched/sched_switch"
            ftrace_events: "power/suspend_resume"
            ftrace_events: "sched/sched_wakeup"
            ftrace_events: "sched/sched_wakeup_new"
            ftrace_events: "sched/sched_process_exit"
            ftrace_events: "sched/sched_process_free"
            ftrace_events: "task/task_newtask"
            ftrace_events: "task/task_rename"
            atrace_categories: "am"
            atrace_categories: "wm"
            atrace_categories: "view"
            atrace_categories: "gfx"
            atrace_categories: "binder_driver"
            atrace_apps: "com.example.app"
        }
    }
}
duration_ms: 10000
EOF

# 2. 导出 trace 文件
adb pull /data/misc/perfetto-traces/trace.perfetto-trace

# 3. 在 https://ui.perfetto.dev 打开分析
```

### 4.5 自定义埋点方案

```kotlin
/**
 * 启动耗时埋点工具类
 * 用于精确测量各阶段耗时
 */
object LaunchTimer {
    
    // 各阶段时间戳
    private var processStartTime: Long = 0L      // 进程启动时间
    private var attachBaseContextTime: Long = 0L // attachBaseContext 时间
    private var applicationCreateTime: Long = 0L // Application.onCreate 开始时间
    private var applicationEndTime: Long = 0L    // Application.onCreate 结束时间
    private var activityCreateTime: Long = 0L    // Activity.onCreate 开始时间
    private var firstFrameTime: Long = 0L        // 首帧绘制完成时间
    
    // 任务耗时记录
    private val taskTimings = mutableMapOf<String, Long>()
    
    /**
     * 记录进程启动时间
     * 在 Application 静态代码块中调用
     */
    fun recordProcessStart() {
        processStartTime = SystemClock.elapsedRealtime()
    }
    
    /**
     * 记录 attachBaseContext 时间
     */
    fun recordAttachBaseContext() {
        attachBaseContextTime = SystemClock.elapsedRealtime()
    }
    
    /**
     * 记录 Application.onCreate 开始
     */
    fun recordApplicationCreateStart() {
        applicationCreateTime = SystemClock.elapsedRealtime()
    }
    
    /**
     * 记录 Application.onCreate 结束
     */
    fun recordApplicationCreateEnd() {
        applicationEndTime = SystemClock.elapsedRealtime()
    }
    
    /**
     * 记录 Activity.onCreate 开始
     */
    fun recordActivityCreate() {
        activityCreateTime = SystemClock.elapsedRealtime()
    }
    
    /**
     * 记录首帧绘制完成
     * 在 Activity 中调用
     */
    fun recordFirstFrame(activity: Activity) {
        // 方法1: 使用 ViewTreeObserver
        activity.window.decorView.viewTreeObserver.addOnPreDrawListener(
            object : ViewTreeObserver.OnPreDrawListener {
                override fun onPreDraw(): Boolean {
                    activity.window.decorView.viewTreeObserver
                        .removeOnPreDrawListener(this)
                    firstFrameTime = SystemClock.elapsedRealtime()
                    reportLaunchTime()
                    return true
                }
            }
        )
        
        // 方法2: 使用 post (不够精确)
        // activity.window.decorView.post {
        //     firstFrameTime = SystemClock.elapsedRealtime()
        //     reportLaunchTime()
        // }
    }
    
    /**
     * 记录任务开始
     */
    fun startTask(taskName: String) {
        taskTimings["${taskName}_start"] = SystemClock.elapsedRealtime()
    }
    
    /**
     * 记录任务结束
     */
    fun endTask(taskName: String) {
        taskTimings["${taskName}_end"] = SystemClock.elapsedRealtime()
    }
    
    /**
     * 获取任务耗时
     */
    fun getTaskDuration(taskName: String): Long {
        val start = taskTimings["${taskName}_start"] ?: return 0
        val end = taskTimings["${taskName}_end"] ?: return 0
        return end - start
    }
    
    /**
     * 上报启动耗时
     */
    private fun reportLaunchTime() {
        val totalTime = firstFrameTime - processStartTime
        val attachTime = attachBaseContextTime - processStartTime
        val applicationTime = applicationEndTime - applicationCreateTime
        val activityTime = firstFrameTime - activityCreateTime
        
        Log.d("LaunchTimer", """
            ========== 启动耗时统计 ==========
            总启动时间: ${totalTime}ms
            进程创建到 attachBaseContext: ${attachTime}ms
            Application.onCreate 耗时: ${applicationTime}ms
            Activity 创建到首帧: ${activityTime}ms
            ================================
        """.trimIndent())
        
        // 上报到监控平台
        // MonitorSDK.reportLaunchTime(totalTime, applicationTime, activityTime)
    }
}

/**
 * Application 中使用
 */
class MyApplication : Application() {
    
    companion object {
        init {
            // 静态代码块，最早执行
            LaunchTimer.recordProcessStart()
        }
    }
    
    override fun attachBaseContext(base: Context) {
        super.attachBaseContext(base)
        LaunchTimer.recordAttachBaseContext()
    }
    
    override fun onCreate() {
        LaunchTimer.recordApplicationCreateStart()
        super.onCreate()
        
        // 各种初始化...
        LaunchTimer.startTask("SDK_Init")
        initSDKs()
        LaunchTimer.endTask("SDK_Init")
        
        LaunchTimer.recordApplicationCreateEnd()
    }
}

/**
 * Activity 中使用
 */
class MainActivity : AppCompatActivity() {
    
    override fun onCreate(savedInstanceState: Bundle?) {
        LaunchTimer.recordActivityCreate()
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        
        // 记录首帧
        LaunchTimer.recordFirstFrame(this)
    }
}
```

### 4.6 使用 ReportFullyDrawn

```kotlin
/**
 * reportFullyDrawn() - 报告完全绘制完成
 * 用于测量包含异步数据加载的完整启动时间
 */
class MainActivity : AppCompatActivity() {
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        
        // 加载数据
        loadData()
    }
    
    private fun loadData() {
        lifecycleScope.launch {
            // 模拟异步数据加载
            val data = withContext(Dispatchers.IO) {
                repository.fetchData()
            }
            
            // 更新 UI
            updateUI(data)
            
            // 报告完全绘制完成
            // 系统会在 Logcat 输出: Fully drawn <package>/<activity>: +<time>
            reportFullyDrawn()
        }
    }
}

// Logcat 输出示例:
// ActivityTaskManager: Displayed com.example.app/.MainActivity: +1s523ms
// ActivityTaskManager: Fully drawn com.example.app/.MainActivity: +2s100ms
```


## 5. 优化手段

### 5.1 优化策略总览

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      启动优化策略分类                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                    Application 阶段优化                         │   │
│  ├─────────────────────────────────────────────────────────────────┤   │
│  │  1. 异步初始化 - 将耗时任务放到子线程                          │   │
│  │  2. 懒加载 - 延迟到首次使用时初始化                            │   │
│  │  3. 按需初始化 - 根据场景选择性初始化                          │   │
│  │  4. 任务编排 - 合理安排任务依赖和执行顺序                      │   │
│  │  5. ContentProvider 优化 - 减少 CP 数量                        │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                    Activity 阶段优化                            │   │
│  ├─────────────────────────────────────────────────────────────────┤   │
│  │  1. 布局优化 - 减少层级、使用 ViewStub                         │   │
│  │  2. 预加载 - 提前加载数据                                      │   │
│  │  3. 延迟加载 - 非首屏内容延迟加载                              │   │
│  │  4. 异步 inflate - 使用 AsyncLayoutInflater                    │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                    系统级优化                                   │   │
│  ├─────────────────────────────────────────────────────────────────┤   │
│  │  1. Baseline Profile - 预编译热点代码                          │   │
│  │  2. 启动窗口优化 - 自定义 SplashScreen                         │   │
│  │  3. 多进程优化 - 避免主进程初始化非必要内容                    │   │
│  │  4. 类加载优化 - 减少类数量、优化 dex                          │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 5.2 异步初始化

```kotlin
/**
 * 异步初始化方案
 * 将耗时的初始化任务放到子线程执行
 */
class MyApplication : Application() {
    
    override fun onCreate() {
        super.onCreate()
        
        // 方案1: 使用线程池异步初始化
        asyncInitWithThreadPool()
        
        // 方案2: 使用协程异步初始化
        asyncInitWithCoroutine()
    }
    
    /**
     * 方案1: 线程池异步初始化
     */
    private fun asyncInitWithThreadPool() {
        val executor = Executors.newFixedThreadPool(
            Runtime.getRuntime().availableProcessors()
        )
        
        // 必须在主线程初始化的 SDK
        initMainThreadSDKs()
        
        // 可以异步初始化的 SDK
        executor.execute {
            initBugly()      // 崩溃收集
        }
        executor.execute {
            initPush()       // 推送
        }
        executor.execute {
            initAnalytics()  // 数据统计
        }
        executor.execute {
            initImageLoader() // 图片加载
        }
        
        // 关闭线程池 (不等待任务完成)
        executor.shutdown()
    }
    
    /**
     * 方案2: 协程异步初始化
     */
    private fun asyncInitWithCoroutine() {
        // 创建应用级 CoroutineScope
        val applicationScope = CoroutineScope(
            SupervisorJob() + Dispatchers.Default
        )
        
        // 主线程初始化
        initMainThreadSDKs()
        
        // 异步初始化
        applicationScope.launch {
            // 并行初始化多个 SDK
            val jobs = listOf(
                async { initBugly() },
                async { initPush() },
                async { initAnalytics() },
                async { initImageLoader() }
            )
            
            // 等待所有初始化完成 (可选)
            // jobs.awaitAll()
        }
    }
    
    /**
     * 必须在主线程初始化的 SDK
     * 通常是需要 Handler 或 UI 相关的 SDK
     */
    private fun initMainThreadSDKs() {
        // 例如: 某些 UI 框架
    }
}

/**
 * 带依赖关系的异步初始化
 * 使用 CountDownLatch 处理依赖
 */
class DependencyAsyncInit(private val application: Application) {
    
    private val executor = Executors.newFixedThreadPool(4)
    
    // 网络初始化完成信号
    private val networkInitLatch = CountDownLatch(1)
    
    fun start() {
        // 任务1: 初始化网络 (无依赖)
        executor.execute {
            initNetwork()
            networkInitLatch.countDown() // 通知网络初始化完成
        }
        
        // 任务2: 初始化推送 (依赖网络)
        executor.execute {
            networkInitLatch.await() // 等待网络初始化完成
            initPush()
        }
        
        // 任务3: 初始化统计 (依赖网络)
        executor.execute {
            networkInitLatch.await()
            initAnalytics()
        }
        
        // 任务4: 初始化图片加载 (无依赖)
        executor.execute {
            initImageLoader()
        }
    }
    
    private fun initNetwork() { /* ... */ }
    private fun initPush() { /* ... */ }
    private fun initAnalytics() { /* ... */ }
    private fun initImageLoader() { /* ... */ }
}
```

### 5.3 懒加载

```kotlin
/**
 * 懒加载方案
 * 延迟到首次使用时才初始化
 */

// 方案1: Kotlin lazy 委托
object SDKManager {
    
    // 懒加载 - 首次访问时初始化
    val imageLoader: ImageLoader by lazy {
        ImageLoader.Builder(AppContext.get())
            .memoryCache { /* ... */ }
            .diskCache { /* ... */ }
            .build()
    }
    
    val analytics: Analytics by lazy {
        Analytics.Builder()
            .setAppId("xxx")
            .build()
    }
    
    // 线程安全的懒加载 (默认就是线程安全的)
    val database: AppDatabase by lazy(LazyThreadSafetyMode.SYNCHRONIZED) {
        Room.databaseBuilder(
            AppContext.get(),
            AppDatabase::class.java,
            "app.db"
        ).build()
    }
    
    // 非线程安全的懒加载 (性能更好，但需要确保单线程访问)
    val config: AppConfig by lazy(LazyThreadSafetyMode.NONE) {
        AppConfig.load()
    }
}

// 方案2: 自定义懒加载包装类
class LazyInit<T>(private val initializer: () -> T) {
    
    @Volatile
    private var instance: T? = null
    
    fun get(): T {
        return instance ?: synchronized(this) {
            instance ?: initializer().also { instance = it }
        }
    }
    
    fun isInitialized(): Boolean = instance != null
    
    // 预初始化 (可选，用于提前初始化)
    fun preInit() {
        get()
    }
}

// 使用示例
object LazySDKManager {
    
    private val _imageLoader = LazyInit {
        ImageLoader.Builder(AppContext.get()).build()
    }
    
    val imageLoader: ImageLoader
        get() = _imageLoader.get()
    
    // 检查是否已初始化
    fun isImageLoaderReady() = _imageLoader.isInitialized()
}

// 方案3: 使用 Provider 模式
interface SDKProvider<T> {
    fun get(): T
    fun isInitialized(): Boolean
}

class LazySDKProvider<T>(
    private val initializer: () -> T
) : SDKProvider<T> {
    
    private var instance: T? = null
    
    override fun get(): T {
        return instance ?: synchronized(this) {
            instance ?: initializer().also { instance = it }
        }
    }
    
    override fun isInitialized(): Boolean = instance != null
}
```

### 5.4 任务编排框架

```kotlin
/**
 * 启动任务编排框架
 * 支持任务依赖、异步执行、主线程等待
 */

/**
 * 启动任务基类
 */
abstract class StartupTask {
    
    // 任务名称
    abstract val name: String
    
    // 依赖的任务列表
    open val dependencies: List<String> = emptyList()
    
    // 是否在主线程执行
    open val runOnMainThread: Boolean = false
    
    // 是否需要等待完成才能进入首页
    open val needWait: Boolean = false
    
    // 执行任务
    abstract fun run()
}

/**
 * 启动任务调度器
 */
class StartupTaskDispatcher private constructor() {
    
    private val tasks = mutableListOf<StartupTask>()
    private val taskMap = mutableMapOf<String, StartupTask>()
    private val completedTasks = ConcurrentHashMap<String, Boolean>()
    private val mainThreadTasks = mutableListOf<StartupTask>()
    private val asyncTasks = mutableListOf<StartupTask>()
    
    private val executor = Executors.newFixedThreadPool(
        Runtime.getRuntime().availableProcessors()
    )
    private val mainHandler = Handler(Looper.getMainLooper())
    private val waitLatch = CountDownLatch(1)
    
    companion object {
        fun create(): StartupTaskDispatcher = StartupTaskDispatcher()
    }
    
    /**
     * 添加任务
     */
    fun addTask(task: StartupTask): StartupTaskDispatcher {
        tasks.add(task)
        taskMap[task.name] = task
        
        if (task.runOnMainThread) {
            mainThreadTasks.add(task)
        } else {
            asyncTasks.add(task)
        }
        
        return this
    }
    
    /**
     * 开始执行
     */
    fun start() {
        // 拓扑排序，处理依赖关系
        val sortedTasks = topologicalSort()
        
        // 执行异步任务
        for (task in sortedTasks.filter { !it.runOnMainThread }) {
            executor.execute {
                // 等待依赖任务完成
                waitForDependencies(task)
                
                // 执行任务
                runTask(task)
            }
        }
        
        // 执行主线程任务
        for (task in sortedTasks.filter { it.runOnMainThread }) {
            // 等待依赖任务完成
            waitForDependencies(task)
            
            // 在主线程执行
            runTask(task)
        }
    }
    
    /**
     * 等待必要任务完成
     */
    fun await() {
        // 等待所有 needWait 的任务完成
        val needWaitTasks = tasks.filter { it.needWait }
        while (needWaitTasks.any { !completedTasks.containsKey(it.name) }) {
            Thread.sleep(10)
        }
    }
    
    /**
     * 等待依赖任务完成
     */
    private fun waitForDependencies(task: StartupTask) {
        for (dependency in task.dependencies) {
            while (!completedTasks.containsKey(dependency)) {
                Thread.sleep(5)
            }
        }
    }
    
    /**
     * 执行任务
     */
    private fun runTask(task: StartupTask) {
        val startTime = SystemClock.elapsedRealtime()
        
        try {
            task.run()
        } catch (e: Exception) {
            Log.e("StartupTask", "Task ${task.name} failed", e)
        }
        
        val duration = SystemClock.elapsedRealtime() - startTime
        Log.d("StartupTask", "Task ${task.name} completed in ${duration}ms")
        
        completedTasks[task.name] = true
    }
    
    /**
     * 拓扑排序
     */
    private fun topologicalSort(): List<StartupTask> {
        val result = mutableListOf<StartupTask>()
        val visited = mutableSetOf<String>()
        val visiting = mutableSetOf<String>()
        
        fun visit(task: StartupTask) {
            if (visited.contains(task.name)) return
            if (visiting.contains(task.name)) {
                throw IllegalStateException("Circular dependency detected: ${task.name}")
            }
            
            visiting.add(task.name)
            
            for (dep in task.dependencies) {
                taskMap[dep]?.let { visit(it) }
            }
            
            visiting.remove(task.name)
            visited.add(task.name)
            result.add(task)
        }
        
        for (task in tasks) {
            visit(task)
        }
        
        return result
    }
}

/**
 * 使用示例
 */
class MyApplication : Application() {
    
    override fun onCreate() {
        super.onCreate()
        
        // 创建任务调度器
        StartupTaskDispatcher.create()
            .addTask(NetworkInitTask())
            .addTask(PushInitTask())
            .addTask(AnalyticsInitTask())
            .addTask(ImageLoaderInitTask())
            .addTask(DatabaseInitTask())
            .start()
        
        // 等待必要任务完成
        // dispatcher.await()
    }
}

// 具体任务实现
class NetworkInitTask : StartupTask() {
    override val name = "NetworkInit"
    override val runOnMainThread = false
    override val needWait = true  // 需要等待完成
    
    override fun run() {
        // 初始化网络
        OkHttpClient.Builder()
            .connectTimeout(30, TimeUnit.SECONDS)
            .build()
    }
}

class PushInitTask : StartupTask() {
    override val name = "PushInit"
    override val dependencies = listOf("NetworkInit")  // 依赖网络
    override val runOnMainThread = false
    
    override fun run() {
        // 初始化推送
    }
}

class AnalyticsInitTask : StartupTask() {
    override val name = "AnalyticsInit"
    override val dependencies = listOf("NetworkInit")
    override val runOnMainThread = false
    
    override fun run() {
        // 初始化统计
    }
}

class ImageLoaderInitTask : StartupTask() {
    override val name = "ImageLoaderInit"
    override val runOnMainThread = false
    
    override fun run() {
        // 初始化图片加载
    }
}

class DatabaseInitTask : StartupTask() {
    override val name = "DatabaseInit"
    override val runOnMainThread = false
    
    override fun run() {
        // 初始化数据库
    }
}
```


### 5.5 App Startup 库

```kotlin
/**
 * Jetpack App Startup 库
 * Google 官方的启动初始化框架
 * 
 * 优势:
 * 1. 统一管理 ContentProvider 初始化
 * 2. 支持依赖关系
 * 3. 支持懒加载
 * 4. 减少 ContentProvider 数量
 */

// 1. 添加依赖
// implementation "androidx.startup:startup-runtime:1.1.1"

/**
 * 定义 Initializer
 */
class NetworkInitializer : Initializer<OkHttpClient> {
    
    override fun create(context: Context): OkHttpClient {
        // 初始化并返回实例
        return OkHttpClient.Builder()
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(30, TimeUnit.SECONDS)
            .build()
    }
    
    override fun dependencies(): List<Class<out Initializer<*>>> {
        // 无依赖
        return emptyList()
    }
}

class AnalyticsInitializer : Initializer<Analytics> {
    
    override fun create(context: Context): Analytics {
        return Analytics.Builder(context)
            .setAppId("xxx")
            .build()
    }
    
    override fun dependencies(): List<Class<out Initializer<*>>> {
        // 依赖网络初始化
        return listOf(NetworkInitializer::class.java)
    }
}

class ImageLoaderInitializer : Initializer<ImageLoader> {
    
    override fun create(context: Context): ImageLoader {
        return ImageLoader.Builder(context)
            .memoryCache {
                MemoryCache.Builder(context)
                    .maxSizePercent(0.25)
                    .build()
            }
            .diskCache {
                DiskCache.Builder()
                    .directory(context.cacheDir.resolve("image_cache"))
                    .maxSizePercent(0.02)
                    .build()
            }
            .build()
    }
    
    override fun dependencies(): List<Class<out Initializer<*>>> {
        return emptyList()
    }
}

/**
 * 在 AndroidManifest.xml 中配置
 */
/*
<provider
    android:name="androidx.startup.InitializationProvider"
    android:authorities="${applicationId}.androidx-startup"
    android:exported="false"
    tools:node="merge">
    
    <!-- 自动初始化 -->
    <meta-data
        android:name="com.example.NetworkInitializer"
        android:value="androidx.startup" />
    
    <meta-data
        android:name="com.example.AnalyticsInitializer"
        android:value="androidx.startup" />
    
    <!-- 禁用自动初始化，改为懒加载 -->
    <meta-data
        android:name="com.example.ImageLoaderInitializer"
        android:value="androidx.startup"
        tools:node="remove" />
</provider>
*/

/**
 * 懒加载初始化
 */
class MainActivity : AppCompatActivity() {
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        // 手动初始化 (懒加载)
        val imageLoader = AppInitializer.getInstance(this)
            .initializeComponent(ImageLoaderInitializer::class.java)
    }
}

/**
 * 获取已初始化的实例
 */
fun getNetworkClient(context: Context): OkHttpClient {
    return AppInitializer.getInstance(context)
        .initializeComponent(NetworkInitializer::class.java)
}

/**
 * 完全禁用 App Startup
 * 如果不需要任何自动初始化
 */
/*
<provider
    android:name="androidx.startup.InitializationProvider"
    android:authorities="${applicationId}.androidx-startup"
    tools:node="remove" />
*/
```

### 5.6 Baseline Profile

```kotlin
/**
 * Baseline Profile - 基准配置文件
 * 
 * 原理:
 * 1. 收集应用启动和关键路径的热点代码
 * 2. 将这些代码预编译为机器码
 * 3. 应用安装时，ART 会优先编译这些代码
 * 4. 首次启动时直接执行机器码，无需 JIT 编译
 * 
 * 效果:
 * - 启动速度提升 30%+
 * - 首帧渲染时间减少 40%+
 */

// ==================== 1. 添加依赖 ====================

// build.gradle (app)
/*
plugins {
    id 'com.android.application'
    id 'androidx.baselineprofile'
}

android {
    defaultConfig {
        // ...
    }
    
    buildTypes {
        release {
            // 启用 Baseline Profile
            baselineProfile {
                automaticGenerationDuringBuild = true
            }
        }
    }
}

dependencies {
    implementation "androidx.profileinstaller:profileinstaller:1.3.1"
    baselineProfile project(':baselineprofile')
}
*/

// build.gradle (baselineprofile module)
/*
plugins {
    id 'com.android.test'
    id 'androidx.baselineprofile'
}

android {
    namespace 'com.example.baselineprofile'
    compileSdk 34
    
    defaultConfig {
        minSdk 28
        targetSdk 34
        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
    }
    
    targetProjectPath = ":app"
}

baselineProfile {
    useConnectedDevices = true
}

dependencies {
    implementation "androidx.test.ext:junit:1.1.5"
    implementation "androidx.test.espresso:espresso-core:3.5.1"
    implementation "androidx.test.uiautomator:uiautomator:2.2.0"
    implementation "androidx.benchmark:benchmark-macro-junit4:1.2.3"
}
*/

// ==================== 2. 编写 Baseline Profile 生成器 ====================

/**
 * BaselineProfileGenerator.kt
 * 放在 baselineprofile 模块中
 */
@RunWith(AndroidJUnit4::class)
@LargeTest
class BaselineProfileGenerator {
    
    @get:Rule
    val rule = BaselineProfileRule()
    
    @Test
    fun generateBaselineProfile() {
        rule.collect(
            packageName = "com.example.app",
            // 包含启动和关键用户路径
            includeInStartupProfile = true,
            profileBlock = {
                // 1. 冷启动
                pressHome()
                startActivityAndWait()
                
                // 2. 等待首页加载完成
                device.wait(
                    Until.hasObject(By.res("main_content")),
                    5000
                )
                
                // 3. 模拟用户操作 - 滑动列表
                val list = device.findObject(By.res("recycler_view"))
                list?.scroll(Direction.DOWN, 1f)
                
                // 4. 模拟用户操作 - 点击详情
                device.findObject(By.res("item_0"))?.click()
                device.wait(
                    Until.hasObject(By.res("detail_content")),
                    3000
                )
                
                // 5. 返回
                device.pressBack()
            }
        )
    }
}

// ==================== 3. 生成 Baseline Profile ====================

// 命令行执行:
// ./gradlew :app:generateBaselineProfile

// 生成的文件位置:
// app/src/main/baseline-prof.txt

// ==================== 4. 验证 Baseline Profile 效果 ====================

/**
 * StartupBenchmark.kt
 * 用于测量启动性能
 */
@RunWith(AndroidJUnit4::class)
@LargeTest
class StartupBenchmark {
    
    @get:Rule
    val rule = MacrobenchmarkRule()
    
    @Test
    fun startupCompilationNone() = startup(CompilationMode.None())
    
    @Test
    fun startupCompilationPartial() = startup(
        CompilationMode.Partial(
            baselineProfileMode = BaselineProfileMode.Require
        )
    )
    
    @Test
    fun startupCompilationFull() = startup(CompilationMode.Full())
    
    private fun startup(compilationMode: CompilationMode) {
        rule.measureRepeated(
            packageName = "com.example.app",
            metrics = listOf(StartupTimingMetric()),
            compilationMode = compilationMode,
            startupMode = StartupMode.COLD,
            iterations = 10
        ) {
            pressHome()
            startActivityAndWait()
        }
    }
}

// ==================== 5. Startup Profile (Android 13+) ====================

/**
 * Startup Profile 是 Baseline Profile 的子集
 * 专门用于优化启动路径
 * 
 * 在 BaselineProfileGenerator 中设置:
 * includeInStartupProfile = true
 */
```

### 5.7 布局优化

```kotlin
/**
 * 布局优化 - 减少首帧渲染时间
 */

// ==================== 1. 减少布局层级 ====================

// 使用 ConstraintLayout 替代嵌套布局
/*
<!-- 优化前: 多层嵌套 -->
<LinearLayout>
    <LinearLayout>
        <RelativeLayout>
            <TextView />
            <ImageView />
        </RelativeLayout>
    </LinearLayout>
</LinearLayout>

<!-- 优化后: 扁平化 -->
<androidx.constraintlayout.widget.ConstraintLayout>
    <TextView
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />
    <ImageView
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintTop_toTopOf="parent" />
</androidx.constraintlayout.widget.ConstraintLayout>
*/

// ==================== 2. 使用 ViewStub 延迟加载 ====================

/*
<ViewStub
    android:id="@+id/stub_error"
    android:layout="@layout/layout_error"
    android:layout_width="match_parent"
    android:layout_height="match_parent" />
*/

class MainActivity : AppCompatActivity() {
    
    private var errorView: View? = null
    
    fun showError() {
        // 首次调用时才会 inflate
        if (errorView == null) {
            val stub = findViewById<ViewStub>(R.id.stub_error)
            errorView = stub.inflate()
        }
        errorView?.visibility = View.VISIBLE
    }
}

// ==================== 3. 使用 merge 减少层级 ====================

/*
<!-- include 的布局使用 merge -->
<merge xmlns:android="http://schemas.android.com/apk/res/android">
    <TextView android:id="@+id/title" />
    <TextView android:id="@+id/subtitle" />
</merge>
*/

// ==================== 4. 异步 inflate ====================

class MainActivity : AppCompatActivity() {
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        // 方案1: AsyncLayoutInflater
        AsyncLayoutInflater(this).inflate(
            R.layout.activity_main,
            null
        ) { view, resid, parent ->
            setContentView(view)
            initViews()
        }
        
        // 方案2: 协程异步 inflate
        lifecycleScope.launch {
            val view = withContext(Dispatchers.Default) {
                // 注意: inflate 本身不能在子线程
                // 这里只是示例，实际需要使用 AsyncLayoutInflater
            }
        }
    }
}

// ==================== 5. 预加载布局 ====================

/**
 * 在 Application 中预加载常用布局
 */
class MyApplication : Application() {
    
    override fun onCreate() {
        super.onCreate()
        
        // 异步预加载布局
        thread {
            val inflater = LayoutInflater.from(this)
            // 预加载但不添加到视图树
            inflater.inflate(R.layout.activity_main, null, false)
            inflater.inflate(R.layout.item_list, null, false)
        }
    }
}
```

### 5.8 多进程优化

```kotlin
/**
 * 多进程优化
 * 避免在非主进程中执行不必要的初始化
 */
class MyApplication : Application() {
    
    override fun onCreate() {
        super.onCreate()
        
        // 判断当前进程
        val processName = getProcessName()
        
        when {
            processName == packageName -> {
                // 主进程初始化
                initMainProcess()
            }
            processName?.endsWith(":push") == true -> {
                // 推送进程，只初始化推送相关
                initPushProcess()
            }
            processName?.endsWith(":webview") == true -> {
                // WebView 进程
                initWebViewProcess()
            }
            else -> {
                // 其他进程，最小化初始化
                initMinimal()
            }
        }
    }
    
    /**
     * 获取当前进程名
     */
    private fun getProcessName(): String? {
        // 方法1: 通过 ActivityManager (API < 28)
        val pid = Process.myPid()
        val am = getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager
        for (info in am.runningAppProcesses ?: emptyList()) {
            if (info.pid == pid) {
                return info.processName
            }
        }
        
        // 方法2: 通过 Application.getProcessName() (API >= 28)
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
            getProcessName()
        } else {
            null
        }
    }
    
    private fun initMainProcess() {
        // 完整初始化
        initNetwork()
        initImageLoader()
        initAnalytics()
        initPush()
        // ...
    }
    
    private fun initPushProcess() {
        // 只初始化推送需要的
        initNetwork()
        initPush()
    }
    
    private fun initWebViewProcess() {
        // WebView 进程初始化
    }
    
    private fun initMinimal() {
        // 最小化初始化
    }
}
```

### 5.9 SplashScreen 优化

```kotlin
/**
 * SplashScreen 优化
 * Android 12+ 使用新的 SplashScreen API
 */

// ==================== 1. 配置 SplashScreen 主题 ====================

/*
<!-- values/themes.xml -->
<style name="Theme.App.Starting" parent="Theme.SplashScreen">
    <!-- 设置启动画面背景色 -->
    <item name="windowSplashScreenBackground">@color/splash_background</item>
    
    <!-- 设置启动画面图标 -->
    <item name="windowSplashScreenAnimatedIcon">@drawable/ic_splash</item>
    
    <!-- 设置图标动画时长 (最长 1000ms) -->
    <item name="windowSplashScreenAnimationDuration">1000</item>
    
    <!-- 设置图标背景色 -->
    <item name="windowSplashScreenIconBackgroundColor">@color/icon_background</item>
    
    <!-- 设置品牌图片 (可选) -->
    <item name="windowSplashScreenBrandingImage">@drawable/branding</item>
    
    <!-- 设置启动后的主题 -->
    <item name="postSplashScreenTheme">@style/Theme.App</item>
</style>
*/

// ==================== 2. 在 Activity 中使用 ====================

class MainActivity : AppCompatActivity() {
    
    override fun onCreate(savedInstanceState: Bundle?) {
        // 必须在 super.onCreate() 之前调用
        val splashScreen = installSplashScreen()
        
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        
        // 控制 SplashScreen 显示时长
        var isReady = false
        splashScreen.setKeepOnScreenCondition { !isReady }
        
        // 加载数据
        lifecycleScope.launch {
            loadInitialData()
            isReady = true
        }
        
        // 自定义退出动画
        splashScreen.setOnExitAnimationListener { splashScreenView ->
            // 创建退出动画
            val fadeOut = ObjectAnimator.ofFloat(
                splashScreenView,
                View.ALPHA,
                1f, 0f
            )
            fadeOut.duration = 500L
            fadeOut.interpolator = AccelerateInterpolator()
            fadeOut.doOnEnd { splashScreenView.remove() }
            fadeOut.start()
        }
    }
}

// ==================== 3. 兼容低版本 ====================

/*
<!-- values-v31/themes.xml (Android 12+) -->
<style name="Theme.App.Starting" parent="Theme.SplashScreen">
    <!-- Android 12+ 配置 -->
</style>

<!-- values/themes.xml (低版本) -->
<style name="Theme.App.Starting" parent="Theme.App">
    <item name="android:windowBackground">@drawable/splash_background</item>
</style>
*/

// 使用 SplashScreen compat 库
// implementation "androidx.core:core-splashscreen:1.0.1"
```


## 6. 实战应用

### 6.1 启动优化实战案例

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    启动优化实战案例                                      │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  案例背景:                                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  某电商 App 冷启动时间: 3.2s                                    │   │
│  │  目标: 优化到 1.5s 以内                                         │   │
│  │  设备: 中端机型 (骁龙 660)                                      │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  优化前耗时分布:                                                        │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  进程创建:           ~300ms (系统控制)                          │   │
│  │  Application.onCreate: ~1200ms                                  │   │
│  │    - 网络初始化:      150ms                                     │   │
│  │    - 图片库初始化:    200ms                                     │   │
│  │    - 推送初始化:      180ms                                     │   │
│  │    - 统计初始化:      120ms                                     │   │
│  │    - 路由初始化:      100ms                                     │   │
│  │    - 数据库初始化:    150ms                                     │   │
│  │    - 其他 SDK:        300ms                                     │   │
│  │  Activity.onCreate:   ~800ms                                    │   │
│  │    - 布局 inflate:    400ms                                     │   │
│  │    - 数据加载:        300ms                                     │   │
│  │    - View 初始化:     100ms                                     │   │
│  │  首帧绘制:            ~900ms                                    │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 6.2 优化方案实施

```kotlin
/**
 * 优化方案1: Application 异步初始化
 */
class OptimizedApplication : Application() {
    
    // 启动任务调度器
    private lateinit var taskDispatcher: StartupTaskDispatcher
    
    override fun attachBaseContext(base: Context) {
        super.attachBaseContext(base)
        
        // 尽早初始化 MultiDex (如果需要)
        // MultiDex.install(this)
    }
    
    override fun onCreate() {
        super.onCreate()
        
        // 判断进程，避免多进程重复初始化
        if (!isMainProcess()) {
            return
        }
        
        // 使用任务调度器进行初始化
        taskDispatcher = StartupTaskDispatcher.create()
            // 必须同步初始化的任务
            .addTask(object : StartupTask() {
                override val name = "CrashHandler"
                override val runOnMainThread = true
                override val needWait = true
                override fun run() {
                    // 崩溃收集必须最先初始化
                    CrashHandler.init(this@OptimizedApplication)
                }
            })
            // 可异步初始化的任务
            .addTask(object : StartupTask() {
                override val name = "Network"
                override val runOnMainThread = false
                override val needWait = true  // 后续任务依赖
                override fun run() {
                    NetworkManager.init(this@OptimizedApplication)
                }
            })
            .addTask(object : StartupTask() {
                override val name = "ImageLoader"
                override val runOnMainThread = false
                override val needWait = false
                override fun run() {
                    ImageLoaderManager.init(this@OptimizedApplication)
                }
            })
            .addTask(object : StartupTask() {
                override val name = "Push"
                override val dependencies = listOf("Network")
                override val runOnMainThread = false
                override val needWait = false
                override fun run() {
                    PushManager.init(this@OptimizedApplication)
                }
            })
            .addTask(object : StartupTask() {
                override val name = "Analytics"
                override val dependencies = listOf("Network")
                override val runOnMainThread = false
                override val needWait = false
                override fun run() {
                    AnalyticsManager.init(this@OptimizedApplication)
                }
            })
            .addTask(object : StartupTask() {
                override val name = "Router"
                override val runOnMainThread = true  // ARouter 需要主线程
                override val needWait = true
                override fun run() {
                    ARouter.init(this@OptimizedApplication)
                }
            })
        
        // 开始执行
        taskDispatcher.start()
        
        // 等待必要任务完成
        taskDispatcher.await()
    }
    
    private fun isMainProcess(): Boolean {
        return packageName == getProcessName()
    }
    
    private fun getProcessName(): String? {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
            getProcessName()
        } else {
            val pid = Process.myPid()
            val am = getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager
            am.runningAppProcesses?.find { it.pid == pid }?.processName
        }
    }
}

/**
 * 优化方案2: Activity 布局优化
 */
class OptimizedMainActivity : AppCompatActivity() {
    
    override fun onCreate(savedInstanceState: Bundle?) {
        // 记录启动时间
        LaunchTimer.recordActivityCreate()
        
        super.onCreate(savedInstanceState)
        
        // 使用优化后的布局
        setContentView(R.layout.activity_main_optimized)
        
        // 延迟初始化非首屏内容
        initFirstScreen()
        
        // 首帧绘制后再初始化其他内容
        window.decorView.post {
            initSecondaryContent()
        }
        
        // 记录首帧
        LaunchTimer.recordFirstFrame(this)
    }
    
    /**
     * 首屏内容初始化
     */
    private fun initFirstScreen() {
        // 只初始化首屏可见的内容
        initToolbar()
        initBanner()
        initTopCategories()
    }
    
    /**
     * 延迟初始化非首屏内容
     */
    private fun initSecondaryContent() {
        // 使用 IdleHandler 在空闲时初始化
        Looper.myQueue().addIdleHandler {
            initRecommendList()
            initBottomNavigation()
            false // 返回 false 表示只执行一次
        }
    }
}

/**
 * 优化方案3: 使用 ViewStub 延迟加载
 */
/*
<!-- activity_main_optimized.xml -->
<androidx.constraintlayout.widget.ConstraintLayout>
    
    <!-- 首屏内容 -->
    <include layout="@layout/layout_toolbar" />
    <include layout="@layout/layout_banner" />
    <include layout="@layout/layout_categories" />
    
    <!-- 非首屏内容使用 ViewStub -->
    <ViewStub
        android:id="@+id/stub_recommend"
        android:layout="@layout/layout_recommend"
        android:inflatedId="@+id/layout_recommend" />
    
    <ViewStub
        android:id="@+id/stub_bottom_nav"
        android:layout="@layout/layout_bottom_nav"
        android:inflatedId="@+id/layout_bottom_nav" />
        
</androidx.constraintlayout.widget.ConstraintLayout>
*/

/**
 * 优化方案4: 预加载数据
 */
class DataPreloader {
    
    companion object {
        private var homeData: HomeData? = null
        private var isLoading = false
        
        /**
         * 在 Application 中预加载首页数据
         */
        fun preload(context: Context) {
            if (isLoading || homeData != null) return
            
            isLoading = true
            
            // 使用协程预加载
            CoroutineScope(Dispatchers.IO).launch {
                try {
                    homeData = HomeRepository.fetchHomeData()
                } catch (e: Exception) {
                    // 预加载失败不影响启动
                } finally {
                    isLoading = false
                }
            }
        }
        
        /**
         * 获取预加载的数据
         */
        suspend fun getHomeData(): HomeData {
            // 如果预加载完成，直接返回
            homeData?.let { return it }
            
            // 否则等待加载完成或重新加载
            return withContext(Dispatchers.IO) {
                while (isLoading) {
                    delay(50)
                }
                homeData ?: HomeRepository.fetchHomeData().also { homeData = it }
            }
        }
    }
}
```

### 6.3 优化效果对比

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    优化效果对比                                          │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  优化后耗时分布:                                                        │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  进程创建:           ~300ms (无法优化)                          │   │
│  │  Application.onCreate: ~400ms (↓800ms)                          │   │
│  │    - 同步任务:        200ms (崩溃收集 + 路由)                   │   │
│  │    - 异步任务:        并行执行，不阻塞主线程                    │   │
│  │  Activity.onCreate:   ~350ms (↓450ms)                           │   │
│  │    - 布局 inflate:    200ms (布局优化)                          │   │
│  │    - 首屏初始化:      150ms                                     │   │
│  │  首帧绘制:            ~350ms (↓550ms)                           │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  总耗时对比:                                                            │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  优化前: 3200ms                                                 │   │
│  │  优化后: 1400ms                                                 │   │
│  │  提升:   56%                                                    │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  各优化手段贡献:                                                        │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  异步初始化:         ~600ms                                     │   │
│  │  布局优化:           ~200ms                                     │   │
│  │  延迟加载:           ~400ms                                     │   │
│  │  数据预加载:         ~200ms                                     │   │
│  │  Baseline Profile:   ~400ms (额外优化)                          │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 6.4 启动监控体系

```kotlin
/**
 * 启动监控体系
 * 用于线上监控启动性能
 */
object LaunchMonitor {
    
    // 启动数据
    data class LaunchData(
        val launchType: LaunchType,           // 启动类型
        val totalTime: Long,                   // 总耗时
        val applicationTime: Long,             // Application 耗时
        val activityTime: Long,                // Activity 耗时
        val firstFrameTime: Long,              // 首帧耗时
        val taskTimings: Map<String, Long>,    // 各任务耗时
        val deviceInfo: DeviceInfo,            // 设备信息
        val timestamp: Long                    // 时间戳
    )
    
    enum class LaunchType {
        COLD, WARM, HOT
    }
    
    data class DeviceInfo(
        val brand: String,
        val model: String,
        val sdkVersion: Int,
        val cpuCores: Int,
        val totalMemory: Long
    )
    
    private var launchData: LaunchData? = null
    
    /**
     * 收集启动数据
     */
    fun collectLaunchData(
        launchType: LaunchType,
        totalTime: Long,
        applicationTime: Long,
        activityTime: Long,
        firstFrameTime: Long,
        taskTimings: Map<String, Long>
    ) {
        launchData = LaunchData(
            launchType = launchType,
            totalTime = totalTime,
            applicationTime = applicationTime,
            activityTime = activityTime,
            firstFrameTime = firstFrameTime,
            taskTimings = taskTimings,
            deviceInfo = collectDeviceInfo(),
            timestamp = System.currentTimeMillis()
        )
        
        // 上报数据
        reportLaunchData()
    }
    
    /**
     * 收集设备信息
     */
    private fun collectDeviceInfo(): DeviceInfo {
        val activityManager = AppContext.get()
            .getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager
        val memoryInfo = ActivityManager.MemoryInfo()
        activityManager.getMemoryInfo(memoryInfo)
        
        return DeviceInfo(
            brand = Build.BRAND,
            model = Build.MODEL,
            sdkVersion = Build.VERSION.SDK_INT,
            cpuCores = Runtime.getRuntime().availableProcessors(),
            totalMemory = memoryInfo.totalMem
        )
    }
    
    /**
     * 上报启动数据
     */
    private fun reportLaunchData() {
        launchData?.let { data ->
            // 上报到监控平台
            CoroutineScope(Dispatchers.IO).launch {
                try {
                    MonitorApi.reportLaunch(data)
                } catch (e: Exception) {
                    // 上报失败，本地缓存
                    LocalCache.saveLaunchData(data)
                }
            }
        }
    }
    
    /**
     * 判断启动类型
     */
    fun detectLaunchType(): LaunchType {
        // 通过 Activity 的 savedInstanceState 和进程状态判断
        return when {
            isProcessJustCreated() -> LaunchType.COLD
            isActivityRecreated() -> LaunchType.WARM
            else -> LaunchType.HOT
        }
    }
    
    private fun isProcessJustCreated(): Boolean {
        // 进程启动时间与当前时间差小于阈值
        val processStartTime = Process.getStartElapsedRealtime()
        return SystemClock.elapsedRealtime() - processStartTime < 5000
    }
    
    private fun isActivityRecreated(): Boolean {
        // 通过 savedInstanceState 判断
        return false // 需要在 Activity 中判断
    }
}
```


## 7. 常见面试题

### 面试题 1：请详细描述 Android 冷启动的完整流程？

**答案要点：**

```
冷启动完整流程分为以下几个阶段：

1. Launcher 进程阶段
   - 用户点击应用图标
   - Launcher 调用 startActivity()
   - 通过 Binder IPC 调用 AMS

2. system_server 进程阶段
   - AMS.startActivity() 处理启动请求
   - 检查目标进程是否存在
   - 进程不存在，调用 AMS.startProcessLocked()
   - 通过 Socket 通知 Zygote fork 新进程

3. Zygote 进程阶段
   - 接收 Socket 请求
   - fork() 创建新的 App 进程
   - 子进程执行 ActivityThread.main()

4. App 进程阶段
   - ActivityThread.main() 作为入口
   - Looper.prepareMainLooper() 初始化主线程 Looper
   - ActivityThread.attach() 绑定到 AMS
   - handleBindApplication() 处理 Application 绑定
     - 创建 Application 对象
     - 调用 attachBaseContext()
     - 安装 ContentProvider (在 onCreate 之前!)
     - 调用 Application.onCreate()
   - handleLaunchActivity() 启动 Activity
     - 创建 Activity 对象
     - 调用 Activity.attach() 创建 PhoneWindow
     - 调用 onCreate() → onStart() → onResume()
   - 首帧绘制完成

关键点：
- ContentProvider.onCreate() 在 Application.onCreate() 之前执行
- 很多三方 SDK 利用 ContentProvider 实现无侵入初始化
- 启动耗时 = 首帧绘制完成时间 - 点击图标时间
```

---

### 面试题 2：冷启动、温启动、热启动的区别是什么？如何判断启动类型？

**答案要点：**

```
三种启动类型的区别：

1. 冷启动 (Cold Start)
   - 进程不存在，需要从头创建
   - 耗时最长，包含进程创建、Application 初始化、Activity 创建
   - 触发场景：设备重启后首次启动、应用被杀死后启动

2. 温启动 (Warm Start)
   - 进程存在，但 Activity 需要重新创建
   - 跳过进程创建，但需要执行 Activity 生命周期
   - 触发场景：用户按返回键退出后重新进入、Activity 被系统回收

3. 热启动 (Hot Start)
   - 进程和 Activity 都存在，只需带到前台
   - 耗时最短，只执行 onRestart() → onStart() → onResume()
   - 触发场景：用户按 Home 键后重新进入

判断启动类型的方法：

// 方法1：通过进程启动时间判断
fun detectLaunchType(): LaunchType {
    val processStartTime = Process.getStartElapsedRealtime()
    val currentTime = SystemClock.elapsedRealtime()
    
    return when {
        // 进程刚创建 (5秒内)
        currentTime - processStartTime < 5000 -> LaunchType.COLD
        // Activity 有 savedInstanceState
        savedInstanceState != null -> LaunchType.WARM
        // 其他情况
        else -> LaunchType.HOT
    }
}

// 方法2：通过 Activity 生命周期判断
// onCreate 被调用 → 冷启动或温启动
// onRestart 被调用 → 热启动
```

---

### 面试题 3：Application.onCreate() 中有哪些优化手段？请详细说明异步初始化的实现方案。

**答案要点：**

```
Application.onCreate() 优化手段：

1. 异步初始化
   - 将不需要在主线程执行的任务放到子线程
   - 使用线程池或协程并行执行
   - 注意处理任务依赖关系

2. 懒加载
   - 延迟到首次使用时才初始化
   - 使用 Kotlin lazy 委托
   - 适用于非启动必需的 SDK

3. 按需初始化
   - 根据进程类型选择性初始化
   - 避免在非主进程执行不必要的初始化

4. 任务编排
   - 使用 App Startup 或自定义调度器
   - 合理安排任务依赖和执行顺序

异步初始化实现方案：

// 方案1：线程池
val executor = Executors.newFixedThreadPool(4)
executor.execute { initSDK1() }
executor.execute { initSDK2() }

// 方案2：协程
applicationScope.launch {
    listOf(
        async { initSDK1() },
        async { initSDK2() }
    ).awaitAll()
}

// 方案3：带依赖的任务调度
class TaskDispatcher {
    fun addTask(task: StartupTask)
    fun start()
    fun await() // 等待必要任务完成
}

注意事项：
- 某些 SDK 必须在主线程初始化 (如 ARouter)
- 需要处理任务依赖关系
- 异步任务的异常处理
- 避免过多线程导致 CPU 竞争
```

---

### 面试题 4：ContentProvider 为什么会影响启动速度？如何优化？

**答案要点：**

```
ContentProvider 影响启动速度的原因：

1. 执行时机早
   - ContentProvider.onCreate() 在 Application.onCreate() 之前执行
   - 所有 ContentProvider 串行初始化
   - 任何一个 CP 耗时都会阻塞启动

2. 三方 SDK 滥用
   - 很多 SDK 使用 ContentProvider 实现无侵入初始化
   - 如 Firebase、LeakCanary、WorkManager 等
   - 每个 SDK 都注册一个 CP，累积耗时严重

3. 源码分析
   // ActivityThread.handleBindApplication()
   if (!ArrayUtils.isEmpty(data.providers)) {
       // 在 Application.onCreate() 之前安装所有 CP
       installContentProviders(app, data.providers);
   }
   // 然后才调用 Application.onCreate()
   mInstrumentation.callApplicationOnCreate(app);

优化方案：

1. 使用 App Startup 合并 ContentProvider
   - 将多个 SDK 的初始化合并到一个 CP
   - 减少 CP 数量

2. 禁用不必要的 ContentProvider
   <!-- 禁用 Firebase 的自动初始化 -->
   <provider
       android:name="com.google.firebase.provider.FirebaseInitProvider"
       android:authorities="${applicationId}.firebaseinitprovider"
       tools:node="remove" />

3. 延迟初始化
   - 使用 App Startup 的懒加载功能
   - 手动控制初始化时机

4. 审查三方 SDK
   - 检查 APK 中的 ContentProvider 数量
   - 评估每个 CP 的必要性
```

---

### 面试题 5：如何测量启动耗时？Systrace/Perfetto 如何分析启动问题？

**答案要点：**

```
启动耗时测量方法：

1. adb 命令
   adb shell am start -W -S -n package/.MainActivity
   # 输出 TotalTime 和 WaitTime

2. Logcat 日志
   adb logcat -s ActivityTaskManager:I | grep "Displayed"
   # 输出: Displayed package/.MainActivity: +1s523ms

3. 自定义埋点
   - 在关键节点记录时间戳
   - 计算各阶段耗时
   - 上报到监控平台

4. Systrace/Perfetto
   - 最精确的分析工具
   - 可以看到每个方法的耗时

Perfetto 分析启动问题：

1. 抓取 Trace
   adb shell perfetto -c config.txt -o trace.perfetto-trace

2. 关键 Track 分析
   - CPU 调度: 查看主线程是否被抢占
   - Binder: 查看 IPC 调用耗时
   - SurfaceFlinger: 查看渲染耗时
   - atrace 标签: 查看系统和应用的 Trace 点

3. 常见问题定位
   - bindApplication 耗时长 → Application 初始化问题
   - activityStart 耗时长 → Activity 创建问题
   - inflate 耗时长 → 布局复杂
   - measure/layout/draw 耗时长 → 绑制问题
   - Binder 调用阻塞 → IPC 问题
   - GC 频繁 → 内存问题

4. 分析技巧
   - 关注主线程 (UI Thread) 的执行情况
   - 查看是否有长时间的锁等待
   - 检查是否有不必要的 IO 操作
```

---

### 面试题 6：Baseline Profile 的原理是什么？如何生成和使用？

**答案要点：**

```
Baseline Profile 原理：

1. 背景知识
   - Android 使用 ART 运行时
   - 代码执行方式：解释执行 → JIT 编译 → AOT 编译
   - 首次启动时，热点代码需要 JIT 编译，影响性能

2. Baseline Profile 作用
   - 收集应用启动和关键路径的热点代码
   - 将这些代码标记为需要预编译
   - 应用安装时，ART 优先 AOT 编译这些代码
   - 首次启动直接执行机器码，无需 JIT

3. 工作流程
   开发阶段：生成 baseline-prof.txt
   ↓
   打包阶段：将 profile 打入 APK
   ↓
   安装阶段：ART 读取 profile，AOT 编译标记的代码
   ↓
   运行阶段：直接执行预编译的机器码

生成和使用：

1. 添加依赖
   implementation "androidx.profileinstaller:profileinstaller:1.3.1"
   baselineProfile project(':baselineprofile')

2. 编写 Profile 生成器
   @Test
   fun generateBaselineProfile() {
       rule.collect(packageName = "com.example.app") {
           pressHome()
           startActivityAndWait()
           // 模拟用户操作
       }
   }

3. 生成 Profile
   ./gradlew :app:generateBaselineProfile

4. 验证效果
   - 使用 Macrobenchmark 对比
   - CompilationMode.None vs CompilationMode.Partial

效果：
- 启动速度提升 30%+
- 首帧渲染时间减少 40%+
```

---

### 面试题 7：如何设计一个启动优化框架？需要考虑哪些因素？（字节/美团常问）

**答案要点：**

```
启动优化框架设计要点：

1. 任务抽象
   abstract class StartupTask {
       val name: String           // 任务名称
       val dependencies: List     // 依赖任务
       val runOnMainThread: Boolean // 是否主线程
       val needWait: Boolean      // 是否需要等待
       fun run()                  // 执行任务
   }

2. 任务调度
   - 拓扑排序处理依赖关系
   - 检测循环依赖
   - 主线程任务串行执行
   - 子线程任务并行执行

3. 线程管理
   - 使用线程池，避免创建过多线程
   - 线程数 = CPU 核心数
   - 主线程任务使用 Handler 调度

4. 等待机制
   - 支持等待指定任务完成
   - 使用 CountDownLatch 或协程

5. 监控统计
   - 记录每个任务的耗时
   - 支持上报到监控平台
   - 异常任务告警

6. 扩展性
   - 支持动态添加任务
   - 支持任务优先级
   - 支持条件执行

7. 调试支持
   - 打印任务执行顺序
   - 打印依赖关系图
   - 支持 Systrace 标签

框架对比：
- App Startup: Google 官方，简单易用，功能有限
- Alpha (阿里): 功能完善，支持锚点任务
- 自研框架: 可定制性强，维护成本高

选择建议：
- 简单场景: App Startup
- 复杂场景: 自研或 Alpha
```

---

### 面试题 8：启动优化的监控指标有哪些？如何建立启动监控体系？（OPPO/vivo 常问）

**答案要点：**

```
启动监控指标：

1. 核心指标
   - 冷启动耗时 (P50/P90/P99)
   - 温启动耗时
   - 热启动耗时
   - 首帧渲染时间
   - 完全加载时间 (reportFullyDrawn)

2. 细分指标
   - Application 初始化耗时
   - Activity 创建耗时
   - 布局 inflate 耗时
   - 各 SDK 初始化耗时
   - 首屏数据加载耗时

3. 辅助指标
   - 启动成功率
   - 启动 ANR 率
   - 启动 Crash 率
   - 启动过程内存峰值

监控体系建设：

1. 数据采集
   - 埋点 SDK 采集启动数据
   - 区分启动类型
   - 采集设备信息 (机型、系统版本、内存)

2. 数据上报
   - 采样上报 (避免数据量过大)
   - 异常全量上报
   - 支持实时和离线上报

3. 数据分析
   - 按机型、系统版本、地区分析
   - 计算 P50/P90/P99 分位值
   - 趋势分析和异常检测

4. 告警机制
   - 启动耗时超阈值告警
   - 启动成功率下降告警
   - 新版本对比告警

5. 可视化
   - 启动耗时趋势图
   - 各阶段耗时占比
   - 机型分布热力图

实践经验：
- 关注 P90/P99，而非平均值
- 按机型分层监控 (高端/中端/低端)
- 建立基线，监控版本间变化
```

---

### 面试题 9：多进程应用如何优化启动？（快手常问）

**答案要点：**

```
多进程启动优化：

1. 问题分析
   - 每个进程都会执行 Application.onCreate()
   - 非主进程可能执行不必要的初始化
   - 多进程同时启动会竞争 CPU 资源

2. 进程判断
   fun isMainProcess(): Boolean {
       return packageName == getProcessName()
   }
   
   fun getProcessName(): String? {
       // API 28+ 直接调用
       if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
           return Application.getProcessName()
       }
       // 低版本通过 ActivityManager 获取
       val am = getSystemService(ACTIVITY_SERVICE) as ActivityManager
       return am.runningAppProcesses?.find { 
           it.pid == Process.myPid() 
       }?.processName
   }

3. 按进程初始化
   override fun onCreate() {
       super.onCreate()
       
       when {
           isMainProcess() -> initMainProcess()
           processName.endsWith(":push") -> initPushProcess()
           processName.endsWith(":webview") -> initWebViewProcess()
           else -> initMinimal()
       }
   }

4. 优化策略
   - 主进程: 完整初始化
   - 推送进程: 只初始化网络和推送
   - WebView 进程: 只初始化 WebView 相关
   - 其他进程: 最小化初始化

5. ContentProvider 优化
   - 使用 tools:process 限制 CP 进程
   <provider
       android:name=".MyProvider"
       android:process=":main"
       tools:process=":main" />

6. 进程启动顺序优化
   - 主进程优先启动
   - 延迟启动非必要进程
   - 避免多进程同时初始化
```

---

### 面试题 10：请结合实际项目经验，描述一次完整的启动优化过程。（综合题）

**答案要点：**

```
启动优化实战案例：

1. 问题发现
   - 线上监控发现冷启动 P90 达到 4.5s
   - 用户反馈启动慢
   - 应用商店评分下降

2. 问题分析
   - 使用 Perfetto 抓取启动 Trace
   - 分析各阶段耗时
   - 发现问题:
     * Application.onCreate 耗时 1.8s
     * 15 个 ContentProvider
     * 主线程同步初始化 12 个 SDK
     * 首页布局层级 8 层

3. 优化方案
   
   阶段一: Application 优化 (收益 800ms)
   - 异步初始化 8 个 SDK
   - 懒加载 3 个非必要 SDK
   - 合并 ContentProvider (15 → 1)
   
   阶段二: Activity 优化 (收益 400ms)
   - 布局层级优化 (8 → 3)
   - 使用 ViewStub 延迟加载
   - 首屏数据预加载
   
   阶段三: 系统级优化 (收益 500ms)
   - 接入 Baseline Profile
   - 优化 SplashScreen
   - 多进程初始化优化

4. 效果验证
   - 冷启动 P90: 4.5s → 1.8s
   - 提升 60%
   - 用户好评率提升

5. 持续监控
   - 建立启动监控体系
   - 设置告警阈值
   - 版本对比分析

经验总结：
- 先测量，后优化
- 优先优化收益大的点
- 建立监控防止劣化
- 持续迭代优化
```

---

## 8. 总结

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      启动优化知识图谱                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  启动流程                                                               │
│  ├── Launcher → AMS → Zygote → App 进程                                │
│  ├── ActivityThread.main() → handleBindApplication()                   │
│  ├── Application.attachBaseContext() → ContentProvider → onCreate()    │
│  └── Activity.onCreate() → onStart() → onResume() → 首帧绘制           │
│                                                                         │
│  启动类型                                                               │
│  ├── 冷启动: 进程不存在，完整启动流程                                  │
│  ├── 温启动: 进程存在，Activity 重建                                   │
│  └── 热启动: 进程和 Activity 都存在                                    │
│                                                                         │
│  测量方法                                                               │
│  ├── adb shell am start -W                                             │
│  ├── Logcat Displayed 日志                                             │
│  ├── Systrace/Perfetto                                                 │
│  └── 自定义埋点                                                        │
│                                                                         │
│  优化手段                                                               │
│  ├── 异步初始化: 子线程执行耗时任务                                    │
│  ├── 懒加载: 延迟到首次使用                                            │
│  ├── 任务编排: App Startup / 自定义调度器                              │
│  ├── 布局优化: 减少层级、ViewStub、异步 inflate                        │
│  ├── Baseline Profile: 预编译热点代码                                  │
│  └── 多进程优化: 按进程选择性初始化                                    │
│                                                                         │
│  监控体系                                                               │
│  ├── 核心指标: 冷启动耗时 P50/P90/P99                                  │
│  ├── 细分指标: 各阶段耗时                                              │
│  └── 告警机制: 阈值告警、版本对比                                      │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

*文档版本: v1.0*  
*更新时间: 2025-01-01*  
*适用版本: Android W*
