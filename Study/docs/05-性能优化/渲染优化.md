# 渲染优化

## 1. 概述

渲染优化是 Android 性能优化中最重要的领域之一，直接影响用户体验。Android 系统采用 **VSYNC（垂直同步）** 机制，以 **60fps（16.67ms/帧）** 或 **120fps（8.33ms/帧）** 的频率刷新屏幕。当一帧的渲染时间超过这个阈值时，就会发生 **掉帧（Jank）**，用户会感知到卡顿。

### 1.1 渲染流程概览

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        Android 渲染流程 (Android W)                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐              │
│  │   Input  │───▶│ Animation│───▶│  Measure │───▶│  Layout  │              │
│  │  Events  │    │  Update  │    │          │    │          │              │
│  └──────────┘    └──────────┘    └──────────┘    └──────────┘              │
│       │                                               │                     │
│       │              UI Thread (Main Thread)          │                     │
│       ▼                                               ▼                     │
│  ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐              │
│  │   Draw   │───▶│  Record  │───▶│   Sync   │───▶│  Upload  │              │
│  │ Commands │    │ DisplayList   │  & Upload│    │ Textures │              │
│  └──────────┘    └──────────┘    └──────────┘    └──────────┘              │
│                                       │                                     │
│                                       ▼                                     │
│                              ┌──────────────┐                               │
│                              │ RenderThread │                               │
│                              │   (GPU渲染)   │                               │
│                              └──────────────┘                               │
│                                       │                                     │
│                                       ▼                                     │
│                              ┌──────────────┐                               │
│                              │SurfaceFlinger│                               │
│                              │   (合成显示)   │                               │
│                              └──────────────┘                               │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 1.2 关键性能指标

| 指标 | 说明 | 目标值 |
|------|------|--------|
| **帧率 (FPS)** | 每秒渲染帧数 | ≥60fps (高刷屏 ≥90/120fps) |
| **帧耗时** | 单帧渲染时间 | ≤16.67ms (60Hz) / ≤8.33ms (120Hz) |
| **掉帧率** | 掉帧占比 | <1% |
| **冻帧** | 单帧耗时>700ms | 0 |
| **P95/P99 帧耗时** | 95%/99%分位帧耗时 | 尽可能低 |

---

## 2. 卡顿原理

### 2.1 掉帧机制详解

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           VSYNC 与掉帧原理                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  VSYNC信号:  ▼         ▼         ▼         ▼         ▼         ▼           │
│             |         |         |         |         |         |            │
│  时间轴:    0ms      16.67ms   33.33ms   50ms     66.67ms   83.33ms        │
│             |         |         |         |         |         |            │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 正常情况:                                                           │   │
│  │  Frame1   Frame2   Frame3   Frame4   Frame5   Frame6               │   │
│  │  [====]   [====]   [====]   [====]   [====]   [====]               │   │
│  │  12ms     14ms     15ms     13ms     16ms     14ms                 │   │
│  │  ✓显示    ✓显示    ✓显示    ✓显示    ✓显示    ✓显示                │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 掉帧情况:                                                           │   │
│  │  Frame1   Frame2        Frame3   Frame4   Frame5                   │   │
│  │  [====]   [============][====]   [====]   [====]                   │   │
│  │  12ms     28ms(超时!)    15ms     13ms     16ms                    │   │
│  │  ✓显示    ✗掉帧         ✓显示    ✓显示    ✓显示                    │   │
│  │           (重复显示Frame1)                                          │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.2 主线程阻塞的常见原因

```java
/**
 * 主线程阻塞的典型场景分析
 */
public class MainThreadBlockingScenarios {
    
    // ❌ 场景1：主线程执行耗时计算
    public void badExample1() {
        // 在主线程进行复杂计算，导致UI无法响应
        for (int i = 0; i < 1000000; i++) {
            complexCalculation(i);
        }
    }
    
    // ❌ 场景2：主线程进行IO操作
    public void badExample2() {
        // SharedPreferences 的 commit() 是同步操作
        SharedPreferences.Editor editor = prefs.edit();
        editor.putString("key", "value");
        editor.commit(); // 阻塞主线程！应使用 apply()
    }
    
    // ❌ 场景3：主线程进行Binder调用
    public void badExample3() {
        // 获取系统服务可能涉及Binder调用
        PackageManager pm = context.getPackageManager();
        // 这个调用可能阻塞主线程
        List<ApplicationInfo> apps = pm.getInstalledApplications(0);
    }
    
    // ❌ 场景4：锁竞争
    private final Object lock = new Object();
    public void badExample4() {
        synchronized (lock) {
            // 如果其他线程长时间持有锁，主线程会被阻塞
            doSomething();
        }
    }
    
    // ❌ 场景5：布局层级过深
    // 深层嵌套的布局会导致 measure/layout 耗时增加
    // 时间复杂度可能达到 O(2^n)
}
```

### 2.3 卡顿分类

| 卡顿类型 | 帧耗时 | 用户感知 | 严重程度 |
|----------|--------|----------|----------|
| **轻微卡顿** | 16-32ms | 轻微不流畅 | 低 |
| **中度卡顿** | 32-100ms | 明显卡顿 | 中 |
| **严重卡顿** | 100-700ms | 严重卡顿 | 高 |
| **冻帧 (ANR风险)** | >700ms | 界面冻结 | 极高 |

---

## 3. 卡顿检测工具概述

### 3.1 工具对比

| 工具 | 类型 | 优势 | 劣势 | 适用场景 |
|------|------|------|------|----------|
| **Perfetto** | 系统级Trace | 全面、精确、可离线分析 | 学习曲线陡峭 | 深度分析、线上问题复现 |
| **Systrace** | 系统级Trace | 轻量、快速 | 功能较少，已被Perfetto取代 | 快速定位 |
| **Android Studio Profiler** | IDE集成 | 易用、实时 | 性能开销大 | 开发调试 |
| **Choreographer** | 代码埋点 | 可线上监控 | 只能检测掉帧，无法定位原因 | 线上监控 |
| **BlockCanary** | 开源库 | 简单易用 | 精度有限 | 快速集成 |
| **Matrix** | 腾讯开源 | 功能全面 | 接入成本高 | 大型项目 |

### 3.2 Choreographer 掉帧检测原理

```java
/**
 * 基于 Choreographer 的掉帧检测
 * 原理：监听每帧回调，计算帧间隔
 */
public class FrameMonitor {
    private static final long FRAME_INTERVAL_NANOS = 16666666L; // 16.67ms
    private long mLastFrameTimeNanos = 0;
    
    public void start() {
        Choreographer.getInstance().postFrameCallback(new Choreographer.FrameCallback() {
            @Override
            public void doFrame(long frameTimeNanos) {
                if (mLastFrameTimeNanos != 0) {
                    long jitterNanos = frameTimeNanos - mLastFrameTimeNanos;
                    int skippedFrames = (int) (jitterNanos / FRAME_INTERVAL_NANOS) - 1;
                    
                    if (skippedFrames > 0) {
                        Log.w("FrameMonitor", "Skipped " + skippedFrames + " frames! " +
                              "The application may be doing too much work on its main thread.");
                    }
                }
                mLastFrameTimeNanos = frameTimeNanos;
                // 继续监听下一帧
                Choreographer.getInstance().postFrameCallback(this);
            }
        });
    }
}
```

---

## 4. Perfetto 工具详解（重点）

### 4.1 Perfetto 简介

**Perfetto** 是 Google 推出的新一代系统级性能分析工具，从 Android 10 开始内置于系统中，用于替代传统的 Systrace。它具有以下特点：

- **全面性**：可以采集 CPU、内存、GPU、Binder、电量等多维度数据
- **高效性**：采用高效的二进制格式，对系统性能影响小
- **可扩展性**：支持自定义 TracePoint
- **强大的分析能力**：提供 SQL 查询接口，支持复杂分析

### 4.2 Perfetto 架构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         Perfetto 系统架构                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                        数据源 (Data Sources)                        │   │
│  ├─────────────────────────────────────────────────────────────────────┤   │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐  │   │
│  │  │  ftrace  │ │  atrace  │ │ heapprofd│ │  traced  │ │ 自定义SDK │  │   │
│  │  │ (内核)   │ │ (Android)│ │ (内存)   │ │ (进程)   │ │          │  │   │
│  │  └──────────┘ └──────────┘ └──────────┘ └──────────┘ └──────────┘  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│                                    ▼                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                      traced (Tracing Service)                       │   │
│  │  ┌──────────────────────────────────────────────────────────────┐  │   │
│  │  │  • 管理数据源                                                 │  │   │
│  │  │  • 协调数据采集                                               │  │   │
│  │  │  • 数据缓冲与写入                                             │  │   │
│  │  └──────────────────────────────────────────────────────────────┘  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│                                    ▼                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                      Trace 文件 (.perfetto-trace)                   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│                                    ▼                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                        分析工具                                     │   │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐              │   │
│  │  │ Perfetto UI  │  │ trace_processor│ │   SQL查询   │              │   │
│  │  │ (Web界面)    │  │ (命令行)      │  │             │              │   │
│  │  └──────────────┘  └──────────────┘  └──────────────┘              │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 4.3 Trace 抓取方法

#### 方法一：使用命令行（推荐用于自动化）

```bash
# 1. 基础抓取命令
adb shell perfetto \
  -c - --txt \
  -o /data/misc/perfetto-traces/trace.perfetto-trace \
<<EOF
buffers: {
    size_kb: 63488
    fill_policy: DISCARD
}
buffers: {
    size_kb: 2048
    fill_policy: DISCARD
}
data_sources: {
    config {
        name: "linux.ftrace"
        ftrace_config {
            ftrace_events: "sched/sched_switch"
            ftrace_events: "power/suspend_resume"
            ftrace_events: "sched/sched_wakeup"
            ftrace_events: "sched/sched_wakeup_new"
            ftrace_events: "sched/sched_waking"
            ftrace_events: "power/cpu_frequency"
            ftrace_events: "power/cpu_idle"
            ftrace_events: "sched/sched_process_exit"
            ftrace_events: "sched/sched_process_free"
            ftrace_events: "task/task_newtask"
            ftrace_events: "task/task_rename"
            atrace_categories: "gfx"
            atrace_categories: "input"
            atrace_categories: "view"
            atrace_categories: "wm"
            atrace_categories: "am"
            atrace_categories: "sm"
            atrace_categories: "camera"
            atrace_categories: "hal"
            atrace_categories: "res"
            atrace_categories: "dalvik"
            atrace_categories: "bionic"
            atrace_categories: "power"
            atrace_categories: "binder_driver"
            atrace_categories: "binder_lock"
            atrace_apps: "com.your.package"
        }
    }
}
data_sources: {
    config {
        name: "linux.process_stats"
        process_stats_config {
            scan_all_processes_on_start: true
        }
    }
}
duration_ms: 10000
EOF

# 2. 拉取 trace 文件
adb pull /data/misc/perfetto-traces/trace.perfetto-trace ./
```

#### 方法二：使用 Perfetto UI（推荐用于手动分析）

```
步骤：
1. 打开 https://ui.perfetto.dev/
2. 点击 "Record new trace"
3. 选择目标设备（需要 ADB 连接）
4. 配置采集选项：
   - CPU: Coarse CPU usage, Scheduling details
   - GPU: GPU frequency, GPU memory
   - Power: Battery drain, CPU frequency
   - Memory: Kernel meminfo, Process memory
   - Android apps & svcs: Atrace userspace annotations
5. 设置采集时长（建议 10-30 秒）
6. 点击 "Start Recording"
7. 在设备上复现问题
8. 停止录制，自动加载分析
```

#### 方法三：使用 Android Studio（最简单）

```
步骤：
1. 打开 Android Studio
2. View -> Tool Windows -> Profiler
3. 选择目标进程
4. 点击 CPU 区域
5. 选择 "System Trace"
6. 点击 Record 开始录制
7. 复现问题后停止
8. 可导出为 Perfetto 格式
```

#### 方法四：代码中添加自定义 Trace 点

```java
import android.os.Trace;

public class CustomTraceExample {
    
    public void doSomething() {
        // 开始 trace 区间
        Trace.beginSection("MyApp:doSomething");
        try {
            // 你的业务代码
            step1();
            
            Trace.beginSection("MyApp:step2");
            step2();
            Trace.endSection();
            
            step3();
        } finally {
            // 确保结束 trace 区间
            Trace.endSection();
        }
    }
    
    // Kotlin 扩展函数方式（更优雅）
    // inline fun <T> trace(sectionName: String, block: () -> T): T {
    //     Trace.beginSection(sectionName)
    //     return try {
    //         block()
    //     } finally {
    //         Trace.endSection()
    //     }
    // }
}
```

### 4.4 Perfetto UI 界面解读

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        Perfetto UI 界面布局                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │ 工具栏: [Open] [Record] [Query] [Metrics] [Info]        时间轴缩放控制 │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │                          时间轴 (Timeline)                            │  │
│  │  |----|----|----|----|----|----|----|----|----|----|----|----|       │  │
│  │  0s   1s   2s   3s   4s   5s   6s   7s   8s   9s   10s  11s          │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │ Track 面板 (可展开/折叠)                                              │  │
│  │                                                                       │  │
│  │ ▼ CPU Usage                                                          │  │
│  │   [████████░░░░████████░░░░████████░░░░████████░░░░]                 │  │
│  │                                                                       │  │
│  │ ▼ CPU 0-7 (各核心调度)                                               │  │
│  │   CPU 0: [app][sys][idle][app][sys]...                               │  │
│  │   CPU 1: [sys][app][idle][sys][app]...                               │  │
│  │   ...                                                                 │  │
│  │                                                                       │  │
│  │ ▼ Process: com.your.app (PID: 12345)                                 │  │
│  │   ▼ Main Thread (TID: 12345)                                         │  │
│  │     [Choreographer#doFrame][measure][layout][draw]                   │  │
│  │   ▼ RenderThread (TID: 12346)                                        │  │
│  │     [DrawFrame][syncFrameState][flush]                               │  │
│  │                                                                       │  │
│  │ ▼ SurfaceFlinger                                                     │  │
│  │   [onMessageReceived][composite][postComposition]                    │  │
│  │                                                                       │  │
│  │ ▼ Binder Transactions                                                │  │
│  │   [transaction][reply][transaction][reply]                           │  │
│  │                                                                       │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │ 详情面板 (选中某个 Slice 后显示)                                      │  │
│  │ Name: Choreographer#doFrame                                          │  │
│  │ Duration: 28.5ms                                                     │  │
│  │ Thread: main (12345)                                                 │  │
│  │ Process: com.your.app                                                │  │
│  │ Category: view                                                       │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 4.5 关键 Track 分析

#### 4.5.1 CPU Track 分析

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           CPU Track 详解                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  CPU Usage (整体使用率):                                                    │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 100%|    ████                    ████████                           │   │
│  │  75%|  ██████████              ████████████                         │   │
│  │  50%|████████████████        ████████████████                       │   │
│  │  25%|██████████████████████████████████████████                     │   │
│  │   0%|────────────────────────────────────────────                   │   │
│  │     0s        2s        4s        6s        8s       10s            │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  单核 CPU 调度 (CPU 0):                                                     │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ [  app  ][sys][ idle ][  app  ][binder][  app  ][ idle ][  app  ]  │   │
│  │  12345   234   ---     12345    567     12345    ---     12345      │   │
│  │                                                                     │   │
│  │ 颜色说明:                                                           │   │
│  │ ■ 绿色: 用户进程运行                                                │   │
│  │ ■ 蓝色: 系统进程运行                                                │   │
│  │ ■ 灰色: CPU 空闲                                                    │   │
│  │ ■ 橙色: 等待 IO                                                     │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  关注点:                                                                    │
│  1. 主线程是否频繁被调度出去（抢占）                                        │
│  2. 主线程是否长时间等待（显示为空白或其他颜色）                            │
│  3. CPU 使用率是否过高（可能导致发热降频）                                  │
│  4. 是否有大核小核调度不合理的情况                                          │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

**CPU 状态说明：**

| 状态 | 颜色 | 含义 | 分析要点 |
|------|------|------|----------|
| **Running** | 绿色 | 线程正在 CPU 上执行 | 正常状态 |
| **Runnable** | 蓝色 | 线程可运行但等待 CPU | 可能 CPU 繁忙 |
| **Sleeping** | 灰色 | 线程主动休眠 | 等待事件/锁 |
| **Uninterruptible Sleep** | 橙色 | 不可中断睡眠（通常是 IO） | 可能有 IO 阻塞 |
| **Blocked** | 红色 | 线程被阻塞 | 需要分析阻塞原因 |

#### 4.5.2 Binder Track 分析

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         Binder Transaction 分析                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  App 主线程 (Client):                                                       │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ [doFrame][binder transaction ─────────────────────────][继续执行]   │   │
│  │          │                                            │             │   │
│  │          │ 发起调用                          收到回复 │             │   │
│  │          ▼                                            ▲             │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  System Server (Server):                                                    │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ [其他工作]    [binder reply ──────────────────]    [其他工作]       │   │
│  │               │                              │                      │   │
│  │               │ 开始处理                完成 │                      │   │
│  │               ▼                              ▲                      │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  Binder 调用耗时分析:                                                       │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  总耗时 = 客户端等待时间                                            │   │
│  │        = 传输时间 + 服务端排队时间 + 服务端处理时间 + 返回传输时间   │   │
│  │                                                                     │   │
│  │  常见问题:                                                          │   │
│  │  1. 服务端处理慢 → 优化服务端逻辑或异步调用                         │   │
│  │  2. Binder 线程池满 → 服务端 Binder 线程不足                        │   │
│  │  3. 频繁小调用 → 合并请求或缓存结果                                 │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 4.5.3 SurfaceFlinger Track 分析

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      SurfaceFlinger Track 详解                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  VSYNC 信号:  ▼         ▼         ▼         ▼         ▼                    │
│              |         |         |         |         |                      │
│                                                                             │
│  App 进程:                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ [Choreographer#doFrame][      ][Choreographer#doFrame][      ]      │   │
│  │ [measure][layout][draw]        [measure][layout][draw]              │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│              │                              │                               │
│              ▼ 提交 Buffer                  ▼                               │
│  BufferQueue:                                                               │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ [dequeue][queue]              [dequeue][queue]                      │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│              │                              │                               │
│              ▼ 获取 Buffer                  ▼                               │
│  SurfaceFlinger:                                                            │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │      [onMessageReceived]           [onMessageReceived]              │   │
│  │      [latchBuffer]                 [latchBuffer]                    │   │
│  │      [composite]                   [composite]                      │   │
│  │      [postComposition]             [postComposition]                │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│              │                              │                               │
│              ▼ 送显                         ▼                               │
│  Display:                                                                   │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │      [Frame N]                     [Frame N+1]                      │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  关键指标:                                                                  │
│  • App 提交 Buffer 时间点是否在 VSYNC 之前                                  │
│  • SurfaceFlinger composite 耗时是否正常（通常 <5ms）                       │
│  • 是否有 Buffer 被丢弃（missed frame）                                     │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

**SurfaceFlinger 关键事件说明：**

| 事件 | 含义 | 正常耗时 |
|------|------|----------|
| **onMessageReceived** | 收到 VSYNC 信号 | <1ms |
| **latchBuffer** | 从 BufferQueue 获取 Buffer | <2ms |
| **composite** | 合成所有图层 | <5ms |
| **postComposition** | 提交到显示设备 | <2ms |

---

## 5. Perfetto 卡顿分析案例（重点）

### 案例1：主线程耗时方法导致掉帧

#### 问题描述
用户反馈列表滑动时出现明显卡顿，帧率从 60fps 下降到 30fps 左右。

#### Perfetto Trace 分析步骤

**Step 1: 定位掉帧位置**
```
在 Perfetto UI 中:
1. 找到 "Frames" track（如果有）或 "Choreographer#doFrame" 事件
2. 查找耗时超过 16.67ms 的帧
3. 红色/橙色标记的帧表示掉帧
```

**Step 2: 分析主线程 Track**
```
┌─────────────────────────────────────────────────────────────────────────────┐
│  主线程 Track 示意图                                                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  正常帧 (16ms):                                                             │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │[Choreographer#doFrame]                                             │    │
│  │  [input][animation][measure][layout][draw]                         │    │
│  │  2ms    1ms        3ms      2ms     4ms    = 12ms ✓                │    │
│  └────────────────────────────────────────────────────────────────────┘    │
│                                                                             │
│  问题帧 (45ms) - 掉帧!:                                                     │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │[Choreographer#doFrame ─────────────────────────────────────────]   │    │
│  │  [input][animation][measure][layout][draw]                         │    │
│  │  2ms    1ms        [parseJson ────────────────────]  4ms           │    │
│  │                    28ms (耗时操作!)                                 │    │
│  │                    = 45ms ✗ 掉帧                                   │    │
│  └────────────────────────────────────────────────────────────────────┘    │
│                                                                             │
│  问题定位: measure 阶段调用了 parseJson 方法，耗时 28ms                      │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

**Step 3: 使用 SQL 查询定位耗时方法**
```sql
-- 在 Perfetto UI 的 Query 面板中执行
-- 查找主线程中耗时超过 16ms 的 slice
SELECT 
    s.name,
    s.dur / 1000000.0 as duration_ms,
    s.ts / 1000000.0 as start_time_ms
FROM slice s
JOIN thread_track tt ON s.track_id = tt.id
JOIN thread t ON tt.utid = t.utid
JOIN process p ON t.upid = p.upid
WHERE p.name LIKE '%your.package%'
  AND t.name = 'main'
  AND s.dur > 16000000  -- 16ms in nanoseconds
ORDER BY s.dur DESC
LIMIT 20;
```

#### 问题定位
通过 Trace 分析发现，在 `RecyclerView.Adapter.onBindViewHolder()` 中调用了 `parseJson()` 方法，该方法在主线程解析大量 JSON 数据，导致帧耗时超过 16.67ms。

#### 解决方案

```java
// ❌ 错误写法：在 onBindViewHolder 中解析 JSON
@Override
public void onBindViewHolder(ViewHolder holder, int position) {
    String jsonStr = dataList.get(position);
    // 耗时操作！
    MyData data = parseJson(jsonStr);
    holder.bindData(data);
}

// ✅ 正确写法：提前在后台线程解析好数据
public class MyAdapter extends RecyclerView.Adapter<ViewHolder> {
    // 存储已解析的数据对象，而非原始 JSON
    private List<MyData> parsedDataList;
    
    // 在后台线程预处理数据
    public void setData(List<String> jsonList) {
        // 使用协程或线程池在后台解析
        CoroutineScope(Dispatchers.Default).launch {
            val parsed = jsonList.map { parseJson(it) }
            withContext(Dispatchers.Main) {
                parsedDataList = parsed
                notifyDataSetChanged()
            }
        }
    }
    
    @Override
    public void onBindViewHolder(ViewHolder holder, int position) {
        // 直接使用已解析的数据，无耗时操作
        holder.bindData(parsedDataList.get(position));
    }
}
```

---

### 案例2：Binder 调用阻塞

#### 问题描述
App 启动时首页加载缓慢，Trace 显示主线程有大量等待时间。

#### Perfetto Trace 分析步骤

**Step 1: 查看主线程状态**
```
┌─────────────────────────────────────────────────────────────────────────────┐
│  主线程状态分析                                                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  Thread State Track:                                                        │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │ [Running][  Sleeping (Binder)  ][Running][  Sleeping  ][Running]   │    │
│  │   5ms         35ms               8ms        42ms         10ms      │    │
│  │          ▲                              ▲                          │    │
│  │          │                              │                          │    │
│  │     Binder 调用阻塞              又一次 Binder 调用                 │    │
│  └────────────────────────────────────────────────────────────────────┘    │
│                                                                             │
│  Binder Transaction Track:                                                  │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │ [getInstalledPackages ─────────────────────────────────────────]   │    │
│  │  调用方: com.your.app (main thread)                                │    │
│  │  服务方: system_server (PackageManagerService)                     │    │
│  │  耗时: 35ms                                                        │    │
│  └────────────────────────────────────────────────────────────────────┘    │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

**Step 2: 分析 Binder 调用链**
```sql
-- 查找耗时的 Binder 调用
SELECT 
    s.name,
    s.dur / 1000000.0 as duration_ms,
    t.name as thread_name,
    p.name as process_name
FROM slice s
JOIN thread_track tt ON s.track_id = tt.id
JOIN thread t ON tt.utid = t.utid
JOIN process p ON t.upid = p.upid
WHERE s.name LIKE '%binder%' OR s.name LIKE '%Binder%'
ORDER BY s.dur DESC
LIMIT 20;
```

#### 问题定位
主线程在启动时调用了 `PackageManager.getInstalledApplications()`，这是一个同步 Binder 调用，需要等待 system_server 处理完成。当设备安装的应用较多时，这个调用可能耗时几十甚至上百毫秒。

#### 解决方案

```kotlin
// ❌ 错误写法：主线程同步调用
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        // 阻塞主线程！
        val apps = packageManager.getInstalledApplications(0)
        showAppList(apps)
    }
}

// ✅ 正确写法1：异步调用
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        
        // 先显示 loading 状态
        showLoading()
        
        // 异步获取数据
        lifecycleScope.launch {
            val apps = withContext(Dispatchers.IO) {
                packageManager.getInstalledApplications(0)
            }
            showAppList(apps)
        }
    }
}

// ✅ 正确写法2：使用缓存
object AppListCache {
    private var cachedApps: List<ApplicationInfo>? = null
    private var lastUpdateTime: Long = 0
    private const val CACHE_DURATION = 60_000L // 1分钟缓存
    
    suspend fun getInstalledApps(context: Context): List<ApplicationInfo> {
        val now = System.currentTimeMillis()
        if (cachedApps != null && now - lastUpdateTime < CACHE_DURATION) {
            return cachedApps!!
        }
        
        return withContext(Dispatchers.IO) {
            context.packageManager.getInstalledApplications(0).also {
                cachedApps = it
                lastUpdateTime = now
            }
        }
    }
}
```

---

### 案例3：锁竞争导致卡顿

#### 问题描述
App 在特定场景下出现间歇性卡顿，卡顿时间不固定，从几十毫秒到几百毫秒不等。

#### Perfetto Trace 分析步骤

**Step 1: 查看主线程阻塞状态**
```
┌─────────────────────────────────────────────────────────────────────────────┐
│  锁竞争导致的主线程阻塞                                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  主线程 (main):                                                             │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │ [Running][    Blocked (monitor)    ][Running]                      │    │
│  │   10ms          85ms                  15ms                         │    │
│  │           ▲                                                        │    │
│  │           │ 等待获取锁                                              │    │
│  │           │ monitor contention with thread: Worker-1               │    │
│  └────────────────────────────────────────────────────────────────────┘    │
│                                                                             │
│  工作线程 (Worker-1):                                                       │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │ [    synchronized(lock) { heavyWork() }    ][释放锁]               │    │
│  │                  85ms                                              │    │
│  │  ▲                                                                 │    │
│  │  │ 持有锁执行耗时操作                                               │    │
│  └────────────────────────────────────────────────────────────────────┘    │
│                                                                             │
│  关键信息:                                                                  │
│  • 主线程状态: Blocked (monitor)                                           │
│  • 阻塞原因: monitor contention                                            │
│  • 持锁线程: Worker-1                                                      │
│  • 阻塞时长: 85ms                                                          │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

**Step 2: 使用 SQL 查询锁竞争事件**
```sql
-- 查找 monitor contention 事件
SELECT 
    s.name,
    s.dur / 1000000.0 as duration_ms,
    EXTRACT_ARG(s.arg_set_id, 'blocking_thread') as blocking_thread,
    t.name as blocked_thread
FROM slice s
JOIN thread_track tt ON s.track_id = tt.id
JOIN thread t ON tt.utid = t.utid
WHERE s.name LIKE '%monitor%' OR s.name LIKE '%contention%'
ORDER BY s.dur DESC;
```

#### 问题定位
主线程和工作线程共用同一把锁，工作线程在持有锁的情况下执行耗时操作，导致主线程等待锁时被阻塞。

#### 解决方案

```kotlin
// ❌ 错误写法：主线程和工作线程竞争同一把锁
class DataManager {
    private val lock = Any()
    private var data: List<Item> = emptyList()
    
    // 工作线程调用，持锁时间长
    fun loadData() {
        synchronized(lock) {
            // 耗时操作
            data = fetchFromNetwork()
            processData()
            saveToDatabase()
        }
    }
    
    // 主线程调用，需要等待锁
    fun getData(): List<Item> {
        synchronized(lock) {
            return data.toList()
        }
    }
}

// ✅ 正确写法1：使用读写锁
class DataManager {
    private val rwLock = ReentrantReadWriteLock()
    private var data: List<Item> = emptyList()
    
    fun loadData() {
        // 只在写入时加写锁
        val newData = fetchFromNetwork() // 不持锁
        val processed = processData(newData) // 不持锁
        
        rwLock.writeLock().lock()
        try {
            data = processed // 快速写入
        } finally {
            rwLock.writeLock().unlock()
        }
        
        saveToDatabase(processed) // 不持锁
    }
    
    fun getData(): List<Item> {
        rwLock.readLock().lock()
        return try {
            data.toList()
        } finally {
            rwLock.readLock().unlock()
        }
    }
}

// ✅ 正确写法2：使用 CopyOnWrite
class DataManager {
    @Volatile
    private var data: List<Item> = emptyList()
    
    fun loadData() {
        val newData = fetchFromNetwork()
        val processed = processData(newData)
        data = processed // 原子替换引用，无需加锁
        saveToDatabase(processed)
    }
    
    fun getData(): List<Item> = data // 无需加锁
}

// ✅ 正确写法3：使用 Kotlin Flow
class DataManager {
    private val _dataFlow = MutableStateFlow<List<Item>>(emptyList())
    val dataFlow: StateFlow<List<Item>> = _dataFlow.asStateFlow()
    
    suspend fun loadData() {
        val newData = withContext(Dispatchers.IO) {
            fetchFromNetwork()
        }
        _dataFlow.value = newData // 线程安全
    }
}
```

---

### 案例4：GC 导致卡顿

#### 问题描述
App 在快速滑动列表时出现周期性卡顿，每隔几秒就会卡一下。

#### Perfetto Trace 分析步骤

**Step 1: 查看 GC 事件**
```
┌─────────────────────────────────────────────────────────────────────────────┐
│  GC 导致的卡顿分析                                                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  主线程 Track:                                                              │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │ [doFrame][doFrame][  GC pause  ][doFrame][doFrame][  GC pause  ]   │    │
│  │   14ms    15ms       12ms        16ms     14ms       15ms          │    │
│  │                  ▲                                ▲                │    │
│  │                  │                                │                │    │
│  │            GC 暂停主线程                    又一次 GC               │    │
│  └────────────────────────────────────────────────────────────────────┘    │
│                                                                             │
│  Heap 内存 Track:                                                           │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │  256MB ┤                    ╱╲                    ╱╲               │    │
│  │  192MB ┤              ╱╲  ╱    ╲  ╱╲        ╱╲  ╱    ╲             │    │
│  │  128MB ┤        ╱╲  ╱    ╲      ╲╱    ╲  ╱    ╲╱                   │    │
│  │   64MB ┤  ╱╲  ╱    ╲                      ╲╱                       │    │
│  │    0MB ┼──────────────────────────────────────────────────────    │    │
│  │        0s    2s    4s    6s    8s    10s   12s   14s   16s        │    │
│  │                  ▲           ▲                   ▲                │    │
│  │                  GC          GC                  GC               │    │
│  └────────────────────────────────────────────────────────────────────┘    │
│                                                                             │
│  GC 事件详情:                                                               │
│  • Type: concurrent copying GC                                             │
│  • Reason: Alloc                                                           │
│  • Freed: 15MB                                                             │
│  • Pause: 12ms                                                             │
│  • Total: 45ms                                                             │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

**Step 2: 分析内存分配热点**
```sql
-- 查找 GC 相关事件
SELECT 
    s.name,
    s.dur / 1000000.0 as duration_ms,
    EXTRACT_ARG(s.arg_set_id, 'freed_bytes') / 1024.0 / 1024.0 as freed_mb
FROM slice s
WHERE s.name LIKE '%GC%' OR s.name LIKE '%gc%'
ORDER BY s.dur DESC;
```

#### 问题定位
列表滑动时，每个 Item 的 `onBindViewHolder` 都创建了大量临时对象（如 String 拼接、临时 List、Bitmap 等），导致内存快速增长，触发频繁 GC。

#### 解决方案

```kotlin
// ❌ 错误写法：频繁创建临时对象
class MyAdapter : RecyclerView.Adapter<ViewHolder>() {
    
    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val item = items[position]
        
        // 每次都创建新的 StringBuilder
        val text = StringBuilder()
            .append(item.title)
            .append(" - ")
            .append(item.subtitle)
            .toString()
        
        // 每次都创建新的 List
        val tags = item.tags.map { "#$it" }
        
        // 每次都解码 Bitmap
        val bitmap = BitmapFactory.decodeResource(resources, item.iconRes)
        
        holder.bind(text, tags, bitmap)
    }
}

// ✅ 正确写法：复用对象，减少内存分配
class MyAdapter : RecyclerView.Adapter<ViewHolder>() {
    
    // 复用 StringBuilder
    private val stringBuilder = StringBuilder()
    
    // 使用对象池复用 Bitmap
    private val bitmapCache = LruCache<Int, Bitmap>(20)
    
    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val item = items[position]
        
        // 复用 StringBuilder
        stringBuilder.clear()
        val text = stringBuilder
            .append(item.title)
            .append(" - ")
            .append(item.subtitle)
            .toString()
        
        // 避免创建中间 List，直接设置
        holder.setTags(item.tags) // 内部直接遍历，不创建新 List
        
        // 使用缓存的 Bitmap
        val bitmap = bitmapCache.get(item.iconRes) ?: run {
            BitmapFactory.decodeResource(resources, item.iconRes).also {
                bitmapCache.put(item.iconRes, it)
            }
        }
        
        holder.bind(text, bitmap)
    }
    
    // 使用 ViewHolder 复用机制
    class ViewHolder(view: View) : RecyclerView.ViewHolder(view) {
        // 预先 findViewById，避免重复查找
        private val titleView: TextView = view.findViewById(R.id.title)
        private val tagsContainer: FlowLayout = view.findViewById(R.id.tags)
        
        // 复用 Tag View
        fun setTags(tags: List<String>) {
            // 复用已有的 TagView，而不是每次都创建新的
            for (i in tags.indices) {
                val tagView = if (i < tagsContainer.childCount) {
                    tagsContainer.getChildAt(i) as TextView
                } else {
                    TextView(itemView.context).also {
                        tagsContainer.addView(it)
                    }
                }
                tagView.text = "#${tags[i]}"
                tagView.visibility = View.VISIBLE
            }
            // 隐藏多余的 TagView
            for (i in tags.size until tagsContainer.childCount) {
                tagsContainer.getChildAt(i).visibility = View.GONE
            }
        }
    }
}
```

---

### 案例5：布局 Inflate 耗时

#### 问题描述
页面首次打开时明显卡顿，后续操作流畅。Trace 显示 `setContentView` 耗时过长。

#### Perfetto Trace 分析步骤

**Step 1: 定位 Inflate 耗时**
```
┌─────────────────────────────────────────────────────────────────────────────┐
│  布局 Inflate 耗时分析                                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  Activity.onCreate Track:                                                   │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │ [onCreate ─────────────────────────────────────────────────────]   │    │
│  │   [setContentView ─────────────────────────────────────────]       │    │
│  │     [inflate ─────────────────────────────────────────────]        │    │
│  │       [LayoutInflater.inflate]                                     │    │
│  │         [createViewFromTag] x 50                                   │    │
│  │           [Constructor] [Constructor] [Constructor] ...            │    │
│  │                                                                    │    │
│  │   总耗时: 180ms                                                    │    │
│  │   - inflate: 150ms                                                 │    │
│  │     - createViewFromTag: 120ms (50个View)                          │    │
│  │     - 其中 CustomView 构造: 80ms                                   │    │
│  └────────────────────────────────────────────────────────────────────┘    │
│                                                                             │
│  问题分析:                                                                  │
│  1. 布局层级过深 (50个View)                                                 │
│  2. CustomView 构造函数耗时 (80ms)                                          │
│  3. 可能存在不必要的嵌套                                                    │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

**Step 2: 分析布局层级**
```bash
# 使用 Layout Inspector 或命令行查看布局层级
adb shell dumpsys activity top | grep -A 100 "View Hierarchy"

# 或使用 Perfetto SQL 查询
```

```sql
-- 查找 inflate 相关耗时
SELECT 
    s.name,
    s.dur / 1000000.0 as duration_ms,
    s.depth
FROM slice s
WHERE s.name LIKE '%inflate%' OR s.name LIKE '%createView%'
ORDER BY s.dur DESC
LIMIT 30;
```

#### 问题定位
1. 布局 XML 层级过深，包含 50+ 个 View
2. 自定义 View 在构造函数中执行了耗时操作
3. 使用了多层嵌套的 LinearLayout

#### 解决方案

```kotlin
// ❌ 错误写法：构造函数中执行耗时操作
class CustomChartView @JvmOverloads constructor(
    context: Context,
    attrs: AttributeSet? = null
) : View(context, attrs) {
    
    private val data: List<DataPoint>
    
    init {
        // 在构造函数中加载数据 - 阻塞 inflate!
        data = loadDataFromDatabase()
        
        // 在构造函数中进行复杂计算
        calculateChartMetrics()
    }
}

// ✅ 正确写法：延迟初始化
class CustomChartView @JvmOverloads constructor(
    context: Context,
    attrs: AttributeSet? = null
) : View(context, attrs) {
    
    private var data: List<DataPoint>? = null
    private var isInitialized = false
    
    init {
        // 构造函数只做必要的初始化
        // 读取 XML 属性等轻量操作
    }
    
    // 延迟到首次绘制前初始化
    override fun onAttachedToWindow() {
        super.onAttachedToWindow()
        if (!isInitialized) {
            // 异步加载数据
            post {
                loadDataAsync()
            }
        }
    }
    
    private fun loadDataAsync() {
        CoroutineScope(Dispatchers.Main).launch {
            data = withContext(Dispatchers.IO) {
                loadDataFromDatabase()
            }
            isInitialized = true
            invalidate()
        }
    }
}
```

**布局优化方案：**

```xml
<!-- ❌ 错误写法：多层嵌套 -->
<LinearLayout android:orientation="vertical">
    <LinearLayout android:orientation="horizontal">
        <LinearLayout android:orientation="vertical">
            <TextView />
            <TextView />
        </LinearLayout>
        <ImageView />
    </LinearLayout>
    <LinearLayout android:orientation="horizontal">
        <!-- 更多嵌套... -->
    </LinearLayout>
</LinearLayout>

<!-- ✅ 正确写法：使用 ConstraintLayout 扁平化 -->
<androidx.constraintlayout.widget.ConstraintLayout>
    <TextView
        android:id="@+id/title"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintStart_toStartOf="parent" />
    
    <TextView
        android:id="@+id/subtitle"
        app:layout_constraintTop_toBottomOf="@id/title"
        app:layout_constraintStart_toStartOf="parent" />
    
    <ImageView
        android:id="@+id/icon"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintEnd_toEndOf="parent" />
    
    <!-- 所有 View 在同一层级 -->
</androidx.constraintlayout.widget.ConstraintLayout>
```

**使用 ViewStub 延迟加载：**

```xml
<!-- 使用 ViewStub 延迟加载不常用的布局 -->
<ViewStub
    android:id="@+id/stub_error_view"
    android:layout="@layout/error_view"
    android:inflatedId="@+id/error_view" />
```

```kotlin
// 需要时才 inflate
fun showError() {
    val stub = findViewById<ViewStub>(R.id.stub_error_view)
    stub?.inflate() // 首次调用时 inflate，后续调用返回 null
    
    // 或者
    val errorView = findViewById<View>(R.id.error_view)
    errorView?.visibility = View.VISIBLE
}
```

---

### 案例6：列表滑动卡顿分析

#### 问题描述
RecyclerView 列表在快速滑动时出现明显卡顿，尤其是包含图片的列表项。

#### Perfetto Trace 分析步骤

**Step 1: 整体帧率分析**
```
┌─────────────────────────────────────────────────────────────────────────────┐
│  列表滑动帧率分析                                                            │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  Frame Timeline:                                                            │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │ VSYNC: ▼    ▼    ▼    ▼    ▼    ▼    ▼    ▼    ▼    ▼    ▼        │    │
│  │                                                                    │    │
│  │ Frame: [F1] [F2] [F3] [  F4  ] [F5] [F6] [    F7    ] [F8] [F9]   │    │
│  │        14ms 15ms 16ms  32ms   15ms 14ms    48ms      16ms 15ms    │    │
│  │                       ▲                   ▲                        │    │
│  │                       掉1帧               掉2帧                    │    │
│  │                                                                    │    │
│  │ 帧率统计:                                                          │    │
│  │ - 平均帧率: 45fps                                                  │    │
│  │ - 掉帧率: 15%                                                      │    │
│  │ - P95 帧耗时: 35ms                                                 │    │
│  │ - 最大帧耗时: 48ms                                                 │    │
│  └────────────────────────────────────────────────────────────────────┘    │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

**Step 2: 分析单帧耗时分布**
```
┌─────────────────────────────────────────────────────────────────────────────┐
│  问题帧 (F7) 详细分析 - 总耗时 48ms                                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  主线程 Track:                                                              │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │ [Choreographer#doFrame ─────────────────────────────────────────]  │    │
│  │   [input]                                                    2ms   │    │
│  │   [animation]                                                1ms   │    │
│  │   [traversal ─────────────────────────────────────────────]       │    │
│  │     [measure ─────────────────────────────]              18ms     │    │
│  │       [onMeasure]                                                 │    │
│  │         [RecyclerView.onMeasure]                                  │    │
│  │           [LayoutManager.onLayoutChildren]                        │    │
│  │             [Adapter.onBindViewHolder] x 5                        │    │
│  │               [Glide.load] [Glide.load] [Glide.load]...          │    │
│  │     [layout ──────────────]                              8ms      │    │
│  │     [draw ─────────────────────────]                    15ms      │    │
│  │       [RenderNode.record]                                         │    │
│  │         [Canvas.drawBitmap] x 5                                   │    │
│  │                                                                    │    │
│  │   问题定位:                                                        │    │
│  │   1. onBindViewHolder 中 Glide.load 调用过多                       │    │
│  │   2. draw 阶段 Bitmap 绘制耗时                                     │    │
│  └────────────────────────────────────────────────────────────────────┘    │
│                                                                             │
│  RenderThread Track:                                                        │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │ [DrawFrame ─────────────────────────────────────────────────────]  │    │
│  │   [syncFrameState]                                          5ms   │    │
│  │   [flush ─────────────────────────────────────────────]    20ms   │    │
│  │     [upload texture] x 5  (上传大图到 GPU)                        │    │
│  │                                                                    │    │
│  │   问题: 大图上传 GPU 耗时过长                                      │    │
│  └────────────────────────────────────────────────────────────────────┘    │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

**Step 3: 使用 SQL 分析 onBindViewHolder 耗时**
```sql
-- 查找 onBindViewHolder 耗时
SELECT 
    s.name,
    s.dur / 1000000.0 as duration_ms,
    COUNT(*) as call_count,
    AVG(s.dur) / 1000000.0 as avg_duration_ms
FROM slice s
WHERE s.name LIKE '%onBindViewHolder%' 
   OR s.name LIKE '%bindViewHolder%'
GROUP BY s.name
ORDER BY AVG(s.dur) DESC;

-- 查找图片加载相关耗时
SELECT 
    s.name,
    s.dur / 1000000.0 as duration_ms
FROM slice s
WHERE s.name LIKE '%Glide%' 
   OR s.name LIKE '%decode%'
   OR s.name LIKE '%Bitmap%'
ORDER BY s.dur DESC
LIMIT 20;
```

#### 问题定位
1. `onBindViewHolder` 中同时加载多张大图
2. 图片尺寸过大，导致 GPU 上传耗时
3. 没有使用图片缓存，重复加载
4. 快速滑动时没有取消不可见 Item 的图片加载

#### 解决方案

```kotlin
// ✅ 完整的列表滑动优化方案
class OptimizedAdapter(
    private val imageLoader: ImageLoader
) : RecyclerView.Adapter<OptimizedAdapter.ViewHolder>() {
    
    // 1. 使用 DiffUtil 进行增量更新
    fun submitList(newList: List<Item>) {
        val diffResult = DiffUtil.calculateDiff(object : DiffUtil.Callback() {
            override fun getOldListSize() = items.size
            override fun getNewListSize() = newList.size
            override fun areItemsTheSame(oldPos: Int, newPos: Int) = 
                items[oldPos].id == newList[newPos].id
            override fun areContentsTheSame(oldPos: Int, newPos: Int) = 
                items[oldPos] == newList[newPos]
        })
        items = newList
        diffResult.dispatchUpdatesTo(this)
    }
    
    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        holder.bind(items[position])
    }
    
    // 2. 当 ViewHolder 被回收时取消图片加载
    override fun onViewRecycled(holder: ViewHolder) {
        holder.cancelImageLoad()
        super.onViewRecycled(holder)
    }
    
    class ViewHolder(view: View) : RecyclerView.ViewHolder(view) {
        private val imageView: ImageView = view.findViewById(R.id.image)
        private var currentLoadJob: Job? = null
        
        fun bind(item: Item) {
            // 3. 取消之前的加载任务
            cancelImageLoad()
            
            // 4. 先显示占位图
            imageView.setImageResource(R.drawable.placeholder)
            
            // 5. 使用合适的图片尺寸
            currentLoadJob = CoroutineScope(Dispatchers.Main).launch {
                imageLoader.load(item.imageUrl)
                    .resize(imageView.width, imageView.height) // 按需缩放
                    .centerCrop()
                    .into(imageView)
            }
        }
        
        fun cancelImageLoad() {
            currentLoadJob?.cancel()
            currentLoadJob = null
        }
    }
}

// 6. 滑动时暂停图片加载
recyclerView.addOnScrollListener(object : RecyclerView.OnScrollListener() {
    override fun onScrollStateChanged(recyclerView: RecyclerView, newState: Int) {
        when (newState) {
            RecyclerView.SCROLL_STATE_IDLE -> {
                // 停止滑动，恢复加载
                Glide.with(context).resumeRequests()
            }
            RecyclerView.SCROLL_STATE_DRAGGING,
            RecyclerView.SCROLL_STATE_SETTLING -> {
                // 滑动中，暂停加载
                Glide.with(context).pauseRequests()
            }
        }
    }
})

// 7. 使用 setHasFixedSize 优化
recyclerView.setHasFixedSize(true)

// 8. 设置合适的缓存大小
recyclerView.setItemViewCacheSize(20)

// 9. 预加载
val layoutManager = LinearLayoutManager(context)
recyclerView.layoutManager = layoutManager

// 使用 Paging 3 进行分页预加载
val pagingAdapter = MyPagingAdapter()
lifecycleScope.launch {
    viewModel.pagingFlow.collectLatest { pagingData ->
        pagingAdapter.submitData(pagingData)
    }
}
```

---

## 6. 布局优化

### 6.1 布局层级优化

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        布局层级与性能关系                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  Measure/Layout 时间复杂度:                                                 │
│                                                                             │
│  LinearLayout (weight):  O(2^n)  - 需要两次 measure                         │
│  RelativeLayout:         O(2^n)  - 需要两次 measure                         │
│  ConstraintLayout:       O(n)    - 单次 measure                             │
│  FrameLayout:            O(n)    - 单次 measure                             │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 层级深度与耗时关系 (示意)                                           │   │
│  │                                                                     │   │
│  │ 耗时(ms)                                                            │   │
│  │   50 ┤                                              ╱               │   │
│  │   40 ┤                                         ╱╱                   │   │
│  │   30 ┤                                    ╱╱                        │   │
│  │   20 ┤                              ╱╱                              │   │
│  │   10 ┤                    ╱╱╱╱╱╱╱                                   │   │
│  │    0 ┼────────────────────────────────────────────────────────     │   │
│  │      1    2    3    4    5    6    7    8    9   10   层级深度      │   │
│  │                                                                     │   │
│  │  建议: 布局层级控制在 10 层以内，最好不超过 5 层                     │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 6.2 使用 merge 减少层级

```xml
<!-- ❌ 不使用 merge：多一层 FrameLayout -->
<!-- custom_title_bar.xml -->
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="48dp">
    
    <ImageView android:id="@+id/back" ... />
    <TextView android:id="@+id/title" ... />
    <ImageView android:id="@+id/menu" ... />
</FrameLayout>

<!-- 使用时 -->
<FrameLayout>
    <include layout="@layout/custom_title_bar" />  <!-- 多了一层! -->
    <RecyclerView ... />
</FrameLayout>

<!-- ✅ 使用 merge：减少一层 -->
<!-- custom_title_bar.xml -->
<merge xmlns:android="http://schemas.android.com/apk/res/android">
    <ImageView android:id="@+id/back" ... />
    <TextView android:id="@+id/title" ... />
    <ImageView android:id="@+id/menu" ... />
</merge>

<!-- 使用时 -->
<FrameLayout>
    <include layout="@layout/custom_title_bar" />  <!-- 直接合并到父布局 -->
    <RecyclerView ... />
</FrameLayout>
```

### 6.3 使用 ViewStub 延迟加载

```kotlin
/**
 * ViewStub 使用场景：
 * 1. 错误页面
 * 2. 空数据页面
 * 3. 加载中页面
 * 4. 不常用的功能区域
 */
class ViewStubExample : AppCompatActivity() {
    
    private var errorView: View? = null
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        // ViewStub 不会被 inflate，节省启动时间
    }
    
    fun showError() {
        if (errorView == null) {
            // 首次调用时才 inflate
            val stub = findViewById<ViewStub>(R.id.stub_error)
            errorView = stub.inflate()
        }
        errorView?.visibility = View.VISIBLE
    }
    
    fun hideError() {
        errorView?.visibility = View.GONE
    }
}
```

```xml
<!-- activity_main.xml -->
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    
    <!-- 主内容 -->
    <RecyclerView
        android:id="@+id/recycler_view"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />
    
    <!-- 错误页面 - 使用 ViewStub 延迟加载 -->
    <ViewStub
        android:id="@+id/stub_error"
        android:layout="@layout/layout_error"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:inflatedId="@+id/error_view" />
    
    <!-- 空数据页面 -->
    <ViewStub
        android:id="@+id/stub_empty"
        android:layout="@layout/layout_empty"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:inflatedId="@+id/empty_view" />
        
</FrameLayout>
```

### 6.4 ConstraintLayout 优化

```xml
<!-- ConstraintLayout 最佳实践 -->
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="wrap_content">
    
    <!-- 1. 使用 Guideline 替代嵌套布局 -->
    <androidx.constraintlayout.widget.Guideline
        android:id="@+id/guideline"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        app:layout_constraintGuide_percent="0.3" />
    
    <!-- 2. 使用 Barrier 处理动态内容 -->
    <androidx.constraintlayout.widget.Barrier
        android:id="@+id/barrier"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        app:barrierDirection="end"
        app:constraint_referenced_ids="label1,label2,label3" />
    
    <!-- 3. 使用 Chain 替代 LinearLayout -->
    <TextView
        android:id="@+id/text1"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        app:layout_constraintHorizontal_chainStyle="spread"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toStartOf="@id/text2" />
    
    <TextView
        android:id="@+id/text2"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        app:layout_constraintStart_toEndOf="@id/text1"
        app:layout_constraintEnd_toStartOf="@id/text3" />
    
    <TextView
        android:id="@+id/text3"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        app:layout_constraintStart_toEndOf="@id/text2"
        app:layout_constraintEnd_toEndOf="parent" />
    
    <!-- 4. 使用 Group 统一控制可见性 -->
    <androidx.constraintlayout.widget.Group
        android:id="@+id/group_loading"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        app:constraint_referenced_ids="progress_bar,loading_text" />
        
</androidx.constraintlayout.widget.ConstraintLayout>
```

---

## 7. 过度绘制检测与优化

### 7.1 过度绘制原理

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          过度绘制 (Overdraw) 原理                            │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  定义: 同一像素在同一帧内被绘制多次                                          │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                                                                     │   │
│  │   Layer 3 (前景)    ████████████                                   │   │
│  │                     ████████████                                   │   │
│  │                                                                     │   │
│  │   Layer 2 (内容)    ████████████████████                           │   │
│  │                     ████████████████████                           │   │
│  │                                                                     │   │
│  │   Layer 1 (背景)    ████████████████████████████                   │   │
│  │                     ████████████████████████████                   │   │
│  │                                                                     │   │
│  │   重叠区域被绘制 3 次 = 2x 过度绘制                                 │   │
│  │                                                                     │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  过度绘制等级:                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  颜色      │  绘制次数  │  过度绘制  │  评价                        │   │
│  │───────────────────────────────────────────────────────────────────│   │
│  │  无色      │    1次     │    0x      │  ✓ 最佳                      │   │
│  │  蓝色      │    2次     │    1x      │  ✓ 可接受                    │   │
│  │  绿色      │    3次     │    2x      │  △ 需要优化                  │   │
│  │  粉色      │    4次     │    3x      │  ✗ 严重                      │   │
│  │  红色      │   ≥5次     │   ≥4x      │  ✗ 非常严重                  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 7.2 开启过度绘制检测

```bash
# 方法1：开发者选项
设置 -> 开发者选项 -> 调试 GPU 过度绘制 -> 显示过度绘制区域

# 方法2：ADB 命令
adb shell setprop debug.hwui.overdraw show
adb shell setprop debug.hwui.overdraw false  # 关闭
```

### 7.3 过度绘制优化方案

```kotlin
/**
 * 过度绘制优化策略
 */
class OverdrawOptimization {
    
    // 1. 移除不必要的背景
    fun removeUnnecessaryBackground() {
        // ❌ 错误：多层背景
        // Activity 主题设置了 windowBackground
        // 根布局又设置了 background
        // 子 View 又设置了 background
        
        // ✅ 正确：只保留必要的背景
        // 方案1：移除 Activity 的 windowBackground
        // 在 styles.xml 中：
        // <item name="android:windowBackground">@null</item>
        
        // 方案2：在代码中移除
        // window.setBackgroundDrawable(null)
    }
}
```

```xml
<!-- styles.xml -->
<style name="AppTheme.NoWindowBackground" parent="AppTheme">
    <!-- 移除窗口背景，减少一层绘制 -->
    <item name="android:windowBackground">@null</item>
</style>

<!-- 或者使用透明背景 -->
<style name="AppTheme.TransparentBackground" parent="AppTheme">
    <item name="android:windowBackground">@android:color/transparent</item>
</style>
```

```kotlin
// 2. 使用 clipRect 减少绘制区域
class OptimizedCustomView(context: Context) : View(context) {
    
    override fun onDraw(canvas: Canvas) {
        // ❌ 错误：绘制整个区域
        // canvas.drawRect(0f, 0f, width.toFloat(), height.toFloat(), paint)
        
        // ✅ 正确：只绘制可见区域
        canvas.save()
        canvas.clipRect(visibleRect)
        // 只绘制 visibleRect 内的内容
        drawContent(canvas)
        canvas.restore()
    }
}

// 3. 使用 canvas.quickReject() 跳过不可见区域
class OptimizedListView(context: Context) : View(context) {
    
    override fun onDraw(canvas: Canvas) {
        for (item in items) {
            val itemRect = item.bounds
            
            // 快速判断是否在可见区域外
            if (canvas.quickReject(itemRect, Canvas.EdgeType.BW)) {
                continue // 跳过不可见的 item
            }
            
            drawItem(canvas, item)
        }
    }
}
```

```xml
<!-- 4. 优化布局背景设置 -->

<!-- ❌ 错误：每层都设置背景 -->
<FrameLayout
    android:background="@color/white">
    
    <LinearLayout
        android:background="@color/white">
        
        <TextView
            android:background="@color/white"
            android:text="Hello" />
            
    </LinearLayout>
</FrameLayout>

<!-- ✅ 正确：只在最外层设置背景 -->
<FrameLayout
    android:background="@color/white">
    
    <LinearLayout>
        
        <TextView
            android:text="Hello" />
            
    </LinearLayout>
</FrameLayout>
```

---

## 8. 列表滑动优化

### 8.1 RecyclerView 优化清单

```kotlin
/**
 * RecyclerView 性能优化完整清单
 */
class RecyclerViewOptimization {
    
    fun setupOptimizedRecyclerView(recyclerView: RecyclerView) {
        
        // 1. 设置固定大小（如果 item 大小不变）
        recyclerView.setHasFixedSize(true)
        
        // 2. 设置缓存大小
        recyclerView.setItemViewCacheSize(20)
        
        // 3. 开启预取
        (recyclerView.layoutManager as? LinearLayoutManager)?.apply {
            initialPrefetchItemCount = 4
        }
        
        // 4. 共享 RecycledViewPool（多个 RecyclerView 场景）
        recyclerView.setRecycledViewPool(sharedPool)
        
        // 5. 禁用动画（如果不需要）
        recyclerView.itemAnimator = null
        
        // 6. 使用 DiffUtil
        // 见下方代码
        
        // 7. 滑动时暂停图片加载
        recyclerView.addOnScrollListener(scrollListener)
    }
    
    // DiffUtil 使用示例
    class MyDiffCallback(
        private val oldList: List<Item>,
        private val newList: List<Item>
    ) : DiffUtil.Callback() {
        
        override fun getOldListSize() = oldList.size
        override fun getNewListSize() = newList.size
        
        override fun areItemsTheSame(oldPos: Int, newPos: Int): Boolean {
            return oldList[oldPos].id == newList[newPos].id
        }
        
        override fun areContentsTheSame(oldPos: Int, newPos: Int): Boolean {
            return oldList[oldPos] == newList[newPos]
        }
        
        // 可选：返回变化的部分，用于局部更新
        override fun getChangePayload(oldPos: Int, newPos: Int): Any? {
            val old = oldList[oldPos]
            val new = newList[newPos]
            val diff = mutableMapOf<String, Any>()
            
            if (old.title != new.title) diff["title"] = new.title
            if (old.count != new.count) diff["count"] = new.count
            
            return if (diff.isNotEmpty()) diff else null
        }
    }
    
    // 在 Adapter 中使用 payload 进行局部更新
    override fun onBindViewHolder(
        holder: ViewHolder, 
        position: Int, 
        payloads: MutableList<Any>
    ) {
        if (payloads.isEmpty()) {
            // 全量更新
            onBindViewHolder(holder, position)
        } else {
            // 局部更新
            val diff = payloads[0] as? Map<*, *> ?: return
            diff["title"]?.let { holder.titleView.text = it as String }
            diff["count"]?.let { holder.countView.text = it.toString() }
        }
    }
}
```

### 8.2 ViewHolder 优化

```kotlin
/**
 * ViewHolder 优化最佳实践
 */
class OptimizedViewHolder(view: View) : RecyclerView.ViewHolder(view) {
    
    // 1. 使用 ViewBinding 替代 findViewById
    private val binding = ItemLayoutBinding.bind(view)
    
    // 2. 缓存 Context 引用
    private val context: Context = view.context
    
    // 3. 复用 Formatter
    private val numberFormat = NumberFormat.getInstance()
    
    // 4. 预创建 SpannableStringBuilder
    private val spannableBuilder = SpannableStringBuilder()
    
    fun bind(item: Item) {
        // 5. 避免在 bind 中创建对象
        binding.title.text = item.title
        
        // 6. 复用 SpannableStringBuilder
        spannableBuilder.clear()
        spannableBuilder.append(item.description)
        // 添加样式...
        binding.description.text = spannableBuilder
        
        // 7. 使用预创建的 Formatter
        binding.count.text = numberFormat.format(item.count)
        
        // 8. 图片加载优化
        loadImage(item.imageUrl)
    }
    
    private var imageLoadJob: Job? = null
    
    private fun loadImage(url: String) {
        // 取消之前的加载
        imageLoadJob?.cancel()
        
        // 设置占位图
        binding.image.setImageResource(R.drawable.placeholder)
        
        // 异步加载
        imageLoadJob = CoroutineScope(Dispatchers.Main).launch {
            Glide.with(context)
                .load(url)
                .override(binding.image.width, binding.image.height)
                .centerCrop()
                .into(binding.image)
        }
    }
    
    fun recycle() {
        imageLoadJob?.cancel()
        Glide.with(context).clear(binding.image)
    }
}
```

### 8.3 嵌套 RecyclerView 优化

```kotlin
/**
 * 嵌套 RecyclerView 优化（如：横向列表嵌套在纵向列表中）
 */
class NestedRecyclerViewOptimization {
    
    // 共享 RecycledViewPool
    private val sharedPool = RecyclerView.RecycledViewPool().apply {
        // 设置每种 ViewType 的最大缓存数
        setMaxRecycledViews(VIEW_TYPE_ITEM, 20)
    }
    
    class OuterAdapter : RecyclerView.Adapter<OuterViewHolder>() {
        
        override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): OuterViewHolder {
            val view = LayoutInflater.from(parent.context)
                .inflate(R.layout.item_outer, parent, false)
            return OuterViewHolder(view, sharedPool)
        }
    }
    
    class OuterViewHolder(
        view: View,
        private val sharedPool: RecyclerView.RecycledViewPool
    ) : RecyclerView.ViewHolder(view) {
        
        private val innerRecyclerView: RecyclerView = view.findViewById(R.id.inner_rv)
        
        init {
            // 1. 共享 RecycledViewPool
            innerRecyclerView.setRecycledViewPool(sharedPool)
            
            // 2. 设置固定大小
            innerRecyclerView.setHasFixedSize(true)
            
            // 3. 禁用嵌套滑动（如果不需要）
            innerRecyclerView.isNestedScrollingEnabled = false
            
            // 4. 设置预取数量
            (innerRecyclerView.layoutManager as? LinearLayoutManager)?.apply {
                initialPrefetchItemCount = 4
            }
        }
        
        fun bind(items: List<InnerItem>) {
            // 5. 复用 Adapter（如果数据结构相同）
            val adapter = innerRecyclerView.adapter as? InnerAdapter
                ?: InnerAdapter().also { innerRecyclerView.adapter = it }
            adapter.submitList(items)
        }
    }
}
```

---

## 9. 渲染优化实战总结

### 9.1 优化检查清单

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        渲染优化检查清单                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  □ 主线程优化                                                               │
│    ├─ □ 避免主线程 IO 操作                                                  │
│    ├─ □ 避免主线程网络请求                                                  │
│    ├─ □ 避免主线程复杂计算                                                  │
│    ├─ □ 避免主线程 JSON 解析                                                │
│    └─ □ 使用 StrictMode 检测违规                                            │
│                                                                             │
│  □ 布局优化                                                                 │
│    ├─ □ 布局层级 ≤ 10 层                                                    │
│    ├─ □ 使用 ConstraintLayout 扁平化布局                                    │
│    ├─ □ 使用 merge 减少层级                                                 │
│    ├─ □ 使用 ViewStub 延迟加载                                              │
│    └─ □ 避免过度使用 weight                                                 │
│                                                                             │
│  □ 过度绘制优化                                                             │
│    ├─ □ 移除不必要的背景                                                    │
│    ├─ □ 使用 clipRect 减少绘制区域                                          │
│    └─ □ 过度绘制区域 < 2x                                                   │
│                                                                             │
│  □ 列表优化                                                                 │
│    ├─ □ 使用 DiffUtil                                                       │
│    ├─ □ 设置 setHasFixedSize(true)                                          │
│    ├─ □ 合理设置缓存大小                                                    │
│    ├─ □ ViewHolder 中避免创建对象                                           │
│    ├─ □ 滑动时暂停图片加载                                                  │
│    └─ □ 使用 payload 局部更新                                               │
│                                                                             │
│  □ 图片优化                                                                 │
│    ├─ □ 按需加载合适尺寸                                                    │
│    ├─ □ 使用图片缓存                                                        │
│    ├─ □ 使用 WebP 格式                                                      │
│    └─ □ 大图分块加载                                                        │
│                                                                             │
│  □ 动画优化                                                                 │
│    ├─ □ 使用硬件加速                                                        │
│    ├─ □ 避免在动画中触发 layout                                             │
│    └─ □ 使用 Property Animation                                             │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 9.2 性能监控方案

```kotlin
/**
 * 线上性能监控方案
 */
object PerformanceMonitor {
    
    // 1. 帧率监控
    fun startFrameMonitor() {
        Choreographer.getInstance().postFrameCallback(object : Choreographer.FrameCallback {
            private var lastFrameTimeNanos = 0L
            private val frameIntervalNanos = 16666666L // 16.67ms
            
            override fun doFrame(frameTimeNanos: Long) {
                if (lastFrameTimeNanos != 0L) {
                    val jitterNanos = frameTimeNanos - lastFrameTimeNanos
                    val skippedFrames = (jitterNanos / frameIntervalNanos).toInt() - 1
                    
                    if (skippedFrames > 0) {
                        // 上报掉帧数据
                        reportJank(skippedFrames, jitterNanos / 1_000_000)
                    }
                }
                lastFrameTimeNanos = frameTimeNanos
                Choreographer.getInstance().postFrameCallback(this)
            }
        })
    }
    
    // 2. 主线程卡顿监控
    fun startBlockMonitor() {
        Looper.getMainLooper().setMessageLogging { log ->
            if (log.startsWith(">>>>> Dispatching")) {
                // 消息开始处理
                startTime = System.currentTimeMillis()
            } else if (log.startsWith("<<<<< Finished")) {
                // 消息处理完成
                val duration = System.currentTimeMillis() - startTime
                if (duration > 100) {
                    // 上报卡顿
                    reportBlock(duration)
                }
            }
        }
    }
    
    // 3. ANR 监控
    fun startANRMonitor() {
        val mainHandler = Handler(Looper.getMainLooper())
        val watchDog = Thread {
            while (true) {
                val latch = CountDownLatch(1)
                mainHandler.post { latch.countDown() }
                
                if (!latch.await(5, TimeUnit.SECONDS)) {
                    // 主线程 5 秒无响应，可能 ANR
                    reportPotentialANR()
                }
                
                Thread.sleep(1000)
            }
        }
        watchDog.start()
    }
}
```

---

## 10. 常见面试题

### 面试题1：请详细描述 Android 渲染机制，一帧是如何绘制到屏幕上的？

**答案要点：**

1. **VSYNC 信号触发**
   - 屏幕以固定频率刷新（60Hz = 16.67ms/帧，120Hz = 8.33ms/帧）
   - VSYNC 信号由 SurfaceFlinger 分发给 App

2. **Choreographer 调度**
   - 收到 VSYNC 后，Choreographer 依次执行：
   - Input → Animation → Traversal (Measure → Layout → Draw)

3. **UI 线程工作**
   - **Measure**：计算 View 大小，自顶向下递归
   - **Layout**：确定 View 位置，自顶向下递归
   - **Draw**：记录绘制命令到 DisplayList

4. **RenderThread 工作**
   - 同步 DisplayList
   - 执行 GPU 渲染
   - 将结果提交到 BufferQueue

5. **SurfaceFlinger 合成**
   - 从各 App 的 BufferQueue 获取 Buffer
   - 合成所有图层
   - 提交到显示设备

```
VSYNC → Choreographer → UI Thread (Measure/Layout/Draw) 
     → RenderThread (GPU渲染) → BufferQueue → SurfaceFlinger → Display
```

---

### 面试题2：如何使用 Perfetto 分析一个卡顿问题？请描述完整流程。

**答案要点：**

1. **抓取 Trace**
   ```bash
   # 使用命令行或 Perfetto UI
   adb shell perfetto -c config.pbtx -o /data/misc/perfetto-traces/trace
   ```

2. **定位掉帧**
   - 在 Perfetto UI 中找到目标进程
   - 查看 Choreographer#doFrame 事件
   - 找到耗时超过 16.67ms 的帧（红色/橙色标记）

3. **分析主线程**
   - 展开问题帧，查看各阶段耗时
   - 确定是 Input/Animation/Measure/Layout/Draw 哪个阶段耗时
   - 深入查看具体方法调用

4. **检查线程状态**
   - Running：正在执行
   - Runnable：等待 CPU
   - Sleeping：等待锁/Binder/IO

5. **分析 Binder 调用**
   - 查看是否有耗时的 Binder Transaction
   - 确认服务端处理时间

6. **使用 SQL 查询**
   ```sql
   SELECT name, dur/1000000.0 as ms FROM slice 
   WHERE dur > 16000000 ORDER BY dur DESC;
   ```

7. **定位根因并优化**
   - 主线程耗时方法 → 异步化
   - Binder 阻塞 → 缓存/异步
   - 锁竞争 → 优化锁粒度
   - GC → 减少对象创建

---

### 面试题3：RecyclerView 有哪些性能优化手段？请从原理层面解释。

**答案要点：**

1. **ViewHolder 复用机制**
   - 原理：通过 RecycledViewPool 缓存已创建的 ViewHolder
   - 优化：减少 View 创建和 findViewById 开销
   - 配置：`setItemViewCacheSize()`、`setRecycledViewPool()`

2. **DiffUtil 增量更新**
   - 原理：使用 Myers 差分算法计算最小更新集
   - 优化：避免 `notifyDataSetChanged()` 全量刷新
   - 进阶：使用 `getChangePayload()` 实现局部更新

3. **预取机制 (Prefetch)**
   - 原理：在 RenderThread 工作时，利用 UI 线程空闲预取下一屏数据
   - 配置：`initialPrefetchItemCount`

4. **setHasFixedSize(true)**
   - 原理：告知 RecyclerView item 大小不变，跳过 `requestLayout()`
   - 适用：item 高度固定的列表

5. **共享 RecycledViewPool**
   - 原理：多个 RecyclerView 共享 ViewHolder 缓存
   - 适用：嵌套 RecyclerView、ViewPager + RecyclerView

6. **禁用动画**
   - 原理：ItemAnimator 会延迟 ViewHolder 回收
   - 配置：`recyclerView.itemAnimator = null`

---

### 面试题4：什么是过度绘制？如何检测和优化？

**答案要点：**

1. **定义**
   - 同一像素在同一帧内被绘制多次
   - 浪费 GPU 资源，影响帧率

2. **检测方法**
   - 开发者选项 → 调试 GPU 过度绘制
   - 颜色含义：无色(1x) → 蓝(2x) → 绿(3x) → 粉(4x) → 红(≥5x)

3. **优化方案**
   - **移除不必要背景**：
     - 移除 windowBackground：`<item name="android:windowBackground">@null</item>`
     - 避免多层布局都设置背景
   
   - **使用 clipRect**：
     ```kotlin
     canvas.clipRect(visibleRect)
     // 只绘制可见区域
     ```
   
   - **使用 quickReject**：
     ```kotlin
     if (canvas.quickReject(rect)) continue
     ```
   
   - **自定义 View 优化**：
     - 重写 `hasOverlappingRendering()` 返回 false
     - 避免在 onDraw 中创建对象

4. **目标**
   - 大部分区域保持蓝色(2x)以下
   - 避免出现红色区域

---

### 面试题5：主线程卡顿的常见原因有哪些？如何监控和定位？

**答案要点：**

1. **常见原因**
   - **耗时计算**：复杂算法、大数据处理
   - **IO 操作**：文件读写、SharedPreferences.commit()
   - **Binder 调用**：系统服务调用、ContentProvider 查询
   - **锁竞争**：synchronized 等待
   - **GC**：频繁创建对象触发 GC
   - **布局问题**：层级过深、Inflate 耗时

2. **监控方案**
   - **Choreographer 监控**：
     ```kotlin
     Choreographer.getInstance().postFrameCallback { frameTimeNanos ->
         // 计算帧间隔，检测掉帧
     }
     ```
   
   - **Looper Printer 监控**：
     ```kotlin
     Looper.getMainLooper().setMessageLogging { log ->
         // 监控消息处理耗时
     }
     ```
   
   - **ANR WatchDog**：
     ```kotlin
     // 定时向主线程发送任务，检测响应时间
     ```

3. **定位工具**
   - **Perfetto/Systrace**：系统级 Trace，精确定位
   - **Android Studio Profiler**：实时分析
   - **StrictMode**：检测主线程违规操作
   - **BlockCanary/Matrix**：开源监控库

4. **优化原则**
   - 耗时操作异步化
   - 使用缓存减少重复计算
   - 优化锁粒度
   - 减少对象创建

---

### 面试题6：Choreographer 的工作原理是什么？它是如何协调渲染的？

**答案要点：**

1. **核心作用**
   - 协调 Input、Animation、Traversal 的执行时机
   - 确保在 VSYNC 信号到来时统一处理

2. **工作流程**
   ```
   VSYNC 信号 → FrameDisplayEventReceiver.onVsync()
            → Choreographer.doFrame()
            → 依次执行 Callback:
               1. CALLBACK_INPUT (输入事件)
               2. CALLBACK_ANIMATION (动画)
               3. CALLBACK_INSETS_ANIMATION
               4. CALLBACK_TRAVERSAL (measure/layout/draw)
               5. CALLBACK_COMMIT
   ```

3. **关键源码**
   ```java
   void doFrame(long frameTimeNanos, int frame) {
       // 计算掉帧数
       long jitterNanos = frameTimeNanos - mLastFrameTimeNanos;
       if (jitterNanos >= mFrameIntervalNanos) {
           long skippedFrames = jitterNanos / mFrameIntervalNanos;
           if (skippedFrames >= SKIPPED_FRAME_WARNING_LIMIT) {
               Log.i(TAG, "Skipped " + skippedFrames + " frames!");
           }
       }
       
       // 依次执行各类型 Callback
       doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);
       doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);
       doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);
   }
   ```

4. **掉帧检测原理**
   - 比较相邻两帧的时间戳
   - 如果间隔超过 mFrameIntervalNanos，说明掉帧

---

### 面试题7：布局优化有哪些手段？ConstraintLayout 为什么性能更好？

**答案要点：**

1. **布局优化手段**
   - **减少层级**：使用 ConstraintLayout 扁平化
   - **使用 merge**：减少 include 带来的额外层级
   - **使用 ViewStub**：延迟加载不常用布局
   - **避免过度使用 weight**：LinearLayout weight 需要两次 measure

2. **ConstraintLayout 优势**
   - **单次 measure**：使用约束求解算法，O(n) 复杂度
   - **扁平化布局**：一层实现复杂布局
   - **丰富的约束**：Guideline、Barrier、Chain、Group

3. **性能对比**
   | 布局 | Measure 复杂度 | 适用场景 |
   |------|---------------|----------|
   | FrameLayout | O(n) | 简单叠加 |
   | LinearLayout | O(n) / O(2n) | 线性排列 |
   | RelativeLayout | O(2n) | 相对定位 |
   | ConstraintLayout | O(n) | 复杂布局 |

4. **最佳实践**
   - 布局层级控制在 10 层以内
   - 复杂布局优先使用 ConstraintLayout
   - 简单布局使用 FrameLayout/LinearLayout
   - 使用 Layout Inspector 检查层级

---

### 面试题8：如何优化列表中的图片加载？滑动时如何避免卡顿？

**答案要点：**

1. **图片尺寸优化**
   ```kotlin
   Glide.with(context)
       .load(url)
       .override(targetWidth, targetHeight) // 按需缩放
       .centerCrop()
       .into(imageView)
   ```

2. **滑动时暂停加载**
   ```kotlin
   recyclerView.addOnScrollListener(object : OnScrollListener() {
       override fun onScrollStateChanged(rv: RecyclerView, state: Int) {
           when (state) {
               SCROLL_STATE_IDLE -> Glide.with(context).resumeRequests()
               else -> Glide.with(context).pauseRequests()
           }
       }
   })
   ```

3. **取消不可见 Item 的加载**
   ```kotlin
   override fun onViewRecycled(holder: ViewHolder) {
       Glide.with(context).clear(holder.imageView)
   }
   ```

4. **使用缓存**
   - 内存缓存：LruCache
   - 磁盘缓存：DiskLruCache
   - Glide/Coil 自带三级缓存

5. **图片格式优化**
   - 使用 WebP 格式（体积小 25-35%）
   - 使用 ARGB_8888 或 RGB_565 根据需求选择

6. **预加载**
   ```kotlin
   // 预加载下一屏图片
   Glide.with(context).load(nextUrl).preload()
   ```

---

## 11. 聊天记录

### 对话1
**用户请求**：创建 Android 高级开发面试知识库文件：docs/05-性能优化/渲染优化.md

**AI 回复**：已创建完整的渲染优化文档，包含以下内容：
1. 渲染机制概述和关键性能指标
2. 卡顿原理（掉帧、主线程阻塞）
3. 卡顿检测工具概述
4. **Perfetto 工具详解**（重点）
   - 架构和基础使用
   - 多种 Trace 抓取方法
   - UI 界面解读
   - 关键 Track 分析（CPU、Binder、SurfaceFlinger）
5. **Perfetto 卡顿分析案例**（6个详细案例）
   - 案例1：主线程耗时方法导致掉帧
   - 案例2：Binder 调用阻塞
   - 案例3：锁竞争导致卡顿
   - 案例4：GC 导致卡顿
   - 案例5：布局 Inflate 耗时
   - 案例6：列表滑动卡顿分析
6. 布局优化（层级优化、merge、ViewStub、ConstraintLayout）
7. 过度绘制检测与优化
8. 列表滑动优化
9. 渲染优化实战总结
10. 8道常见面试题（贴合字节、美团、快手、OPPO、vivo面试风格）
