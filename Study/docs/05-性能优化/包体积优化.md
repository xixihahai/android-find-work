# Android 包体积优化

## 1. 概述

包体积优化是 Android 性能优化的重要组成部分，直接影响用户下载转化率、安装成功率和应用启动速度。据 Google 统计，APK 每增加 6MB，安装转化率下降约 1%。对于大厂应用而言，包体积优化是一项持续性的技术工作。

### 1.1 为什么要做包体积优化

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        包体积优化的价值                                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  用户体验影响:                                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  1. 下载转化率: APK 每增加 6MB，转化率下降约 1%                 │   │
│  │  2. 安装成功率: 低端设备存储空间有限                            │   │
│  │  3. 启动速度: 包体积影响解压、dex 加载时间                      │   │
│  │  4. 运行内存: 资源文件影响运行时内存占用                        │   │
│  │  5. 更新成本: 增量更新包大小与全量包相关                        │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  业务价值:                                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  ✓ 提升用户获取效率                                             │   │
│  │  ✓ 降低 CDN 带宽成本                                            │   │
│  │  ✓ 提升应用商店排名                                             │   │
│  │  ✓ 满足应用商店上架要求 (Google Play 150MB 限制)                │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 1.2 包体积优化全景图

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        包体积优化全景图                                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                         APK 组成                                │   │
│  │  ┌──────────┬──────────┬──────────┬──────────┬──────────┐      │   │
│  │  │  DEX     │ Resources│  Assets  │   So库   │  其他    │      │   │
│  │  │ (代码)   │ (资源)   │ (原始)   │ (Native) │ (签名等) │      │   │
│  │  │  ~30%    │  ~40%    │  ~10%    │  ~15%    │  ~5%     │      │   │
│  │  └──────────┴──────────┴──────────┴──────────┴──────────┘      │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  优化手段:                                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  代码优化          资源优化          So库优化        分发优化   │   │
│  │  ├─ R8/ProGuard   ├─ 图片压缩       ├─ ABI 精简     ├─ 动态下发│   │
│  │  ├─ 代码裁剪      ├─ 资源混淆       ├─ So 压缩      ├─ App Bundle│  │
│  │  ├─ 去除调试信息  ├─ 无用资源移除   ├─ So 动态加载  ├─ Split APK│   │
│  │  └─ 字节码优化    └─ 资源合并       └─ 符号裁剪     └─ 按需下载│   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```


## 2. 核心原理

### 2.1 APK 结构分析

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          APK 文件结构                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  APK 本质是 ZIP 压缩包，包含以下内容:                                   │
│                                                                         │
│  app.apk                                                                │
│  ├── AndroidManifest.xml      # 清单文件 (二进制 XML)                   │
│  ├── classes.dex              # 主 DEX 文件 (Java/Kotlin 字节码)        │
│  ├── classes2.dex             # 分包 DEX (MultiDex)                     │
│  ├── classes3.dex             # ...                                     │
│  ├── resources.arsc           # 编译后的资源索引表                      │
│  ├── res/                     # 资源文件目录                            │
│  │   ├── drawable-xxhdpi/     # 图片资源                                │
│  │   ├── layout/              # 布局文件 (二进制 XML)                   │
│  │   ├── values/              # 值资源 (已编译到 resources.arsc)        │
│  │   └── ...                                                            │
│  ├── assets/                  # 原始资源文件 (不编译)                   │
│  ├── lib/                     # Native 库目录                           │
│  │   ├── armeabi-v7a/         # 32位 ARM                                │
│  │   ├── arm64-v8a/           # 64位 ARM                                │
│  │   ├── x86/                 # 32位 x86                                │
│  │   └── x86_64/              # 64位 x86                                │
│  ├── META-INF/                # 签名信息                                │
│  │   ├── MANIFEST.MF          # 清单摘要                                │
│  │   ├── CERT.SF              # 签名文件                                │
│  │   └── CERT.RSA             # 证书文件                                │
│  └── kotlin/                  # Kotlin 元数据 (可移除)                  │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

#### APK 分析工具

```bash
# 1. 使用 Android Studio APK Analyzer
# Build -> Analyze APK -> 选择 APK 文件

# 2. 使用 apkanalyzer 命令行工具
# 查看 APK 大小分布
apkanalyzer apk summary app-release.apk

# 查看 DEX 文件信息
apkanalyzer dex packages app-release.apk

# 查看资源文件
apkanalyzer resources packages app-release.apk

# 比较两个 APK 的差异
apkanalyzer apk compare old.apk new.apk

# 3. 使用 bundletool 分析 AAB
bundletool build-apks --bundle=app.aab --output=app.apks
bundletool get-size total --apks=app.apks
```

```kotlin
/**
 * APK 分析工具类
 * 用于分析 APK 各部分大小占比
 */
object ApkAnalyzer {
    
    /**
     * 分析 APK 文件结构
     * @param apkPath APK 文件路径
     * @return 各部分大小信息
     */
    fun analyzeApk(apkPath: String): ApkSizeInfo {
        val zipFile = ZipFile(File(apkPath))
        val sizeInfo = ApkSizeInfo()
        
        zipFile.entries().asSequence().forEach { entry ->
            val size = entry.compressedSize  // 压缩后大小
            val name = entry.name
            
            when {
                // DEX 文件
                name.endsWith(".dex") -> {
                    sizeInfo.dexSize += size
                    sizeInfo.dexFiles.add(DexFileInfo(name, size, entry.size))
                }
                // 资源文件
                name.startsWith("res/") -> {
                    sizeInfo.resSize += size
                    categorizeResource(name, size, sizeInfo)
                }
                // Assets 文件
                name.startsWith("assets/") -> {
                    sizeInfo.assetsSize += size
                }
                // Native 库
                name.startsWith("lib/") -> {
                    sizeInfo.nativeSize += size
                    categorizeNativeLib(name, size, sizeInfo)
                }
                // 资源索引表
                name == "resources.arsc" -> {
                    sizeInfo.arscSize = size
                }
                // 其他文件
                else -> {
                    sizeInfo.otherSize += size
                }
            }
        }
        
        sizeInfo.totalSize = File(apkPath).length()
        return sizeInfo
    }
    
    /**
     * 分类资源文件
     */
    private fun categorizeResource(name: String, size: Long, info: ApkSizeInfo) {
        when {
            name.contains("drawable") || name.contains("mipmap") -> {
                info.drawableSize += size
            }
            name.contains("layout") -> {
                info.layoutSize += size
            }
            name.contains("raw") -> {
                info.rawSize += size
            }
        }
    }
    
    /**
     * 分类 Native 库
     */
    private fun categorizeNativeLib(name: String, size: Long, info: ApkSizeInfo) {
        val abi = name.split("/").getOrNull(1) ?: return
        info.nativeLibsByAbi.getOrPut(abi) { mutableListOf() }
            .add(NativeLibInfo(name, size))
    }
}

/**
 * APK 大小信息
 */
data class ApkSizeInfo(
    var totalSize: Long = 0,
    var dexSize: Long = 0,
    var resSize: Long = 0,
    var assetsSize: Long = 0,
    var nativeSize: Long = 0,
    var arscSize: Long = 0,
    var otherSize: Long = 0,
    var drawableSize: Long = 0,
    var layoutSize: Long = 0,
    var rawSize: Long = 0,
    val dexFiles: MutableList<DexFileInfo> = mutableListOf(),
    val nativeLibsByAbi: MutableMap<String, MutableList<NativeLibInfo>> = mutableMapOf()
) {
    /**
     * 打印分析报告
     */
    fun printReport() {
        println("""
            |========== APK Size Report ==========
            |Total Size: ${formatSize(totalSize)}
            |
            |DEX Files: ${formatSize(dexSize)} (${percentage(dexSize)}%)
            |Resources: ${formatSize(resSize)} (${percentage(resSize)}%)
            |  - Drawables: ${formatSize(drawableSize)}
            |  - Layouts: ${formatSize(layoutSize)}
            |  - Raw: ${formatSize(rawSize)}
            |Assets: ${formatSize(assetsSize)} (${percentage(assetsSize)}%)
            |Native Libs: ${formatSize(nativeSize)} (${percentage(nativeSize)}%)
            |resources.arsc: ${formatSize(arscSize)} (${percentage(arscSize)}%)
            |Other: ${formatSize(otherSize)} (${percentage(otherSize)}%)
            |=====================================
        """.trimMargin())
    }
    
    private fun formatSize(bytes: Long): String {
        return when {
            bytes >= 1024 * 1024 -> "%.2f MB".format(bytes / 1024.0 / 1024.0)
            bytes >= 1024 -> "%.2f KB".format(bytes / 1024.0)
            else -> "$bytes B"
        }
    }
    
    private fun percentage(size: Long): String {
        return "%.1f".format(size * 100.0 / totalSize)
    }
}
```


### 2.2 代码混淆与压缩 (R8/ProGuard)

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      R8/ProGuard 工作原理                                │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  R8 是 Android 官方推荐的代码优化工具，替代 ProGuard:                   │
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  Java/Kotlin 源码                                               │   │
│  │        │                                                        │   │
│  │        ↓                                                        │   │
│  │  ┌──────────┐                                                   │   │
│  │  │  编译器  │ → .class 文件                                     │   │
│  │  └──────────┘                                                   │   │
│  │        │                                                        │   │
│  │        ↓                                                        │   │
│  │  ┌──────────────────────────────────────────────────────────┐  │   │
│  │  │                      R8 编译器                            │  │   │
│  │  │  ┌────────────┐  ┌────────────┐  ┌────────────┐         │  │   │
│  │  │  │   Shrink   │→ │  Optimize  │→ │  Obfuscate │         │  │   │
│  │  │  │  (代码裁剪) │  │ (代码优化) │  │  (代码混淆) │         │  │   │
│  │  │  └────────────┘  └────────────┘  └────────────┘         │  │   │
│  │  │                        │                                 │  │   │
│  │  │                        ↓                                 │  │   │
│  │  │               ┌────────────┐                             │  │   │
│  │  │               │  Dex 转换  │                             │  │   │
│  │  │               └────────────┘                             │  │   │
│  │  └──────────────────────────────────────────────────────────┘  │   │
│  │        │                                                        │   │
│  │        ↓                                                        │   │
│  │  classes.dex (优化后的 DEX 文件)                                │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  R8 vs ProGuard:                                                        │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  R8 优势:                                                       │   │
│  │  ✓ 编译速度更快 (单次处理，无需先生成 .class)                   │   │
│  │  ✓ 更好的代码优化效果                                           │   │
│  │  ✓ 更小的输出体积                                               │   │
│  │  ✓ 与 D8 集成，减少中间步骤                                     │   │
│  │  ✓ 支持 Kotlin 特定优化                                         │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

#### R8 配置详解

```groovy
// build.gradle (Module)
android {
    buildTypes {
        release {
            // 启用代码压缩
            minifyEnabled true
            // 启用资源压缩
            shrinkResources true
            // ProGuard 规则文件
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'),
                    'proguard-rules.pro'
        }
    }
    
    // R8 全模式 (更激进的优化)
    buildFeatures {
        // 启用 R8 全模式
    }
}

// gradle.properties
// 启用 R8 全模式 (Android Gradle Plugin 8.0+ 默认开启)
android.enableR8.fullMode=true
```

```proguard
# proguard-rules.pro - 混淆规则配置

#==================== 基础配置 ====================#

# 保留行号信息，用于崩溃堆栈还原
-keepattributes SourceFile,LineNumberTable

# 保留注解
-keepattributes *Annotation*

# 保留泛型签名 (反射需要)
-keepattributes Signature

# 保留异常信息
-keepattributes Exceptions

#==================== 代码保留规则 ====================#

# 保留四大组件
-keep public class * extends android.app.Activity
-keep public class * extends android.app.Service
-keep public class * extends android.content.BroadcastReceiver
-keep public class * extends android.content.ContentProvider

# 保留 Application
-keep public class * extends android.app.Application

# 保留 View 构造函数 (XML 反射创建)
-keepclasseswithmembers class * {
    public <init>(android.content.Context, android.util.AttributeSet);
    public <init>(android.content.Context, android.util.AttributeSet, int);
}

# 保留 Parcelable 实现
-keepclassmembers class * implements android.os.Parcelable {
    public static final ** CREATOR;
}

# 保留 Serializable 实现
-keepclassmembers class * implements java.io.Serializable {
    static final long serialVersionUID;
    private static final java.io.ObjectStreamField[] serialPersistentFields;
    private void writeObject(java.io.ObjectOutputStream);
    private void readObject(java.io.ObjectInputStream);
    java.lang.Object writeReplace();
    java.lang.Object readResolve();
}

# 保留枚举
-keepclassmembers enum * {
    public static **[] values();
    public static ** valueOf(java.lang.String);
}

# 保留 native 方法
-keepclasseswithmembernames class * {
    native <methods>;
}

#==================== 第三方库规则 ====================#

# Gson
-keepattributes Signature
-keepattributes *Annotation*
-dontwarn sun.misc.**
-keep class com.google.gson.** { *; }
-keep class * extends com.google.gson.TypeAdapter
-keep class * implements com.google.gson.TypeAdapterFactory
-keep class * implements com.google.gson.JsonSerializer
-keep class * implements com.google.gson.JsonDeserializer
# 保留数据类 (Gson 反射需要)
-keepclassmembers,allowobfuscation class * {
    @com.google.gson.annotations.SerializedName <fields>;
}

# Retrofit
-dontwarn retrofit2.**
-keep class retrofit2.** { *; }
-keepattributes Signature
-keepattributes Exceptions
-keepclasseswithmembers class * {
    @retrofit2.http.* <methods>;
}

# OkHttp
-dontwarn okhttp3.**
-dontwarn okio.**
-keep class okhttp3.** { *; }
-keep interface okhttp3.** { *; }

# Kotlin Coroutines
-keepnames class kotlinx.coroutines.internal.MainDispatcherFactory {}
-keepnames class kotlinx.coroutines.CoroutineExceptionHandler {}
-keepclassmembers class kotlinx.coroutines.** {
    volatile <fields>;
}

# Kotlin Serialization
-keepattributes *Annotation*, InnerClasses
-dontnote kotlinx.serialization.AnnotationsKt
-keepclassmembers @kotlinx.serialization.Serializable class ** {
    *** Companion;
    *** INSTANCE;
    kotlinx.serialization.KSerializer serializer(...);
}

#==================== 优化配置 ====================#

# 优化次数
-optimizationpasses 5

# 混淆时采用的算法
-optimizations !code/simplification/arithmetic,!field/*,!class/merging/*

# 不跳过非公共库的类成员
-dontskipnonpubliclibraryclassmembers

# 打印混淆映射
-printmapping mapping.txt

# 打印移除的代码
-printusage unused.txt

# 打印配置
-printconfiguration configuration.txt
```


#### R8 高级优化技巧

```kotlin
/**
 * R8 优化效果分析工具
 * 用于对比优化前后的代码变化
 */
object R8OptimizationAnalyzer {
    
    /**
     * 分析 mapping.txt 文件
     * 了解混淆映射关系
     */
    fun analyzeMappingFile(mappingPath: String): MappingInfo {
        val mappingInfo = MappingInfo()
        var currentClass: String? = null
        
        File(mappingPath).forEachLine { line ->
            when {
                // 类映射: com.example.MyClass -> a.a.a:
                line.contains(" -> ") && line.endsWith(":") -> {
                    val parts = line.removeSuffix(":").split(" -> ")
                    currentClass = parts[0]
                    mappingInfo.classMappings[parts[0]] = parts[1]
                }
                // 方法/字段映射
                line.startsWith("    ") && currentClass != null -> {
                    val trimmed = line.trim()
                    if (trimmed.contains(" -> ")) {
                        val parts = trimmed.split(" -> ")
                        mappingInfo.memberMappings["$currentClass.${parts[0]}"] = parts[1]
                    }
                }
            }
        }
        
        return mappingInfo
    }
    
    /**
     * 分析 unused.txt 文件
     * 了解被移除的代码
     */
    fun analyzeUnusedCode(unusedPath: String): UnusedCodeInfo {
        val unusedInfo = UnusedCodeInfo()
        
        File(unusedPath).forEachLine { line ->
            when {
                !line.startsWith("    ") -> {
                    // 类级别
                    unusedInfo.unusedClasses.add(line.trim())
                }
                else -> {
                    // 成员级别
                    unusedInfo.unusedMembers.add(line.trim())
                }
            }
        }
        
        return unusedInfo
    }
}

/**
 * 堆栈还原工具
 * 将混淆后的堆栈还原为原始代码位置
 */
object StackTraceDeobfuscator {
    
    /**
     * 使用 retrace 工具还原堆栈
     * @param mappingFile mapping.txt 文件路径
     * @param stackTrace 混淆后的堆栈信息
     * @return 还原后的堆栈信息
     */
    fun deobfuscate(mappingFile: String, stackTrace: String): String {
        // 使用 R8 retrace 工具
        // 命令: java -jar retrace.jar mapping.txt stacktrace.txt
        
        val process = ProcessBuilder(
            "java", "-jar", 
            "${System.getenv("ANDROID_HOME")}/cmdline-tools/latest/lib/retrace.jar",
            mappingFile
        ).start()
        
        process.outputStream.bufferedWriter().use { writer ->
            writer.write(stackTrace)
        }
        
        return process.inputStream.bufferedReader().readText()
    }
    
    /**
     * 解析混淆后的类名
     */
    fun deobfuscateClassName(
        obfuscatedName: String, 
        mappings: Map<String, String>
    ): String {
        // 反向查找映射
        return mappings.entries
            .find { it.value == obfuscatedName }
            ?.key ?: obfuscatedName
    }
}
```

### 2.3 资源优化

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          资源优化策略                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  资源优化方向:                                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  1. 图片压缩                                                    │   │
│  │     ├─ PNG → WebP 转换 (无损压缩节省 25%+)                      │   │
│  │     ├─ 使用 VectorDrawable 替代位图                             │   │
│  │     ├─ 使用 TinyPNG/pngquant 压缩                               │   │
│  │     └─ 按需提供不同分辨率资源                                   │   │
│  │                                                                 │   │
│  │  2. 资源混淆                                                    │   │
│  │     ├─ 资源名称混淆 (res/drawable/icon → res/a/a)               │   │
│  │     ├─ 资源路径扁平化                                           │   │
│  │     └─ 使用 AndResGuard 工具                                    │   │
│  │                                                                 │   │
│  │  3. 无用资源移除                                                │   │
│  │     ├─ shrinkResources 自动移除                                 │   │
│  │     ├─ Lint 检查未使用资源                                      │   │
│  │     └─ 手动清理冗余资源                                         │   │
│  │                                                                 │   │
│  │  4. 资源合并                                                    │   │
│  │     ├─ 合并重复资源                                             │   │
│  │     ├─ 使用 Shape 替代图片                                      │   │
│  │     └─ 使用 Tint 着色复用图片                                   │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

#### 图片压缩配置

```groovy
// build.gradle (Module)
android {
    defaultConfig {
        // 只保留指定语言资源
        resConfigs "zh", "en"
    }
    
    buildTypes {
        release {
            // 启用资源压缩
            shrinkResources true
            minifyEnabled true
        }
    }
    
    // 图片压缩配置 (AGP 4.1+)
    androidResources {
        // 不压缩的文件类型
        noCompress 'webp', 'png'
    }
}

// 使用 WebP 格式
android {
    buildFeatures {
        // 自动将 PNG/JPEG 转换为 WebP
    }
}
```

```kotlin
/**
 * 图片资源优化工具
 */
object ImageOptimizer {
    
    /**
     * 批量将 PNG 转换为 WebP
     * @param resDir 资源目录
     * @param quality WebP 质量 (0-100)
     */
    fun convertPngToWebP(resDir: File, quality: Int = 80) {
        resDir.walkTopDown()
            .filter { it.extension == "png" }
            .forEach { pngFile ->
                val webpFile = File(pngFile.parent, "${pngFile.nameWithoutExtension}.webp")
                
                // 使用 cwebp 工具转换
                val process = ProcessBuilder(
                    "cwebp",
                    "-q", quality.toString(),
                    pngFile.absolutePath,
                    "-o", webpFile.absolutePath
                ).start()
                
                if (process.waitFor() == 0) {
                    val savedSize = pngFile.length() - webpFile.length()
                    println("Converted ${pngFile.name}: saved ${savedSize / 1024}KB")
                    
                    // 如果 WebP 更小，删除原 PNG
                    if (webpFile.length() < pngFile.length()) {
                        pngFile.delete()
                    } else {
                        webpFile.delete()
                    }
                }
            }
    }
    
    /**
     * 检查图片资源是否可以使用 VectorDrawable 替代
     */
    fun suggestVectorReplacement(resDir: File): List<ImageSuggestion> {
        val suggestions = mutableListOf<ImageSuggestion>()
        
        resDir.walkTopDown()
            .filter { it.extension in listOf("png", "jpg", "webp") }
            .forEach { imageFile ->
                val bitmap = BitmapFactory.decodeFile(imageFile.absolutePath)
                
                // 简单图标通常可以用 Vector 替代
                if (bitmap != null) {
                    val isSimpleIcon = bitmap.width <= 96 && 
                                       bitmap.height <= 96 &&
                                       countColors(bitmap) <= 8
                    
                    if (isSimpleIcon) {
                        suggestions.add(ImageSuggestion(
                            file = imageFile,
                            reason = "Small icon with few colors, consider VectorDrawable",
                            potentialSaving = imageFile.length()
                        ))
                    }
                }
            }
        
        return suggestions
    }
    
    /**
     * 统计图片颜色数量
     */
    private fun countColors(bitmap: Bitmap): Int {
        val colors = mutableSetOf<Int>()
        for (x in 0 until bitmap.width) {
            for (y in 0 until bitmap.height) {
                colors.add(bitmap.getPixel(x, y))
            }
        }
        return colors.size
    }
}
```

#### 资源混淆 (AndResGuard)

```groovy
// build.gradle (Project)
buildscript {
    dependencies {
        classpath 'com.tencent.mm:AndResGuard-gradle-plugin:1.2.21'
    }
}

// build.gradle (Module)
apply plugin: 'AndResGuard'

andResGuard {
    // 混淆后的资源路径
    mappingFile = file("./resource_mapping.txt")
    
    // 使用 7zip 压缩
    use7zip = true
    useSign = true
    
    // 保持不混淆的资源
    whiteList = [
        // 第三方 SDK 需要的资源
        "R.drawable.icon",
        "R.string.app_name",
        // 通过 getIdentifier 动态获取的资源
        "R.drawable.notification_*",
        "R.layout.custom_*"
    ]
    
    // 压缩配置
    compressFilePattern = [
        "*.png",
        "*.jpg",
        "*.jpeg",
        "*.gif",
        "resources.arsc"
    ]
    
    // 7zip 路径
    sevenzip {
        artifact = 'com.tencent.mm:SevenZip:1.2.21'
    }
    
    // 签名配置
    finalApkBackupPath = "${project.rootDir}/final.apk"
    
    // 资源路径扁平化
    // res/drawable-xxhdpi/icon.png → res/a/a.png
    fixedResName = "arg"
    
    // 合并重复资源
    mergeDuplicatedRes = true
}
```


#### 无用资源检测与移除

```kotlin
/**
 * 无用资源检测工具
 * 配合 Lint 和 shrinkResources 使用
 */
object UnusedResourceDetector {
    
    /**
     * 使用 Lint 检测未使用的资源
     */
    fun runLintCheck(projectDir: File): List<UnusedResource> {
        // 执行 Lint 检查
        // ./gradlew lint
        
        val lintResultFile = File(projectDir, "app/build/reports/lint-results.xml")
        return parseLintResult(lintResultFile)
    }
    
    /**
     * 解析 Lint 结果
     */
    private fun parseLintResult(resultFile: File): List<UnusedResource> {
        val unusedResources = mutableListOf<UnusedResource>()
        
        // 解析 XML 结果，查找 UnusedResources 类型的 issue
        val document = DocumentBuilderFactory.newInstance()
            .newDocumentBuilder()
            .parse(resultFile)
        
        val issues = document.getElementsByTagName("issue")
        for (i in 0 until issues.length) {
            val issue = issues.item(i)
            if (issue.attributes.getNamedItem("id")?.nodeValue == "UnusedResources") {
                val location = issue.childNodes.item(1)
                unusedResources.add(UnusedResource(
                    name = issue.attributes.getNamedItem("message")?.nodeValue ?: "",
                    file = location?.attributes?.getNamedItem("file")?.nodeValue ?: ""
                ))
            }
        }
        
        return unusedResources
    }
    
    /**
     * 配置 shrinkResources 的 keep 规则
     * res/raw/keep.xml
     */
    fun generateKeepXml(resourcesToKeep: List<String>): String {
        return buildString {
            appendLine("<?xml version=\"1.0\" encoding=\"utf-8\"?>")
            appendLine("<resources xmlns:tools=\"http://schemas.android.com/tools\"")
            append("    tools:keep=\"")
            append(resourcesToKeep.joinToString(","))
            appendLine("\"")
            appendLine("    tools:shrinkMode=\"strict\" />")
        }
    }
}

/**
 * res/raw/keep.xml 示例
 * 用于控制资源压缩行为
 */
/*
<?xml version="1.0" encoding="utf-8"?>
<resources xmlns:tools="http://schemas.android.com/tools"
    tools:keep="@layout/activity_*,@drawable/icon_*"
    tools:discard="@layout/unused_*"
    tools:shrinkMode="strict" />
*/
```

### 2.4 So 库优化

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          So 库优化策略                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  So 库通常占 APK 体积的 15-30%，优化空间很大:                           │
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  1. ABI 精简                                                    │   │
│  │     ├─ 只保留必要的 ABI (arm64-v8a 覆盖 99%+ 设备)              │   │
│  │     ├─ 使用 abiFilters 配置                                     │   │
│  │     └─ 通过 App Bundle 按设备分发                               │   │
│  │                                                                 │   │
│  │  2. So 压缩                                                     │   │
│  │     ├─ 使用 UPX 压缩 (需注意兼容性)                             │   │
│  │     ├─ 自定义压缩方案                                           │   │
│  │     └─ 运行时解压加载                                           │   │
│  │                                                                 │   │
│  │  3. So 动态下发                                                 │   │
│  │     ├─ 首次启动下载                                             │   │
│  │     ├─ 按需下载                                                 │   │
│  │     └─ 插件化加载                                               │   │
│  │                                                                 │   │
│  │  4. 符号裁剪                                                    │   │
│  │     ├─ strip 移除调试符号                                       │   │
│  │     ├─ -fvisibility=hidden 隐藏符号                             │   │
│  │     └─ version script 控制导出符号                              │   │
│  │                                                                 │   │
│  │  5. 编译优化                                                    │   │
│  │     ├─ -Oz 优化体积                                             │   │
│  │     ├─ LTO (Link Time Optimization)                             │   │
│  │     └─ 移除未使用代码                                           │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ABI 覆盖率 (2024年数据):                                               │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  arm64-v8a  : 85%+  (主流 64 位设备)                            │   │
│  │  armeabi-v7a: 10%+  (老旧 32 位设备)                            │   │
│  │  x86_64     : 3%    (模拟器、Chromebook)                        │   │
│  │  x86        : 1%    (老旧模拟器)                                │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

#### ABI 配置

```groovy
// build.gradle (Module)
android {
    defaultConfig {
        ndk {
            // 方案1: 只保留 arm64-v8a (推荐，覆盖 85%+ 设备)
            abiFilters 'arm64-v8a'
            
            // 方案2: 保留 arm64-v8a 和 armeabi-v7a (覆盖 99%+ 设备)
            // abiFilters 'arm64-v8a', 'armeabi-v7a'
        }
    }
    
    // 按 ABI 分包
    splits {
        abi {
            enable true
            reset()
            include 'arm64-v8a', 'armeabi-v7a'
            universalApk false  // 不生成通用包
        }
    }
    
    // 为不同 ABI 设置不同的 versionCode
    applicationVariants.all { variant ->
        variant.outputs.each { output ->
            def abiFilter = output.getFilter(OutputFile.ABI)
            def abiVersionCode = abiCodes.get(abiFilter) ?: 0
            output.versionCodeOverride = variant.versionCode * 10 + abiVersionCode
        }
    }
}

// ABI 版本码映射
ext.abiCodes = [
    'armeabi-v7a': 1,
    'arm64-v8a': 2,
    'x86': 3,
    'x86_64': 4
]
```

#### So 动态加载

```kotlin
/**
 * So 库动态加载管理器
 * 支持从网络下载和本地加载
 */
class SoLibraryManager(
    private val context: Context,
    private val downloadUrl: String
) {
    
    companion object {
        private const val TAG = "SoLibraryManager"
        private const val SO_DIR = "so_libs"
    }
    
    // So 库存储目录
    private val soDir: File by lazy {
        File(context.filesDir, SO_DIR).apply { mkdirs() }
    }
    
    /**
     * 加载 So 库
     * @param libName 库名称 (不含 lib 前缀和 .so 后缀)
     * @return 是否加载成功
     */
    suspend fun loadLibrary(libName: String): Boolean {
        return withContext(Dispatchers.IO) {
            try {
                // 1. 尝试从 APK 内加载
                if (tryLoadFromApk(libName)) {
                    Log.d(TAG, "Loaded $libName from APK")
                    return@withContext true
                }
                
                // 2. 尝试从本地缓存加载
                val localSoFile = getSoFile(libName)
                if (localSoFile.exists() && tryLoadFromFile(localSoFile)) {
                    Log.d(TAG, "Loaded $libName from local cache")
                    return@withContext true
                }
                
                // 3. 从网络下载
                if (downloadSoLibrary(libName)) {
                    if (tryLoadFromFile(localSoFile)) {
                        Log.d(TAG, "Loaded $libName from downloaded file")
                        return@withContext true
                    }
                }
                
                Log.e(TAG, "Failed to load $libName")
                false
            } catch (e: Exception) {
                Log.e(TAG, "Error loading $libName", e)
                false
            }
        }
    }
    
    /**
     * 尝试从 APK 内加载
     */
    private fun tryLoadFromApk(libName: String): Boolean {
        return try {
            System.loadLibrary(libName)
            true
        } catch (e: UnsatisfiedLinkError) {
            false
        }
    }
    
    /**
     * 从文件加载 So 库
     */
    private fun tryLoadFromFile(soFile: File): Boolean {
        return try {
            System.load(soFile.absolutePath)
            true
        } catch (e: UnsatisfiedLinkError) {
            Log.e(TAG, "Failed to load from file: ${soFile.absolutePath}", e)
            false
        }
    }
    
    /**
     * 下载 So 库
     */
    private suspend fun downloadSoLibrary(libName: String): Boolean {
        val abi = Build.SUPPORTED_ABIS.firstOrNull() ?: return false
        val soFileName = "lib${libName}.so"
        val url = "$downloadUrl/$abi/$soFileName"
        
        return try {
            val soFile = getSoFile(libName)
            val tempFile = File(soDir, "$soFileName.tmp")
            
            // 下载到临时文件
            URL(url).openStream().use { input ->
                tempFile.outputStream().use { output ->
                    input.copyTo(output)
                }
            }
            
            // 验证文件完整性 (可添加 MD5 校验)
            if (tempFile.length() > 0) {
                tempFile.renameTo(soFile)
                // 设置可执行权限
                soFile.setExecutable(true, false)
                true
            } else {
                tempFile.delete()
                false
            }
        } catch (e: Exception) {
            Log.e(TAG, "Download failed: $url", e)
            false
        }
    }
    
    /**
     * 获取 So 文件路径
     */
    private fun getSoFile(libName: String): File {
        val abi = Build.SUPPORTED_ABIS.firstOrNull() ?: "arm64-v8a"
        val abiDir = File(soDir, abi).apply { mkdirs() }
        return File(abiDir, "lib${libName}.so")
    }
    
    /**
     * 预下载 So 库
     */
    suspend fun preloadLibraries(libNames: List<String>) {
        withContext(Dispatchers.IO) {
            libNames.forEach { libName ->
                val soFile = getSoFile(libName)
                if (!soFile.exists()) {
                    downloadSoLibrary(libName)
                }
            }
        }
    }
    
    /**
     * 清理缓存
     */
    fun clearCache() {
        soDir.deleteRecursively()
    }
}

/**
 * So 库压缩加载器
 * 支持加载压缩的 So 库
 */
class CompressedSoLoader(private val context: Context) {
    
    private val cacheDir: File by lazy {
        File(context.cacheDir, "compressed_so").apply { mkdirs() }
    }
    
    /**
     * 加载压缩的 So 库
     * @param compressedSoPath 压缩文件路径 (assets 或文件系统)
     * @param libName 库名称
     */
    fun loadCompressedLibrary(compressedSoPath: String, libName: String): Boolean {
        return try {
            val soFile = File(cacheDir, "lib${libName}.so")
            
            // 解压 So 文件
            if (!soFile.exists()) {
                decompressSo(compressedSoPath, soFile)
            }
            
            // 加载
            System.load(soFile.absolutePath)
            true
        } catch (e: Exception) {
            Log.e("CompressedSoLoader", "Failed to load compressed so", e)
            false
        }
    }
    
    /**
     * 解压 So 文件
     */
    private fun decompressSo(compressedPath: String, outputFile: File) {
        // 使用 ZSTD 或 LZ4 解压
        context.assets.open(compressedPath).use { input ->
            // ZstdInputStream(input).use { zstdInput ->
            GZIPInputStream(input).use { gzipInput ->
                outputFile.outputStream().use { output ->
                    gzipInput.copyTo(output)
                }
            }
        }
        outputFile.setExecutable(true, false)
    }
}
```


### 2.5 动态下发

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          动态下发架构                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  动态下发是大厂常用的包体积优化手段，将非核心功能延迟加载:              │
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │                    ┌─────────────────┐                          │   │
│  │                    │    基础 APK     │                          │   │
│  │                    │  (核心功能)     │                          │   │
│  │                    │   ~30MB         │                          │   │
│  │                    └────────┬────────┘                          │   │
│  │                             │                                   │   │
│  │              ┌──────────────┼──────────────┐                    │   │
│  │              │              │              │                    │   │
│  │              ↓              ↓              ↓                    │   │
│  │      ┌─────────────┐ ┌─────────────┐ ┌─────────────┐           │   │
│  │      │  功能模块A  │ │  功能模块B  │ │  So 库包    │           │   │
│  │      │  (按需下载) │ │  (按需下载) │ │  (按需下载) │           │   │
│  │      │   ~5MB      │ │   ~3MB      │ │   ~10MB     │           │   │
│  │      └─────────────┘ └─────────────┘ └─────────────┘           │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  动态下发内容:                                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  1. 功能插件: 非核心业务模块 (如直播、小游戏)                   │   │
│  │  2. So 库: 大型 Native 库 (如 FFmpeg、OpenCV)                   │   │
│  │  3. 资源包: 皮肤、主题、字体                                    │   │
│  │  4. 热修复补丁: Bug 修复                                        │   │
│  │  5. 配置文件: 动态配置、AB 测试                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

```kotlin
/**
 * 动态下发管理器
 * 管理功能模块的下载、安装和加载
 */
class DynamicDeliveryManager(
    private val context: Context,
    private val serverUrl: String
) {
    
    companion object {
        private const val TAG = "DynamicDelivery"
        private const val MODULES_DIR = "dynamic_modules"
        private const val MANIFEST_FILE = "modules_manifest.json"
    }
    
    private val modulesDir: File by lazy {
        File(context.filesDir, MODULES_DIR).apply { mkdirs() }
    }
    
    private val gson = Gson()
    private val downloadingModules = ConcurrentHashMap<String, Job>()
    
    /**
     * 模块信息
     */
    data class ModuleInfo(
        val name: String,
        val version: Int,
        val downloadUrl: String,
        val md5: String,
        val size: Long,
        val dependencies: List<String> = emptyList()
    )
    
    /**
     * 模块状态
     */
    sealed class ModuleState {
        object NotInstalled : ModuleState()
        data class Downloading(val progress: Float) : ModuleState()
        object Installed : ModuleState()
        object Loading : ModuleState()
        object Loaded : ModuleState()
        data class Error(val message: String) : ModuleState()
    }
    
    // 模块状态 Flow
    private val _moduleStates = MutableStateFlow<Map<String, ModuleState>>(emptyMap())
    val moduleStates: StateFlow<Map<String, ModuleState>> = _moduleStates.asStateFlow()
    
    /**
     * 检查模块是否已安装
     */
    fun isModuleInstalled(moduleName: String): Boolean {
        val moduleDir = File(modulesDir, moduleName)
        val manifestFile = File(moduleDir, MANIFEST_FILE)
        return moduleDir.exists() && manifestFile.exists()
    }
    
    /**
     * 下载并安装模块
     */
    suspend fun installModule(moduleInfo: ModuleInfo): Result<Unit> {
        return withContext(Dispatchers.IO) {
            try {
                updateModuleState(moduleInfo.name, ModuleState.Downloading(0f))
                
                // 1. 下载依赖模块
                for (dependency in moduleInfo.dependencies) {
                    if (!isModuleInstalled(dependency)) {
                        val depInfo = fetchModuleInfo(dependency)
                        installModule(depInfo).getOrThrow()
                    }
                }
                
                // 2. 下载模块文件
                val moduleDir = File(modulesDir, moduleInfo.name)
                moduleDir.mkdirs()
                
                val zipFile = File(moduleDir, "${moduleInfo.name}.zip")
                downloadFile(moduleInfo.downloadUrl, zipFile) { progress ->
                    updateModuleState(moduleInfo.name, ModuleState.Downloading(progress))
                }
                
                // 3. 验证 MD5
                val actualMd5 = calculateMd5(zipFile)
                if (actualMd5 != moduleInfo.md5) {
                    zipFile.delete()
                    throw IllegalStateException("MD5 verification failed")
                }
                
                // 4. 解压模块
                unzipModule(zipFile, moduleDir)
                zipFile.delete()
                
                // 5. 保存模块信息
                saveModuleManifest(moduleDir, moduleInfo)
                
                updateModuleState(moduleInfo.name, ModuleState.Installed)
                Result.success(Unit)
            } catch (e: Exception) {
                Log.e(TAG, "Failed to install module: ${moduleInfo.name}", e)
                updateModuleState(moduleInfo.name, ModuleState.Error(e.message ?: "Unknown error"))
                Result.failure(e)
            }
        }
    }
    
    /**
     * 加载模块
     */
    suspend fun loadModule(moduleName: String): Result<ClassLoader> {
        return withContext(Dispatchers.IO) {
            try {
                if (!isModuleInstalled(moduleName)) {
                    throw IllegalStateException("Module not installed: $moduleName")
                }
                
                updateModuleState(moduleName, ModuleState.Loading)
                
                val moduleDir = File(modulesDir, moduleName)
                val dexFile = File(moduleDir, "classes.dex")
                val soDir = File(moduleDir, "lib")
                val optimizedDir = File(moduleDir, "optimized").apply { mkdirs() }
                
                // 创建 DexClassLoader
                val classLoader = DexClassLoader(
                    dexFile.absolutePath,
                    optimizedDir.absolutePath,
                    if (soDir.exists()) soDir.absolutePath else null,
                    context.classLoader
                )
                
                updateModuleState(moduleName, ModuleState.Loaded)
                Result.success(classLoader)
            } catch (e: Exception) {
                Log.e(TAG, "Failed to load module: $moduleName", e)
                updateModuleState(moduleName, ModuleState.Error(e.message ?: "Unknown error"))
                Result.failure(e)
            }
        }
    }
    
    /**
     * 下载文件
     */
    private suspend fun downloadFile(
        url: String, 
        outputFile: File,
        onProgress: (Float) -> Unit
    ) {
        val connection = URL(url).openConnection() as HttpURLConnection
        connection.connect()
        
        val totalSize = connection.contentLength.toLong()
        var downloadedSize = 0L
        
        connection.inputStream.use { input ->
            outputFile.outputStream().use { output ->
                val buffer = ByteArray(8192)
                var bytesRead: Int
                
                while (input.read(buffer).also { bytesRead = it } != -1) {
                    output.write(buffer, 0, bytesRead)
                    downloadedSize += bytesRead
                    onProgress(downloadedSize.toFloat() / totalSize)
                }
            }
        }
    }
    
    /**
     * 解压模块
     */
    private fun unzipModule(zipFile: File, outputDir: File) {
        ZipInputStream(zipFile.inputStream()).use { zis ->
            var entry = zis.nextEntry
            while (entry != null) {
                val file = File(outputDir, entry.name)
                if (entry.isDirectory) {
                    file.mkdirs()
                } else {
                    file.parentFile?.mkdirs()
                    file.outputStream().use { output ->
                        zis.copyTo(output)
                    }
                }
                entry = zis.nextEntry
            }
        }
    }
    
    /**
     * 计算 MD5
     */
    private fun calculateMd5(file: File): String {
        val md = MessageDigest.getInstance("MD5")
        file.inputStream().use { input ->
            val buffer = ByteArray(8192)
            var bytesRead: Int
            while (input.read(buffer).also { bytesRead = it } != -1) {
                md.update(buffer, 0, bytesRead)
            }
        }
        return md.digest().joinToString("") { "%02x".format(it) }
    }
    
    private fun updateModuleState(moduleName: String, state: ModuleState) {
        _moduleStates.update { it + (moduleName to state) }
    }
    
    private suspend fun fetchModuleInfo(moduleName: String): ModuleInfo {
        // 从服务器获取模块信息
        val url = "$serverUrl/modules/$moduleName/info.json"
        val json = URL(url).readText()
        return gson.fromJson(json, ModuleInfo::class.java)
    }
    
    private fun saveModuleManifest(moduleDir: File, moduleInfo: ModuleInfo) {
        val manifestFile = File(moduleDir, MANIFEST_FILE)
        manifestFile.writeText(gson.toJson(moduleInfo))
    }
}
```


### 2.6 App Bundle 与 Split APK

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    App Bundle 与 Split APK                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  Android App Bundle (AAB) 是 Google 推荐的发布格式:                     │
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  传统 APK 发布:                                                 │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │  Universal APK (包含所有资源)                           │   │   │
│  │  │  ├─ 所有 ABI (arm64, arm, x86, x86_64)                  │   │   │
│  │  │  ├─ 所有语言资源                                        │   │   │
│  │  │  ├─ 所有屏幕密度资源                                    │   │   │
│  │  │  └─ 体积: ~100MB                                        │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │                                                                 │   │
│  │  App Bundle 发布:                                               │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │  AAB → Google Play → 按设备生成优化 APK                 │   │   │
│  │  │                                                         │   │   │
│  │  │  设备 A (arm64, xxhdpi, zh):                            │   │   │
│  │  │  ├─ Base APK + arm64 Split + xxhdpi Split + zh Split    │   │   │
│  │  │  └─ 体积: ~40MB (节省 60%)                              │   │   │
│  │  │                                                         │   │   │
│  │  │  设备 B (arm, hdpi, en):                                │   │   │
│  │  │  ├─ Base APK + arm Split + hdpi Split + en Split        │   │   │
│  │  │  └─ 体积: ~35MB                                         │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  Split APK 类型:                                                        │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  1. Configuration Splits (配置分包)                             │   │
│  │     ├─ ABI Splits: arm64-v8a, armeabi-v7a, x86, x86_64          │   │
│  │     ├─ Density Splits: ldpi, mdpi, hdpi, xhdpi, xxhdpi, xxxhdpi │   │
│  │     └─ Language Splits: zh, en, ja, ko...                       │   │
│  │                                                                 │   │
│  │  2. Dynamic Feature Modules (动态功能模块)                      │   │
│  │     ├─ 按需下载的功能模块                                       │   │
│  │     ├─ 首次使用时安装                                           │   │
│  │     └─ 可卸载以释放空间                                         │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

#### App Bundle 配置

```groovy
// build.gradle (Module)
android {
    // 启用 Bundle 配置
    bundle {
        // 语言分包
        language {
            enableSplit = true
        }
        // 屏幕密度分包
        density {
            enableSplit = true
        }
        // ABI 分包
        abi {
            enableSplit = true
        }
        // 纹理压缩格式分包 (游戏相关)
        texture {
            enableSplit = true
        }
    }
    
    // 动态功能模块配置
    dynamicFeatures = [':feature_live', ':feature_game']
}

// 生成 AAB
// ./gradlew bundleRelease
```

#### Dynamic Feature Module

```groovy
// feature_live/build.gradle
plugins {
    id 'com.android.dynamic-feature'
}

android {
    compileSdk 34
    
    defaultConfig {
        minSdk 21
    }
}

dependencies {
    // 依赖主模块
    implementation project(':app')
}
```

```xml
<!-- feature_live/src/main/AndroidManifest.xml -->
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:dist="http://schemas.android.com/apk/distribution"
    package="com.example.feature.live">

    <dist:module
        dist:instant="false"
        dist:title="@string/title_live">
        
        <!-- 按需下载 -->
        <dist:delivery>
            <dist:on-demand />
        </dist:delivery>
        
        <!-- 或者安装时下载 -->
        <!--
        <dist:delivery>
            <dist:install-time />
        </dist:delivery>
        -->
        
        <dist:fusing dist:include="true" />
    </dist:module>
</manifest>
```

```kotlin
/**
 * 动态功能模块管理器
 * 使用 Play Core Library 管理动态模块
 */
class DynamicFeatureManager(private val context: Context) {
    
    private val splitInstallManager: SplitInstallManager by lazy {
        SplitInstallManagerFactory.create(context)
    }
    
    // 模块安装状态
    private val _installState = MutableStateFlow<InstallState>(InstallState.Idle)
    val installState: StateFlow<InstallState> = _installState.asStateFlow()
    
    sealed class InstallState {
        object Idle : InstallState()
        data class Downloading(val progress: Int) : InstallState()
        object Installing : InstallState()
        object Installed : InstallState()
        data class Failed(val errorCode: Int) : InstallState()
        object RequiresConfirmation : InstallState()
    }
    
    /**
     * 检查模块是否已安装
     */
    fun isModuleInstalled(moduleName: String): Boolean {
        return splitInstallManager.installedModules.contains(moduleName)
    }
    
    /**
     * 安装动态功能模块
     */
    fun installModule(moduleName: String) {
        if (isModuleInstalled(moduleName)) {
            _installState.value = InstallState.Installed
            return
        }
        
        val request = SplitInstallRequest.newBuilder()
            .addModule(moduleName)
            .build()
        
        splitInstallManager.startInstall(request)
            .addOnSuccessListener { sessionId ->
                Log.d("DynamicFeature", "Install started, sessionId: $sessionId")
            }
            .addOnFailureListener { exception ->
                Log.e("DynamicFeature", "Install failed", exception)
                _installState.value = InstallState.Failed(
                    (exception as? SplitInstallException)?.errorCode ?: -1
                )
            }
    }
    
    /**
     * 注册安装状态监听
     */
    fun registerStateListener() {
        val listener = SplitInstallStateUpdatedListener { state ->
            when (state.status()) {
                SplitInstallSessionStatus.PENDING -> {
                    _installState.value = InstallState.Downloading(0)
                }
                SplitInstallSessionStatus.DOWNLOADING -> {
                    val progress = (state.bytesDownloaded() * 100 / 
                                   state.totalBytesToDownload()).toInt()
                    _installState.value = InstallState.Downloading(progress)
                }
                SplitInstallSessionStatus.DOWNLOADED -> {
                    _installState.value = InstallState.Installing
                }
                SplitInstallSessionStatus.INSTALLING -> {
                    _installState.value = InstallState.Installing
                }
                SplitInstallSessionStatus.INSTALLED -> {
                    _installState.value = InstallState.Installed
                }
                SplitInstallSessionStatus.FAILED -> {
                    _installState.value = InstallState.Failed(state.errorCode())
                }
                SplitInstallSessionStatus.REQUIRES_USER_CONFIRMATION -> {
                    _installState.value = InstallState.RequiresConfirmation
                }
                SplitInstallSessionStatus.CANCELING,
                SplitInstallSessionStatus.CANCELED -> {
                    _installState.value = InstallState.Idle
                }
            }
        }
        
        splitInstallManager.registerListener(listener)
    }
    
    /**
     * 卸载动态功能模块
     */
    fun uninstallModule(moduleName: String) {
        splitInstallManager.deferredUninstall(listOf(moduleName))
            .addOnSuccessListener {
                Log.d("DynamicFeature", "Module uninstalled: $moduleName")
            }
            .addOnFailureListener { exception ->
                Log.e("DynamicFeature", "Uninstall failed", exception)
            }
    }
    
    /**
     * 获取已安装的模块列表
     */
    fun getInstalledModules(): Set<String> {
        return splitInstallManager.installedModules
    }
}

/**
 * 动态功能模块使用示例
 */
class LiveFeatureActivity : AppCompatActivity() {
    
    private lateinit var dynamicFeatureManager: DynamicFeatureManager
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        dynamicFeatureManager = DynamicFeatureManager(this)
        
        // 检查模块是否已安装
        if (dynamicFeatureManager.isModuleInstalled("feature_live")) {
            // 直接启动功能
            launchLiveFeature()
        } else {
            // 下载模块
            showDownloadDialog()
            dynamicFeatureManager.installModule("feature_live")
            
            // 监听安装状态
            lifecycleScope.launch {
                dynamicFeatureManager.installState.collect { state ->
                    when (state) {
                        is DynamicFeatureManager.InstallState.Downloading -> {
                            updateProgress(state.progress)
                        }
                        is DynamicFeatureManager.InstallState.Installed -> {
                            dismissDownloadDialog()
                            launchLiveFeature()
                        }
                        is DynamicFeatureManager.InstallState.Failed -> {
                            showError("安装失败: ${state.errorCode}")
                        }
                        else -> {}
                    }
                }
            }
        }
    }
    
    private fun launchLiveFeature() {
        // 使用反射或 SplitCompat 加载动态模块中的类
        SplitCompat.installActivity(this)
        
        val intent = Intent()
        intent.setClassName(
            packageName,
            "com.example.feature.live.LiveActivity"
        )
        startActivity(intent)
    }
}
```


### 2.7 包体积监控

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          包体积监控体系                                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  包体积监控是持续优化的基础，需要建立完整的监控体系:                    │
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  CI/CD 集成                                                     │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │  1. 每次构建自动分析 APK 大小                           │   │   │
│  │  │  2. 与基准版本对比，超阈值告警                          │   │   │
│  │  │  3. 生成详细的大小变化报告                              │   │   │
│  │  │  4. 阻止体积异常增长的 MR 合入                          │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │                                                                 │   │
│  │  监控维度                                                       │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │  ├─ 总体积变化趋势                                      │   │   │
│  │  │  ├─ 各模块体积占比                                      │   │   │
│  │  │  ├─ DEX 文件数量和大小                                  │   │   │
│  │  │  ├─ 资源文件大小分布                                    │   │   │
│  │  │  ├─ So 库大小                                           │   │   │
│  │  │  └─ 新增/删除文件列表                                   │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │                                                                 │   │
│  │  告警规则                                                       │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │  ├─ 单次增量 > 500KB: 警告                              │   │   │
│  │  │  ├─ 单次增量 > 1MB: 阻断                                │   │   │
│  │  │  ├─ 新增大文件 (>100KB): 需审批                         │   │   │
│  │  │  └─ 新增 So 库: 需审批                                  │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

```kotlin
/**
 * APK 体积监控工具
 * 用于 CI/CD 集成
 */
class ApkSizeMonitor(
    private val baselineApkPath: String,
    private val currentApkPath: String,
    private val config: MonitorConfig
) {
    
    data class MonitorConfig(
        val warningThreshold: Long = 500 * 1024,      // 500KB 警告
        val blockingThreshold: Long = 1024 * 1024,    // 1MB 阻断
        val largeFileThreshold: Long = 100 * 1024,    // 100KB 大文件
        val outputDir: String = "build/reports/apk-size"
    )
    
    data class SizeCompareResult(
        val baselineSize: Long,
        val currentSize: Long,
        val sizeDiff: Long,
        val diffPercentage: Float,
        val addedFiles: List<FileChange>,
        val removedFiles: List<FileChange>,
        val changedFiles: List<FileChange>,
        val status: Status
    ) {
        enum class Status { OK, WARNING, BLOCKING }
    }
    
    data class FileChange(
        val path: String,
        val oldSize: Long,
        val newSize: Long
    ) {
        val sizeDiff: Long get() = newSize - oldSize
    }
    
    /**
     * 执行体积对比分析
     */
    fun analyze(): SizeCompareResult {
        val baselineInfo = analyzeApk(baselineApkPath)
        val currentInfo = analyzeApk(currentApkPath)
        
        val sizeDiff = currentInfo.totalSize - baselineInfo.totalSize
        val diffPercentage = sizeDiff * 100f / baselineInfo.totalSize
        
        // 分析文件变化
        val baselineFiles = baselineInfo.files.associateBy { it.path }
        val currentFiles = currentInfo.files.associateBy { it.path }
        
        val addedFiles = currentFiles.keys
            .filter { it !in baselineFiles }
            .map { FileChange(it, 0, currentFiles[it]!!.size) }
        
        val removedFiles = baselineFiles.keys
            .filter { it !in currentFiles }
            .map { FileChange(it, baselineFiles[it]!!.size, 0) }
        
        val changedFiles = currentFiles.keys
            .filter { it in baselineFiles && currentFiles[it]!!.size != baselineFiles[it]!!.size }
            .map { FileChange(it, baselineFiles[it]!!.size, currentFiles[it]!!.size) }
        
        // 判断状态
        val status = when {
            sizeDiff > config.blockingThreshold -> SizeCompareResult.Status.BLOCKING
            sizeDiff > config.warningThreshold -> SizeCompareResult.Status.WARNING
            else -> SizeCompareResult.Status.OK
        }
        
        return SizeCompareResult(
            baselineSize = baselineInfo.totalSize,
            currentSize = currentInfo.totalSize,
            sizeDiff = sizeDiff,
            diffPercentage = diffPercentage,
            addedFiles = addedFiles,
            removedFiles = removedFiles,
            changedFiles = changedFiles,
            status = status
        )
    }
    
    /**
     * 生成报告
     */
    fun generateReport(result: SizeCompareResult): String {
        return buildString {
            appendLine("# APK Size Report")
            appendLine()
            appendLine("## Summary")
            appendLine("| Metric | Value |")
            appendLine("|--------|-------|")
            appendLine("| Baseline Size | ${formatSize(result.baselineSize)} |")
            appendLine("| Current Size | ${formatSize(result.currentSize)} |")
            appendLine("| Size Diff | ${formatSize(result.sizeDiff)} (${result.diffPercentage.format(2)}%) |")
            appendLine("| Status | ${result.status} |")
            appendLine()
            
            if (result.addedFiles.isNotEmpty()) {
                appendLine("## Added Files")
                appendLine("| File | Size |")
                appendLine("|------|------|")
                result.addedFiles
                    .sortedByDescending { it.newSize }
                    .take(20)
                    .forEach { file ->
                        appendLine("| ${file.path} | ${formatSize(file.newSize)} |")
                    }
                appendLine()
            }
            
            if (result.changedFiles.isNotEmpty()) {
                appendLine("## Changed Files (Top 20)")
                appendLine("| File | Old Size | New Size | Diff |")
                appendLine("|------|----------|----------|------|")
                result.changedFiles
                    .sortedByDescending { kotlin.math.abs(it.sizeDiff) }
                    .take(20)
                    .forEach { file ->
                        appendLine("| ${file.path} | ${formatSize(file.oldSize)} | ${formatSize(file.newSize)} | ${formatSize(file.sizeDiff)} |")
                    }
                appendLine()
            }
            
            // 大文件警告
            val largeAddedFiles = result.addedFiles.filter { it.newSize > config.largeFileThreshold }
            if (largeAddedFiles.isNotEmpty()) {
                appendLine("## ⚠️ Large Files Added")
                largeAddedFiles.forEach { file ->
                    appendLine("- ${file.path}: ${formatSize(file.newSize)}")
                }
            }
        }
    }
    
    private fun analyzeApk(apkPath: String): ApkInfo {
        val files = mutableListOf<ApkFileInfo>()
        var totalSize = 0L
        
        ZipFile(File(apkPath)).use { zip ->
            zip.entries().asSequence().forEach { entry ->
                files.add(ApkFileInfo(entry.name, entry.compressedSize))
                totalSize += entry.compressedSize
            }
        }
        
        return ApkInfo(totalSize, files)
    }
    
    private fun formatSize(bytes: Long): String {
        val absBytes = kotlin.math.abs(bytes)
        val sign = if (bytes < 0) "-" else ""
        return when {
            absBytes >= 1024 * 1024 -> "$sign${(absBytes / 1024.0 / 1024.0).format(2)} MB"
            absBytes >= 1024 -> "$sign${(absBytes / 1024.0).format(2)} KB"
            else -> "$sign$absBytes B"
        }
    }
    
    private fun Float.format(digits: Int) = "%.${digits}f".format(this)
    private fun Double.format(digits: Int) = "%.${digits}f".format(this)
    
    data class ApkInfo(val totalSize: Long, val files: List<ApkFileInfo>)
    data class ApkFileInfo(val path: String, val size: Long)
}

/**
 * Gradle 插件集成示例
 * 在 CI 中自动执行体积检查
 */
// build.gradle
/*
task checkApkSize {
    doLast {
        def monitor = new ApkSizeMonitor(
            "baseline/app-release.apk",
            "app/build/outputs/apk/release/app-release.apk",
            new ApkSizeMonitor.MonitorConfig()
        )
        
        def result = monitor.analyze()
        def report = monitor.generateReport(result)
        
        // 输出报告
        file("build/reports/apk-size/report.md").text = report
        
        // 根据状态决定是否失败
        if (result.status == ApkSizeMonitor.SizeCompareResult.Status.BLOCKING) {
            throw new GradleException("APK size increased by ${result.sizeDiff} bytes, exceeds threshold!")
        }
    }
}
*/
```


## 3. 关键源码解析

### 3.1 R8 代码裁剪原理

```kotlin
/**
 * R8 代码裁剪核心原理
 * 
 * R8 使用 "树摇" (Tree Shaking) 算法移除未使用的代码:
 * 1. 从入口点 (Entry Points) 开始分析
 * 2. 标记所有可达的类、方法、字段
 * 3. 移除未被标记的代码
 */

/*
 * R8 入口点配置 (简化版)
 * 
 * 默认入口点包括:
 * - AndroidManifest.xml 中声明的组件
 * - 反射调用的类 (需要 keep 规则)
 * - JNI 调用的方法
 * - 序列化相关的类
 */

/**
 * 模拟 R8 的可达性分析
 */
class ReachabilityAnalyzer {
    
    // 入口点集合
    private val entryPoints = mutableSetOf<String>()
    
    // 可达的类和成员
    private val reachableClasses = mutableSetOf<String>()
    private val reachableMethods = mutableSetOf<String>()
    private val reachableFields = mutableSetOf<String>()
    
    // 待处理队列
    private val workQueue = ArrayDeque<String>()
    
    /**
     * 添加入口点
     */
    fun addEntryPoint(className: String) {
        entryPoints.add(className)
        workQueue.add(className)
    }
    
    /**
     * 执行可达性分析
     */
    fun analyze(classPool: Map<String, ClassInfo>) {
        while (workQueue.isNotEmpty()) {
            val className = workQueue.removeFirst()
            
            if (className in reachableClasses) continue
            reachableClasses.add(className)
            
            val classInfo = classPool[className] ?: continue
            
            // 分析父类
            classInfo.superClass?.let { 
                if (it !in reachableClasses) workQueue.add(it) 
            }
            
            // 分析接口
            classInfo.interfaces.forEach { 
                if (it !in reachableClasses) workQueue.add(it) 
            }
            
            // 分析方法引用
            classInfo.methods.forEach { method ->
                reachableMethods.add("$className.${method.name}")
                
                // 分析方法体中的引用
                method.referencedClasses.forEach { ref ->
                    if (ref !in reachableClasses) workQueue.add(ref)
                }
                method.referencedMethods.forEach { ref ->
                    reachableMethods.add(ref)
                }
                method.referencedFields.forEach { ref ->
                    reachableFields.add(ref)
                }
            }
            
            // 分析字段引用
            classInfo.fields.forEach { field ->
                reachableFields.add("$className.${field.name}")
                if (field.type !in reachableClasses) {
                    workQueue.add(field.type)
                }
            }
        }
    }
    
    /**
     * 获取可移除的类
     */
    fun getRemovableClasses(allClasses: Set<String>): Set<String> {
        return allClasses - reachableClasses
    }
    
    data class ClassInfo(
        val name: String,
        val superClass: String?,
        val interfaces: List<String>,
        val methods: List<MethodInfo>,
        val fields: List<FieldInfo>
    )
    
    data class MethodInfo(
        val name: String,
        val referencedClasses: Set<String>,
        val referencedMethods: Set<String>,
        val referencedFields: Set<String>
    )
    
    data class FieldInfo(
        val name: String,
        val type: String
    )
}
```

### 3.2 资源压缩原理 (shrinkResources)

```kotlin
/**
 * 资源压缩原理分析
 * 
 * shrinkResources 工作流程:
 * 1. 分析代码中的资源引用 (R.drawable.xxx, getIdentifier())
 * 2. 分析 XML 中的资源引用 (@drawable/xxx)
 * 3. 标记未被引用的资源
 * 4. 将未使用资源替换为空文件 (保持 R 文件索引不变)
 */

/**
 * 资源引用分析器
 */
class ResourceReferenceAnalyzer {
    
    // 被引用的资源 ID
    private val referencedResources = mutableSetOf<Int>()
    
    // 动态引用的资源名称 (getIdentifier)
    private val dynamicReferences = mutableSetOf<String>()
    
    /**
     * 分析 DEX 文件中的资源引用
     */
    fun analyzeDexFile(dexFile: File) {
        // 解析 DEX 文件，查找以下模式:
        // 1. 直接引用: R.drawable.icon (编译为常量)
        // 2. 动态引用: getIdentifier("icon", "drawable", packageName)
        
        // 伪代码示例
        /*
        dexFile.classes.forEach { clazz ->
            clazz.methods.forEach { method ->
                method.instructions.forEach { instruction ->
                    when (instruction) {
                        is ConstInstruction -> {
                            // 检查是否是资源 ID
                            if (isResourceId(instruction.value)) {
                                referencedResources.add(instruction.value)
                            }
                        }
                        is InvokeInstruction -> {
                            // 检查是否是 getIdentifier 调用
                            if (instruction.method == "getIdentifier") {
                                val resourceName = extractResourceName(instruction)
                                dynamicReferences.add(resourceName)
                            }
                        }
                    }
                }
            }
        }
        */
    }
    
    /**
     * 分析 XML 文件中的资源引用
     */
    fun analyzeXmlFile(xmlFile: File) {
        // 解析 XML，查找资源引用
        // @drawable/icon, @string/app_name, ?attr/colorPrimary
        
        val document = DocumentBuilderFactory.newInstance()
            .newDocumentBuilder()
            .parse(xmlFile)
        
        analyzeNode(document.documentElement)
    }
    
    private fun analyzeNode(node: Node) {
        // 分析属性中的资源引用
        val attributes = node.attributes
        if (attributes != null) {
            for (i in 0 until attributes.length) {
                val attr = attributes.item(i)
                val value = attr.nodeValue
                
                // 匹配 @type/name 格式
                val resourceRef = Regex("@(\\w+)/(\\w+)").find(value)
                if (resourceRef != null) {
                    val (type, name) = resourceRef.destructured
                    dynamicReferences.add("$type/$name")
                }
            }
        }
        
        // 递归分析子节点
        val children = node.childNodes
        for (i in 0 until children.length) {
            analyzeNode(children.item(i))
        }
    }
    
    /**
     * 获取未使用的资源
     */
    fun getUnusedResources(allResources: Map<Int, String>): List<String> {
        return allResources
            .filter { (id, name) -> 
                id !in referencedResources && 
                name !in dynamicReferences 
            }
            .values
            .toList()
    }
}

/**
 * resources.arsc 文件结构分析
 * 
 * resources.arsc 是编译后的资源索引表，包含:
 * - 字符串池 (String Pool): 所有资源名称和字符串值
 * - 包信息 (Package): 包名、资源类型
 * - 类型规格 (Type Spec): 资源配置信息
 * - 类型数据 (Type): 具体资源条目
 */
class ResourceTableAnalyzer {
    
    /**
     * 解析 resources.arsc 文件
     */
    fun parseResourceTable(arscFile: File): ResourceTable {
        val buffer = ByteBuffer.wrap(arscFile.readBytes())
            .order(ByteOrder.LITTLE_ENDIAN)
        
        // 读取文件头
        val type = buffer.short      // 类型: RES_TABLE_TYPE
        val headerSize = buffer.short
        val size = buffer.int
        val packageCount = buffer.int
        
        // 读取字符串池
        val stringPool = readStringPool(buffer)
        
        // 读取包信息
        val packages = mutableListOf<PackageInfo>()
        repeat(packageCount) {
            packages.add(readPackage(buffer, stringPool))
        }
        
        return ResourceTable(stringPool, packages)
    }
    
    private fun readStringPool(buffer: ByteBuffer): List<String> {
        // 解析字符串池
        // ...
        return emptyList()
    }
    
    private fun readPackage(buffer: ByteBuffer, stringPool: List<String>): PackageInfo {
        // 解析包信息
        // ...
        return PackageInfo("", emptyList())
    }
    
    data class ResourceTable(
        val stringPool: List<String>,
        val packages: List<PackageInfo>
    )
    
    data class PackageInfo(
        val name: String,
        val types: List<TypeInfo>
    )
    
    data class TypeInfo(
        val name: String,
        val entries: List<ResourceEntry>
    )
    
    data class ResourceEntry(
        val id: Int,
        val name: String,
        val value: Any?
    )
}
```

### 3.3 So 库加载原理

```kotlin
/**
 * Android So 库加载原理
 * 
 * System.loadLibrary() 调用链:
 * 1. System.loadLibrary(libName)
 * 2. Runtime.loadLibrary0(classLoader, libName)
 * 3. ClassLoader.findLibrary(libName) - 查找 So 文件路径
 * 4. Runtime.nativeLoad(path, classLoader) - 调用 dlopen 加载
 */

/**
 * 自定义 So 加载器
 * 支持从自定义路径加载 So 库
 */
class CustomSoLoader(private val context: Context) {
    
    companion object {
        private const val TAG = "CustomSoLoader"
        
        // So 库搜索路径
        private val NATIVE_LIB_DIRS = listOf(
            "lib/arm64-v8a",
            "lib/armeabi-v7a",
            "lib/x86_64",
            "lib/x86"
        )
    }
    
    // 已加载的库
    private val loadedLibraries = mutableSetOf<String>()
    
    // 自定义搜索路径
    private val customSearchPaths = mutableListOf<File>()
    
    /**
     * 添加自定义搜索路径
     */
    fun addSearchPath(path: File) {
        if (path.isDirectory) {
            customSearchPaths.add(path)
        }
    }
    
    /**
     * 加载 So 库
     */
    fun loadLibrary(libName: String): Boolean {
        if (libName in loadedLibraries) {
            return true
        }
        
        val soFileName = "lib${libName}.so"
        
        // 1. 尝试从系统路径加载
        try {
            System.loadLibrary(libName)
            loadedLibraries.add(libName)
            Log.d(TAG, "Loaded $libName from system path")
            return true
        } catch (e: UnsatisfiedLinkError) {
            Log.d(TAG, "Not found in system path: $libName")
        }
        
        // 2. 从自定义路径加载
        val abi = getCurrentAbi()
        for (searchPath in customSearchPaths) {
            val soFile = File(searchPath, "$abi/$soFileName")
            if (soFile.exists()) {
                try {
                    System.load(soFile.absolutePath)
                    loadedLibraries.add(libName)
                    Log.d(TAG, "Loaded $libName from ${soFile.absolutePath}")
                    return true
                } catch (e: UnsatisfiedLinkError) {
                    Log.e(TAG, "Failed to load from ${soFile.absolutePath}", e)
                }
            }
        }
        
        // 3. 从 APK 内解压加载
        return loadFromApk(libName, soFileName, abi)
    }
    
    /**
     * 从 APK 内解压并加载
     */
    private fun loadFromApk(libName: String, soFileName: String, abi: String): Boolean {
        try {
            val apkPath = context.applicationInfo.sourceDir
            val zipFile = ZipFile(apkPath)
            
            // 查找 So 文件
            val entryName = "lib/$abi/$soFileName"
            val entry = zipFile.getEntry(entryName) ?: return false
            
            // 解压到私有目录
            val outputDir = File(context.filesDir, "native_libs/$abi")
            outputDir.mkdirs()
            val outputFile = File(outputDir, soFileName)
            
            if (!outputFile.exists()) {
                zipFile.getInputStream(entry).use { input ->
                    outputFile.outputStream().use { output ->
                        input.copyTo(output)
                    }
                }
                outputFile.setExecutable(true, false)
            }
            
            // 加载
            System.load(outputFile.absolutePath)
            loadedLibraries.add(libName)
            Log.d(TAG, "Loaded $libName from APK")
            return true
        } catch (e: Exception) {
            Log.e(TAG, "Failed to load from APK: $libName", e)
            return false
        }
    }
    
    /**
     * 获取当前设备 ABI
     */
    private fun getCurrentAbi(): String {
        return Build.SUPPORTED_ABIS.firstOrNull() ?: "arm64-v8a"
    }
    
    /**
     * 预加载 So 库
     * 在后台线程解压，加速后续加载
     */
    suspend fun preloadLibraries(libNames: List<String>) {
        withContext(Dispatchers.IO) {
            val abi = getCurrentAbi()
            val apkPath = context.applicationInfo.sourceDir
            val zipFile = ZipFile(apkPath)
            
            val outputDir = File(context.filesDir, "native_libs/$abi")
            outputDir.mkdirs()
            
            libNames.forEach { libName ->
                val soFileName = "lib${libName}.so"
                val entryName = "lib/$abi/$soFileName"
                val entry = zipFile.getEntry(entryName)
                
                if (entry != null) {
                    val outputFile = File(outputDir, soFileName)
                    if (!outputFile.exists()) {
                        zipFile.getInputStream(entry).use { input ->
                            outputFile.outputStream().use { output ->
                                input.copyTo(output)
                            }
                        }
                        outputFile.setExecutable(true, false)
                    }
                }
            }
        }
    }
}
```


## 4. 实战应用

### 4.1 包体积优化实战案例

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      包体积优化实战案例                                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  案例背景: 某电商 App 包体积从 80MB 优化到 45MB                         │
│                                                                         │
│  优化前分析:                                                            │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  总体积: 80MB                                                   │   │
│  │  ├─ DEX 文件: 25MB (31%)                                        │   │
│  │  ├─ 资源文件: 30MB (38%)                                        │   │
│  │  │   ├─ 图片资源: 22MB                                          │   │
│  │  │   └─ 其他资源: 8MB                                           │   │
│  │  ├─ So 库: 20MB (25%)                                           │   │
│  │  │   ├─ arm64-v8a: 10MB                                         │   │
│  │  │   └─ armeabi-v7a: 10MB                                       │   │
│  │  └─ 其他: 5MB (6%)                                              │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  优化措施及效果:                                                        │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  1. 代码优化 (25MB → 18MB, 节省 7MB)                            │   │
│  │     ├─ 开启 R8 全模式                                           │   │
│  │     ├─ 移除无用代码和库                                         │   │
│  │     └─ 优化 Kotlin 元数据                                       │   │
│  │                                                                 │   │
│  │  2. 资源优化 (30MB → 15MB, 节省 15MB)                           │   │
│  │     ├─ PNG → WebP 转换 (节省 8MB)                               │   │
│  │     ├─ 资源混淆 AndResGuard (节省 3MB)                          │   │
│  │     ├─ 移除无用资源 (节省 2MB)                                  │   │
│  │     └─ 图片按需下载 (节省 2MB)                                  │   │
│  │                                                                 │   │
│  │  3. So 库优化 (20MB → 10MB, 节省 10MB)                          │   │
│  │     ├─ 只保留 arm64-v8a (节省 10MB)                             │   │
│  │     └─ 非核心 So 动态下发                                       │   │
│  │                                                                 │   │
│  │  4. 其他优化 (5MB → 2MB, 节省 3MB)                              │   │
│  │     ├─ 移除调试信息                                             │   │
│  │     └─ 优化签名配置                                             │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  优化后: 45MB (节省 35MB, 降低 44%)                                     │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 4.2 最佳实践清单

```kotlin
/**
 * 包体积优化最佳实践清单
 */
object PackageSizeOptimizationChecklist {
    
    /**
     * 代码优化清单
     */
    val codeOptimizations = listOf(
        // 基础配置
        "开启 minifyEnabled",
        "开启 shrinkResources",
        "使用 R8 全模式 (android.enableR8.fullMode=true)",
        
        // 代码裁剪
        "移除未使用的依赖库",
        "使用 implementation 替代 api 减少传递依赖",
        "移除调试代码和日志",
        "使用 @Keep 精确保留必要代码",
        
        // Kotlin 优化
        "移除 kotlin-reflect 依赖 (如非必要)",
        "使用 -Xno-param-assertions 减少断言代码",
        "配置 kotlin.stdlib.default.dependency=false 避免重复依赖"
    )
    
    /**
     * 资源优化清单
     */
    val resourceOptimizations = listOf(
        // 图片优化
        "PNG/JPEG 转换为 WebP",
        "使用 VectorDrawable 替代小图标",
        "移除未使用的图片资源",
        "只保留必要的屏幕密度资源 (xxhdpi)",
        "大图使用网络加载",
        
        // 资源配置
        "配置 resConfigs 只保留必要语言",
        "使用 AndResGuard 进行资源混淆",
        "合并重复资源",
        "使用 Shape 替代纯色图片",
        "使用 Tint 着色复用图片"
    )
    
    /**
     * So 库优化清单
     */
    val nativeOptimizations = listOf(
        // ABI 配置
        "只保留 arm64-v8a (覆盖 85%+ 设备)",
        "使用 App Bundle 按设备分发",
        
        // So 优化
        "strip 移除调试符号",
        "使用 -Oz 编译优化体积",
        "启用 LTO (Link Time Optimization)",
        "非核心 So 动态下发",
        
        // 压缩
        "So 库压缩存储，运行时解压"
    )
    
    /**
     * 分发优化清单
     */
    val deliveryOptimizations = listOf(
        "使用 App Bundle 发布",
        "配置 Dynamic Feature Modules",
        "非核心功能动态下发",
        "资源按需下载",
        "增量更新"
    )
    
    /**
     * 监控清单
     */
    val monitoringChecklist = listOf(
        "CI/CD 集成包体积检查",
        "设置体积增长阈值告警",
        "定期生成体积分析报告",
        "追踪各模块体积变化",
        "新增大文件审批流程"
    )
}

/**
 * 包体积优化 Gradle 配置模板
 */
/*
// build.gradle (Module: app)
android {
    defaultConfig {
        // 只保留中文和英文
        resConfigs "zh", "en"
        
        // 只保留 arm64-v8a
        ndk {
            abiFilters 'arm64-v8a'
        }
    }
    
    buildTypes {
        release {
            // 代码压缩
            minifyEnabled true
            // 资源压缩
            shrinkResources true
            // 混淆规则
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'),
                    'proguard-rules.pro'
        }
    }
    
    // App Bundle 配置
    bundle {
        language {
            enableSplit = true
        }
        density {
            enableSplit = true
        }
        abi {
            enableSplit = true
        }
    }
    
    // 动态功能模块
    dynamicFeatures = [':feature_live', ':feature_game']
}

// gradle.properties
android.enableR8.fullMode=true
kotlin.stdlib.default.dependency=false
*/
```

### 4.3 常见问题与解决方案

```kotlin
/**
 * 包体积优化常见问题与解决方案
 */
object TroubleshootingGuide {
    
    /**
     * 问题1: 开启混淆后崩溃
     * 原因: 反射、序列化、JNI 调用的类被混淆
     */
    val issue1 = """
        解决方案:
        1. 查看崩溃堆栈，使用 mapping.txt 还原
        2. 添加 keep 规则保留相关类
        3. 常见需要保留的类:
           - Gson/Moshi 数据类
           - Retrofit 接口
           - JNI 调用的类
           - 反射创建的类
        
        示例 keep 规则:
        -keep class com.example.model.** { *; }
        -keepclassmembers class * {
            @com.google.gson.annotations.SerializedName <fields>;
        }
    """.trimIndent()
    
    /**
     * 问题2: 资源压缩后找不到资源
     * 原因: 动态获取的资源被移除
     */
    val issue2 = """
        解决方案:
        1. 使用 tools:keep 保留动态资源
        2. 避免使用 getIdentifier() 动态获取资源
        3. 配置 res/raw/keep.xml
        
        示例:
        <?xml version="1.0" encoding="utf-8"?>
        <resources xmlns:tools="http://schemas.android.com/tools"
            tools:keep="@drawable/dynamic_*,@string/dynamic_*"
            tools:shrinkMode="strict" />
    """.trimIndent()
    
    /**
     * 问题3: So 库加载失败
     * 原因: ABI 不匹配或 So 文件损坏
     */
    val issue3 = """
        解决方案:
        1. 检查设备 ABI: Build.SUPPORTED_ABIS
        2. 确保 APK 包含对应 ABI 的 So 文件
        3. 动态加载时检查文件完整性 (MD5)
        4. 设置正确的文件权限 (可执行)
        
        调试代码:
        Log.d("ABI", "Supported ABIs: " + Build.SUPPORTED_ABIS.joinToString())
        Log.d("ABI", "Primary ABI: " + Build.SUPPORTED_ABIS[0])
    """.trimIndent()
    
    /**
     * 问题4: App Bundle 安装失败
     * 原因: Split APK 签名不一致或版本不匹配
     */
    val issue4 = """
        解决方案:
        1. 确保所有 Split APK 使用相同签名
        2. 检查 versionCode 是否一致
        3. 使用 bundletool 验证 AAB
        
        验证命令:
        bundletool validate --bundle=app.aab
        bundletool build-apks --bundle=app.aab --output=app.apks --mode=universal
    """.trimIndent()
    
    /**
     * 问题5: 动态功能模块下载失败
     * 原因: 网络问题或 Play Core 版本不兼容
     */
    val issue5 = """
        解决方案:
        1. 检查网络连接
        2. 更新 Play Core 库版本
        3. 处理各种错误码
        4. 提供降级方案 (内置基础功能)
        
        错误码处理:
        when (errorCode) {
            SplitInstallErrorCode.NETWORK_ERROR -> "网络错误，请检查网络连接"
            SplitInstallErrorCode.INSUFFICIENT_STORAGE -> "存储空间不足"
            SplitInstallErrorCode.MODULE_UNAVAILABLE -> "模块不可用"
            else -> "未知错误: " + errorCode
        }
    """.trimIndent()
}
```


## 5. 常见面试题

### 面试题 1：请介绍一下 APK 的组成结构，以及各部分的优化策略？

**答案要点：**

```
APK 结构及优化策略:

1. DEX 文件 (约 30%)
   - 组成: Java/Kotlin 编译后的字节码
   - 优化策略:
     * 开启 R8/ProGuard 代码混淆和压缩
     * 移除未使用的代码和依赖
     * 使用 R8 全模式进行更激进的优化
     * 移除 Kotlin 元数据 (kotlin/ 目录)

2. 资源文件 (约 40%)
   - 组成: res/ 目录下的图片、布局、values 等
   - 优化策略:
     * PNG/JPEG 转 WebP (节省 25%+)
     * 使用 VectorDrawable 替代位图图标
     * 资源混淆 (AndResGuard)
     * 移除无用资源 (shrinkResources)
     * 只保留必要的屏幕密度和语言

3. Native 库 (约 15-25%)
   - 组成: lib/ 目录下的 .so 文件
   - 优化策略:
     * 只保留必要的 ABI (arm64-v8a)
     * 使用 App Bundle 按设备分发
     * 非核心 So 动态下发
     * strip 移除调试符号

4. Assets 文件 (约 10%)
   - 组成: 原始资源文件
   - 优化策略:
     * 压缩存储，运行时解压
     * 大文件动态下发
     * 按需加载

5. 其他 (约 5%)
   - 组成: AndroidManifest.xml、签名信息等
   - 优化策略:
     * 使用 V2/V3 签名方案
     * 移除不必要的元数据
```

---

### 面试题 2：R8 和 ProGuard 有什么区别？R8 的工作原理是什么？

**答案要点：**

```
R8 vs ProGuard 区别:

1. 处理流程
   - ProGuard: .class → 混淆/优化 → .class → D8 → .dex
   - R8: .class → 混淆/优化/dex转换 → .dex (一步完成)

2. 性能对比
   - R8 编译速度更快 (减少中间步骤)
   - R8 输出体积更小 (更好的优化算法)
   - R8 与 AGP 深度集成

3. 功能差异
   - R8 支持 Kotlin 特定优化
   - R8 支持更多的代码优化模式
   - R8 全模式提供更激进的优化

R8 工作原理:

1. 代码裁剪 (Shrinking)
   - 从入口点 (Entry Points) 开始分析
   - 使用可达性分析标记所有被引用的代码
   - 移除未被标记的类、方法、字段

2. 代码优化 (Optimization)
   - 内联短方法
   - 移除无用参数
   - 合并相同代码
   - 常量折叠和传播

3. 代码混淆 (Obfuscation)
   - 类名、方法名、字段名重命名为短名称
   - 减少字符串池大小
   - 增加逆向难度

4. DEX 转换
   - 将优化后的字节码转换为 DEX 格式
   - 进行 DEX 级别的优化
```

---

### 面试题 3：如何实现 So 库的动态下发？需要注意哪些问题？

**答案要点：**

```
So 库动态下发实现:

1. 服务端准备
   - 按 ABI 分类存储 So 文件
   - 提供版本管理和 MD5 校验
   - 支持增量更新

2. 客户端实现
   - 检测设备 ABI: Build.SUPPORTED_ABIS[0]
   - 下载对应 ABI 的 So 文件
   - 存储到应用私有目录
   - 使用 System.load() 加载

3. 加载方式
   // 从绝对路径加载
   System.load("/data/data/com.example/files/libs/arm64-v8a/libxxx.so")
   
   // 而非从系统路径加载
   System.loadLibrary("xxx")

注意事项:

1. 安全性
   - MD5/SHA256 校验文件完整性
   - 使用 HTTPS 下载
   - 防止中间人攻击

2. 兼容性
   - 处理多 ABI 兼容 (arm64 设备可能需要 arm32 库)
   - 处理 So 依赖关系
   - 版本兼容性检查

3. 用户体验
   - 提供下载进度提示
   - 支持断点续传
   - 预下载机制 (WiFi 环境)
   - 降级方案 (下载失败时的处理)

4. 权限问题
   - 设置文件可执行权限: file.setExecutable(true, false)
   - 存储到正确的目录 (filesDir 而非 cacheDir)

5. 加载时机
   - 在使用前确保 So 已下载
   - 处理加载失败的情况
   - 考虑多线程并发加载
```

---

### 面试题 4：App Bundle 和传统 APK 有什么区别？Dynamic Feature Module 是如何工作的？

**答案要点：**

```
App Bundle vs APK:

1. 发布格式
   - APK: 单一安装包，包含所有资源
   - AAB: 发布格式，由 Google Play 生成优化 APK

2. 体积对比
   - APK: 包含所有 ABI、语言、屏幕密度资源
   - AAB: 按设备配置生成定制 APK，平均节省 35%

3. 分发方式
   - APK: 直接安装
   - AAB: Google Play 生成 Split APKs 安装

Split APK 类型:
- Base APK: 核心代码和资源
- Configuration Splits: ABI、语言、屏幕密度
- Dynamic Feature Splits: 按需下载的功能模块

Dynamic Feature Module 工作原理:

1. 模块定义
   - 使用 com.android.dynamic-feature 插件
   - 在 AndroidManifest.xml 中配置分发方式
   - 可选: on-demand (按需) 或 install-time (安装时)

2. 下载安装
   - 使用 Play Core Library 的 SplitInstallManager
   - 请求下载: startInstall(SplitInstallRequest)
   - 监听状态: SplitInstallStateUpdatedListener

3. 加载使用
   - 安装后自动合并到应用
   - 使用 SplitCompat.installActivity() 确保资源可用
   - 通过反射或 Intent 访问模块中的类

4. 卸载释放
   - 使用 deferredUninstall() 延迟卸载
   - 释放存储空间

适用场景:
- 大型功能模块 (直播、游戏、AR)
- 特定用户群体的功能
- 低频使用的功能
- A/B 测试功能
```

---

### 面试题 5：如何建立包体积监控体系？在 CI/CD 中如何集成？

**答案要点：**

```
包体积监控体系设计:

1. 监控维度
   - 总体积变化趋势
   - 各模块体积占比 (DEX、资源、So、Assets)
   - 新增/删除文件列表
   - 大文件清单
   - 与基准版本对比

2. CI/CD 集成
   
   // Gradle Task 示例
   task checkApkSize {
       dependsOn 'assembleRelease'
       doLast {
           def currentApk = file("app/build/outputs/apk/release/app-release.apk")
           def baselineApk = file("baseline/app-release.apk")
           
           def currentSize = currentApk.length()
           def baselineSize = baselineApk.length()
           def diff = currentSize - baselineSize
           
           if (diff > 1024 * 1024) { // 1MB
               throw new GradleException("APK size increased by ${diff} bytes!")
           }
       }
   }

3. 告警规则
   - 单次增量 > 500KB: 警告
   - 单次增量 > 1MB: 阻断 MR
   - 新增大文件 (>100KB): 需审批
   - 新增 So 库: 需审批

4. 报告内容
   - 体积变化摘要
   - 详细文件变化列表
   - 优化建议
   - 历史趋势图表

5. 工具选择
   - APK Analyzer (Android Studio)
   - apkanalyzer (命令行)
   - bundletool (AAB 分析)
   - 自定义分析脚本

6. 最佳实践
   - 保存每个版本的 APK 作为基准
   - 定期清理基准，保留关键版本
   - 自动生成周报/月报
   - 建立体积预算机制
   - 新功能上线前评估体积影响
```

---

### 面试题 6：资源混淆 (AndResGuard) 的原理是什么？有哪些注意事项？

**答案要点：**

```
AndResGuard 原理:

1. 资源路径混淆
   - 原始: res/drawable-xxhdpi/ic_launcher.png
   - 混淆后: r/d/a.png
   - 缩短路径和文件名，减少字符串池大小

2. resources.arsc 优化
   - 重写资源索引表
   - 缩短资源名称
   - 合并重复资源

3. 7zip 重压缩
   - 使用 7zip 替代 zip 压缩
   - 更高的压缩率

工作流程:
1. 解压 APK
2. 解析 resources.arsc
3. 重命名资源文件
4. 重写 resources.arsc
5. 使用 7zip 重新压缩
6. 重新签名

注意事项:

1. 白名单配置
   - 第三方 SDK 需要的资源
   - 通过 getIdentifier() 动态获取的资源
   - 反射访问的资源
   
   whiteList = [
       "R.drawable.icon",
       "R.string.app_name",
       "R.drawable.notification_*"
   ]

2. 兼容性问题
   - WebView 加载的本地资源
   - 某些 ROM 的兼容性
   - 第三方库的资源引用

3. 调试困难
   - 保存 mapping 文件用于问题排查
   - 开发环境不建议开启

4. 与其他工具配合
   - 需要在 R8 之后执行
   - 需要重新签名
```

---

### 面试题 7：如何分析和优化 DEX 文件大小？MultiDex 对包体积有什么影响？

**答案要点：**

```
DEX 文件分析:

1. 分析工具
   - APK Analyzer: 查看 DEX 文件内容
   - dexdump: 命令行分析工具
   - apkanalyzer dex packages: 查看包大小

2. DEX 组成
   - 类定义 (class_defs)
   - 方法代码 (code_item)
   - 字符串池 (string_ids)
   - 类型池 (type_ids)
   - 方法签名 (proto_ids)

3. 优化策略
   - 移除未使用的类和方法 (R8)
   - 减少方法数 (避免 MultiDex)
   - 优化字符串使用
   - 移除调试信息

MultiDex 影响:

1. 体积影响
   - 每个 DEX 文件有独立的字符串池
   - 跨 DEX 引用增加开销
   - 总体积略有增加

2. 性能影响
   - 冷启动时需要加载多个 DEX
   - Android 5.0 以下需要额外处理
   - 类加载可能跨 DEX 查找

3. 优化建议
   - 尽量控制方法数在 65536 以内
   - 使用 R8 移除未使用代码
   - 合理拆分模块
   - 主 DEX 保留启动必需的类

4. 方法数统计
   // 使用 apkanalyzer
   apkanalyzer dex references app.apk
   
   // 输出示例
   classes.dex: 45000 methods
   classes2.dex: 20000 methods
```

---

### 面试题 8：字节跳动/美团等大厂是如何做包体积优化的？有哪些业界最佳实践？

**答案要点：**

```
大厂包体积优化实践:

1. 字节跳动
   - 自研包体积分析平台
   - 细粒度的体积归因 (精确到代码行)
   - 严格的体积预算机制
   - 动态下发 + 插件化架构
   - So 库按需加载

2. 美团
   - 资源混淆 + 7zip 压缩
   - 图片自动转 WebP
   - 模块化拆分 + 动态下发
   - 包体积监控告警系统
   - 定期体积治理专项

3. 快手
   - 视频/音频编解码库动态下发
   - 多 ABI 按需分发
   - 资源按需下载
   - 增量更新优化

业界最佳实践:

1. 建立体积预算
   - 每个模块分配体积配额
   - 超出配额需要审批
   - 定期 review 体积变化

2. 自动化监控
   - CI/CD 集成体积检查
   - 自动生成体积报告
   - 异常增长自动告警

3. 技术方案
   - App Bundle + Dynamic Feature
   - 资源混淆 (AndResGuard)
   - So 动态下发
   - 插件化架构

4. 组织保障
   - 专人负责体积优化
   - 定期体积治理专项
   - 体积指标纳入 KPI

5. 工具建设
   - 自研体积分析工具
   - 体积归因系统
   - 优化建议自动生成
```

---

### 面试题 9：如何优化图片资源？WebP、VectorDrawable、SVG 各有什么优缺点？

**答案要点：**

```
图片格式对比:

1. WebP
   优点:
   - 比 PNG 小 25-35%
   - 比 JPEG 小 25-34%
   - 支持透明度和动画
   - Android 4.0+ 支持
   
   缺点:
   - 编解码略慢于 PNG/JPEG
   - 部分老设备兼容性问题
   
   适用场景:
   - 照片、复杂图片
   - 需要透明度的图片
   - 替代 PNG/JPEG

2. VectorDrawable
   优点:
   - 体积极小 (通常 < 1KB)
   - 无限缩放不失真
   - 支持动画
   - 可动态着色
   
   缺点:
   - 复杂图形渲染性能差
   - 不适合照片类图片
   - 设计工具支持有限
   
   适用场景:
   - 图标、Logo
   - 简单图形
   - 需要多尺寸适配的图片

3. SVG
   优点:
   - 通用矢量格式
   - 设计工具支持好
   
   缺点:
   - Android 不直接支持
   - 需要转换为 VectorDrawable
   - 复杂 SVG 转换可能失败
   
   使用方式:
   - Android Studio 导入时自动转换
   - 使用第三方库 (AndroidSVG)

优化建议:
1. 图标类: 优先使用 VectorDrawable
2. 照片类: 使用 WebP
3. 大图: 网络加载 + 缓存
4. 纯色图: 使用 Shape Drawable
5. 多色图标: 使用 Tint 着色复用
```

---

### 面试题 10：包体积优化和启动速度优化有什么关系？如何平衡两者？

**答案要点：**

```
包体积与启动速度的关系:

1. 正相关因素
   - DEX 文件大小影响类加载时间
   - 资源文件影响解压和加载时间
   - So 库影响加载时间

2. 可能的冲突
   - 动态下发: 减小包体积，但首次使用需要下载
   - So 压缩: 减小包体积，但需要运行时解压
   - 代码混淆: 减小体积，但可能影响反射性能

平衡策略:

1. 启动路径优化
   - 启动必需的代码放在主 DEX
   - 启动资源不压缩或预解压
   - 启动 So 库内置，非启动 So 动态下发

2. 分级策略
   - 核心功能: 内置，优先保证启动速度
   - 次要功能: 可动态下发
   - 低频功能: 按需下载

3. 预加载机制
   - 后台预下载动态模块
   - 预解压压缩资源
   - 预加载 So 库

4. 监控指标
   - 同时监控包体积和启动时间
   - 建立两者的平衡基准
   - 优化时评估对另一指标的影响

5. 技术方案
   - Baseline Profile: 优化启动，不影响体积
   - App Bundle: 减小下载体积，不影响运行
   - 增量更新: 减小更新体积，不影响启动

最佳实践:
- 启动路径代码: 优化性能优先
- 非启动代码: 优化体积优先
- 定期评估两者平衡点
```

---

*文档版本: v1.0*
*更新时间: 2024-01*
*适用版本: Android W*
*目标公司: 字节、美团、快手、OPPO、vivo*
