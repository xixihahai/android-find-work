# 响应式编程

## 1. 概述

响应式编程是一种基于数据流和变化传播的编程范式。Android 中主要使用 RxJava 和 Kotlin Flow。

## 2. 核心原理

### 2.1 RxJava 核心概念

```
┌─────────────────────────────────────────────────────────────┐
│                    RxJava 核心概念                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   Observable (被观察者)                                      │
│       │                                                     │
│       │ subscribe                                           │
│       ▼                                                     │
│   Observer (观察者)                                          │
│       - onNext(T)      接收数据                              │
│       - onError(e)     接收错误                              │
│       - onComplete()   完成通知                              │
│                                                             │
│   Scheduler (调度器)                                         │
│       - Schedulers.io()           IO 线程                   │
│       - Schedulers.computation()  计算线程                   │
│       - AndroidSchedulers.mainThread()  主线程              │
│                                                             │
│   Operator (操作符)                                          │
│       - 创建：create, just, fromIterable                    │
│       - 转换：map, flatMap, concatMap                       │
│       - 过滤：filter, take, skip                            │
│       - 组合：merge, zip, combineLatest                     │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 RxJava 基本使用

```kotlin
// 创建 Observable
val observable = Observable.create<Int> { emitter ->
    emitter.onNext(1)
    emitter.onNext(2)
    emitter.onNext(3)
    emitter.onComplete()
}

// 订阅
observable
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(
        { value -> println("onNext: $value") },
        { error -> println("onError: $error") },
        { println("onComplete") }
    )

// 常用操作符
Observable.just(1, 2, 3, 4, 5)
    .filter { it > 2 }           // 过滤
    .map { it * 2 }              // 转换
    .take(2)                     // 取前 2 个
    .subscribe { println(it) }   // 输出: 6, 8
```

### 2.3 RxJava 原理

```java
// Observable.java
public abstract class Observable<T> implements ObservableSource<T> {
    
    // 创建 Observable
    public static <T> Observable<T> create(ObservableOnSubscribe<T> source) {
        return new ObservableCreate<>(source);
    }
    
    // 订阅
    @Override
    public final void subscribe(Observer<? super T> observer) {
        // 包装 Observer
        observer = RxJavaPlugins.onSubscribe(this, observer);
        // 调用 subscribeActual
        subscribeActual(observer);
    }
    
    protected abstract void subscribeActual(Observer<? super T> observer);
}

// ObservableCreate.java
public final class ObservableCreate<T> extends Observable<T> {
    final ObservableOnSubscribe<T> source;
    
    @Override
    protected void subscribeActual(Observer<? super T> observer) {
        // 创建 Emitter
        CreateEmitter<T> parent = new CreateEmitter<>(observer);
        // 通知订阅
        observer.onSubscribe(parent);
        // 执行订阅逻辑
        source.subscribe(parent);
    }
}

// 装饰器模式 - map 操作符
public final class ObservableMap<T, U> extends AbstractObservableWithUpstream<T, U> {
    final Function<? super T, ? extends U> function;
    
    @Override
    protected void subscribeActual(Observer<? super U> observer) {
        // 包装 Observer
        source.subscribe(new MapObserver<>(observer, function));
    }
    
    static final class MapObserver<T, U> implements Observer<T> {
        final Observer<? super U> downstream;
        final Function<? super T, ? extends U> mapper;
        
        @Override
        public void onNext(T t) {
            U v = mapper.apply(t);
            downstream.onNext(v);
        }
    }
}
```

### 2.4 RxJava vs Kotlin Flow

```kotlin
// RxJava
fun getUserRx(): Observable<User> {
    return Observable.create { emitter ->
        val user = api.getUser()
        emitter.onNext(user)
        emitter.onComplete()
    }
}

// Kotlin Flow
fun getUserFlow(): Flow<User> = flow {
    val user = api.getUser()
    emit(user)
}

// 对比
/*
┌─────────────────────────────────────────────────────────────┐
│                  RxJava vs Kotlin Flow                       │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   特性          │  RxJava           │  Kotlin Flow          │
│   ─────────────┼───────────────────┼─────────────────────── │
│   冷/热流      │  Observable(热)    │  Flow(冷)             │
│                │  Flowable(冷)     │  StateFlow(热)        │
│   背压        │  Flowable 支持     │  buffer/conflate      │
│   取消        │  Disposable       │  协程取消              │
│   线程切换    │  subscribeOn/     │  flowOn/              │
│               │  observeOn        │  collect              │
│   操作符      │  丰富              │  较少但够用            │
│   学习成本    │  高                │  低                   │
│   包大小      │  大                │  小                   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
*/
```

### 2.5 EventBus 原理

```java
// EventBus.java
public class EventBus {
    // 订阅者方法缓存
    private final Map<Class<?>, CopyOnWriteArrayList<Subscription>> subscriptionsByEventType;
    // 订阅者的事件类型
    private final Map<Object, List<Class<?>>> typesBySubscriber;
    
    // 注册
    public void register(Object subscriber) {
        Class<?> subscriberClass = subscriber.getClass();
        // 查找订阅方法
        List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
        synchronized (this) {
            for (SubscriberMethod subscriberMethod : subscriberMethods) {
                subscribe(subscriber, subscriberMethod);
            }
        }
    }
    
    // 订阅
    private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
        Class<?> eventType = subscriberMethod.eventType;
        Subscription newSubscription = new Subscription(subscriber, subscriberMethod);
        
        CopyOnWriteArrayList<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
        if (subscriptions == null) {
            subscriptions = new CopyOnWriteArrayList<>();
            subscriptionsByEventType.put(eventType, subscriptions);
        }
        subscriptions.add(newSubscription);
    }
    
    // 发送事件
    public void post(Object event) {
        PostingThreadState postingState = currentPostingThreadState.get();
        List<Object> eventQueue = postingState.eventQueue;
        eventQueue.add(event);
        
        while (!eventQueue.isEmpty()) {
            postSingleEvent(eventQueue.remove(0), postingState);
        }
    }
    
    private void postSingleEvent(Object event, PostingThreadState postingState) {
        Class<?> eventClass = event.getClass();
        // 查找订阅者
        CopyOnWriteArrayList<Subscription> subscriptions = subscriptionsByEventType.get(eventClass);
        if (subscriptions != null) {
            for (Subscription subscription : subscriptions) {
                postToSubscription(subscription, event, postingState.isMainThread);
            }
        }
    }
    
    // 根据线程模式分发
    private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {
        switch (subscription.subscriberMethod.threadMode) {
            case POSTING:
                invokeSubscriber(subscription, event);
                break;
            case MAIN:
                if (isMainThread) {
                    invokeSubscriber(subscription, event);
                } else {
                    mainThreadPoster.enqueue(subscription, event);
                }
                break;
            case BACKGROUND:
                if (isMainThread) {
                    backgroundPoster.enqueue(subscription, event);
                } else {
                    invokeSubscriber(subscription, event);
                }
                break;
            case ASYNC:
                asyncPoster.enqueue(subscription, event);
                break;
        }
    }
}

// 使用示例
class MyActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        EventBus.getDefault().register(this)
    }
    
    override fun onDestroy() {
        super.onDestroy()
        EventBus.getDefault().unregister(this)
    }
    
    @Subscribe(threadMode = ThreadMode.MAIN)
    fun onMessageEvent(event: MessageEvent) {
        // 处理事件
    }
}
```

## 3. 关键源码解析

### 3.1 RxJava 线程切换

```java
// subscribeOn - 指定订阅线程
public final Observable<T> subscribeOn(Scheduler scheduler) {
    return new ObservableSubscribeOn<>(this, scheduler);
}

// ObservableSubscribeOn.java
public final class ObservableSubscribeOn<T> extends AbstractObservableWithUpstream<T, T> {
    final Scheduler scheduler;
    
    @Override
    protected void subscribeActual(Observer<? super T> observer) {
        SubscribeOnObserver<T> parent = new SubscribeOnObserver<>(observer);
        observer.onSubscribe(parent);
        // 在指定线程执行订阅
        parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));
    }
    
    final class SubscribeTask implements Runnable {
        @Override
        public void run() {
            source.subscribe(parent);
        }
    }
}

// observeOn - 指定观察线程
public final Observable<T> observeOn(Scheduler scheduler) {
    return new ObservableObserveOn<>(this, scheduler, false, bufferSize());
}

// ObservableObserveOn.java
public final class ObservableObserveOn<T> extends AbstractObservableWithUpstream<T, T> {
    @Override
    protected void subscribeActual(Observer<? super T> observer) {
        Scheduler.Worker w = scheduler.createWorker();
        source.subscribe(new ObserveOnObserver<>(observer, w, delayError, bufferSize));
    }
    
    static final class ObserveOnObserver<T> implements Observer<T>, Runnable {
        @Override
        public void onNext(T t) {
            // 加入队列
            queue.offer(t);
            schedule();
        }
        
        void schedule() {
            // 在指定线程执行
            worker.schedule(this);
        }
        
        @Override
        public void run() {
            // 从队列取出并分发
            T v = queue.poll();
            downstream.onNext(v);
        }
    }
}
```

## 4. 实战应用

### 4.1 RxJava 最佳实践

```kotlin
// 1. 网络请求
apiService.getUser(userId)
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(
        { user -> updateUI(user) },
        { error -> showError(error) }
    )

// 2. 搜索防抖
searchEditText.textChanges()
    .debounce(300, TimeUnit.MILLISECONDS)
    .filter { it.isNotBlank() }
    .distinctUntilChanged()
    .switchMap { query -> apiService.search(query) }
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe { results -> showResults(results) }

// 3. 并行请求
Observable.zip(
    apiService.getUser(userId),
    apiService.getPosts(userId),
    apiService.getComments(userId)
) { user, posts, comments ->
    CombinedData(user, posts, comments)
}
.subscribeOn(Schedulers.io())
.observeOn(AndroidSchedulers.mainThread())
.subscribe { data -> updateUI(data) }

// 4. 内存泄漏处理
class MyActivity : AppCompatActivity() {
    private val compositeDisposable = CompositeDisposable()
    
    fun loadData() {
        compositeDisposable.add(
            apiService.getData()
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe { data -> updateUI(data) }
        )
    }
    
    override fun onDestroy() {
        super.onDestroy()
        compositeDisposable.clear()
    }
}
```

## 5. 常见面试题

### 问题1：RxJava 的核心思想是什么？

**答案要点**：
- 观察者模式：Observable 和 Observer
- 函数式编程：操作符链式调用
- 异步编程：Scheduler 线程切换
- 响应式：数据流驱动

### 问题2：subscribeOn 和 observeOn 的区别是什么？

**答案要点**：
- subscribeOn：指定订阅（数据发射）线程，只有第一个生效
- observeOn：指定观察（数据接收）线程，可以多次切换
- subscribeOn 影响上游，observeOn 影响下游

### 问题3：RxJava 如何处理背压？

**答案要点**：
- 使用 Flowable 代替 Observable
- 背压策略：BUFFER、DROP、LATEST、ERROR
- 使用 onBackpressureBuffer/Drop/Latest

### 问题4：EventBus 的原理是什么？

**答案要点**：
- 发布-订阅模式
- 注解处理器查找订阅方法
- Map 存储事件类型和订阅者
- 根据 ThreadMode 分发到不同线程

### 问题5：RxJava 和 Kotlin Flow 如何选择？

**答案要点**：
- 新项目推荐 Kotlin Flow
- Flow 与协程集成更好
- RxJava 操作符更丰富
- Flow 学习成本更低
