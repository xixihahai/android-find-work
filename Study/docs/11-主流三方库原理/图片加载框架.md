# 图片加载框架

## 1. 概述

图片加载是 Android 开发中的常见需求，主流框架包括 Glide、Coil、Picasso 等。本文重点分析 Glide 和 Coil 的原理。

### 框架对比

| 特性 | Glide | Coil | Picasso |
|------|-------|------|---------|
| 语言 | Java | Kotlin | Java |
| 协程支持 | 否 | 是 | 否 |
| 生命周期 | 自动管理 | 自动管理 | 手动管理 |
| 缓存 | 内存+磁盘 | 内存+磁盘 | 内存+磁盘 |
| GIF 支持 | 是 | 是 | 否 |
| 包大小 | ~500KB | ~250KB | ~120KB |

## 2. 核心原理

### 2.1 Glide 整体架构

```
┌─────────────────────────────────────────────────────────────┐
│                    Glide 架构图                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   ┌──────────────────────────────────────────────────────┐  │
│   │                      Glide                           │  │
│   │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  │  │
│   │  │RequestManager│  │   Engine    │  │MemoryCache │  │  │
│   │  └──────┬──────┘  └──────┬──────┘  └─────────────┘  │  │
│   │         │                │                          │  │
│   │         ▼                ▼                          │  │
│   │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  │  │
│   │  │   Request   │  │ DecodeJob  │  │ DiskCache   │  │  │
│   │  └──────┬──────┘  └──────┬──────┘  └─────────────┘  │  │
│   │         │                │                          │  │
│   │         ▼                ▼                          │  │
│   │  ┌─────────────┐  ┌─────────────┐                   │  │
│   │  │   Target    │  │ DataFetcher │                   │  │
│   │  └─────────────┘  └─────────────┘                   │  │
│   └──────────────────────────────────────────────────────┘  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 Glide 生命周期管理

```java
// RequestManagerRetriever.java
public RequestManager get(@NonNull FragmentActivity activity) {
    if (Util.isOnBackgroundThread()) {
        return get(activity.getApplicationContext());
    }
    
    // 获取或创建 SupportRequestManagerFragment
    FragmentManager fm = activity.getSupportFragmentManager();
    return supportFragmentGet(activity, fm, null, isActivityVisible(activity));
}

private RequestManager supportFragmentGet(Context context, FragmentManager fm,
        Fragment parentHint, boolean isParentVisible) {
    // 获取或创建空白 Fragment
    SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm, parentHint);
    
    RequestManager requestManager = current.getRequestManager();
    if (requestManager == null) {
        // 创建 RequestManager
        Glide glide = Glide.get(context);
        requestManager = factory.build(glide, current.getGlideLifecycle(),
                current.getRequestManagerTreeNode(), context);
        current.setRequestManager(requestManager);
    }
    return requestManager;
}

// SupportRequestManagerFragment.java
public class SupportRequestManagerFragment extends Fragment {
    private final ActivityFragmentLifecycle lifecycle;
    
    @Override
    public void onStart() {
        super.onStart();
        lifecycle.onStart();  // 通知 RequestManager
    }
    
    @Override
    public void onStop() {
        super.onStop();
        lifecycle.onStop();  // 暂停请求
    }
    
    @Override
    public void onDestroy() {
        super.onDestroy();
        lifecycle.onDestroy();  // 取消请求
    }
}
```

### 2.3 Glide 缓存机制

```java
// 缓存层级
/*
┌─────────────────────────────────────────────────────────────┐
│                    Glide 缓存层级                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   1. ActiveResources (活跃资源缓存)                          │
│      - 正在使用的资源                                        │
│      - 弱引用存储                                           │
│                                                             │
│   2. MemoryCache (内存缓存)                                  │
│      - LruCache 实现                                        │
│      - 默认大小：可用内存的 1/8                              │
│                                                             │
│   3. DiskCache (磁盘缓存)                                    │
│      - DiskLruCache 实现                                    │
│      - 默认大小：250MB                                       │
│      - 两种策略：DATA (原始数据) / RESOURCE (处理后)          │
│                                                             │
│   4. Network (网络)                                          │
│      - 从网络下载                                           │
│                                                             │
└─────────────────────────────────────────────────────────────┘
*/

// Engine.java - 加载流程
public <R> LoadStatus load(...) {
    // 1. 从 ActiveResources 获取
    EngineResource<?> active = loadFromActiveResources(key, isMemoryCacheable);
    if (active != null) {
        cb.onResourceReady(active, DataSource.MEMORY_CACHE);
        return null;
    }
    
    // 2. 从 MemoryCache 获取
    EngineResource<?> cached = loadFromCache(key, isMemoryCacheable);
    if (cached != null) {
        cb.onResourceReady(cached, DataSource.MEMORY_CACHE);
        return null;
    }
    
    // 3. 从磁盘或网络获取
    EngineJob<R> engineJob = engineJobFactory.build(...);
    DecodeJob<R> decodeJob = decodeJobFactory.build(...);
    
    jobs.put(key, engineJob);
    engineJob.addCallback(cb, callbackExecutor);
    engineJob.start(decodeJob);
    
    return new LoadStatus(cb, engineJob);
}

// DecodeJob.java - 解码任务
private void runWrapped() {
    switch (runReason) {
        case INITIALIZE:
            stage = getNextStage(Stage.INITIALIZE);
            currentGenerator = getNextGenerator();
            runGenerators();
            break;
        case SWITCH_TO_SOURCE_SERVICE:
            runGenerators();
            break;
        case DECODE_DATA:
            decodeFromRetrievedData();
            break;
    }
}

// 获取下一个数据源
private DataFetcherGenerator getNextGenerator() {
    switch (stage) {
        case RESOURCE_CACHE:
            return new ResourceCacheGenerator(decodeHelper, this);
        case DATA_CACHE:
            return new DataCacheGenerator(decodeHelper, this);
        case SOURCE:
            return new SourceGenerator(decodeHelper, this);
        case FINISHED:
            return null;
    }
}
```

### 2.4 Glide 图片变换

```java
// Transformation 接口
public interface Transformation<T> {
    Resource<T> transform(Context context, Resource<T> resource, int outWidth, int outHeight);
}

// 圆形裁剪
public class CircleCrop extends BitmapTransformation {
    @Override
    protected Bitmap transform(BitmapPool pool, Bitmap toTransform,
            int outWidth, int outHeight) {
        return TransformationUtils.circleCrop(pool, toTransform, outWidth, outHeight);
    }
}

// 圆角
public class RoundedCorners extends BitmapTransformation {
    private final int roundingRadius;
    
    @Override
    protected Bitmap transform(BitmapPool pool, Bitmap toTransform,
            int outWidth, int outHeight) {
        return TransformationUtils.roundedCorners(pool, toTransform, roundingRadius);
    }
}

// 使用示例
Glide.with(context)
    .load(url)
    .transform(CircleCrop())
    .into(imageView)
```

### 2.5 Coil 原理

```kotlin
// Coil 基于协程实现
// ImageLoader.kt
class RealImageLoader(
    val context: Context,
    override val defaults: DefaultRequestOptions,
    val memoryCacheLazy: Lazy<MemoryCache?>,
    val diskCacheLazy: Lazy<DiskCache?>,
    val callFactory: Lazy<Call.Factory>,
    val eventListenerFactory: EventListener.Factory,
    val componentRegistry: ComponentRegistry,
    val options: ImageLoaderOptions,
    val logger: Logger?
) : ImageLoader {
    
    override fun enqueue(request: ImageRequest): Disposable {
        // 启动协程执行请求
        val job = scope.async {
            executeMain(request, REQUEST_TYPE_ENQUEUE).also { result ->
                if (result is ErrorResult) {
                    logger?.log(TAG, Log.ERROR, result.throwable.message, result.throwable)
                }
            }
        }
        return OneShotDisposable(job)
    }
    
    override suspend fun execute(request: ImageRequest): ImageResult {
        return executeMain(request, REQUEST_TYPE_EXECUTE)
    }
    
    private suspend fun executeMain(request: ImageRequest, type: Int): ImageResult {
        // 1. 检查内存缓存
        val memoryCacheKey = request.memoryCacheKey
        val memoryCacheValue = memoryCache?.get(memoryCacheKey)
        if (memoryCacheValue != null) {
            return SuccessResult(
                drawable = memoryCacheValue.bitmap.toDrawable(context.resources),
                request = request,
                dataSource = DataSource.MEMORY_CACHE
            )
        }
        
        // 2. 执行请求
        return withContext(request.dispatcher) {
            execute(request, type, memoryCacheKey)
        }
    }
}

// 使用示例
imageView.load(url) {
    crossfade(true)
    placeholder(R.drawable.placeholder)
    error(R.drawable.error)
    transformations(CircleCropTransformation())
}
```

## 3. 关键源码解析

### 3.1 Glide 请求流程

```java
// RequestBuilder.java
public ViewTarget<ImageView, TranscodeType> into(@NonNull ImageView view) {
    // 创建 Target
    ViewTarget<ImageView, TranscodeType> target = buildImageViewTarget(view, transcodeClass);
    return into(target, null, Executors.mainThreadExecutor());
}

private <Y extends Target<TranscodeType>> Y into(Y target, RequestListener<TranscodeType> targetListener,
        Executor callbackExecutor) {
    // 构建 Request
    Request request = buildRequest(target, targetListener, options, callbackExecutor);
    
    // 获取之前的 Request
    Request previous = target.getRequest();
    if (request.isEquivalentTo(previous)) {
        // 相同请求，复用
        if (!Preconditions.checkNotNull(previous).isRunning()) {
            previous.begin();
        }
        return target;
    }
    
    // 清除之前的请求
    requestManager.clear(target);
    
    // 设置新请求
    target.setRequest(request);
    requestManager.track(target, request);
    
    return target;
}

// SingleRequest.java
@Override
public void begin() {
    synchronized (requestLock) {
        if (status == Status.RUNNING) {
            return;
        }
        
        // 如果有缓存的资源
        if (Util.isValidDimensions(overrideWidth, overrideHeight)) {
            onSizeReady(overrideWidth, overrideHeight);
        } else {
            // 等待 View 测量完成
            target.getSize(this);
        }
    }
}

@Override
public void onSizeReady(int width, int height) {
    synchronized (requestLock) {
        // 开始加载
        loadStatus = engine.load(
                glideContext,
                model,
                requestOptions.getSignature(),
                this.width,
                this.height,
                requestOptions.getResourceClass(),
                transcodeClass,
                priority,
                requestOptions.getDiskCacheStrategy(),
                requestOptions.getTransformations(),
                requestOptions.isTransformationRequired(),
                requestOptions.isScaleOnlyOrNoTransform(),
                requestOptions.getOptions(),
                requestOptions.isMemoryCacheable(),
                requestOptions.getUseUnlimitedSourceGeneratorsPool(),
                requestOptions.getUseAnimationPool(),
                requestOptions.getOnlyRetrieveFromCache(),
                this,
                callbackExecutor);
    }
}
```

## 4. 实战应用

### 4.1 Glide 最佳实践

```kotlin
// 1. 基本使用
Glide.with(context)
    .load(url)
    .placeholder(R.drawable.placeholder)
    .error(R.drawable.error)
    .into(imageView)

// 2. 自定义配置
@GlideModule
class MyAppGlideModule : AppGlideModule() {
    override fun applyOptions(context: Context, builder: GlideBuilder) {
        // 内存缓存大小
        builder.setMemoryCache(LruResourceCache(20 * 1024 * 1024))
        
        // 磁盘缓存
        builder.setDiskCache(InternalCacheDiskCacheFactory(context, 100 * 1024 * 1024))
        
        // 默认请求选项
        builder.setDefaultRequestOptions(
            RequestOptions()
                .format(DecodeFormat.PREFER_RGB_565)
                .diskCacheStrategy(DiskCacheStrategy.ALL)
        )
    }
}

// 3. 预加载
Glide.with(context)
    .load(url)
    .preload()

// 4. 清除缓存
// 清除内存缓存（主线程）
Glide.get(context).clearMemory()

// 清除磁盘缓存（子线程）
Thread {
    Glide.get(context).clearDiskCache()
}.start()
```

## 5. 常见面试题

### 问题1：Glide 的缓存机制是怎样的？

**答案要点**：
- **ActiveResources**：正在使用的资源，弱引用
- **MemoryCache**：LruCache，默认可用内存的 1/8
- **DiskCache**：DiskLruCache，默认 250MB
- 查找顺序：Active → Memory → Disk → Network

### 问题2：Glide 如何管理生命周期？

**答案要点**：
- 添加空白 Fragment 到 Activity/Fragment
- Fragment 生命周期回调通知 RequestManager
- onStart 恢复请求，onStop 暂停请求，onDestroy 取消请求

### 问题3：Glide 和 Coil 的区别是什么？

**答案要点**：
- Coil 基于 Kotlin 协程，Glide 基于线程池
- Coil 包更小，API 更简洁
- Glide 功能更丰富，生态更完善
- Coil 更适合纯 Kotlin 项目

### 问题4：如何优化图片加载性能？

**答案要点**：
- 使用合适的图片格式（RGB_565 vs ARGB_8888）
- 设置合适的缓存策略
- 使用 thumbnail 加载缩略图
- 列表滑动时暂停加载
- 预加载即将显示的图片

### 问题5：Glide 如何处理大图？

**答案要点**：
- 自动根据 ImageView 大小采样
- 使用 override() 指定加载尺寸
- 使用 BitmapRegionDecoder 加载超大图
