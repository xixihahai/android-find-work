# 依赖注入框架

## 1. 概述

依赖注入（DI）是一种设计模式，用于实现控制反转（IoC）。Android 主流 DI 框架包括 Hilt、Dagger、Koin。

### 框架对比

| 特性 | Hilt | Dagger | Koin |
|------|------|--------|------|
| 实现方式 | 编译时生成 | 编译时生成 | 运行时反射 |
| 性能 | 高 | 高 | 较低 |
| 学习成本 | 中 | 高 | 低 |
| Android 支持 | 原生支持 | 需要配置 | 原生支持 |
| 错误检测 | 编译时 | 编译时 | 运行时 |

## 2. 核心原理

### 2.1 Hilt 架构

```
┌─────────────────────────────────────────────────────────────┐
│                    Hilt 组件层级                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   ┌─────────────────────────────────────────────────────┐   │
│   │              SingletonComponent                     │   │
│   │              (Application 生命周期)                  │   │
│   └───────────────────────┬─────────────────────────────┘   │
│                           │                                 │
│           ┌───────────────┼───────────────┐                │
│           │               │               │                │
│           ▼               ▼               ▼                │
│   ┌───────────────┐ ┌───────────────┐ ┌───────────────┐   │
│   │ActivityRetained│ │ServiceComponent│ │ViewModelComp │   │
│   │   Component   │ │               │ │   onent      │   │
│   └───────┬───────┘ └───────────────┘ └───────────────┘   │
│           │                                                │
│           ▼                                                │
│   ┌───────────────┐                                       │
│   │Activity       │                                       │
│   │  Component    │                                       │
│   └───────┬───────┘                                       │
│           │                                                │
│           ▼                                                │
│   ┌───────────────┐                                       │
│   │Fragment       │                                       │
│   │  Component    │                                       │
│   └───────────────┘                                       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 Hilt 使用

```kotlin
// 1. Application
@HiltAndroidApp
class MyApplication : Application()

// 2. Activity
@AndroidEntryPoint
class MainActivity : AppCompatActivity() {
    @Inject
    lateinit var repository: UserRepository
}

// 3. ViewModel
@HiltViewModel
class MainViewModel @Inject constructor(
    private val repository: UserRepository
) : ViewModel()

// 4. Module
@Module
@InstallIn(SingletonComponent::class)
object AppModule {
    
    @Provides
    @Singleton
    fun provideOkHttpClient(): OkHttpClient {
        return OkHttpClient.Builder().build()
    }
    
    @Provides
    @Singleton
    fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit {
        return Retrofit.Builder()
            .baseUrl("https://api.example.com/")
            .client(okHttpClient)
            .build()
    }
}

// 5. 接口绑定
@Module
@InstallIn(SingletonComponent::class)
abstract class RepositoryModule {
    
    @Binds
    @Singleton
    abstract fun bindUserRepository(impl: UserRepositoryImpl): UserRepository
}
```

### 2.3 Hilt 生成代码分析

```java
// Hilt 生成的 Application
public abstract class Hilt_MyApplication extends Application implements GeneratedComponentManagerHolder {
    private final ApplicationComponentManager componentManager = new ApplicationComponentManager(
        new ComponentSupplier() {
            @Override
            public Object get() {
                return DaggerMyApplication_HiltComponents_SingletonC.builder()
                    .applicationContextModule(new ApplicationContextModule(Hilt_MyApplication.this))
                    .build();
            }
        }
    );
    
    @Override
    public final GeneratedComponentManager<?> componentManager() {
        return componentManager;
    }
    
    protected void inject() {
        ((MyApplication_GeneratedInjector) componentManager().generatedComponent())
            .injectMyApplication(UnsafeCasts.<MyApplication>unsafeCast(this));
    }
}

// Hilt 生成的 Activity
public abstract class Hilt_MainActivity extends AppCompatActivity implements GeneratedComponentManagerHolder {
    
    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        inject();
        super.onCreate(savedInstanceState);
    }
    
    protected void inject() {
        ((MainActivity_GeneratedInjector) this.generatedComponent())
            .injectMainActivity(this);
    }
}
```

### 2.4 Koin 原理

```kotlin
// Koin 基于 DSL 和运行时反射
// 定义模块
val appModule = module {
    single { OkHttpClient.Builder().build() }
    single { Retrofit.Builder().client(get()).build() }
    single<UserRepository> { UserRepositoryImpl(get()) }
    viewModel { MainViewModel(get()) }
}

// 启动 Koin
class MyApplication : Application() {
    override fun onCreate() {
        super.onCreate()
        startKoin {
            androidContext(this@MyApplication)
            modules(appModule)
        }
    }
}

// 使用
class MainActivity : AppCompatActivity() {
    private val viewModel: MainViewModel by viewModel()
    private val repository: UserRepository by inject()
}

// Koin 核心源码
// Scope.kt
class Scope(val scopeDefinition: ScopeDefinition, val id: ScopeID) {
    
    // 实例缓存
    private val _instances = hashMapOf<IndexKey, InstanceFactory<*>>()
    
    // 获取实例
    fun <T> get(clazz: KClass<*>, qualifier: Qualifier?, parameters: ParametersDefinition?): T {
        val indexKey = indexKey(clazz, qualifier)
        val instance = _instances[indexKey]
        
        return if (instance != null) {
            instance.get(InstanceContext(this, parameters)) as T
        } else {
            // 从父 Scope 查找
            _parentScope?.get(clazz, qualifier, parameters)
                ?: throw NoBeanDefFoundException("No definition found for $clazz")
        }
    }
}

// InstanceFactory.kt
sealed class InstanceFactory<T> {
    abstract fun get(context: InstanceContext): T
    
    // 单例
    class Single<T>(val definition: Definition<T>) : InstanceFactory<T>() {
        private var value: T? = null
        
        override fun get(context: InstanceContext): T {
            return value ?: synchronized(this) {
                value ?: definition(context.scope, context.parameters ?: emptyParametersHolder())
                    .also { value = it }
            }
        }
    }
    
    // 工厂
    class Factory<T>(val definition: Definition<T>) : InstanceFactory<T>() {
        override fun get(context: InstanceContext): T {
            return definition(context.scope, context.parameters ?: emptyParametersHolder())
        }
    }
}
```

## 3. 关键源码解析

### 3.1 Dagger 生成代码

```java
// Dagger 生成的 Component
@DaggerGenerated
public final class DaggerAppComponent implements AppComponent {
    private final AppModule appModule;
    
    private DaggerAppComponent(AppModule appModuleParam) {
        this.appModule = appModuleParam;
    }
    
    public static Builder builder() {
        return new Builder();
    }
    
    @Override
    public OkHttpClient okHttpClient() {
        return AppModule_ProvideOkHttpClientFactory.provideOkHttpClient(appModule);
    }
    
    @Override
    public void inject(MainActivity activity) {
        injectMainActivity(activity);
    }
    
    private MainActivity injectMainActivity(MainActivity instance) {
        MainActivity_MembersInjector.injectRepository(instance, userRepositoryProvider.get());
        return instance;
    }
}

// 生成的 Factory
@DaggerGenerated
public final class UserRepositoryImpl_Factory implements Factory<UserRepositoryImpl> {
    private final Provider<ApiService> apiServiceProvider;
    
    public UserRepositoryImpl_Factory(Provider<ApiService> apiServiceProvider) {
        this.apiServiceProvider = apiServiceProvider;
    }
    
    @Override
    public UserRepositoryImpl get() {
        return newInstance(apiServiceProvider.get());
    }
    
    public static UserRepositoryImpl newInstance(ApiService apiService) {
        return new UserRepositoryImpl(apiService);
    }
}
```

## 4. 实战应用

### 4.1 Hilt 最佳实践

```kotlin
// 1. 作用域选择
@Module
@InstallIn(SingletonComponent::class)  // 全局单例
object NetworkModule {
    @Provides
    @Singleton
    fun provideOkHttpClient(): OkHttpClient = OkHttpClient.Builder().build()
}

@Module
@InstallIn(ActivityComponent::class)  // Activity 作用域
object ActivityModule {
    @Provides
    @ActivityScoped
    fun provideAnalytics(): Analytics = Analytics()
}

// 2. 限定符
@Qualifier
@Retention(AnnotationRetention.BINARY)
annotation class IoDispatcher

@Qualifier
@Retention(AnnotationRetention.BINARY)
annotation class MainDispatcher

@Module
@InstallIn(SingletonComponent::class)
object DispatcherModule {
    @Provides
    @IoDispatcher
    fun provideIoDispatcher(): CoroutineDispatcher = Dispatchers.IO
    
    @Provides
    @MainDispatcher
    fun provideMainDispatcher(): CoroutineDispatcher = Dispatchers.Main
}

// 使用
class MyRepository @Inject constructor(
    @IoDispatcher private val ioDispatcher: CoroutineDispatcher
)

// 3. 测试替换
@Module
@TestInstallIn(
    components = [SingletonComponent::class],
    replaces = [RepositoryModule::class]
)
object FakeRepositoryModule {
    @Provides
    @Singleton
    fun provideFakeRepository(): UserRepository = FakeUserRepository()
}
```

## 5. 常见面试题

### 问题1：Hilt 和 Dagger 的区别是什么？

**答案要点**：
- Hilt 是 Dagger 的封装，简化 Android 使用
- Hilt 预定义了组件和作用域
- Hilt 自动生成 Component
- Hilt 与 Jetpack 集成更好

### 问题2：Hilt 的组件层级是怎样的？

**答案要点**：
- SingletonComponent（Application）
- ActivityRetainedComponent（ViewModel）
- ActivityComponent（Activity）
- FragmentComponent（Fragment）
- ViewComponent（View）

### 问题3：@Provides 和 @Binds 的区别是什么？

**答案要点**：
- @Provides：提供实例，可以有复杂逻辑
- @Binds：绑定接口和实现，更高效
- @Binds 只能用于抽象方法
- @Binds 生成的代码更少

### 问题4：Koin 和 Hilt 如何选择？

**答案要点**：
- Hilt：编译时检查，性能更好，适合大型项目
- Koin：简单易用，适合小型项目和快速开发
- Hilt 是 Google 官方推荐
- Koin 学习成本更低

### 问题5：依赖注入的好处是什么？

**答案要点**：
- 解耦：类不需要知道依赖如何创建
- 可测试：容易替换为 Mock 对象
- 可维护：集中管理依赖
- 可复用：依赖可以在多处共享
