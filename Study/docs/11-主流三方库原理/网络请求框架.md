# 网络请求框架

## 1. 概述

OkHttp 和 Retrofit 是 Android 最主流的网络请求框架，OkHttp 负责底层网络通信，Retrofit 提供声明式 API。

## 2. 核心原理

### 2.1 OkHttp 整体架构

```
┌─────────────────────────────────────────────────────────────┐
│                    OkHttp 架构图                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   ┌──────────────────────────────────────────────────────┐  │
│   │                    OkHttpClient                      │  │
│   └───────────────────────┬──────────────────────────────┘  │
│                           │                                 │
│                           ▼                                 │
│   ┌──────────────────────────────────────────────────────┐  │
│   │                    Dispatcher                        │  │
│   │              (异步请求调度)                            │  │
│   └───────────────────────┬──────────────────────────────┘  │
│                           │                                 │
│                           ▼                                 │
│   ┌──────────────────────────────────────────────────────┐  │
│   │                 Interceptor Chain                    │  │
│   │  ┌─────────────────────────────────────────────────┐ │  │
│   │  │ RetryAndFollowUpInterceptor (重试和重定向)       │ │  │
│   │  ├─────────────────────────────────────────────────┤ │  │
│   │  │ BridgeInterceptor (请求/响应转换)                │ │  │
│   │  ├─────────────────────────────────────────────────┤ │  │
│   │  │ CacheInterceptor (缓存)                         │ │  │
│   │  ├─────────────────────────────────────────────────┤ │  │
│   │  │ ConnectInterceptor (建立连接)                   │ │  │
│   │  ├─────────────────────────────────────────────────┤ │  │
│   │  │ CallServerInterceptor (发送请求/读取响应)        │ │  │
│   │  └─────────────────────────────────────────────────┘ │  │
│   └──────────────────────────────────────────────────────┘  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 拦截器链

```java
// RealCall.java
@Override
public Response execute() throws IOException {
    synchronized (this) {
        if (executed) throw new IllegalStateException("Already Executed");
        executed = true;
    }
    try {
        client.dispatcher().executed(this);
        return getResponseWithInterceptorChain();
    } finally {
        client.dispatcher().finished(this);
    }
}

Response getResponseWithInterceptorChain() throws IOException {
    List<Interceptor> interceptors = new ArrayList<>();
    
    // 用户自定义拦截器
    interceptors.addAll(client.interceptors());
    
    // 内置拦截器
    interceptors.add(new RetryAndFollowUpInterceptor(client));
    interceptors.add(new BridgeInterceptor(client.cookieJar()));
    interceptors.add(new CacheInterceptor(client.cache()));
    interceptors.add(new ConnectInterceptor(client));
    
    if (!forWebSocket) {
        interceptors.addAll(client.networkInterceptors());
    }
    
    interceptors.add(new CallServerInterceptor(forWebSocket));
    
    // 创建拦截器链
    Interceptor.Chain chain = new RealInterceptorChain(interceptors, transmitter,
            null, 0, originalRequest, this, client.connectTimeoutMillis(),
            client.readTimeoutMillis(), client.writeTimeoutMillis());
    
    return chain.proceed(originalRequest);
}

// RealInterceptorChain.java
@Override
public Response proceed(Request request) throws IOException {
    // 调用下一个拦截器
    RealInterceptorChain next = new RealInterceptorChain(interceptors, transmitter,
            exchange, index + 1, request, call, connectTimeout, readTimeout, writeTimeout);
    Interceptor interceptor = interceptors.get(index);
    Response response = interceptor.intercept(next);
    return response;
}
```

### 2.3 连接池

```java
// ConnectionPool.java
public final class ConnectionPool {
    // 最大空闲连接数
    private final int maxIdleConnections;
    // 空闲连接存活时间
    private final long keepAliveDurationNs;
    // 连接队列
    private final Deque<RealConnection> connections = new ArrayDeque<>();
    
    // 获取连接
    @Nullable RealConnection get(Address address, StreamAllocation streamAllocation,
            Route route) {
        for (RealConnection connection : connections) {
            if (connection.isEligible(address, route)) {
                streamAllocation.acquire(connection, true);
                return connection;
            }
        }
        return null;
    }
    
    // 放回连接
    void put(RealConnection connection) {
        connections.add(connection);
        cleanupRunning = true;
        executor.execute(cleanupRunnable);
    }
    
    // 清理空闲连接
    long cleanup(long now) {
        // 遍历连接，清理空闲超时的连接
        for (Iterator<RealConnection> i = connections.iterator(); i.hasNext(); ) {
            RealConnection connection = i.next();
            if (connection.idleAtNanos + keepAliveDurationNs < now) {
                i.remove();
                connection.socket().close();
            }
        }
        return keepAliveDurationNs;
    }
}
```

### 2.4 Retrofit 原理

```java
// Retrofit.java
public <T> T create(final Class<T> service) {
    // 验证接口
    validateServiceInterface(service);
    
    // 动态代理
    return (T) Proxy.newProxyInstance(
            service.getClassLoader(),
            new Class<?>[] { service },
            new InvocationHandler() {
                @Override
                public Object invoke(Object proxy, Method method, Object[] args)
                        throws Throwable {
                    // Object 方法直接调用
                    if (method.getDeclaringClass() == Object.class) {
                        return method.invoke(this, args);
                    }
                    
                    // 加载 ServiceMethod
                    return loadServiceMethod(method).invoke(args);
                }
            });
}

// 加载 ServiceMethod
ServiceMethod<?> loadServiceMethod(Method method) {
    ServiceMethod<?> result = serviceMethodCache.get(method);
    if (result != null) return result;
    
    synchronized (serviceMethodCache) {
        result = serviceMethodCache.get(method);
        if (result == null) {
            // 解析方法注解，创建 ServiceMethod
            result = ServiceMethod.parseAnnotations(this, method);
            serviceMethodCache.put(method, result);
        }
    }
    return result;
}

// HttpServiceMethod.java
static <ResponseT, ReturnT> HttpServiceMethod<ResponseT, ReturnT> parseAnnotations(
        Retrofit retrofit, Method method, RequestFactory requestFactory) {
    
    // 获取 CallAdapter
    CallAdapter<ResponseT, ReturnT> callAdapter =
            createCallAdapter(retrofit, method, adapterType, annotations);
    
    // 获取 Converter
    Converter<ResponseBody, ResponseT> responseConverter =
            createResponseConverter(retrofit, method, responseType);
    
    // 创建 HttpServiceMethod
    return new CallAdapted<>(requestFactory, callFactory, responseConverter, callAdapter);
}

// 执行请求
@Override
final @Nullable ReturnT invoke(Object[] args) {
    Call<ResponseT> call = new OkHttpCall<>(requestFactory, args, callFactory, responseConverter);
    return adapt(call, args);
}
```

### 2.5 Converter 和 CallAdapter

```java
// Converter - 数据转换
public interface Converter<F, T> {
    T convert(F value) throws IOException;
    
    abstract class Factory {
        // 响应体转换
        public @Nullable Converter<ResponseBody, ?> responseBodyConverter(
                Type type, Annotation[] annotations, Retrofit retrofit) {
            return null;
        }
        
        // 请求体转换
        public @Nullable Converter<?, RequestBody> requestBodyConverter(
                Type type, Annotation[] parameterAnnotations,
                Annotation[] methodAnnotations, Retrofit retrofit) {
            return null;
        }
    }
}

// GsonConverterFactory
public final class GsonConverterFactory extends Converter.Factory {
    private final Gson gson;
    
    @Override
    public Converter<ResponseBody, ?> responseBodyConverter(Type type,
            Annotation[] annotations, Retrofit retrofit) {
        TypeAdapter<?> adapter = gson.getAdapter(TypeToken.get(type));
        return new GsonResponseBodyConverter<>(gson, adapter);
    }
}

// CallAdapter - 调用适配
public interface CallAdapter<R, T> {
    Type responseType();
    T adapt(Call<R> call);
    
    abstract class Factory {
        public abstract @Nullable CallAdapter<?, ?> get(
                Type returnType, Annotation[] annotations, Retrofit retrofit);
    }
}

// RxJava2CallAdapterFactory
public final class RxJava2CallAdapterFactory extends CallAdapter.Factory {
    @Override
    public @Nullable CallAdapter<?, ?> get(Type returnType, Annotation[] annotations,
            Retrofit retrofit) {
        Class<?> rawType = getRawType(returnType);
        
        if (rawType == Observable.class) {
            return new RxJava2CallAdapter<>(responseType, scheduler, isAsync, false, false, false, false, false, true);
        }
        // ...
    }
}
```

## 3. 关键源码解析

### 3.1 缓存拦截器

```java
// CacheInterceptor.java
@Override
public Response intercept(Chain chain) throws IOException {
    // 获取缓存响应
    Response cacheCandidate = cache != null
            ? cache.get(chain.request())
            : null;
    
    // 缓存策略
    CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate)
            .compute();
    Request networkRequest = strategy.networkRequest;
    Response cacheResponse = strategy.cacheResponse;
    
    // 只使用缓存
    if (networkRequest == null) {
        return cacheResponse.newBuilder()
                .cacheResponse(stripBody(cacheResponse))
                .build();
    }
    
    // 发起网络请求
    Response networkResponse = chain.proceed(networkRequest);
    
    // 304 Not Modified
    if (networkResponse.code() == HTTP_NOT_MODIFIED) {
        Response response = cacheResponse.newBuilder()
                .headers(combine(cacheResponse.headers(), networkResponse.headers()))
                .cacheResponse(stripBody(cacheResponse))
                .networkResponse(stripBody(networkResponse))
                .build();
        cache.update(cacheResponse, response);
        return response;
    }
    
    // 缓存响应
    if (cache != null && HttpHeaders.hasBody(networkResponse)
            && CacheStrategy.isCacheable(networkResponse, networkRequest)) {
        CacheRequest cacheRequest = cache.put(networkResponse);
        return cacheWritingResponse(cacheRequest, networkResponse);
    }
    
    return networkResponse;
}
```

## 4. 实战应用

### 4.1 OkHttp + Retrofit 配置

```kotlin
// OkHttpClient 配置
val okHttpClient = OkHttpClient.Builder()
    .connectTimeout(30, TimeUnit.SECONDS)
    .readTimeout(30, TimeUnit.SECONDS)
    .writeTimeout(30, TimeUnit.SECONDS)
    .addInterceptor(HttpLoggingInterceptor().apply {
        level = HttpLoggingInterceptor.Level.BODY
    })
    .addInterceptor { chain ->
        val request = chain.request().newBuilder()
            .addHeader("Authorization", "Bearer $token")
            .build()
        chain.proceed(request)
    }
    .build()

// Retrofit 配置
val retrofit = Retrofit.Builder()
    .baseUrl("https://api.example.com/")
    .client(okHttpClient)
    .addConverterFactory(GsonConverterFactory.create())
    .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
    .build()

// API 接口
interface ApiService {
    @GET("users/{id}")
    suspend fun getUser(@Path("id") id: String): User
    
    @POST("users")
    suspend fun createUser(@Body user: User): User
    
    @GET("users")
    fun getUsersRx(): Observable<List<User>>
}
```

## 5. 常见面试题

### 问题1：OkHttp 的拦截器链是如何工作的？

**答案要点**：
- 责任链模式
- 拦截器按顺序执行
- 每个拦截器调用 chain.proceed() 传递给下一个
- 响应按相反顺序返回

### 问题2：OkHttp 的连接池是如何工作的？

**答案要点**：
- 复用 TCP 连接，减少握手开销
- 默认最多 5 个空闲连接，存活 5 分钟
- 根据 Address 匹配可复用的连接
- 后台线程定期清理空闲连接

### 问题3：Retrofit 是如何实现的？

**答案要点**：
- 动态代理拦截接口方法调用
- 解析方法注解生成 Request
- Converter 处理数据转换
- CallAdapter 适配返回类型

### 问题4：如何实现网络请求的缓存？

**答案要点**：
- OkHttp 内置 CacheInterceptor
- 遵循 HTTP 缓存协议（Cache-Control、ETag）
- 可自定义缓存策略
- 支持强制使用缓存或网络

### 问题5：如何处理网络请求的重试？

**答案要点**：
- RetryAndFollowUpInterceptor 处理重试
- 默认重试连接失败、重定向
- 可自定义拦截器实现业务重试
- 注意幂等性问题
