# Android 动画体系

## 1. 概述

Android 动画体系是构建流畅用户体验的核心技术，从早期的 View 动画（补间动画）到现代的属性动画、Transition 框架、MotionLayout，Android 提供了丰富的动画解决方案。本文将深入讲解各种动画的实现原理、源码分析和最佳实践，帮助开发者在面试中展现对动画体系的深度理解。

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        Android 动画体系演进                              │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  API 1+     View 动画 (补间动画)                                        │
│     │       - AlphaAnimation, ScaleAnimation, RotateAnimation          │
│     │       - TranslateAnimation, AnimationSet                         │
│     │       - 只改变绘制效果，不改变实际属性                            │
│     ↓                                                                   │
│  API 11+    属性动画 (Property Animation)                               │
│     │       - ValueAnimator, ObjectAnimator, AnimatorSet               │
│     │       - 真正改变对象属性值                                        │
│     ↓                                                                   │
│  API 19+    Transition 框架                                             │
│     │       - Scene, Transition, TransitionManager                     │
│     │       - 自动计算场景变化动画                                      │
│     ↓                                                                   │
│  API 21+    Activity/Fragment Transition                                │
│     │       - 共享元素动画                                              │
│     │       - 进入/退出动画                                             │
│     ↓                                                                   │
│  ConstraintLayout 2.0+  MotionLayout                                    │
│             - 声明式动画                                                │
│             - 复杂手势驱动动画                                          │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

## 2. 核心原理

### 2.1 View 动画（补间动画）

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        View 动画原理                                     │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  四种基本动画类型:                                                      │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  类型              │  类名                │  效果                │   │
│  │  ─────────────────────────────────────────────────────────────  │   │
│  │  透明度            │  AlphaAnimation      │  渐变透明            │   │
│  │  缩放              │  ScaleAnimation      │  放大/缩小           │   │
│  │  旋转              │  RotateAnimation     │  旋转                │   │
│  │  平移              │  TranslateAnimation  │  位置移动            │   │
│  │  组合              │  AnimationSet        │  多动画组合          │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  工作原理:                                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  view.startAnimation(animation)                                 │   │
│  │           │                                                     │   │
│  │           ↓                                                     │   │
│  │  ┌─────────────────┐                                            │   │
│  │  │ setAnimation()  │ → 保存 Animation 到 View                   │   │
│  │  └────────┬────────┘                                            │   │
│  │           ↓                                                     │   │
│  │  ┌─────────────────┐                                            │   │
│  │  │ invalidate()    │ → 触发重绘                                 │   │
│  │  └────────┬────────┘                                            │   │
│  │           ↓                                                     │   │
│  │  ┌─────────────────┐                                            │   │
│  │  │ draw(canvas)    │ → 绘制时应用变换矩阵                       │   │
│  │  └────────┬────────┘                                            │   │
│  │           ↓                                                     │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │ animation.getTransformation(currentTime, transformation) │   │   │
│  │  │ → 根据当前时间计算变换矩阵                               │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │           ↓                                                     │   │
│  │  ┌─────────────────┐                                            │   │
│  │  │ canvas.concat() │ → 应用变换矩阵到 Canvas                    │   │
│  │  └─────────────────┘                                            │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ⚠️ 重要特性:                                                           │
│  - View 动画只改变绘制效果，不改变 View 的实际属性                      │
│  - 动画结束后，View 的点击区域仍在原位置                                │
│  - 适用于简单的视觉效果，不适合交互动画                                 │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```


### 2.2 属性动画原理

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        属性动画核心架构                                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  核心类关系:                                                            │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │                      Animator (抽象基类)                        │   │
│  │                           │                                     │   │
│  │              ┌────────────┴────────────┐                        │   │
│  │              ↓                         ↓                        │   │
│  │       ValueAnimator              AnimatorSet                    │   │
│  │              │                   (动画组合)                     │   │
│  │              ↓                                                  │   │
│  │       ObjectAnimator                                            │   │
│  │       (对象属性动画)                                            │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ValueAnimator 工作流程:                                                │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  ValueAnimator.ofFloat(0f, 1f)                                  │   │
│  │           │                                                     │   │
│  │           ↓                                                     │   │
│  │  ┌─────────────────┐                                            │   │
│  │  │ start()         │ → 启动动画                                 │   │
│  │  └────────┬────────┘                                            │   │
│  │           ↓                                                     │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │ AnimationHandler.addAnimationFrameCallback()             │   │   │
│  │  │ → 注册到 Choreographer 的 CALLBACK_ANIMATION             │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │           ↓                                                     │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │ Choreographer.postFrameCallback()                        │   │   │
│  │  │ → 等待 VSYNC 信号                                        │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │           ↓                                                     │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │ doAnimationFrame(frameTime)                              │   │   │
│  │  │ → 每帧回调，计算当前值                                   │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │           ↓                                                     │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │ 1. 计算时间因子: fraction = (currentTime - startTime)    │   │   │
│  │  │                            / duration                    │   │   │
│  │  │ 2. 插值器计算: interpolatedFraction =                    │   │   │
│  │  │                interpolator.getInterpolation(fraction)   │   │   │
│  │  │ 3. 估值器计算: value = evaluator.evaluate(               │   │   │
│  │  │                interpolatedFraction, startValue, endValue)│   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │           ↓                                                     │   │
│  │  ┌─────────────────┐                                            │   │
│  │  │ 回调 Listener   │ → onAnimationUpdate(animation)             │   │
│  │  └─────────────────┘                                            │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    ObjectAnimator 工作原理                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ObjectAnimator 继承自 ValueAnimator，增加了自动设置属性的能力          │
│                                                                         │
│  属性设置流程:                                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  ObjectAnimator.ofFloat(view, "alpha", 0f, 1f)                  │   │
│  │           │                                                     │   │
│  │           ↓                                                     │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │ PropertyValuesHolder.setPropertyName("alpha")            │   │   │
│  │  │ → 保存属性名                                             │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │           ↓                                                     │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │ setupSetterAndGetter()                                   │   │   │
│  │  │ → 通过反射查找 setAlpha()/getAlpha() 方法               │   │   │
│  │  │ → 或查找 Property<View, Float> 对象                      │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │           ↓                                                     │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │ animateValue(fraction)                                   │   │   │
│  │  │ → 计算当前值后调用 setter 方法                           │   │   │
│  │  │ → view.setAlpha(currentValue)                            │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  属性查找优先级:                                                        │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  1. Property 对象 (最高效，无反射)                              │   │
│  │     ObjectAnimator.ofFloat(view, View.ALPHA, 0f, 1f)            │   │
│  │                                                                 │   │
│  │  2. setter/getter 方法 (反射调用)                               │   │
│  │     ObjectAnimator.ofFloat(view, "alpha", 0f, 1f)               │   │
│  │     → 查找 setAlpha(float) 和 getAlpha()                        │   │
│  │                                                                 │   │
│  │  3. 自定义 Property                                             │   │
│  │     val customProperty = object : Property<View, Float>(...) {  │   │
│  │         override fun get(view: View) = ...                      │   │
│  │         override fun set(view: View, value: Float) = ...        │   │
│  │     }                                                           │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.3 插值器与估值器

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        插值器 (Interpolator)                             │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  作用: 控制动画的变化速率                                               │
│                                                                         │
│  常用插值器:                                                            │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  插值器                    │  效果                              │   │
│  │  ─────────────────────────────────────────────────────────────  │   │
│  │  LinearInterpolator        │  匀速                              │   │
│  │  AccelerateInterpolator    │  加速                              │   │
│  │  DecelerateInterpolator    │  减速                              │   │
│  │  AccelerateDecelerateInterpolator │  先加速后减速              │   │
│  │  OvershootInterpolator     │  超出后回弹                        │   │
│  │  AnticipateInterpolator    │  先后退再前进                      │   │
│  │  BounceInterpolator        │  弹跳效果                          │   │
│  │  CycleInterpolator         │  循环/正弦波                       │   │
│  │  PathInterpolator          │  自定义路径 (API 21+)              │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  插值器曲线示意:                                                        │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  Linear          Accelerate       Decelerate      Overshoot    │   │
│  │  1.0 ─────/      1.0      /       1.0 ──────      1.0 ──┐      │   │
│  │       /              /                 /              │  │      │   │
│  │      /              /                 /               │  │      │   │
│  │     /              /                 /                └──┘      │   │
│  │  0 ─────────    0 ─────────      0 ─────────      0 ─────────   │   │
│  │    0    1.0       0    1.0         0    1.0         0    1.0   │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────┐
│                        估值器 (TypeEvaluator)                            │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  作用: 根据插值后的 fraction 计算属性的实际值                           │
│                                                                         │
│  内置估值器:                                                            │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  估值器                │  用途                                  │   │
│  │  ─────────────────────────────────────────────────────────────  │   │
│  │  IntEvaluator          │  整数值                                │   │
│  │  FloatEvaluator        │  浮点数值                              │   │
│  │  ArgbEvaluator         │  颜色值 (ARGB)                         │   │
│  │  PointFEvaluator       │  PointF 对象                           │   │
│  │  RectEvaluator         │  Rect 对象                             │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  计算公式:                                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  // FloatEvaluator 实现                                         │   │
│  │  result = startValue + fraction * (endValue - startValue)       │   │
│  │                                                                 │   │
│  │  // ArgbEvaluator 实现 (分别计算 ARGB 四个通道)                 │   │
│  │  startA = (startValue >> 24) & 0xff                             │   │
│  │  endA = (endValue >> 24) & 0xff                                 │   │
│  │  resultA = startA + (int)(fraction * (endA - startA))           │   │
│  │  // ... 同理计算 R, G, B                                        │   │
│  │  result = (resultA << 24) | (resultR << 16) | ...               │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```


### 2.4 AnimatorSet 组合动画

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        AnimatorSet 组合动画                              │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  组合方式:                                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  1. playTogether() - 同时播放                                   │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │  AnimatorSet().apply {                                   │   │   │
│  │  │      playTogether(animator1, animator2, animator3)       │   │   │
│  │  │      start()                                             │   │   │
│  │  │  }                                                       │   │   │
│  │  │                                                          │   │   │
│  │  │  时间线: ├──animator1──┤                                 │   │   │
│  │  │         ├──animator2──┤                                  │   │   │
│  │  │         ├──animator3──┤                                  │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │                                                                 │   │
│  │  2. playSequentially() - 顺序播放                               │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │  AnimatorSet().apply {                                   │   │   │
│  │  │      playSequentially(animator1, animator2, animator3)   │   │   │
│  │  │      start()                                             │   │   │
│  │  │  }                                                       │   │   │
│  │  │                                                          │   │   │
│  │  │  时间线: ├──animator1──┼──animator2──┼──animator3──┤     │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │                                                                 │   │
│  │  3. Builder 链式调用 - 灵活控制                                 │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │  AnimatorSet().apply {                                   │   │   │
│  │  │      play(animator1).with(animator2)  // 同时            │   │   │
│  │  │                     .before(animator3) // 之前           │   │   │
│  │  │      play(animator3).after(animator4)  // 之后           │   │   │
│  │  │      start()                                             │   │   │
│  │  │  }                                                       │   │   │
│  │  │                                                          │   │   │
│  │  │  时间线: ├──animator1──┤                                 │   │   │
│  │  │         ├──animator2──┼──animator3──┤                    │   │   │
│  │  │                       ├──animator4──┤                    │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.5 布局动画 (LayoutTransition)

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        LayoutTransition 布局动画                         │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  作用: 当 ViewGroup 中的子 View 发生变化时自动执行动画                  │
│                                                                         │
│  四种动画类型:                                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  类型                    │  触发时机                            │   │
│  │  ─────────────────────────────────────────────────────────────  │   │
│  │  APPEARING               │  子 View 添加到容器时                │   │
│  │  DISAPPEARING            │  子 View 从容器移除时                │   │
│  │  CHANGE_APPEARING        │  因添加 View 导致其他 View 变化      │   │
│  │  CHANGE_DISAPPEARING     │  因移除 View 导致其他 View 变化      │   │
│  │  CHANGING (API 16+)      │  布局变化但不涉及添加/移除           │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  执行顺序:                                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  添加 View 时:                                                  │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │  1. CHANGE_APPEARING (其他 View 移动)                    │   │   │
│  │  │  2. APPEARING (新 View 出现)                             │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │                                                                 │   │
│  │  移除 View 时:                                                  │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │  1. DISAPPEARING (被移除 View 消失)                      │   │   │
│  │  │  2. CHANGE_DISAPPEARING (其他 View 移动)                 │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.6 Transition 框架

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        Transition 框架原理                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  核心概念:                                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  Scene (场景)      → 定义 UI 的某个状态                         │   │
│  │  Transition (过渡) → 定义场景切换时的动画                       │   │
│  │  TransitionManager → 管理场景切换                               │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  工作流程:                                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  TransitionManager.go(scene, transition)                        │   │
│  │           │                                                     │   │
│  │           ↓                                                     │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │ 1. captureStartValues()                                  │   │   │
│  │  │    → 捕获当前场景所有 View 的属性值                      │   │   │
│  │  │    → 保存到 TransitionValues 中                          │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │           ↓                                                     │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │ 2. scene.enter()                                         │   │   │
│  │  │    → 切换到目标场景 (更新布局)                           │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │           ↓                                                     │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │ 3. captureEndValues()                                    │   │   │
│  │  │    → 捕获目标场景所有 View 的属性值                      │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │           ↓                                                     │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │ 4. createAnimator()                                      │   │   │
│  │  │    → 比较 start/end 值，创建属性动画                     │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │           ↓                                                     │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │ 5. 执行动画                                              │   │   │
│  │  │    → 从 startValues 过渡到 endValues                     │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  内置 Transition:                                                       │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  Transition           │  效果                                   │   │
│  │  ─────────────────────────────────────────────────────────────  │   │
│  │  Fade                  │  淡入淡出                              │   │
│  │  Slide                 │  滑动进入/退出                         │   │
│  │  Explode               │  爆炸效果                              │   │
│  │  ChangeBounds          │  位置和大小变化                        │   │
│  │  ChangeTransform       │  缩放和旋转变化                        │   │
│  │  ChangeClipBounds      │  裁剪区域变化                          │   │
│  │  ChangeImageTransform  │  ImageView 变换                        │   │
│  │  AutoTransition        │  自动选择合适的过渡                    │   │
│  │  TransitionSet         │  组合多个过渡                          │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```


### 2.7 Activity/Fragment Transition

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    Activity/Fragment Transition                          │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  共享元素动画原理:                                                      │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  Activity A                        Activity B                   │   │
│  │  ┌─────────────┐                  ┌─────────────┐              │   │
│  │  │  ┌─────┐    │                  │             │              │   │
│  │  │  │ IMG │    │  ─────────────→  │  ┌───────┐  │              │   │
│  │  │  └─────┘    │  共享元素动画    │  │  IMG  │  │              │   │
│  │  │  Title      │                  │  └───────┘  │              │   │
│  │  └─────────────┘                  │  Title      │              │   │
│  │                                   └─────────────┘              │   │
│  │                                                                 │   │
│  │  实现步骤:                                                      │   │
│  │  1. 两个 Activity 中的共享 View 设置相同的 transitionName       │   │
│  │  2. 使用 ActivityOptions.makeSceneTransitionAnimation()         │   │
│  │  3. 系统自动计算位置/大小变化，创建动画                         │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  Transition 类型:                                                       │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │  Enter Transition    │  新 Activity 进入时的动画        │   │   │
│  │  │  Exit Transition     │  当前 Activity 退出时的动画      │   │   │
│  │  │  Return Transition   │  返回时新 Activity 的动画        │   │   │
│  │  │  Reenter Transition  │  返回时原 Activity 的动画        │   │   │
│  │  │  Shared Element      │  共享元素的过渡动画              │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │                                                                 │   │
│  │  时间线:                                                        │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │  A → B:                                                  │   │   │
│  │  │  ├── A.exitTransition ──┤                                │   │   │
│  │  │  ├── B.enterTransition ─┤                                │   │   │
│  │  │  ├── sharedElementTransition ──┤                         │   │   │
│  │  │                                                          │   │   │
│  │  │  B → A (返回):                                           │   │   │
│  │  │  ├── B.returnTransition ──┤                              │   │   │
│  │  │  ├── A.reenterTransition ─┤                              │   │   │
│  │  │  ├── sharedElementReturnTransition ──┤                   │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.8 MotionLayout

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        MotionLayout 原理                                 │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  MotionLayout 是 ConstraintLayout 的子类，专为复杂动画设计              │
│                                                                         │
│  核心概念:                                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  MotionScene (动画场景文件)                                     │   │
│  │       │                                                         │   │
│  │       ├── ConstraintSet (start) → 起始状态约束                  │   │
│  │       │                                                         │   │
│  │       ├── ConstraintSet (end)   → 结束状态约束                  │   │
│  │       │                                                         │   │
│  │       └── Transition             → 过渡配置                     │   │
│  │              │                                                  │   │
│  │              ├── OnClick         → 点击触发                     │   │
│  │              ├── OnSwipe         → 滑动触发                     │   │
│  │              └── KeyFrameSet     → 关键帧                       │   │
│  │                    │                                            │   │
│  │                    ├── KeyPosition  → 位置关键帧                │   │
│  │                    ├── KeyAttribute → 属性关键帧                │   │
│  │                    └── KeyCycle     → 循环关键帧                │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  工作原理:                                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  progress: 0.0 ─────────────────────────────────────→ 1.0       │   │
│  │                                                                 │   │
│  │  ConstraintSet(start)                    ConstraintSet(end)     │   │
│  │  ┌─────────────┐                        ┌─────────────┐        │   │
│  │  │ ┌───┐       │                        │       ┌───┐ │        │   │
│  │  │ │ A │       │  ───────────────────→  │       │ A │ │        │   │
│  │  │ └───┘       │                        │       └───┘ │        │   │
│  │  └─────────────┘                        └─────────────┘        │   │
│  │                                                                 │   │
│  │  MotionLayout 根据 progress 值插值计算每个 View 的:             │   │
│  │  - 位置 (x, y)                                                  │   │
│  │  - 大小 (width, height)                                         │   │
│  │  - 透明度 (alpha)                                               │   │
│  │  - 旋转 (rotation)                                              │   │
│  │  - 缩放 (scaleX, scaleY)                                        │   │
│  │  - 自定义属性                                                   │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  关键帧类型:                                                            │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  KeyPosition - 控制运动路径                                     │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │  start ──────────────────────────────────────→ end       │   │   │
│  │  │         \                                   /             │   │   │
│  │  │          \                                 /              │   │   │
│  │  │           ● KeyPosition (50%)             /               │   │   │
│  │  │            \                             /                │   │   │
│  │  │             ─────────────────────────────                 │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │                                                                 │   │
│  │  KeyAttribute - 控制属性变化                                    │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │  alpha: 1.0 → 0.5 (50%) → 1.0                            │   │   │
│  │  │  rotation: 0° → 180° (50%) → 360°                        │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │                                                                 │   │
│  │  KeyCycle - 循环动画效果                                        │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │  translationY: ∿∿∿∿∿∿∿∿ (波浪运动)                       │   │   │
│  │  │  rotation: 循环旋转                                      │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.9 Lottie 动画原理

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        Lottie 动画原理                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  Lottie 是 Airbnb 开源的动画库，可以渲染 After Effects 导出的动画       │
│                                                                         │
│  工作流程:                                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  After Effects                                                  │   │
│  │       │                                                         │   │
│  │       ↓ (Bodymovin 插件导出)                                    │   │
│  │  ┌─────────────────┐                                            │   │
│  │  │  JSON 文件      │ → 描述动画的所有信息                       │   │
│  │  │  - 图层         │                                            │   │
│  │  │  - 关键帧       │                                            │   │
│  │  │  - 路径         │                                            │   │
│  │  │  - 颜色         │                                            │   │
│  │  └────────┬────────┘                                            │   │
│  │           ↓                                                     │   │
│  │  ┌─────────────────┐                                            │   │
│  │  │ LottieComposition│ → 解析 JSON，构建动画模型                 │   │
│  │  └────────┬────────┘                                            │   │
│  │           ↓                                                     │   │
│  │  ┌─────────────────┐                                            │   │
│  │  │ LottieDrawable  │ → 根据 progress 绘制每一帧                 │   │
│  │  └────────┬────────┘                                            │   │
│  │           ↓                                                     │   │
│  │  ┌─────────────────┐                                            │   │
│  │  │ LottieAnimationView │ → 显示动画                             │   │
│  │  └─────────────────┘                                            │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  核心架构:                                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  LottieComposition (动画数据)                                   │   │
│  │       │                                                         │   │
│  │       ├── Layer (图层)                                          │   │
│  │       │     │                                                   │   │
│  │       │     ├── ShapeLayer (形状图层)                           │   │
│  │       │     │     └── ShapeContent (形状内容)                   │   │
│  │       │     │           ├── PathContent (路径)                  │   │
│  │       │     │           ├── FillContent (填充)                  │   │
│  │       │     │           └── StrokeContent (描边)                │   │
│  │       │     │                                                   │   │
│  │       │     ├── ImageLayer (图片图层)                           │   │
│  │       │     ├── TextLayer (文字图层)                            │   │
│  │       │     └── PrecompLayer (预合成图层)                       │   │
│  │       │                                                         │   │
│  │       └── Keyframe (关键帧)                                     │   │
│  │             └── 插值计算属性值                                  │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  渲染流程:                                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  setProgress(0.5f)                                              │   │
│  │       │                                                         │   │
│  │       ↓                                                         │   │
│  │  遍历所有 Layer                                                 │   │
│  │       │                                                         │   │
│  │       ↓                                                         │   │
│  │  根据 progress 计算每个 Layer 的:                               │   │
│  │  - Transform (位置、缩放、旋转、透明度)                         │   │
│  │  - Path (路径数据)                                              │   │
│  │  - Color (颜色)                                                 │   │
│  │       │                                                         │   │
│  │       ↓                                                         │   │
│  │  使用 Canvas API 绘制                                           │   │
│  │  - canvas.drawPath()                                            │   │
│  │  - canvas.drawBitmap()                                          │   │
│  │  - canvas.drawText()                                            │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```


## 3. 关键源码解析

### 3.1 ValueAnimator 核心源码

```java
/**
 * ValueAnimator 核心源码分析
 * 路径: android/animation/ValueAnimator.java
 */
public class ValueAnimator extends Animator implements AnimationHandler.AnimationFrameCallback {
    
    // 动画时长，默认 300ms
    private long mDuration = 300;
    
    // 当前播放时间
    private long mCurrentPlayTime = 0;
    
    // 动画进度 [0, 1]
    private float mCurrentFraction = 0f;
    
    // 插值器，默认加速减速
    private TimeInterpolator mInterpolator = sDefaultInterpolator;
    
    // 属性值持有者数组，存储动画的起始值和结束值
    PropertyValuesHolder[] mValues;
    
    // 动画更新监听器
    ArrayList<AnimatorUpdateListener> mUpdateListeners;
    
    /**
     * 创建 float 类型的 ValueAnimator
     * 这是最常用的工厂方法
     */
    public static ValueAnimator ofFloat(float... values) {
        ValueAnimator anim = new ValueAnimator();
        // 设置 float 类型的属性值
        anim.setFloatValues(values);
        return anim;
    }
    
    /**
     * 启动动画
     * 这是动画的入口方法
     */
    @Override
    public void start() {
        start(false);
    }
    
    private void start(boolean playBackwards) {
        // 必须在主线程调用
        if (Looper.myLooper() == null) {
            throw new AndroidRuntimeException("Animators may only be run on Looper threads");
        }
        
        mReversing = playBackwards;
        mSelfPulse = !mSuppressSelfPulseRequested;
        
        // 如果设置了 startDelay，先等待
        if (mStartDelay == 0 || mSeekFraction >= 0 || mReversing) {
            // 立即开始
            startAnimation();
            // 如果 duration 为 0，直接结束
            if (mDuration == 0) {
                doAnimationFrame(AnimationUtils.currentAnimationTimeMillis());
            }
        }
        
        // 标记动画已启动
        mStarted = true;
        mPaused = false;
        mRunning = false;
        
        // 【关键】将动画注册到 AnimationHandler
        // AnimationHandler 会在每个 VSYNC 信号到来时回调
        AnimationHandler animationHandler = AnimationHandler.getInstance();
        animationHandler.addAnimationFrameCallback(this, mStartDelay);
        
        // 通知监听器动画开始
        if (mStartDelay == 0 || mSeekFraction >= 0) {
            notifyStartListeners();
        }
    }
    
    /**
     * 【核心方法】每帧回调，计算当前动画值
     * 由 AnimationHandler 在 VSYNC 信号到来时调用
     * 
     * @param frameTime 当前帧的时间戳
     * @return 动画是否结束
     */
    @Override
    public final boolean doAnimationFrame(long frameTime) {
        // 处理暂停状态
        if (mPaused) {
            mPauseTime = frameTime;
            return false;
        }
        
        // 第一帧，记录开始时间
        if (mStartTime < 0) {
            mStartTime = frameTime;
        }
        
        // 计算当前播放时间
        final long currentTime = Math.max(frameTime, mStartTime);
        
        // 【关键】执行动画帧计算
        boolean finished = animateBasedOnTime(currentTime);
        
        if (finished) {
            // 动画结束，清理资源
            endAnimation();
        }
        
        return finished;
    }
    
    /**
     * 根据时间计算动画值
     * 这是动画计算的核心逻辑
     */
    boolean animateBasedOnTime(long currentTime) {
        boolean done = false;
        
        if (mRunning) {
            // 计算已播放时间
            final long scaledDuration = getScaledDuration();
            // 计算原始进度 [0, 1]
            final float fraction = scaledDuration > 0 ?
                    (float)(currentTime - mStartTime) / scaledDuration : 1f;
            
            // 处理重复播放
            final float lastFraction = mCurrentFraction;
            final int iteration = (int) fraction;
            final boolean newIteration = iteration > mCurrentIteration;
            
            // 判断是否结束
            final boolean lastIterationFinished = (fraction >= mRepeatCount + 1) &&
                    (mRepeatCount != INFINITE);
            
            if (lastIterationFinished) {
                done = true;
            }
            
            // 计算当前迭代内的进度
            float currentIterationFraction = fraction - iteration;
            
            // 处理反向播放
            if (mReversing) {
                currentIterationFraction = 1f - currentIterationFraction;
            }
            
            // 【关键】调用 animateValue 计算并设置属性值
            animateValue(currentIterationFraction);
        }
        
        return done;
    }
    
    /**
     * 【核心方法】计算动画值并通知监听器
     * 
     * @param fraction 当前进度 [0, 1]
     */
    void animateValue(float fraction) {
        // 【关键步骤1】通过插值器计算插值后的进度
        // 例如：AccelerateInterpolator 会让动画先慢后快
        fraction = mInterpolator.getInterpolation(fraction);
        mCurrentFraction = fraction;
        
        // 【关键步骤2】遍历所有 PropertyValuesHolder，计算属性值
        int numValues = mValues.length;
        for (int i = 0; i < numValues; ++i) {
            // 每个 PropertyValuesHolder 使用估值器计算当前值
            // 例如：FloatEvaluator 计算 startValue + fraction * (endValue - startValue)
            mValues[i].calculateValue(fraction);
        }
        
        // 【关键步骤3】通知所有更新监听器
        if (mUpdateListeners != null) {
            int numListeners = mUpdateListeners.size();
            for (int i = 0; i < numListeners; ++i) {
                // 回调 onAnimationUpdate，开发者在这里获取当前值
                mUpdateListeners.get(i).onAnimationUpdate(this);
            }
        }
    }
    
    /**
     * 获取当前动画值
     * 开发者在 onAnimationUpdate 回调中调用此方法
     */
    public Object getAnimatedValue() {
        if (mValues != null && mValues.length > 0) {
            return mValues[0].getAnimatedValue();
        }
        return null;
    }
}
```

### 3.2 ObjectAnimator 源码分析

```java
/**
 * ObjectAnimator 源码分析
 * 继承自 ValueAnimator，增加了自动设置属性的能力
 * 路径: android/animation/ObjectAnimator.java
 */
public final class ObjectAnimator extends ValueAnimator {
    
    // 目标对象的弱引用，避免内存泄漏
    private WeakReference<Object> mTarget;
    
    // 属性名称
    private String mPropertyName;
    
    // Property 对象，比反射更高效
    private Property mProperty;
    
    /**
     * 创建 ObjectAnimator
     * 最常用的工厂方法
     */
    public static ObjectAnimator ofFloat(Object target, String propertyName, float... values) {
        ObjectAnimator anim = new ObjectAnimator(target, propertyName);
        anim.setFloatValues(values);
        return anim;
    }
    
    /**
     * 使用 Property 对象创建，性能更好
     * 推荐使用这种方式，避免反射开销
     */
    public static <T> ObjectAnimator ofFloat(T target, Property<T, Float> property,
            float... values) {
        ObjectAnimator anim = new ObjectAnimator(target, property);
        anim.setFloatValues(values);
        return anim;
    }
    
    /**
     * 初始化 setter 和 getter 方法
     * 在动画开始前调用
     */
    @Override
    void initAnimation() {
        if (!mInitialized) {
            final Object target = getTarget();
            if (target != null) {
                final int numValues = mValues.length;
                for (int i = 0; i < numValues; ++i) {
                    // 【关键】为每个 PropertyValuesHolder 设置目标对象
                    // 这会触发反射查找 setter/getter 方法
                    mValues[i].setupSetterAndGetter(target);
                }
            }
            super.initAnimation();
        }
    }
    
    /**
     * 【核心方法】重写父类方法，在计算值后自动设置属性
     */
    @Override
    void animateValue(float fraction) {
        final Object target = getTarget();
        if (target == null) {
            // 目标对象被回收，取消动画
            cancel();
            return;
        }
        
        // 调用父类方法计算值
        super.animateValue(fraction);
        
        // 【关键】遍历所有 PropertyValuesHolder，设置属性值
        final int numValues = mValues.length;
        for (int i = 0; i < numValues; ++i) {
            // 调用 setter 方法设置属性值
            // 例如：view.setAlpha(currentValue)
            mValues[i].setAnimatedValue(target);
        }
    }
}

/**
 * PropertyValuesHolder 源码分析
 * 负责保存属性值和调用 setter/getter
 */
public class PropertyValuesHolder implements Cloneable {
    
    // 属性名
    String mPropertyName;
    
    // Property 对象
    Property mProperty;
    
    // setter 方法（通过反射获取）
    Method mSetter = null;
    
    // getter 方法（通过反射获取）
    Method mGetter = null;
    
    // 关键帧数组
    Keyframes mKeyframes = null;
    
    // 当前动画值
    Object mAnimatedValue;
    
    /**
     * 设置 setter 和 getter 方法
     * 通过反射查找目标对象的方法
     */
    void setupSetterAndGetter(Object target) {
        if (mProperty != null) {
            // 使用 Property 对象，无需反射
            // 这是推荐的方式
            return;
        }
        
        // 【反射查找 setter 方法】
        // 例如：属性名 "alpha" → 查找 setAlpha(float) 方法
        if (mSetter == null) {
            // 构造 setter 方法名：set + 首字母大写的属性名
            String methodName = getMethodName("set", mPropertyName);
            // 通过反射获取方法
            mSetter = getPropertyFunction(target.getClass(), methodName, mValueType);
        }
        
        // 【反射查找 getter 方法】
        // 用于获取初始值（如果没有指定起始值）
        if (mGetter == null) {
            String methodName = getMethodName("get", mPropertyName);
            mGetter = getPropertyFunction(target.getClass(), methodName, null);
        }
    }
    
    /**
     * 计算当前帧的属性值
     * 使用估值器进行插值计算
     */
    void calculateValue(float fraction) {
        // 从关键帧中获取插值后的值
        // Keyframes 内部使用 TypeEvaluator 计算
        Object value = mKeyframes.getValue(fraction);
        mAnimatedValue = value;
    }
    
    /**
     * 设置属性值到目标对象
     */
    void setAnimatedValue(Object target) {
        if (mProperty != null) {
            // 使用 Property 对象设置，高效
            mProperty.set(target, getAnimatedValue());
        } else if (mSetter != null) {
            try {
                // 使用反射调用 setter 方法
                mSetter.invoke(target, getAnimatedValue());
            } catch (Exception e) {
                Log.e("PropertyValuesHolder", "Error setting property", e);
            }
        }
    }
}
```


### 3.3 AnimationHandler 与 Choreographer

```java
/**
 * AnimationHandler 源码分析
 * 负责协调所有动画的帧回调
 * 路径: android/animation/AnimationHandler.java
 */
public class AnimationHandler {
    
    // 线程本地单例
    private static final ThreadLocal<AnimationHandler> sAnimatorHandler = new ThreadLocal<>();
    
    // 动画回调列表
    private final ArrayMap<AnimationFrameCallback, Long> mAnimationCallbacks = new ArrayMap<>();
    
    // Choreographer 帧回调
    private final Choreographer.FrameCallback mFrameCallback = new Choreographer.FrameCallback() {
        @Override
        public void doFrame(long frameTimeNanos) {
            // 【关键】每个 VSYNC 信号到来时执行
            doAnimationFrame(getProvider().getFrameTime());
            
            // 如果还有动画在运行，继续注册下一帧回调
            if (mAnimationCallbacks.size() > 0) {
                getProvider().postFrameCallback(this);
            }
        }
    };
    
    /**
     * 获取当前线程的 AnimationHandler 实例
     */
    public static AnimationHandler getInstance() {
        if (sAnimatorHandler.get() == null) {
            sAnimatorHandler.set(new AnimationHandler());
        }
        return sAnimatorHandler.get();
    }
    
    /**
     * 添加动画帧回调
     * ValueAnimator.start() 时调用
     */
    public void addAnimationFrameCallback(AnimationFrameCallback callback, long delay) {
        if (mAnimationCallbacks.size() == 0) {
            // 第一个动画，开始监听 VSYNC
            getProvider().postFrameCallback(mFrameCallback);
        }
        // 添加到回调列表
        mAnimationCallbacks.put(callback, delay > 0 ? 
                (SystemClock.uptimeMillis() + delay) : 0);
    }
    
    /**
     * 【核心方法】处理动画帧
     * 在每个 VSYNC 信号到来时调用
     */
    private void doAnimationFrame(long frameTime) {
        long currentTime = SystemClock.uptimeMillis();
        
        // 遍历所有动画回调
        for (int i = 0; i < mAnimationCallbacks.size(); i++) {
            final AnimationFrameCallback callback = mAnimationCallbacks.keyAt(i);
            
            // 检查延迟
            if (mAnimationCallbacks.valueAt(i) <= currentTime) {
                // 【关键】调用每个动画的 doAnimationFrame
                // 这会触发 ValueAnimator.doAnimationFrame()
                callback.doAnimationFrame(frameTime);
            }
        }
        
        // 清理已完成的动画
        cleanUpList();
    }
    
    /**
     * 帧时间提供者
     * 封装 Choreographer 的调用
     */
    private class MyFrameCallbackProvider implements AnimationFrameCallbackProvider {
        final Choreographer mChoreographer = Choreographer.getInstance();
        
        @Override
        public void postFrameCallback(Choreographer.FrameCallback callback) {
            // 注册到 Choreographer 的 CALLBACK_ANIMATION 类型
            mChoreographer.postFrameCallback(callback);
        }
        
        @Override
        public long getFrameTime() {
            return mChoreographer.getFrameTime();
        }
    }
}

/**
 * Choreographer 与动画的关系
 * Choreographer 是 Android 渲染系统的核心调度器
 */
public final class Choreographer {
    
    // 回调类型
    public static final int CALLBACK_INPUT = 0;      // 输入事件
    public static final int CALLBACK_ANIMATION = 1;  // 动画 ← 属性动画使用这个
    public static final int CALLBACK_TRAVERSAL = 2;  // View 遍历（measure/layout/draw）
    public static final int CALLBACK_COMMIT = 3;     // 提交
    
    // VSYNC 信号接收器
    private FrameDisplayEventReceiver mDisplayEventReceiver;
    
    /**
     * VSYNC 信号到来时的处理
     */
    void doFrame(long frameTimeNanos, int frame) {
        // 按顺序执行各类型回调
        
        // 1. 处理输入事件
        doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);
        
        // 2. 【处理动画】← 属性动画在这里执行
        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);
        
        // 3. 处理 View 遍历
        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);
        
        // 4. 提交
        doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);
    }
}
```

### 3.4 View 动画源码分析

```java
/**
 * View 动画源码分析
 * 路径: android/view/View.java
 */
public class View {
    
    // 当前动画
    Animation mCurrentAnimation;
    
    // 变换信息
    private TransformationInfo mTransformationInfo;
    
    /**
     * 启动动画
     */
    public void startAnimation(Animation animation) {
        // 设置动画开始时间
        animation.setStartTime(Animation.START_ON_FIRST_FRAME);
        // 保存动画引用
        setAnimation(animation);
        // 使父 View 的缓存失效
        invalidateParentCaches();
        // 触发重绘
        invalidate(true);
    }
    
    /**
     * 绘制方法中应用动画
     * 这是 View 动画的核心实现
     */
    boolean draw(Canvas canvas, ViewGroup parent, long drawingTime) {
        // ...
        
        final Animation a = getAnimation();
        if (a != null) {
            // 【关键】获取当前时间的变换矩阵
            more = applyLegacyAnimation(parent, drawingTime, a, scalingRequired);
            
            // 获取变换信息
            Transformation t = parent.getChildTransformation();
            
            // 应用变换矩阵到 Canvas
            if (transformToApply != null) {
                // 保存 Canvas 状态
                canvas.save();
                // 【关键】应用变换矩阵
                canvas.concat(transformToApply.getMatrix());
                // 设置透明度
                canvas.setAlpha(transformToApply.getAlpha());
            }
        }
        
        // 绘制 View 内容
        draw(canvas);
        
        // 恢复 Canvas 状态
        canvas.restore();
        
        // ...
    }
    
    /**
     * 应用传统动画（View 动画）
     */
    private boolean applyLegacyAnimation(ViewGroup parent, long drawingTime,
            Animation a, boolean scalingRequired) {
        
        Transformation t = parent.getChildTransformation();
        
        // 【关键】获取当前时间的变换
        // Animation.getTransformation() 会根据当前时间计算变换矩阵
        boolean more = a.getTransformation(drawingTime, t, 1f);
        
        if (more) {
            // 动画未结束，继续请求重绘
            if (!a.willChangeBounds()) {
                // 只需要重绘当前区域
                parent.invalidate(mLeft, mTop, mRight, mBottom);
            } else {
                // 需要重绘整个父 View
                parent.invalidate();
            }
        }
        
        return more;
    }
}

/**
 * Animation 基类源码
 * 路径: android/view/animation/Animation.java
 */
public abstract class Animation {
    
    // 动画时长
    long mDuration;
    
    // 开始时间
    long mStartTime = -1;
    
    // 插值器
    Interpolator mInterpolator;
    
    // 填充模式
    int mFillBefore = true;
    int mFillAfter = false;
    
    /**
     * 【核心方法】获取当前时间的变换
     * 
     * @param currentTime 当前时间
     * @param outTransformation 输出的变换信息
     * @param scale 缩放因子
     * @return 动画是否还在进行
     */
    public boolean getTransformation(long currentTime, Transformation outTransformation,
            float scale) {
        
        // 计算已过时间
        final long startOffset = getStartOffset();
        final long duration = mDuration;
        float normalizedTime;
        
        if (duration != 0) {
            // 计算归一化时间 [0, 1]
            normalizedTime = ((float) (currentTime - (mStartTime + startOffset))) /
                    (float) duration;
        } else {
            normalizedTime = currentTime < mStartTime ? 0.0f : 1.0f;
        }
        
        // 判断动画是否结束
        final boolean expired = normalizedTime >= 1.0f || isCanceled();
        
        if (normalizedTime >= 0.0f && normalizedTime <= 1.0f) {
            // 【关键】通过插值器计算插值后的进度
            final float interpolatedTime = mInterpolator.getInterpolation(
                    Math.min(normalizedTime, 1.0f));
            
            // 【关键】调用子类实现，应用变换
            // 例如：AlphaAnimation 会设置 alpha
            //      TranslateAnimation 会设置平移矩阵
            applyTransformation(interpolatedTime, outTransformation);
        }
        
        // 返回动画是否还在进行
        return !expired;
    }
    
    /**
     * 子类实现此方法，应用具体的变换
     * 这是模板方法模式
     */
    protected abstract void applyTransformation(float interpolatedTime, 
            Transformation t);
}

/**
 * AlphaAnimation 实现
 */
public class AlphaAnimation extends Animation {
    
    private float mFromAlpha;
    private float mToAlpha;
    
    @Override
    protected void applyTransformation(float interpolatedTime, Transformation t) {
        // 计算当前 alpha 值
        final float alpha = mFromAlpha + ((mToAlpha - mFromAlpha) * interpolatedTime);
        // 设置到 Transformation
        t.setAlpha(alpha);
    }
}

/**
 * TranslateAnimation 实现
 */
public class TranslateAnimation extends Animation {
    
    private float mFromXDelta;
    private float mToXDelta;
    private float mFromYDelta;
    private float mToYDelta;
    
    @Override
    protected void applyTransformation(float interpolatedTime, Transformation t) {
        // 计算当前位移
        float dx = mFromXDelta + ((mToXDelta - mFromXDelta) * interpolatedTime);
        float dy = mFromYDelta + ((mToYDelta - mFromYDelta) * interpolatedTime);
        // 设置平移矩阵
        t.getMatrix().setTranslate(dx, dy);
    }
}
```


### 3.5 Transition 框架源码分析

```java
/**
 * Transition 框架核心源码
 * 路径: android/transition/Transition.java
 */
public abstract class Transition implements Cloneable {
    
    // 捕获的起始值
    ArrayList<TransitionValues> mStartValues = new ArrayList<>();
    
    // 捕获的结束值
    ArrayList<TransitionValues> mEndValues = new ArrayList<>();
    
    // 目标 View 列表
    ArrayList<View> mTargets = new ArrayList<>();
    
    /**
     * 【核心方法】捕获 View 的属性值
     * 子类必须实现此方法，指定要捕获哪些属性
     */
    public abstract void captureStartValues(TransitionValues transitionValues);
    public abstract void captureEndValues(TransitionValues transitionValues);
    
    /**
     * 【核心方法】创建动画
     * 子类实现此方法，根据 start/end 值创建 Animator
     */
    public abstract Animator createAnimator(ViewGroup sceneRoot,
            TransitionValues startValues, TransitionValues endValues);
    
    /**
     * 执行过渡动画
     * TransitionManager 调用此方法
     */
    void playTransition(ViewGroup sceneRoot) {
        // 1. 匹配 start 和 end 的 View
        matchStartAndEnd();
        
        // 2. 创建动画
        ArrayMap<Animator, AnimationInfo> runningAnimators = getRunningAnimators();
        
        for (int i = 0; i < mStartValues.size(); i++) {
            TransitionValues start = mStartValues.get(i);
            TransitionValues end = mEndValues.get(i);
            
            // 【关键】调用子类的 createAnimator 创建动画
            Animator animator = createAnimator(sceneRoot, start, end);
            
            if (animator != null) {
                // 启动动画
                animator.start();
            }
        }
    }
}

/**
 * ChangeBounds 实现 - 位置和大小变化动画
 * 路径: android/transition/ChangeBounds.java
 */
public class ChangeBounds extends Transition {
    
    // 要捕获的属性名
    private static final String PROPNAME_BOUNDS = "android:changeBounds:bounds";
    private static final String PROPNAME_PARENT = "android:changeBounds:parent";
    
    @Override
    public void captureStartValues(TransitionValues transitionValues) {
        captureValues(transitionValues);
    }
    
    @Override
    public void captureEndValues(TransitionValues transitionValues) {
        captureValues(transitionValues);
    }
    
    /**
     * 捕获 View 的位置和大小
     */
    private void captureValues(TransitionValues values) {
        View view = values.view;
        
        // 捕获边界
        Rect bounds = new Rect(view.getLeft(), view.getTop(),
                view.getRight(), view.getBottom());
        values.values.put(PROPNAME_BOUNDS, bounds);
        
        // 捕获父 View
        values.values.put(PROPNAME_PARENT, view.getParent());
    }
    
    /**
     * 创建位置/大小变化动画
     */
    @Override
    public Animator createAnimator(ViewGroup sceneRoot,
            TransitionValues startValues, TransitionValues endValues) {
        
        if (startValues == null || endValues == null) {
            return null;
        }
        
        // 获取起始和结束边界
        Rect startBounds = (Rect) startValues.values.get(PROPNAME_BOUNDS);
        Rect endBounds = (Rect) endValues.values.get(PROPNAME_BOUNDS);
        
        // 如果边界相同，不需要动画
        if (startBounds.equals(endBounds)) {
            return null;
        }
        
        final View view = endValues.view;
        
        // 【关键】创建属性动画
        // 使用 ObjectAnimator 同时动画 left, top, right, bottom
        ObjectAnimator animator = ObjectAnimator.ofObject(view, 
                new PropertyValuesHolder[]{
                    PropertyValuesHolder.ofInt("left", startBounds.left, endBounds.left),
                    PropertyValuesHolder.ofInt("top", startBounds.top, endBounds.top),
                    PropertyValuesHolder.ofInt("right", startBounds.right, endBounds.right),
                    PropertyValuesHolder.ofInt("bottom", startBounds.bottom, endBounds.bottom)
                });
        
        return animator;
    }
}

/**
 * TransitionManager 源码
 * 管理场景切换
 */
public class TransitionManager {
    
    /**
     * 切换到指定场景
     */
    public static void go(Scene scene, Transition transition) {
        // 获取场景根 View
        ViewGroup sceneRoot = scene.getSceneRoot();
        
        // 1. 【捕获起始值】
        transition.captureValues(sceneRoot, true /* start */);
        
        // 2. 【切换场景】
        scene.enter();
        
        // 3. 【捕获结束值】
        // 使用 OnPreDrawListener 确保布局完成后再捕获
        sceneRoot.getViewTreeObserver().addOnPreDrawListener(
                new ViewTreeObserver.OnPreDrawListener() {
                    @Override
                    public boolean onPreDraw() {
                        sceneRoot.getViewTreeObserver().removeOnPreDrawListener(this);
                        
                        // 捕获结束值
                        transition.captureValues(sceneRoot, false /* end */);
                        
                        // 4. 【执行动画】
                        transition.playTransition(sceneRoot);
                        
                        return true;
                    }
                });
    }
    
    /**
     * 延迟过渡 - 自动检测布局变化
     * 最常用的 API
     */
    public static void beginDelayedTransition(ViewGroup sceneRoot, Transition transition) {
        // 捕获当前状态
        transition.captureValues(sceneRoot, true);
        
        // 在下一帧捕获结束状态并执行动画
        sceneRoot.getViewTreeObserver().addOnPreDrawListener(
                new ViewTreeObserver.OnPreDrawListener() {
                    @Override
                    public boolean onPreDraw() {
                        sceneRoot.getViewTreeObserver().removeOnPreDrawListener(this);
                        transition.captureValues(sceneRoot, false);
                        transition.playTransition(sceneRoot);
                        return true;
                    }
                });
    }
}
```

### 3.6 插值器源码分析

```java
/**
 * 常用插值器源码分析
 */

/**
 * 线性插值器 - 匀速
 */
public class LinearInterpolator implements Interpolator {
    @Override
    public float getInterpolation(float input) {
        // 直接返回输入值，匀速变化
        return input;
    }
}

/**
 * 加速插值器
 * 使用幂函数实现加速效果
 */
public class AccelerateInterpolator implements Interpolator {
    private final float mFactor;  // 加速因子
    private final double mDoubleFactor;
    
    public AccelerateInterpolator(float factor) {
        mFactor = factor;
        mDoubleFactor = 2 * factor;
    }
    
    @Override
    public float getInterpolation(float input) {
        // 使用幂函数：input^(2*factor)
        // factor 越大，加速越明显
        if (mFactor == 1.0f) {
            return input * input;  // 平方
        } else {
            return (float) Math.pow(input, mDoubleFactor);
        }
    }
}

/**
 * 减速插值器
 * 使用 1 - (1-x)^(2*factor) 实现减速效果
 */
public class DecelerateInterpolator implements Interpolator {
    private float mFactor = 1.0f;
    
    @Override
    public float getInterpolation(float input) {
        if (mFactor == 1.0f) {
            // 1 - (1-x)^2
            return 1.0f - (1.0f - input) * (1.0f - input);
        } else {
            return (float) (1.0f - Math.pow((1.0f - input), 2 * mFactor));
        }
    }
}

/**
 * 超出回弹插值器
 * 动画会超出目标值然后回弹
 */
public class OvershootInterpolator implements Interpolator {
    private final float mTension;  // 张力，控制超出程度
    
    public OvershootInterpolator(float tension) {
        mTension = tension;
    }
    
    @Override
    public float getInterpolation(float t) {
        // 公式：(t-1)^2 * ((tension+1) * (t-1) + tension) + 1
        // 当 t=1 时，结果为 1
        // 在 t 接近 1 时会超出 1，然后回到 1
        t -= 1.0f;
        return t * t * ((mTension + 1) * t + mTension) + 1.0f;
    }
}

/**
 * 弹跳插值器
 * 模拟物体落地弹跳效果
 */
public class BounceInterpolator implements Interpolator {
    
    @Override
    public float getInterpolation(float t) {
        // 分段函数，模拟多次弹跳
        // 每次弹跳高度递减
        t *= 1.1226f;
        if (t < 0.3535f) {
            return bounce(t);
        } else if (t < 0.7408f) {
            return bounce(t - 0.54719f) + 0.7f;
        } else if (t < 0.9644f) {
            return bounce(t - 0.8526f) + 0.9f;
        } else {
            return bounce(t - 1.0435f) + 0.95f;
        }
    }
    
    private static float bounce(float t) {
        return t * t * 8.0f;
    }
}

/**
 * 路径插值器 (API 21+)
 * 使用贝塞尔曲线定义插值
 */
public class PathInterpolator implements Interpolator {
    
    private float[] mX;  // 路径 X 坐标数组
    private float[] mY;  // 路径 Y 坐标数组
    
    /**
     * 使用控制点创建三次贝塞尔曲线插值器
     */
    public PathInterpolator(float controlX1, float controlY1,
            float controlX2, float controlY2) {
        // 创建贝塞尔曲线路径
        initCubic(controlX1, controlY1, controlX2, controlY2);
    }
    
    @Override
    public float getInterpolation(float t) {
        if (t <= 0) return 0;
        if (t >= 1) return 1;
        
        // 二分查找 X 坐标对应的索引
        int startIndex = 0;
        int endIndex = mX.length - 1;
        
        while (endIndex - startIndex > 1) {
            int midIndex = (startIndex + endIndex) / 2;
            if (t < mX[midIndex]) {
                endIndex = midIndex;
            } else {
                startIndex = midIndex;
            }
        }
        
        // 线性插值计算 Y 值
        float xRange = mX[endIndex] - mX[startIndex];
        if (xRange == 0) {
            return mY[startIndex];
        }
        
        float tInRange = t - mX[startIndex];
        float fraction = tInRange / xRange;
        
        float startY = mY[startIndex];
        float endY = mY[endIndex];
        
        return startY + (fraction * (endY - startY));
    }
}
```


## 4. 实战应用

### 4.1 属性动画最佳实践

```kotlin
/**
 * 属性动画最佳实践
 */
class AnimationBestPractices {
    
    /**
     * 1. 使用 Property 对象代替字符串，避免反射开销
     */
    fun usePropertyObject(view: View) {
        // ❌ 不推荐：使用字符串，需要反射
        ObjectAnimator.ofFloat(view, "alpha", 0f, 1f)
        
        // ✅ 推荐：使用 Property 对象，无反射
        ObjectAnimator.ofFloat(view, View.ALPHA, 0f, 1f)
        
        // 常用 Property 对象
        // View.ALPHA, View.TRANSLATION_X, View.TRANSLATION_Y
        // View.SCALE_X, View.SCALE_Y, View.ROTATION
        // View.X, View.Y
    }
    
    /**
     * 2. 使用 ViewPropertyAnimator 简化代码
     * 内部优化，性能更好
     */
    fun useViewPropertyAnimator(view: View) {
        // ❌ 传统方式
        val animatorSet = AnimatorSet()
        animatorSet.playTogether(
            ObjectAnimator.ofFloat(view, View.ALPHA, 0f, 1f),
            ObjectAnimator.ofFloat(view, View.TRANSLATION_X, 100f, 0f),
            ObjectAnimator.ofFloat(view, View.SCALE_X, 0.5f, 1f),
            ObjectAnimator.ofFloat(view, View.SCALE_Y, 0.5f, 1f)
        )
        animatorSet.duration = 300
        animatorSet.start()
        
        // ✅ 推荐：ViewPropertyAnimator
        view.animate()
            .alpha(1f)
            .translationX(0f)
            .scaleX(1f)
            .scaleY(1f)
            .setDuration(300)
            .start()
    }
    
    /**
     * 3. 正确取消动画，避免内存泄漏
     */
    class MyActivity : AppCompatActivity() {
        private var animator: ObjectAnimator? = null
        
        fun startAnimation(view: View) {
            animator = ObjectAnimator.ofFloat(view, View.ALPHA, 0f, 1f).apply {
                duration = 1000
                start()
            }
        }
        
        override fun onDestroy() {
            super.onDestroy()
            // ✅ 在 Activity 销毁时取消动画
            animator?.cancel()
            animator = null
        }
    }
    
    /**
     * 4. 使用 Kotlin 扩展简化动画代码
     */
    fun View.fadeIn(duration: Long = 300) {
        alpha = 0f
        visibility = View.VISIBLE
        animate()
            .alpha(1f)
            .setDuration(duration)
            .setListener(null)
            .start()
    }
    
    fun View.fadeOut(duration: Long = 300, onEnd: () -> Unit = {}) {
        animate()
            .alpha(0f)
            .setDuration(duration)
            .setListener(object : AnimatorListenerAdapter() {
                override fun onAnimationEnd(animation: Animator) {
                    visibility = View.GONE
                    onEnd()
                }
            })
            .start()
    }
    
    /**
     * 5. 使用硬件加速优化动画性能
     */
    fun optimizeWithHardwareLayer(view: View) {
        view.animate()
            .alpha(0f)
            .translationX(100f)
            .withLayer()  // 启用硬件层
            .setDuration(300)
            .start()
    }
}
```

### 4.2 Transition 框架实战

```kotlin
/**
 * Transition 框架实战应用
 */
class TransitionPractices {
    
    /**
     * 1. 基本的延迟过渡
     */
    fun basicDelayedTransition(container: ViewGroup) {
        // 开始延迟过渡
        TransitionManager.beginDelayedTransition(container, AutoTransition())
        
        // 修改布局
        val view = container.getChildAt(0)
        val params = view.layoutParams
        params.width = 200.dp
        params.height = 200.dp
        view.layoutParams = params
        
        // 系统会自动计算变化并执行动画
    }
    
    /**
     * 2. 自定义 Transition 组合
     */
    fun customTransitionSet(container: ViewGroup) {
        val transition = TransitionSet().apply {
            ordering = TransitionSet.ORDERING_TOGETHER
            addTransition(Fade(Fade.OUT))
            addTransition(ChangeBounds())
            addTransition(Fade(Fade.IN))
            duration = 300
            interpolator = FastOutSlowInInterpolator()
        }
        
        TransitionManager.beginDelayedTransition(container, transition)
        
        // 修改布局...
    }
    
    /**
     * 3. 共享元素动画
     */
    fun sharedElementTransition(activity: Activity, imageView: ImageView) {
        val intent = Intent(activity, DetailActivity::class.java)
        
        // 创建共享元素选项
        val options = ActivityOptions.makeSceneTransitionAnimation(
            activity,
            imageView,  // 共享的 View
            "shared_image"  // transitionName，两个 Activity 中必须相同
        )
        
        activity.startActivity(intent, options.toBundle())
    }
    
    /**
     * 4. 多个共享元素
     */
    fun multipleSharedElements(activity: Activity, imageView: ImageView, titleView: TextView) {
        val intent = Intent(activity, DetailActivity::class.java)
        
        val pairs = arrayOf(
            Pair.create(imageView as View, "shared_image"),
            Pair.create(titleView as View, "shared_title")
        )
        
        val options = ActivityOptions.makeSceneTransitionAnimation(activity, *pairs)
        activity.startActivity(intent, options.toBundle())
    }
    
    /**
     * 5. 自定义 Transition
     */
    class CircularRevealTransition : Visibility() {
        
        override fun onAppear(
            sceneRoot: ViewGroup,
            view: View,
            startValues: TransitionValues?,
            endValues: TransitionValues?
        ): Animator? {
            // 计算圆形揭示动画的中心和半径
            val cx = view.width / 2
            val cy = view.height / 2
            val finalRadius = hypot(cx.toDouble(), cy.toDouble()).toFloat()
            
            // 创建圆形揭示动画
            return ViewAnimationUtils.createCircularReveal(
                view, cx, cy, 0f, finalRadius
            )
        }
        
        override fun onDisappear(
            sceneRoot: ViewGroup,
            view: View,
            startValues: TransitionValues?,
            endValues: TransitionValues?
        ): Animator? {
            val cx = view.width / 2
            val cy = view.height / 2
            val initialRadius = hypot(cx.toDouble(), cy.toDouble()).toFloat()
            
            return ViewAnimationUtils.createCircularReveal(
                view, cx, cy, initialRadius, 0f
            )
        }
    }
}
```

### 4.3 MotionLayout 实战

```xml
<!-- 1. 布局文件 activity_motion.xml -->
<androidx.constraintlayout.motion.widget.MotionLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:id="@+id/motionLayout"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    app:layoutDescription="@xml/scene_header_collapse">

    <ImageView
        android:id="@+id/headerImage"
        android:layout_width="match_parent"
        android:layout_height="200dp"
        android:scaleType="centerCrop"
        android:src="@drawable/header" />

    <TextView
        android:id="@+id/titleText"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Title"
        android:textSize="24sp" />

</androidx.constraintlayout.motion.widget.MotionLayout>
```

```xml
<!-- 2. MotionScene 文件 res/xml/scene_header_collapse.xml -->
<MotionScene xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:motion="http://schemas.android.com/apk/res-auto">

    <!-- 过渡定义 -->
    <Transition
        motion:constraintSetStart="@id/start"
        motion:constraintSetEnd="@id/end"
        motion:duration="300">

        <!-- 滑动触发 -->
        <OnSwipe
            motion:touchAnchorId="@id/headerImage"
            motion:touchAnchorSide="bottom"
            motion:dragDirection="dragUp" />

        <!-- 关键帧 -->
        <KeyFrameSet>
            <!-- 位置关键帧：让标题走弧线 -->
            <KeyPosition
                motion:motionTarget="@id/titleText"
                motion:framePosition="50"
                motion:keyPositionType="pathRelative"
                motion:percentY="-0.2" />

            <!-- 属性关键帧：中间时刻透明度变化 -->
            <KeyAttribute
                motion:motionTarget="@id/headerImage"
                motion:framePosition="50"
                android:alpha="0.5" />
        </KeyFrameSet>
    </Transition>

    <!-- 起始状态 -->
    <ConstraintSet android:id="@+id/start">
        <Constraint
            android:id="@id/headerImage"
            android:layout_width="match_parent"
            android:layout_height="200dp"
            motion:layout_constraintTop_toTopOf="parent" />

        <Constraint
            android:id="@id/titleText"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginStart="16dp"
            android:layout_marginBottom="16dp"
            motion:layout_constraintStart_toStartOf="parent"
            motion:layout_constraintBottom_toBottomOf="@id/headerImage">
            <CustomAttribute
                motion:attributeName="textSize"
                motion:customFloatValue="24" />
        </Constraint>
    </ConstraintSet>

    <!-- 结束状态 -->
    <ConstraintSet android:id="@+id/end">
        <Constraint
            android:id="@id/headerImage"
            android:layout_width="match_parent"
            android:layout_height="56dp"
            motion:layout_constraintTop_toTopOf="parent" />

        <Constraint
            android:id="@id/titleText"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginStart="72dp"
            motion:layout_constraintStart_toStartOf="parent"
            motion:layout_constraintTop_toTopOf="parent"
            motion:layout_constraintBottom_toBottomOf="@id/headerImage">
            <CustomAttribute
                motion:attributeName="textSize"
                motion:customFloatValue="18" />
        </Constraint>
    </ConstraintSet>

</MotionScene>
```

```kotlin
/**
 * MotionLayout 代码控制
 */
class MotionLayoutController {
    
    fun controlMotionLayout(motionLayout: MotionLayout) {
        // 1. 设置进度
        motionLayout.progress = 0.5f
        
        // 2. 过渡到结束状态
        motionLayout.transitionToEnd()
        
        // 3. 过渡到起始状态
        motionLayout.transitionToStart()
        
        // 4. 监听过渡
        motionLayout.setTransitionListener(object : MotionLayout.TransitionListener {
            override fun onTransitionStarted(
                motionLayout: MotionLayout,
                startId: Int,
                endId: Int
            ) {
                // 过渡开始
            }
            
            override fun onTransitionChange(
                motionLayout: MotionLayout,
                startId: Int,
                endId: Int,
                progress: Float
            ) {
                // 进度变化
            }
            
            override fun onTransitionCompleted(
                motionLayout: MotionLayout,
                currentId: Int
            ) {
                // 过渡完成
            }
            
            override fun onTransitionTrigger(
                motionLayout: MotionLayout,
                triggerId: Int,
                positive: Boolean,
                progress: Float
            ) {
                // 触发器触发
            }
        })
    }
}
```

### 4.4 Lottie 动画实战

```kotlin
/**
 * Lottie 动画最佳实践
 */
class LottiePractices {
    
    /**
     * 1. 基本使用
     */
    fun basicUsage(lottieView: LottieAnimationView) {
        // 从 assets 加载
        lottieView.setAnimation("animation.json")
        lottieView.playAnimation()
        
        // 从 raw 资源加载
        lottieView.setAnimation(R.raw.animation)
        lottieView.playAnimation()
        
        // 从 URL 加载
        lottieView.setAnimationFromUrl("https://example.com/animation.json")
        lottieView.playAnimation()
    }
    
    /**
     * 2. 控制播放
     */
    fun controlPlayback(lottieView: LottieAnimationView) {
        // 播放
        lottieView.playAnimation()
        
        // 暂停
        lottieView.pauseAnimation()
        
        // 取消
        lottieView.cancelAnimation()
        
        // 设置进度
        lottieView.progress = 0.5f
        
        // 设置播放范围（帧）
        lottieView.setMinAndMaxFrame(0, 30)
        
        // 设置播放范围（进度）
        lottieView.setMinAndMaxProgress(0f, 0.5f)
        
        // 循环播放
        lottieView.repeatCount = LottieDrawable.INFINITE
        
        // 反向播放
        lottieView.repeatMode = LottieDrawable.REVERSE
        
        // 播放速度
        lottieView.speed = 2f
    }
    
    /**
     * 3. 动态修改属性
     */
    fun dynamicProperties(lottieView: LottieAnimationView) {
        // 修改颜色
        lottieView.addValueCallback(
            KeyPath("**"),  // 匹配所有图层
            LottieProperty.COLOR_FILTER
        ) { PorterDuffColorFilter(Color.RED, PorterDuff.Mode.SRC_ATOP) }
        
        // 修改特定图层的颜色
        lottieView.addValueCallback(
            KeyPath("Layer Name", "**"),
            LottieProperty.COLOR
        ) { Color.BLUE }
        
        // 修改透明度
        lottieView.addValueCallback(
            KeyPath("**"),
            LottieProperty.OPACITY
        ) { 50 }  // 0-100
    }
    
    /**
     * 4. 监听动画
     */
    fun addListeners(lottieView: LottieAnimationView) {
        lottieView.addAnimatorListener(object : Animator.AnimatorListener {
            override fun onAnimationStart(animation: Animator) {
                // 动画开始
            }
            
            override fun onAnimationEnd(animation: Animator) {
                // 动画结束
            }
            
            override fun onAnimationCancel(animation: Animator) {
                // 动画取消
            }
            
            override fun onAnimationRepeat(animation: Animator) {
                // 动画重复
            }
        })
        
        // 进度更新
        lottieView.addAnimatorUpdateListener { animation ->
            val progress = animation.animatedFraction
            // 处理进度
        }
    }
    
    /**
     * 5. 性能优化
     */
    fun optimizePerformance(lottieView: LottieAnimationView) {
        // 使用硬件加速
        lottieView.setRenderMode(RenderMode.HARDWARE)
        
        // 缓存 Composition
        LottieCompositionFactory.fromAsset(context, "animation.json")
            .addListener { composition ->
                // 缓存 composition，避免重复解析
                lottieView.setComposition(composition)
            }
        
        // 设置缓存策略
        lottieView.setCacheComposition(true)
        
        // 减少内存占用：使用较小的缩放
        lottieView.setImageAssetsFolder("images/")
    }
}
```


### 4.5 动画性能优化

```kotlin
/**
 * 动画性能优化最佳实践
 */
class AnimationPerformanceOptimization {
    
    /**
     * 1. 使用硬件层加速
     */
    fun useHardwareLayer(view: View) {
        // 动画开始前设置硬件层
        view.setLayerType(View.LAYER_TYPE_HARDWARE, null)
        
        view.animate()
            .translationX(100f)
            .setDuration(300)
            .setListener(object : AnimatorListenerAdapter() {
                override fun onAnimationEnd(animation: Animator) {
                    // 动画结束后移除硬件层，释放 GPU 内存
                    view.setLayerType(View.LAYER_TYPE_NONE, null)
                }
            })
            .start()
        
        // 或使用 withLayer()
        view.animate()
            .alpha(0f)
            .withLayer()  // 自动管理硬件层
            .start()
    }
    
    /**
     * 2. 避免在动画中触发布局
     */
    fun avoidLayoutDuringAnimation(view: View) {
        // ❌ 不推荐：修改 LayoutParams 会触发 requestLayout
        val animator = ValueAnimator.ofInt(100, 200)
        animator.addUpdateListener {
            val params = view.layoutParams
            params.width = it.animatedValue as Int
            view.layoutParams = params  // 触发 requestLayout!
        }
        
        // ✅ 推荐：使用 scaleX/scaleY 代替修改宽高
        view.animate()
            .scaleX(2f)
            .scaleY(2f)
            .start()
        
        // ✅ 或使用 translationX/Y 代替修改 margin
        view.animate()
            .translationX(100f)
            .start()
    }
    
    /**
     * 3. 使用 RenderThread 动画 (API 21+)
     */
    fun useRenderThreadAnimation(view: View) {
        // ViewPropertyAnimator 在 API 21+ 会自动使用 RenderThread
        // 动画在渲染线程执行，不受主线程卡顿影响
        view.animate()
            .translationX(100f)
            .setDuration(300)
            .start()
        
        // 以下属性支持 RenderThread 动画：
        // - translationX, translationY, translationZ
        // - scaleX, scaleY
        // - rotation, rotationX, rotationY
        // - alpha
        // - x, y, z
    }
    
    /**
     * 4. 减少过度绘制
     */
    fun reduceOverdraw(view: View) {
        // 动画期间隐藏不可见的 View
        view.animate()
            .alpha(0f)
            .setListener(object : AnimatorListenerAdapter() {
                override fun onAnimationEnd(animation: Animator) {
                    view.visibility = View.GONE  // 完全移除绘制
                }
            })
            .start()
    }
    
    /**
     * 5. 使用 Choreographer 同步动画
     */
    fun syncWithChoreographer() {
        val choreographer = Choreographer.getInstance()
        
        choreographer.postFrameCallback(object : Choreographer.FrameCallback {
            override fun doFrame(frameTimeNanos: Long) {
                // 在 VSYNC 信号时执行
                // 确保动画与屏幕刷新同步
                updateAnimation(frameTimeNanos)
                
                // 继续下一帧
                choreographer.postFrameCallback(this)
            }
        })
    }
    
    /**
     * 6. 动画帧率监控
     */
    fun monitorFrameRate() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
            val frameMetrics = Window.OnFrameMetricsAvailableListener { window, frameMetrics, dropCountSinceLastInvocation ->
                // 获取帧时间
                val totalDuration = frameMetrics.getMetric(FrameMetrics.TOTAL_DURATION)
                val layoutDuration = frameMetrics.getMetric(FrameMetrics.LAYOUT_MEASURE_DURATION)
                val drawDuration = frameMetrics.getMetric(FrameMetrics.DRAW_DURATION)
                
                // 检测掉帧
                if (totalDuration > 16_000_000) {  // 超过 16ms
                    Log.w("FrameMetrics", "Frame dropped! Total: ${totalDuration / 1_000_000}ms")
                }
            }
            
            window.addOnFrameMetricsAvailableListener(frameMetrics, Handler(Looper.getMainLooper()))
        }
    }
}
```

## 5. 常见面试题

### 5.1 View 动画与属性动画的区别？

**答案要点：**

| 特性 | View 动画 | 属性动画 |
|------|----------|---------|
| **实现原理** | 通过 Matrix 变换 Canvas 绘制 | 真正修改对象属性值 |
| **作用对象** | 只能作用于 View | 可作用于任意对象 |
| **属性改变** | 不改变 View 实际属性 | 真正改变属性值 |
| **点击区域** | 动画后点击区域不变 | 点击区域随动画变化 |
| **支持属性** | 仅支持透明度、缩放、旋转、平移 | 支持任意属性 |
| **API 版本** | API 1+ | API 11+ |
| **性能** | 较好（只改变绘制） | 需要反射（可优化） |

**深入解析：**
```kotlin
// View 动画：只改变绘制，不改变实际位置
val translateAnimation = TranslateAnimation(0f, 200f, 0f, 0f)
view.startAnimation(translateAnimation)
// 动画结束后，view.getX() 仍然是原来的值
// 点击原位置仍然能响应点击事件

// 属性动画：真正改变属性值
ObjectAnimator.ofFloat(view, View.TRANSLATION_X, 0f, 200f).start()
// 动画结束后，view.getTranslationX() = 200f
// 点击新位置才能响应点击事件
```

---

### 5.2 属性动画的工作原理？ValueAnimator 和 ObjectAnimator 的区别？

**答案要点：**

**属性动画工作原理：**
1. **注册到 Choreographer**：动画启动时注册到 AnimationHandler，AnimationHandler 向 Choreographer 注册帧回调
2. **VSYNC 驱动**：每个 VSYNC 信号到来时，Choreographer 回调 AnimationHandler
3. **计算当前值**：根据已过时间计算 fraction，通过插值器和估值器计算当前属性值
4. **通知更新**：回调 AnimatorUpdateListener 或直接设置属性值

**ValueAnimator vs ObjectAnimator：**

| 特性 | ValueAnimator | ObjectAnimator |
|------|--------------|----------------|
| **功能** | 只计算值，不设置属性 | 计算值并自动设置属性 |
| **使用方式** | 需要手动在回调中设置属性 | 自动通过反射/Property 设置 |
| **灵活性** | 更灵活，可控制多个属性 | 简单直接，一对一映射 |
| **性能** | 无反射开销 | 有反射开销（可用 Property 优化） |

```kotlin
// ValueAnimator：手动设置属性
ValueAnimator.ofFloat(0f, 1f).apply {
    addUpdateListener { animator ->
        val value = animator.animatedValue as Float
        view.alpha = value  // 手动设置
        view.scaleX = value
        view.scaleY = value
    }
    start()
}

// ObjectAnimator：自动设置属性
ObjectAnimator.ofFloat(view, View.ALPHA, 0f, 1f).start()
```

---

### 5.3 插值器和估值器的作用？如何自定义？

**答案要点：**

**插值器 (Interpolator)：**
- 作用：控制动画的变化速率
- 输入：时间进度 [0, 1]
- 输出：插值后的进度 [0, 1]（可超出范围）

**估值器 (TypeEvaluator)：**
- 作用：根据进度计算属性的实际值
- 输入：插值后的进度、起始值、结束值
- 输出：当前属性值

```kotlin
// 自定义插值器：弹性效果
class SpringInterpolator(private val factor: Float = 0.4f) : Interpolator {
    override fun getInterpolation(input: Float): Float {
        // 弹性公式
        return (2.0.pow(-10.0 * input) * sin((input - factor / 4) * 
                (2 * Math.PI) / factor) + 1).toFloat()
    }
}

// 自定义估值器：PointF 类型
class PointFEvaluator : TypeEvaluator<PointF> {
    override fun evaluate(fraction: Float, startValue: PointF, endValue: PointF): PointF {
        return PointF(
            startValue.x + fraction * (endValue.x - startValue.x),
            startValue.y + fraction * (endValue.y - startValue.y)
        )
    }
}

// 使用自定义估值器
val animator = ValueAnimator.ofObject(
    PointFEvaluator(),
    PointF(0f, 0f),
    PointF(100f, 100f)
)
```

---

### 5.4 Transition 框架的工作原理？如何实现共享元素动画？

**答案要点：**

**Transition 框架工作原理：**
1. **captureStartValues()**：捕获场景切换前所有 View 的属性值
2. **场景切换**：执行布局变化
3. **captureEndValues()**：捕获场景切换后所有 View 的属性值
4. **createAnimator()**：比较 start/end 值，创建属性动画
5. **执行动画**：从 startValues 过渡到 endValues

**共享元素动画实现：**
```kotlin
// Activity A
val intent = Intent(this, DetailActivity::class.java)
val options = ActivityOptions.makeSceneTransitionAnimation(
    this,
    imageView,
    "shared_image"  // transitionName
)
startActivity(intent, options.toBundle())

// Activity B 的 ImageView
android:transitionName="shared_image"

// 自定义共享元素 Transition
window.sharedElementEnterTransition = TransitionSet().apply {
    addTransition(ChangeBounds())
    addTransition(ChangeTransform())
    addTransition(ChangeImageTransform())
    duration = 300
}
```

---

### 5.5 MotionLayout 的优势和使用场景？

**答案要点：**

**优势：**
1. **声明式动画**：在 XML 中定义动画，代码更清晰
2. **手势驱动**：原生支持滑动、点击等手势触发动画
3. **关键帧支持**：可以定义中间状态，实现复杂路径动画
4. **与 ConstraintLayout 集成**：复用约束布局的强大能力
5. **可视化编辑**：Android Studio 提供 Motion Editor

**使用场景：**
- 折叠/展开头部（CoordinatorLayout 效果）
- 引导页动画
- 复杂的手势交互动画
- 状态切换动画

```xml
<!-- MotionScene 示例 -->
<Transition
    motion:constraintSetStart="@id/collapsed"
    motion:constraintSetEnd="@id/expanded">
    
    <OnSwipe
        motion:touchAnchorId="@id/header"
        motion:dragDirection="dragDown" />
    
    <KeyFrameSet>
        <KeyPosition
            motion:motionTarget="@id/icon"
            motion:framePosition="50"
            motion:percentY="0.2" />
    </KeyFrameSet>
</Transition>
```

---

### 5.6 如何优化动画性能？

**答案要点：**

1. **使用硬件层**
```kotlin
view.animate().withLayer()  // 自动管理
// 或手动管理
view.setLayerType(View.LAYER_TYPE_HARDWARE, null)
```

2. **避免触发布局**
```kotlin
// ❌ 修改 LayoutParams 触发 requestLayout
// ✅ 使用 translationX/Y, scaleX/Y 代替
```

3. **使用 Property 对象**
```kotlin
// ❌ ObjectAnimator.ofFloat(view, "alpha", 0f, 1f)  // 反射
// ✅ ObjectAnimator.ofFloat(view, View.ALPHA, 0f, 1f)  // 无反射
```

4. **使用 ViewPropertyAnimator**
```kotlin
view.animate().alpha(1f).translationX(100f)  // 内部优化
```

5. **及时取消动画**
```kotlin
override fun onDestroy() {
    animator?.cancel()
}
```

6. **使用 RenderThread 动画**（API 21+）
- translationX/Y/Z, scaleX/Y, rotation, alpha 等属性支持

---

### 5.7 Lottie 动画的原理？如何优化 Lottie 性能？

**答案要点：**

**Lottie 原理：**
1. **JSON 解析**：解析 After Effects 导出的 JSON 文件
2. **构建模型**：创建 LottieComposition，包含图层、关键帧、路径等信息
3. **帧渲染**：根据 progress 计算每个图层的属性，使用 Canvas API 绘制

**性能优化：**
```kotlin
// 1. 使用硬件加速
lottieView.setRenderMode(RenderMode.HARDWARE)

// 2. 缓存 Composition
LottieCompositionFactory.fromAsset(context, "animation.json")
    .addListener { composition ->
        lottieView.setComposition(composition)
    }

// 3. 减少动画复杂度
// - 减少图层数量
// - 避免使用蒙版和遮罩
// - 简化路径

// 4. 控制动画大小
// - 使用合适的尺寸
// - 避免过大的动画文件

// 5. 按需播放
lottieView.setMinAndMaxFrame(0, 30)  // 只播放部分帧
```

---

### 5.8 属性动画如何实现无限循环？如何避免内存泄漏？

**答案要点：**

**无限循环：**
```kotlin
val animator = ObjectAnimator.ofFloat(view, View.ROTATION, 0f, 360f).apply {
    duration = 1000
    repeatCount = ValueAnimator.INFINITE  // 无限循环
    repeatMode = ValueAnimator.RESTART    // 重新开始
    // 或 ValueAnimator.REVERSE  // 反向播放
    interpolator = LinearInterpolator()
}
animator.start()
```

**避免内存泄漏：**
```kotlin
class MyActivity : AppCompatActivity() {
    private var animator: ObjectAnimator? = null
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        animator = ObjectAnimator.ofFloat(view, View.ALPHA, 0f, 1f).apply {
            repeatCount = ValueAnimator.INFINITE
            start()
        }
    }
    
    override fun onDestroy() {
        super.onDestroy()
        // ✅ 必须取消动画
        animator?.cancel()
        animator?.removeAllListeners()
        animator = null
    }
}

// 使用 lifecycleScope 自动管理
lifecycleScope.launch {
    repeatOnLifecycle(Lifecycle.State.STARTED) {
        // 动画只在 STARTED 状态执行
        startAnimation()
    }
}
```

---

### 5.9 如何实现一个自定义的 Transition？

**答案要点：**

```kotlin
/**
 * 自定义圆形揭示 Transition
 */
class CircularRevealTransition : Visibility() {
    
    companion object {
        private const val PROPNAME_SCREEN_LOCATION = "circularReveal:screenLocation"
    }
    
    override fun captureStartValues(transitionValues: TransitionValues) {
        super.captureStartValues(transitionValues)
        captureValues(transitionValues)
    }
    
    override fun captureEndValues(transitionValues: TransitionValues) {
        super.captureEndValues(transitionValues)
        captureValues(transitionValues)
    }
    
    private fun captureValues(transitionValues: TransitionValues) {
        val view = transitionValues.view
        val location = IntArray(2)
        view.getLocationOnScreen(location)
        transitionValues.values[PROPNAME_SCREEN_LOCATION] = location
    }
    
    override fun onAppear(
        sceneRoot: ViewGroup,
        view: View,
        startValues: TransitionValues?,
        endValues: TransitionValues?
    ): Animator? {
        if (endValues == null) return null
        
        val cx = view.width / 2
        val cy = view.height / 2
        val endRadius = hypot(cx.toDouble(), cy.toDouble()).toFloat()
        
        return ViewAnimationUtils.createCircularReveal(view, cx, cy, 0f, endRadius)
    }
    
    override fun onDisappear(
        sceneRoot: ViewGroup,
        view: View,
        startValues: TransitionValues?,
        endValues: TransitionValues?
    ): Animator? {
        if (startValues == null) return null
        
        val cx = view.width / 2
        val cy = view.height / 2
        val startRadius = hypot(cx.toDouble(), cy.toDouble()).toFloat()
        
        return ViewAnimationUtils.createCircularReveal(view, cx, cy, startRadius, 0f)
    }
}

// 使用
TransitionManager.beginDelayedTransition(container, CircularRevealTransition())
view.visibility = View.VISIBLE
```

---

### 5.10 字节/美团/快手面试真题

**字节跳动：**
1. 属性动画是如何与 Choreographer 配合工作的？
2. 为什么 View 动画不会改变 View 的实际属性？从源码角度分析
3. 如何实现一个 60fps 的流畅动画？有哪些优化手段？

**美团：**
1. Transition 框架是如何自动计算动画的？
2. 共享元素动画的实现原理是什么？
3. MotionLayout 相比传统动画有什么优势？

**快手：**
1. Lottie 动画的渲染原理是什么？
2. 如何优化复杂动画的性能？
3. 属性动画的内存泄漏问题如何解决？

**OPPO/vivo：**
1. View 动画和属性动画分别在什么场景下使用？
2. 插值器和估值器的区别是什么？如何自定义？
3. 如何实现一个弹性动画效果？

---

## 6. 聊天记录

### 用户请求
创建 Android 高级开发面试知识库文件：`docs/03-UI框架与渲染/动画体系.md`

### 文档内容
- View 动画（补间动画）
- 属性动画原理（ValueAnimator、ObjectAnimator）
- AnimatorSet 组合动画
- 插值器与估值器
- 布局动画（LayoutTransition）
- Transition 框架
- MotionLayout
- Lottie 动画

### 完成情况
✅ 已完成文档创建，包含：
1. 概述 - Android 动画体系演进
2. 核心原理 - 各种动画的工作原理和架构图
3. 关键源码解析 - ValueAnimator、ObjectAnimator、AnimationHandler、Transition 等核心源码
4. 实战应用 - 最佳实践和性能优化
5. 常见面试题 - 10道面试题，覆盖字节、美团、快手、OPPO、vivo 面试风格
