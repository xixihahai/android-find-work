# Android 事件分发机制

## 1. 概述

事件分发机制是 Android UI 框架的核心机制之一，它决定了用户的触摸事件如何在 View 层级中传递和处理。理解事件分发机制对于解决滑动冲突、自定义手势处理、优化用户交互体验至关重要。

### 1.1 什么是事件分发

当用户触摸屏幕时，系统会将触摸事件封装成 `MotionEvent` 对象，然后按照一定的规则在 View 层级中传递，直到某个 View 消费该事件或者事件被丢弃。这个传递过程就是事件分发。

### 1.2 事件分发的核心问题

- **事件传递给谁？** - 确定哪个 View 应该接收事件
- **事件如何传递？** - 事件在 View 层级中的传递路径
- **事件由谁处理？** - 确定哪个 View 最终消费事件

### 1.3 事件分发涉及的核心类

| 类名 | 作用 |
|------|------|
| `MotionEvent` | 封装触摸事件信息（坐标、动作类型等） |
| `Activity` | 事件分发的起点 |
| `Window/PhoneWindow` | 窗口抽象，连接 Activity 和 DecorView |
| `DecorView` | 顶层 View，继承自 FrameLayout |
| `ViewGroup` | 容器 View，负责事件的分发和拦截 |
| `View` | 最终的事件消费者 |


## 2. 核心原理

### 2.1 事件分发流程图

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              事件分发完整流程                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   ┌──────────┐    ┌──────────┐    ┌───────────┐    ┌───────────┐           │
│   │ Activity │───▶│  Window  │───▶│ DecorView │───▶│ ViewGroup │           │
│   └──────────┘    └──────────┘    └───────────┘    └─────┬─────┘           │
│        │                                                  │                 │
│        │                                                  ▼                 │
│        │                                           ┌───────────┐           │
│        │                                           │   View    │           │
│        │                                           └─────┬─────┘           │
│        │                                                  │                 │
│        │◀────────────────────────────────────────────────┘                 │
│        │              事件未被消费时回传                                      │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

事件传递方向：自顶向下（分发）
事件回传方向：自底向上（未消费时）
```

### 2.2 三个核心方法

事件分发涉及三个核心方法，它们的调用关系如下：

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           三个核心方法的关系                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │                    dispatchTouchEvent()                             │   │
│   │                    负责事件的分发                                     │   │
│   │                                                                     │   │
│   │    ┌─────────────────────────────────────────────────────────────┐ │   │
│   │    │              onInterceptTouchEvent()                        │ │   │
│   │    │              ViewGroup 特有，决定是否拦截事件                  │ │   │
│   │    │                                                             │ │   │
│   │    │    ┌─────────────────────────────────────────────────────┐ │ │   │
│   │    │    │                onTouchEvent()                       │ │ │   │
│   │    │    │                负责事件的消费处理                      │ │ │   │
│   │    │    └─────────────────────────────────────────────────────┘ │ │   │
│   │    └─────────────────────────────────────────────────────────────┘ │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

| 方法 | 所属类 | 作用 | 返回值含义 |
|------|--------|------|------------|
| `dispatchTouchEvent()` | Activity/ViewGroup/View | 分发事件 | true: 事件被消费; false: 事件未被消费 |
| `onInterceptTouchEvent()` | ViewGroup | 拦截事件 | true: 拦截事件; false: 不拦截 |
| `onTouchEvent()` | View/ViewGroup | 处理事件 | true: 消费事件; false: 不消费 |


### 2.3 事件序列（Event Sequence）

一个完整的触摸事件序列包含以下事件类型：

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              事件序列示意图                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   手指按下        手指移动        手指移动        手指抬起                     │
│      │              │              │              │                         │
│      ▼              ▼              ▼              ▼                         │
│   ┌──────┐      ┌──────┐      ┌──────┐      ┌──────┐                       │
│   │ DOWN │─────▶│ MOVE │─────▶│ MOVE │─────▶│  UP  │                       │
│   └──────┘      └──────┘      └──────┘      └──────┘                       │
│                                                                             │
│   一个事件序列 = 1个DOWN + N个MOVE + 1个UP/CANCEL                            │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

**MotionEvent 常见动作类型：**

| 动作类型 | 常量值 | 说明 |
|----------|--------|------|
| `ACTION_DOWN` | 0 | 手指按下，事件序列的开始 |
| `ACTION_UP` | 1 | 手指抬起，事件序列的正常结束 |
| `ACTION_MOVE` | 2 | 手指移动 |
| `ACTION_CANCEL` | 3 | 事件被取消（父 View 拦截） |
| `ACTION_POINTER_DOWN` | 5 | 多指触控时，非第一个手指按下 |
| `ACTION_POINTER_UP` | 6 | 多指触控时，非最后一个手指抬起 |

### 2.4 事件分发的核心规则

**规则一：事件序列的一致性**
- 如果一个 View 消费了 `ACTION_DOWN` 事件，那么后续的 `MOVE` 和 `UP` 事件都会交给它处理
- 如果一个 View 不消费 `ACTION_DOWN`，那么后续事件也不会传递给它

**规则二：事件拦截的影响**
- ViewGroup 可以通过 `onInterceptTouchEvent()` 拦截事件
- 一旦拦截，子 View 会收到 `ACTION_CANCEL`，后续事件直接交给 ViewGroup 处理

**规则三：事件消费的传递**
- 如果子 View 不消费事件，事件会回传给父 View 的 `onTouchEvent()`
- 如果所有 View 都不消费，最终由 Activity 的 `onTouchEvent()` 处理


## 3. 关键源码解析

### 3.1 Activity.dispatchTouchEvent()

```java
// frameworks/base/core/java/android/app/Activity.java
// Android W (API 35) 源码

public boolean dispatchTouchEvent(MotionEvent ev) {
    // 1. 如果是 ACTION_DOWN 事件，调用 onUserInteraction()
    // 这个方法可以被重写，用于检测用户交互（如重置屏幕超时）
    if (ev.getAction() == MotionEvent.ACTION_DOWN) {
        onUserInteraction();
    }
    
    // 2. 将事件传递给 Window（实际是 PhoneWindow）
    // getWindow() 返回 PhoneWindow 实例
    // superDispatchTouchEvent() 会将事件传递给 DecorView
    if (getWindow().superDispatchTouchEvent(ev)) {
        // 如果 Window 消费了事件，返回 true
        return true;
    }
    
    // 3. 如果 Window 没有消费事件，调用 Activity 自己的 onTouchEvent()
    // 这是事件分发的最后一道防线
    return onTouchEvent(ev);
}

// Activity 的 onTouchEvent 默认实现
public boolean onTouchEvent(MotionEvent event) {
    // 处理窗口边界外的点击，关闭窗口
    if (mWindow.shouldCloseOnTouch(this, event)) {
        finish();
        return true;
    }
    // 默认不消费事件
    return false;
}
```

### 3.2 PhoneWindow.superDispatchTouchEvent()

```java
// frameworks/base/core/java/com/android/internal/policy/PhoneWindow.java

@Override
public boolean superDispatchTouchEvent(MotionEvent event) {
    // 直接将事件传递给 DecorView
    // mDecor 是 DecorView 实例，它是整个 View 树的根节点
    return mDecor.superDispatchTouchEvent(event);
}
```

### 3.3 DecorView.superDispatchTouchEvent()

```java
// frameworks/base/core/java/com/android/internal/policy/DecorView.java

public boolean superDispatchTouchEvent(MotionEvent event) {
    // DecorView 继承自 FrameLayout，调用父类的 dispatchTouchEvent
    // 从这里开始进入标准的 ViewGroup 事件分发流程
    return super.dispatchTouchEvent(event);
}
```


### 3.4 ViewGroup.dispatchTouchEvent() - 核心源码

```java
// frameworks/base/core/java/android/view/ViewGroup.java
// Android W (API 35) 源码 - 简化版，保留核心逻辑

@Override
public boolean dispatchTouchEvent(MotionEvent ev) {
    // 输入事件一致性验证器（调试用）
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 1);
    }

    // 辅助功能相关处理
    if (ev.isTargetAccessibilityFocus() && isAccessibilityFocusedViewOrHost()) {
        ev.setTargetAccessibilityFocus(false);
    }

    boolean handled = false;

    // 安全策略检查：如果窗口被遮挡，可能会过滤掉事件
    if (onFilterTouchEventForSecurity(ev)) {
        final int action = ev.getAction();
        final int actionMasked = action & MotionEvent.ACTION_MASK;

        // ========== 第一步：处理 ACTION_DOWN，重置状态 ==========
        if (actionMasked == MotionEvent.ACTION_DOWN) {
            // 新的事件序列开始，清除之前的触摸目标
            // mFirstTouchTarget 是一个链表，记录了消费事件的子 View
            cancelAndClearTouchTargets(ev);
            // 重置触摸状态，包括 FLAG_DISALLOW_INTERCEPT 标志
            resetTouchState();
        }

        // ========== 第二步：判断是否拦截事件 ==========
        final boolean intercepted;
        
        // 只有在 ACTION_DOWN 或者已有触摸目标时才检查拦截
        if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {
            // 检查子 View 是否调用了 requestDisallowInterceptTouchEvent(true)
            // FLAG_DISALLOW_INTERCEPT 标志位由子 View 设置，用于禁止父 View 拦截
            final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
            
            if (!disallowIntercept) {
                // 子 View 没有禁止拦截，调用 onInterceptTouchEvent 判断是否拦截
                intercepted = onInterceptTouchEvent(ev);
                // 恢复 action，防止被修改
                ev.setAction(action);
            } else {
                // 子 View 禁止拦截，不拦截事件
                intercepted = false;
            }
        } else {
            // 没有触摸目标且不是 DOWN 事件，直接拦截
            // 这种情况说明之前的 DOWN 事件没有被任何子 View 消费
            intercepted = true;
        }

        // 如果拦截了事件，或者已经有触摸目标，重置辅助功能焦点
        if (intercepted || mFirstTouchTarget != null) {
            ev.setTargetAccessibilityFocus(false);
        }

        // 检查是否是取消事件
        final boolean canceled = resetCancelNextUpFlag(this)
                || actionMasked == MotionEvent.ACTION_CANCEL;

        // 是否需要分割事件（多点触控支持）
        final boolean isMouseEvent = ev.getSource() == InputDevice.SOURCE_MOUSE;
        final boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0 && !isMouseEvent;
        
        TouchTarget newTouchTarget = null;
        boolean alreadyDispatchedToNewTouchTarget = false;

        // ========== 第三步：分发事件给子 View ==========
        if (!canceled && !intercepted) {
            // 没有取消且没有拦截，尝试分发给子 View
            
            // 对于 ACTION_DOWN 或 ACTION_POINTER_DOWN，需要寻找新的触摸目标
            if (actionMasked == MotionEvent.ACTION_DOWN
                    || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN)
                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                
                final int actionIndex = ev.getActionIndex();
                final int idBitsToAssign = split ? 1 << ev.getPointerId(actionIndex)
                        : TouchTarget.ALL_POINTER_IDS;

                // 清除之前的触摸目标（针对这个 pointer）
                removePointersFromTouchTargets(idBitsToAssign);

                final int childrenCount = mChildrenCount;
                if (newTouchTarget == null && childrenCount != 0) {
                    final float x = ev.getX(actionIndex);
                    final float y = ev.getY(actionIndex);
                    
                    // 按照 Z 轴顺序（从上到下）遍历子 View
                    // buildTouchDispatchChildList() 返回按绘制顺序排序的子 View 列表
                    final ArrayList<View> preorderedList = buildTouchDispatchChildList();
                    final boolean customOrder = preorderedList == null
                            && isChildrenDrawingOrderEnabled();
                    final View[] children = mChildren;
                    
                    // 从后往前遍历（Z 轴顺序，上层 View 优先）
                    for (int i = childrenCount - 1; i >= 0; i--) {
                        final int childIndex = getAndVerifyPreorderedIndex(
                                childrenCount, i, customOrder);
                        final View child = getAndVerifyPreorderedView(
                                preorderedList, children, childIndex);

                        // 检查子 View 是否可以接收事件
                        // 1. canViewReceivePointerEvents(): View 可见或正在动画
                        // 2. isTransformedTouchPointInView(): 触摸点在 View 范围内
                        if (!child.canViewReceivePointerEvents()
                                || !isTransformedTouchPointInView(x, y, child, null)) {
                            continue;
                        }

                        // 检查是否已经是触摸目标
                        newTouchTarget = getTouchTarget(child);
                        if (newTouchTarget != null) {
                            // 已经是触摸目标，添加新的 pointer
                            newTouchTarget.pointerIdBits |= idBitsToAssign;
                            break;
                        }

                        resetCancelNextUpFlag(child);
                        
                        // ★★★ 核心：调用 dispatchTransformedTouchEvent 分发事件 ★★★
                        // 这个方法会调用子 View 的 dispatchTouchEvent()
                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                            // 子 View 消费了事件
                            mLastTouchDownTime = ev.getDownTime();
                            if (preorderedList != null) {
                                for (int j = 0; j < childrenCount; j++) {
                                    if (children[childIndex] == mChildren[j]) {
                                        mLastTouchDownIndex = j;
                                        break;
                                    }
                                }
                            } else {
                                mLastTouchDownIndex = childIndex;
                            }
                            mLastTouchDownX = ev.getX();
                            mLastTouchDownY = ev.getY();
                            
                            // 将子 View 添加到触摸目标链表
                            newTouchTarget = addTouchTarget(child, idBitsToAssign);
                            alreadyDispatchedToNewTouchTarget = true;
                            break;
                        }
                    }
                    
                    if (preorderedList != null) preorderedList.clear();
                }
            }
        }

        // ========== 第四步：处理触摸目标 ==========
        if (mFirstTouchTarget == null) {
            // 没有触摸目标，ViewGroup 自己处理事件
            // 传入 null 作为 child，会调用 super.dispatchTouchEvent()
            // 即调用 View.dispatchTouchEvent()，最终调用 onTouchEvent()
            handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);
        } else {
            // 有触摸目标，分发事件给触摸目标
            TouchTarget predecessor = null;
            TouchTarget target = mFirstTouchTarget;
            
            while (target != null) {
                final TouchTarget next = target.next;
                
                if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {
                    // 已经分发过了
                    handled = true;
                } else {
                    // 检查是否需要发送 CANCEL 事件
                    final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted;
                    
                    // 分发事件给触摸目标
                    if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) {
                        handled = true;
                    }
                    
                    // 如果发送了 CANCEL，移除触摸目标
                    if (cancelChild) {
                        if (predecessor == null) {
                            mFirstTouchTarget = next;
                        } else {
                            predecessor.next = next;
                        }
                        target.recycle();
                        target = next;
                        continue;
                    }
                }
                predecessor = target;
                target = next;
            }
        }

        // ========== 第五步：清理工作 ==========
        if (canceled || actionMasked == MotionEvent.ACTION_UP
                || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
            // 事件序列结束，重置触摸状态
            resetTouchState();
        } else if (split && actionMasked == MotionEvent.ACTION_POINTER_UP) {
            // 多点触控时，某个手指抬起
            final int actionIndex = ev.getActionIndex();
            final int idBitsToRemove = 1 << ev.getPointerId(actionIndex);
            removePointersFromTouchTargets(idBitsToRemove);
        }
    }

    // 输入事件一致性验证
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
    }
    
    return handled;
}
```


### 3.5 ViewGroup.onInterceptTouchEvent()

```java
// frameworks/base/core/java/android/view/ViewGroup.java

/**
 * 判断是否拦截触摸事件
 * 
 * 默认实现：不拦截任何事件
 * 子类可以重写此方法来实现自定义的拦截逻辑
 * 
 * @param ev 触摸事件
 * @return true 表示拦截事件，事件不再传递给子 View
 *         false 表示不拦截，事件继续传递给子 View
 */
public boolean onInterceptTouchEvent(MotionEvent ev) {
    // 特殊处理：鼠标事件的拖拽
    if (ev.isFromSource(InputDevice.SOURCE_MOUSE)
            && ev.getAction() == MotionEvent.ACTION_DOWN
            && ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)
            && isOnScrollbarThumb(ev.getX(), ev.getY())) {
        return true;
    }
    // 默认不拦截
    return false;
}
```

### 3.6 View.dispatchTouchEvent()

```java
// frameworks/base/core/java/android/view/View.java
// Android W (API 35) 源码

public boolean dispatchTouchEvent(MotionEvent event) {
    // 输入事件一致性验证
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(event, 0);
    }

    // 处理辅助功能焦点
    if (event.isTargetAccessibilityFocus()) {
        if (!isAccessibilityFocusedViewOrHost()) {
            return false;
        }
        event.setTargetAccessibilityFocus(false);
    }

    boolean result = false;

    // 安全策略检查
    if (onFilterTouchEventForSecurity(event)) {
        // 如果正在滚动，停止滚动
        if ((mViewFlags & ENABLED_MASK) == ENABLED && handleScrollBarDragging(event)) {
            result = true;
        }
        
        // ★★★ 核心逻辑：OnTouchListener 优先于 onTouchEvent ★★★
        // ListenerInfo 包含了各种监听器
        ListenerInfo li = mListenerInfo;
        
        // 判断条件：
        // 1. li != null：设置了 ListenerInfo
        // 2. li.mOnTouchListener != null：设置了 OnTouchListener
        // 3. (mViewFlags & ENABLED_MASK) == ENABLED：View 是启用状态
        // 4. li.mOnTouchListener.onTouch(this, event)：OnTouchListener 返回 true
        if (li != null && li.mOnTouchListener != null
                && (mViewFlags & ENABLED_MASK) == ENABLED
                && li.mOnTouchListener.onTouch(this, event)) {
            // OnTouchListener 消费了事件，不再调用 onTouchEvent
            result = true;
        }

        // 如果 OnTouchListener 没有消费事件，调用 onTouchEvent
        if (!result && onTouchEvent(event)) {
            result = true;
        }
    }

    // 输入事件一致性验证
    if (!result && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);
    }

    // 处理嵌套滚动
    if (event.getAction() == MotionEvent.ACTION_UP
            || event.getAction() == MotionEvent.ACTION_CANCEL
            || (event.getAction() == MotionEvent.ACTION_DOWN && !result)) {
        stopNestedScroll();
    }

    return result;
}
```


### 3.7 View.onTouchEvent()

```java
// frameworks/base/core/java/android/view/View.java
// Android W (API 35) 源码 - 简化版

public boolean onTouchEvent(MotionEvent event) {
    final float x = event.getX();
    final float y = event.getY();
    final int viewFlags = mViewFlags;
    final int action = event.getAction();

    // 判断 View 是否可点击
    final boolean clickable = ((viewFlags & CLICKABLE) == CLICKABLE
            || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE)
            || (viewFlags & CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;

    // ★ 重要：即使 View 是 DISABLED 状态，只要是可点击的，仍然会消费事件
    // 只是不会触发点击回调
    if ((viewFlags & ENABLED_MASK) == DISABLED) {
        if (action == MotionEvent.ACTION_UP && (mPrivateFlags & PFLAG_PRESSED) != 0) {
            setPressed(false);
        }
        mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
        // 可点击的 disabled View 仍然消费事件，只是不响应
        return clickable;
    }

    // 触摸代理：允许扩大 View 的触摸区域
    if (mTouchDelegate != null) {
        if (mTouchDelegate.onTouchEvent(event)) {
            return true;
        }
    }

    // 如果 View 可点击或者可以显示 tooltip
    if (clickable || (viewFlags & TOOLTIP) == TOOLTIP) {
        switch (action) {
            case MotionEvent.ACTION_UP:
                // 手指抬起
                mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
                
                // 处理 tooltip
                if ((viewFlags & TOOLTIP) == TOOLTIP) {
                    handleTooltipUp();
                }
                
                if (!clickable) {
                    removeTapCallback();
                    removeLongPressCallback();
                    mInContextButtonPress = false;
                    mHasPerformedLongPress = false;
                    mIgnoreNextUpEvent = false;
                    break;
                }
                
                boolean prepressed = (mPrivateFlags & PFLAG_PREPRESSED) != 0;
                
                if ((mPrivateFlags & PFLAG_PRESSED) != 0 || prepressed) {
                    boolean focusTaken = false;
                    
                    // 请求焦点
                    if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {
                        focusTaken = requestFocus();
                    }

                    if (prepressed) {
                        setPressed(true, x, y);
                    }

                    // 如果没有执行长按，执行点击
                    if (!mHasPerformedLongPress && !mIgnoreNextUpEvent) {
                        removeLongPressCallback();

                        if (!focusTaken) {
                            // 使用 post 延迟执行点击，让用户看到按下效果
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            // ★★★ 触发 onClick 回调 ★★★
                            if (!post(mPerformClick)) {
                                performClickInternal();
                            }
                        }
                    }

                    // 重置按下状态
                    if (mUnsetPressedState == null) {
                        mUnsetPressedState = new UnsetPressedState();
                    }

                    if (prepressed) {
                        postDelayed(mUnsetPressedState,
                                ViewConfiguration.getPressedStateDuration());
                    } else if (!post(mUnsetPressedState)) {
                        mUnsetPressedState.run();
                    }

                    removeTapCallback();
                }
                mIgnoreNextUpEvent = false;
                break;

            case MotionEvent.ACTION_DOWN:
                // 手指按下
                if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) {
                    mPrivateFlags3 |= PFLAG3_FINGER_DOWN;
                }
                
                mHasPerformedLongPress = false;

                if (!clickable) {
                    // 不可点击，检查长按 tooltip
                    checkForLongClick(
                            ViewConfiguration.getLongPressTimeout(),
                            x, y,
                            TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS);
                    break;
                }

                // 检查是否在滚动容器中
                if (performButtonActionOnTouchDown(event)) {
                    break;
                }

                boolean isInScrollingContainer = isInScrollingContainer();

                if (isInScrollingContainer) {
                    // 在滚动容器中，延迟设置按下状态
                    // 避免滚动时出现按下效果
                    mPrivateFlags |= PFLAG_PREPRESSED;
                    if (mPendingCheckForTap == null) {
                        mPendingCheckForTap = new CheckForTap();
                    }
                    mPendingCheckForTap.x = event.getX();
                    mPendingCheckForTap.y = event.getY();
                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                } else {
                    // 不在滚动容器中，立即设置按下状态
                    setPressed(true, x, y);
                    // 检查长按
                    checkForLongClick(
                            ViewConfiguration.getLongPressTimeout(),
                            x, y,
                            TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS);
                }
                break;

            case MotionEvent.ACTION_CANCEL:
                // 事件取消
                if (clickable) {
                    setPressed(false);
                }
                removeTapCallback();
                removeLongPressCallback();
                mInContextButtonPress = false;
                mHasPerformedLongPress = false;
                mIgnoreNextUpEvent = false;
                mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
                break;

            case MotionEvent.ACTION_MOVE:
                // 手指移动
                if (clickable) {
                    drawableHotspotChanged(x, y);
                }

                final int motionClassification = event.getClassification();
                final boolean ambiguousGesture =
                        motionClassification == MotionEvent.CLASSIFICATION_AMBIGUOUS_GESTURE;
                int touchSlop = mTouchSlop;
                
                // 如果手势模糊，增加触摸阈值
                if (ambiguousGesture && hasPendingLongPressCallback()) {
                    if (!pointInView(x, y, touchSlop)) {
                        removeLongPressCallback();
                        long delay = (long) (ViewConfiguration.getLongPressTimeout()
                                * mAmbiguousGestureMultiplier);
                        delay -= event.getEventTime() - event.getDownTime();
                        checkForLongClick(
                                delay,
                                x, y,
                                TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS);
                    }
                    touchSlop *= mAmbiguousGestureMultiplier;
                }

                // 检查是否移出了 View 范围
                if (!pointInView(x, y, touchSlop)) {
                    // 移出范围，取消按下状态和长按检测
                    removeTapCallback();
                    removeLongPressCallback();
                    if ((mPrivateFlags & PFLAG_PRESSED) != 0) {
                        setPressed(false);
                    }
                    mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
                }

                // 深度按压检测
                final boolean deepPress =
                        motionClassification == MotionEvent.CLASSIFICATION_DEEP_PRESS;
                if (deepPress && hasPendingLongPressCallback()) {
                    removeLongPressCallback();
                    checkForLongClick(
                            0,
                            x, y,
                            TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__DEEP_PRESS);
                }
                break;
        }

        return true;
    }

    return false;
}
```


### 3.8 dispatchTransformedTouchEvent() - 事件转换与分发

```java
// frameworks/base/core/java/android/view/ViewGroup.java

/**
 * 将触摸事件转换后分发给子 View
 * 
 * @param event 原始事件
 * @param cancel 是否发送取消事件
 * @param child 目标子 View，如果为 null 则分发给自己
 * @param desiredPointerIdBits 需要处理的 pointer ID
 * @return 事件是否被消费
 */
private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,
        View child, int desiredPointerIdBits) {
    final boolean handled;

    // 如果是取消事件，不需要做坐标转换
    final int oldAction = event.getAction();
    if (cancel || oldAction == MotionEvent.ACTION_CANCEL) {
        event.setAction(MotionEvent.ACTION_CANCEL);
        if (child == null) {
            // 分发给自己（调用 View.dispatchTouchEvent）
            handled = super.dispatchTouchEvent(event);
        } else {
            // 分发给子 View
            handled = child.dispatchTouchEvent(event);
        }
        event.setAction(oldAction);
        return handled;
    }

    // 计算需要处理的 pointer
    final int oldPointerIdBits = event.getPointerIdBits();
    final int newPointerIdBits = oldPointerIdBits & desiredPointerIdBits;

    // 如果没有需要处理的 pointer，丢弃事件
    if (newPointerIdBits == 0) {
        return false;
    }

    // 创建转换后的事件
    final MotionEvent transformedEvent;
    if (newPointerIdBits == oldPointerIdBits) {
        // 不需要分割事件
        if (child == null || child.hasIdentityMatrix()) {
            if (child == null) {
                handled = super.dispatchTouchEvent(event);
            } else {
                // ★ 关键：将坐标从父 View 坐标系转换到子 View 坐标系
                final float offsetX = mScrollX - child.mLeft;
                final float offsetY = mScrollY - child.mTop;
                event.offsetLocation(offsetX, offsetY);

                handled = child.dispatchTouchEvent(event);

                // 恢复坐标
                event.offsetLocation(-offsetX, -offsetY);
            }
            return handled;
        }
        transformedEvent = MotionEvent.obtain(event);
    } else {
        // 需要分割事件（多点触控）
        transformedEvent = event.split(newPointerIdBits);
    }

    // 分发转换后的事件
    if (child == null) {
        handled = super.dispatchTouchEvent(transformedEvent);
    } else {
        // 应用子 View 的变换矩阵（处理 scale、rotation 等）
        final float offsetX = mScrollX - child.mLeft;
        final float offsetY = mScrollY - child.mTop;
        transformedEvent.offsetLocation(offsetX, offsetY);
        if (!child.hasIdentityMatrix()) {
            transformedEvent.transform(child.getInverseMatrix());
        }

        handled = child.dispatchTouchEvent(transformedEvent);
    }

    // 回收事件对象
    transformedEvent.recycle();
    return handled;
}
```


## 4. 实战应用

### 4.1 滑动冲突解决

滑动冲突是 Android 开发中最常见的问题之一，主要发生在嵌套可滑动控件的场景。

#### 4.1.1 滑动冲突的类型

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           滑动冲突类型                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   类型一：同向滑动冲突              类型二：异向滑动冲突                         │
│   ┌─────────────────┐            ┌─────────────────┐                       │
│   │  ScrollView     │            │  ViewPager      │                       │
│   │  ┌───────────┐  │            │  ┌───────────┐  │                       │
│   │  │ ListView  │  │            │  │ ListView  │  │                       │
│   │  │     ↕     │  │            │  │     ↕     │  │                       │
│   │  └───────────┘  │            │  └───────────┘  │                       │
│   │       ↕         │            │       ↔         │                       │
│   └─────────────────┘            └─────────────────┘                       │
│   父子都是垂直滑动                 父水平滑动，子垂直滑动                        │
│                                                                             │
│   类型三：混合滑动冲突                                                        │
│   ┌─────────────────┐                                                      │
│   │  ScrollView     │                                                      │
│   │  ┌───────────┐  │                                                      │
│   │  │ ViewPager │  │                                                      │
│   │  │     ↔     │  │                                                      │
│   │  └───────────┘  │                                                      │
│   │       ↕         │                                                      │
│   └─────────────────┘                                                      │
│   多层嵌套，多种滑动方向                                                      │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 4.1.2 外部拦截法（推荐）

**原理**：父 View 在 `onInterceptTouchEvent()` 中根据条件决定是否拦截事件。

```java
/**
 * 外部拦截法示例 - 自定义 ViewGroup
 * 
 * 适用场景：父 View 需要根据滑动方向决定是否拦截
 * 优点：逻辑清晰，符合事件分发的设计思想
 */
public class InterceptViewGroup extends ViewGroup {
    
    private int mLastX, mLastY;
    private int mLastInterceptX, mLastInterceptY;
    
    @Override
    public boolean onInterceptTouchEvent(MotionEvent ev) {
        boolean intercepted = false;
        int x = (int) ev.getX();
        int y = (int) ev.getY();
        
        switch (ev.getAction()) {
            case MotionEvent.ACTION_DOWN:
                // ★ DOWN 事件不能拦截，否则子 View 收不到任何事件
                intercepted = false;
                // 记录按下位置
                mLastInterceptX = x;
                mLastInterceptY = y;
                break;
                
            case MotionEvent.ACTION_MOVE:
                // 计算滑动距离
                int deltaX = x - mLastInterceptX;
                int deltaY = y - mLastInterceptY;
                
                // ★ 根据业务逻辑判断是否拦截
                // 示例：水平滑动距离大于垂直滑动距离时，父 View 拦截
                if (Math.abs(deltaX) > Math.abs(deltaY)) {
                    intercepted = true;
                } else {
                    intercepted = false;
                }
                break;
                
            case MotionEvent.ACTION_UP:
                // ★ UP 事件不拦截，让子 View 能正常处理点击
                intercepted = false;
                break;
        }
        
        mLastX = x;
        mLastY = y;
        mLastInterceptX = x;
        mLastInterceptY = y;
        
        return intercepted;
    }
    
    @Override
    public boolean onTouchEvent(MotionEvent event) {
        // 处理父 View 自己的滑动逻辑
        int x = (int) event.getX();
        int y = (int) event.getY();
        
        switch (event.getAction()) {
            case MotionEvent.ACTION_DOWN:
                break;
            case MotionEvent.ACTION_MOVE:
                int deltaX = x - mLastX;
                int deltaY = y - mLastY;
                // 执行滑动
                scrollBy(-deltaX, 0);
                break;
            case MotionEvent.ACTION_UP:
                break;
        }
        
        mLastX = x;
        mLastY = y;
        return true;
    }
}
```


#### 4.1.3 内部拦截法

**原理**：子 View 通过 `requestDisallowInterceptTouchEvent()` 控制父 View 是否拦截。

```java
/**
 * 内部拦截法示例 - 子 View
 * 
 * 适用场景：子 View 需要优先处理事件，根据条件决定是否交给父 View
 * 注意：需要配合父 View 的配置使用
 */
public class InnerView extends View {
    
    private int mLastX, mLastY;
    
    @Override
    public boolean dispatchTouchEvent(MotionEvent event) {
        int x = (int) event.getX();
        int y = (int) event.getY();
        
        switch (event.getAction()) {
            case MotionEvent.ACTION_DOWN:
                // ★ DOWN 时禁止父 View 拦截
                // 这样后续的 MOVE 事件才能传递到子 View
                getParent().requestDisallowInterceptTouchEvent(true);
                break;
                
            case MotionEvent.ACTION_MOVE:
                int deltaX = x - mLastX;
                int deltaY = y - mLastY;
                
                // ★ 根据业务逻辑判断是否需要父 View 处理
                // 示例：水平滑动时交给父 View 处理
                if (Math.abs(deltaX) > Math.abs(deltaY)) {
                    // 允许父 View 拦截
                    getParent().requestDisallowInterceptTouchEvent(false);
                }
                break;
                
            case MotionEvent.ACTION_UP:
                break;
        }
        
        mLastX = x;
        mLastY = y;
        
        return super.dispatchTouchEvent(event);
    }
}

/**
 * 内部拦截法 - 父 View 配置
 * 
 * 父 View 需要在 onInterceptTouchEvent 中做特殊处理
 */
public class OuterViewGroup extends ViewGroup {
    
    @Override
    public boolean onInterceptTouchEvent(MotionEvent ev) {
        int action = ev.getAction();
        
        // ★ 关键：DOWN 事件不拦截，其他事件都拦截
        // 这样子 View 才能通过 requestDisallowInterceptTouchEvent 控制
        if (action == MotionEvent.ACTION_DOWN) {
            return false;
        } else {
            return true;
        }
    }
}
```

#### 4.1.4 两种方法对比

| 特性 | 外部拦截法 | 内部拦截法 |
|------|-----------|-----------|
| 实现位置 | 父 View | 子 View + 父 View |
| 复杂度 | 简单 | 较复杂 |
| 灵活性 | 一般 | 更灵活 |
| 推荐场景 | 父 View 主导的滑动冲突 | 子 View 主导的滑动冲突 |
| 代码侵入性 | 只需修改父 View | 需要同时修改父子 View |


### 4.2 NestedScrolling 机制

NestedScrolling 是 Android 5.0 引入的嵌套滚动机制，用于解决传统事件分发无法处理的复杂滑动场景。

#### 4.2.1 核心接口

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        NestedScrolling 架构                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │                    NestedScrollingParent3                           │   │
│   │                    (CoordinatorLayout 等)                           │   │
│   │                                                                     │   │
│   │    - onStartNestedScroll()      开始嵌套滚动                         │   │
│   │    - onNestedScrollAccepted()   接受嵌套滚动                         │   │
│   │    - onNestedPreScroll()        子 View 滚动前，父 View 先消费       │   │
│   │    - onNestedScroll()           子 View 滚动后，父 View 消费剩余     │   │
│   │    - onNestedPreFling()         子 View fling 前                    │   │
│   │    - onNestedFling()            子 View fling 后                    │   │
│   │    - onStopNestedScroll()       停止嵌套滚动                         │   │
│   │                                                                     │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                                    ▲                                        │
│                                    │ 协作                                   │
│                                    ▼                                        │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │                    NestedScrollingChild3                            │   │
│   │                    (RecyclerView, NestedScrollView 等)              │   │
│   │                                                                     │   │
│   │    - startNestedScroll()        开始嵌套滚动                         │   │
│   │    - dispatchNestedPreScroll()  分发预滚动                           │   │
│   │    - dispatchNestedScroll()     分发滚动                             │   │
│   │    - dispatchNestedPreFling()   分发预 fling                        │   │
│   │    - dispatchNestedFling()      分发 fling                          │   │
│   │    - stopNestedScroll()         停止嵌套滚动                         │   │
│   │                                                                     │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 4.2.2 NestedScrolling 工作流程

```java
/**
 * NestedScrolling 工作流程示意
 * 
 * 以 RecyclerView 在 CoordinatorLayout 中滚动为例
 */

// 1. ACTION_DOWN 时，子 View 开始嵌套滚动
child.startNestedScroll(ViewCompat.SCROLL_AXIS_VERTICAL);
    ↓
// 父 View 决定是否接受
parent.onStartNestedScroll(child, target, axes);
parent.onNestedScrollAccepted(child, target, axes);

// 2. ACTION_MOVE 时，子 View 准备滚动
// 先询问父 View 是否要预先消费
child.dispatchNestedPreScroll(dx, dy, consumed, offsetInWindow);
    ↓
parent.onNestedPreScroll(target, dx, dy, consumed);
// 父 View 可以在 consumed 数组中记录消费的距离

// 3. 子 View 滚动剩余距离
int unconsumedX = dx - consumed[0];
int unconsumedY = dy - consumed[1];
child.scrollBy(unconsumedX, unconsumedY);

// 4. 子 View 滚动后，将未消费的距离交给父 View
child.dispatchNestedScroll(consumedX, consumedY, unconsumedX, unconsumedY, offsetInWindow);
    ↓
parent.onNestedScroll(target, dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed);

// 5. ACTION_UP 时，处理 fling
child.dispatchNestedPreFling(velocityX, velocityY);
    ↓
parent.onNestedPreFling(target, velocityX, velocityY);

child.dispatchNestedFling(velocityX, velocityY, consumed);
    ↓
parent.onNestedFling(target, velocityX, velocityY, consumed);

// 6. 停止嵌套滚动
child.stopNestedScroll();
    ↓
parent.onStopNestedScroll(target);
```

#### 4.2.3 NestedScrollingParent 实现示例

```java
/**
 * 自定义 NestedScrollingParent 示例
 * 实现类似 CoordinatorLayout 的效果
 */
public class CustomNestedScrollParent extends FrameLayout 
        implements NestedScrollingParent3 {
    
    private final NestedScrollingParentHelper mParentHelper;
    private View mHeaderView;
    private int mHeaderHeight;
    
    public CustomNestedScrollParent(Context context) {
        super(context);
        mParentHelper = new NestedScrollingParentHelper(this);
    }
    
    // ========== NestedScrollingParent3 接口实现 ==========
    
    @Override
    public boolean onStartNestedScroll(@NonNull View child, @NonNull View target, 
            int axes, int type) {
        // 只处理垂直方向的嵌套滚动
        return (axes & ViewCompat.SCROLL_AXIS_VERTICAL) != 0;
    }
    
    @Override
    public void onNestedScrollAccepted(@NonNull View child, @NonNull View target, 
            int axes, int type) {
        mParentHelper.onNestedScrollAccepted(child, target, axes, type);
    }
    
    @Override
    public void onNestedPreScroll(@NonNull View target, int dx, int dy, 
            @NonNull int[] consumed, int type) {
        // ★ 关键：在子 View 滚动前，父 View 先消费
        // 实现 Header 收起效果
        
        if (dy > 0 && getScrollY() < mHeaderHeight) {
            // 向上滑动，且 Header 还没完全收起
            int consumeY = Math.min(dy, mHeaderHeight - getScrollY());
            scrollBy(0, consumeY);
            consumed[1] = consumeY;  // 记录消费的距离
        }
    }
    
    @Override
    public void onNestedScroll(@NonNull View target, int dxConsumed, int dyConsumed,
            int dxUnconsumed, int dyUnconsumed, int type, @NonNull int[] consumed) {
        // 子 View 滚动后，处理未消费的距离
        
        if (dyUnconsumed < 0 && getScrollY() > 0) {
            // 向下滑动，且 Header 已经收起
            int consumeY = Math.max(dyUnconsumed, -getScrollY());
            scrollBy(0, consumeY);
            consumed[1] = consumeY;
        }
    }
    
    @Override
    public boolean onNestedPreFling(@NonNull View target, float velocityX, float velocityY) {
        // 返回 true 表示父 View 消费了 fling
        return false;
    }
    
    @Override
    public boolean onNestedFling(@NonNull View target, float velocityX, float velocityY, 
            boolean consumed) {
        return false;
    }
    
    @Override
    public void onStopNestedScroll(@NonNull View target, int type) {
        mParentHelper.onStopNestedScroll(target, type);
    }
    
    // ========== 兼容旧版本的方法 ==========
    
    @Override
    public void onNestedScroll(@NonNull View target, int dxConsumed, int dyConsumed,
            int dxUnconsumed, int dyUnconsumed, int type) {
        onNestedScroll(target, dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed, 
                type, new int[2]);
    }
    
    @Override
    public void onNestedScroll(@NonNull View target, int dxConsumed, int dyConsumed,
            int dxUnconsumed, int dyUnconsumed) {
        onNestedScroll(target, dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed,
                ViewCompat.TYPE_TOUCH);
    }
}
```


### 4.3 手势检测

Android 提供了 `GestureDetector` 和 `ScaleGestureDetector` 来简化手势识别。

#### 4.3.1 GestureDetector 使用

```java
/**
 * GestureDetector 完整使用示例
 */
public class GestureView extends View {
    
    private GestureDetector mGestureDetector;
    
    public GestureView(Context context) {
        super(context);
        initGestureDetector(context);
    }
    
    private void initGestureDetector(Context context) {
        // 创建 GestureDetector，传入监听器
        mGestureDetector = new GestureDetector(context, 
                new GestureDetector.SimpleOnGestureListener() {
            
            /**
             * 按下事件
             * ★ 必须返回 true，否则后续事件不会传递
             */
            @Override
            public boolean onDown(MotionEvent e) {
                Log.d("Gesture", "onDown: " + e.getX() + ", " + e.getY());
                return true;
            }
            
            /**
             * 显示按下状态
             * 用于给用户视觉反馈，如高亮显示
             */
            @Override
            public void onShowPress(MotionEvent e) {
                Log.d("Gesture", "onShowPress");
            }
            
            /**
             * 单击事件（手指抬起时触发）
             */
            @Override
            public boolean onSingleTapUp(MotionEvent e) {
                Log.d("Gesture", "onSingleTapUp");
                return true;
            }
            
            /**
             * 单击确认（区别于双击的单击）
             * 在确认不是双击后触发
             */
            @Override
            public boolean onSingleTapConfirmed(MotionEvent e) {
                Log.d("Gesture", "onSingleTapConfirmed");
                return true;
            }
            
            /**
             * 双击事件
             */
            @Override
            public boolean onDoubleTap(MotionEvent e) {
                Log.d("Gesture", "onDoubleTap");
                return true;
            }
            
            /**
             * 双击过程中的事件（DOWN、MOVE、UP）
             */
            @Override
            public boolean onDoubleTapEvent(MotionEvent e) {
                Log.d("Gesture", "onDoubleTapEvent: " + e.getAction());
                return true;
            }
            
            /**
             * 长按事件
             */
            @Override
            public void onLongPress(MotionEvent e) {
                Log.d("Gesture", "onLongPress");
            }
            
            /**
             * 滚动事件
             * @param e1 按下时的事件
             * @param e2 当前移动事件
             * @param distanceX X 方向滚动距离（e1.x - e2.x）
             * @param distanceY Y 方向滚动距离（e1.y - e2.y）
             */
            @Override
            public boolean onScroll(MotionEvent e1, MotionEvent e2, 
                    float distanceX, float distanceY) {
                Log.d("Gesture", "onScroll: dx=" + distanceX + ", dy=" + distanceY);
                return true;
            }
            
            /**
             * 快速滑动（Fling）事件
             * @param e1 按下时的事件
             * @param e2 抬起时的事件
             * @param velocityX X 方向速度（像素/秒）
             * @param velocityY Y 方向速度（像素/秒）
             */
            @Override
            public boolean onFling(MotionEvent e1, MotionEvent e2, 
                    float velocityX, float velocityY) {
                Log.d("Gesture", "onFling: vx=" + velocityX + ", vy=" + velocityY);
                return true;
            }
            
            /**
             * 上下文点击（鼠标右键等）
             */
            @Override
            public boolean onContextClick(MotionEvent e) {
                Log.d("Gesture", "onContextClick");
                return true;
            }
        });
        
        // 设置双击监听（如果使用 SimpleOnGestureListener 则不需要）
        // mGestureDetector.setOnDoubleTapListener(listener);
        
        // 设置是否启用长按
        mGestureDetector.setIsLongpressEnabled(true);
    }
    
    @Override
    public boolean onTouchEvent(MotionEvent event) {
        // ★ 将事件交给 GestureDetector 处理
        return mGestureDetector.onTouchEvent(event);
    }
}
```

#### 4.3.2 ScaleGestureDetector 使用

```java
/**
 * ScaleGestureDetector 缩放手势检测示例
 * 常用于图片缩放、地图缩放等场景
 */
public class ScaleView extends View {
    
    private ScaleGestureDetector mScaleDetector;
    private float mScaleFactor = 1.0f;
    
    public ScaleView(Context context) {
        super(context);
        initScaleDetector(context);
    }
    
    private void initScaleDetector(Context context) {
        mScaleDetector = new ScaleGestureDetector(context, 
                new ScaleGestureDetector.SimpleOnScaleGestureListener() {
            
            /**
             * 缩放开始
             * @return true 表示处理缩放事件
             */
            @Override
            public boolean onScaleBegin(ScaleGestureDetector detector) {
                Log.d("Scale", "onScaleBegin");
                return true;
            }
            
            /**
             * 缩放进行中
             * @param detector 缩放检测器
             * @return true 表示事件已处理
             */
            @Override
            public boolean onScale(ScaleGestureDetector detector) {
                // 获取缩放因子
                float scaleFactor = detector.getScaleFactor();
                
                // 累积缩放
                mScaleFactor *= scaleFactor;
                
                // 限制缩放范围
                mScaleFactor = Math.max(0.1f, Math.min(mScaleFactor, 10.0f));
                
                // 获取缩放中心点
                float focusX = detector.getFocusX();
                float focusY = detector.getFocusY();
                
                Log.d("Scale", "onScale: factor=" + scaleFactor 
                        + ", focus=(" + focusX + ", " + focusY + ")");
                
                // 触发重绘
                invalidate();
                return true;
            }
            
            /**
             * 缩放结束
             */
            @Override
            public void onScaleEnd(ScaleGestureDetector detector) {
                Log.d("Scale", "onScaleEnd");
            }
        });
        
        // Android 4.4+ 可以设置快速缩放（双击拖动缩放）
        mScaleDetector.setQuickScaleEnabled(true);
        
        // Android 6.0+ 可以设置触控笔缩放
        // mScaleDetector.setStylusScaleEnabled(true);
    }
    
    @Override
    public boolean onTouchEvent(MotionEvent event) {
        // 交给 ScaleGestureDetector 处理
        mScaleDetector.onTouchEvent(event);
        return true;
    }
    
    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        
        // 应用缩放
        canvas.save();
        canvas.scale(mScaleFactor, mScaleFactor, getWidth() / 2f, getHeight() / 2f);
        // 绘制内容...
        canvas.restore();
    }
}
```


#### 4.3.3 组合使用 GestureDetector 和 ScaleGestureDetector

```java
/**
 * 同时支持单指滑动和双指缩放的 View
 * 常见于图片查看器、地图等应用
 */
public class MultiGestureView extends View {
    
    private GestureDetector mGestureDetector;
    private ScaleGestureDetector mScaleDetector;
    
    private float mTranslateX = 0f;
    private float mTranslateY = 0f;
    private float mScaleFactor = 1.0f;
    
    public MultiGestureView(Context context) {
        super(context);
        
        // 初始化手势检测器
        mGestureDetector = new GestureDetector(context, 
                new GestureDetector.SimpleOnGestureListener() {
            @Override
            public boolean onDown(MotionEvent e) {
                return true;
            }
            
            @Override
            public boolean onScroll(MotionEvent e1, MotionEvent e2, 
                    float distanceX, float distanceY) {
                // ★ 关键：缩放时不处理滑动
                if (!mScaleDetector.isInProgress()) {
                    mTranslateX -= distanceX;
                    mTranslateY -= distanceY;
                    invalidate();
                }
                return true;
            }
            
            @Override
            public boolean onDoubleTap(MotionEvent e) {
                // 双击重置
                mScaleFactor = 1.0f;
                mTranslateX = 0f;
                mTranslateY = 0f;
                invalidate();
                return true;
            }
        });
        
        mScaleDetector = new ScaleGestureDetector(context, 
                new ScaleGestureDetector.SimpleOnScaleGestureListener() {
            @Override
            public boolean onScale(ScaleGestureDetector detector) {
                mScaleFactor *= detector.getScaleFactor();
                mScaleFactor = Math.max(0.5f, Math.min(mScaleFactor, 5.0f));
                invalidate();
                return true;
            }
        });
    }
    
    @Override
    public boolean onTouchEvent(MotionEvent event) {
        // ★ 两个检测器都要处理事件
        mScaleDetector.onTouchEvent(event);
        mGestureDetector.onTouchEvent(event);
        return true;
    }
    
    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        
        canvas.save();
        canvas.translate(mTranslateX, mTranslateY);
        canvas.scale(mScaleFactor, mScaleFactor, getWidth() / 2f, getHeight() / 2f);
        // 绘制内容...
        canvas.restore();
    }
}
```

### 4.4 VelocityTracker 速度追踪

```java
/**
 * VelocityTracker 使用示例
 * 用于计算手指滑动速度，实现 Fling 效果
 */
public class VelocityView extends View {
    
    private VelocityTracker mVelocityTracker;
    private Scroller mScroller;
    
    public VelocityView(Context context) {
        super(context);
        mScroller = new Scroller(context);
    }
    
    @Override
    public boolean onTouchEvent(MotionEvent event) {
        // 获取或创建 VelocityTracker
        if (mVelocityTracker == null) {
            mVelocityTracker = VelocityTracker.obtain();
        }
        
        // ★ 添加事件到追踪器
        mVelocityTracker.addMovement(event);
        
        switch (event.getAction()) {
            case MotionEvent.ACTION_DOWN:
                // 停止之前的滚动
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                }
                break;
                
            case MotionEvent.ACTION_MOVE:
                // 处理滑动...
                break;
                
            case MotionEvent.ACTION_UP:
                // ★ 计算速度
                // 参数：时间单位（1000 = 每秒像素数）
                mVelocityTracker.computeCurrentVelocity(1000);
                
                // 获取速度
                float velocityX = mVelocityTracker.getXVelocity();
                float velocityY = mVelocityTracker.getYVelocity();
                
                // 判断是否达到 Fling 阈值
                int minimumVelocity = ViewConfiguration.get(getContext())
                        .getScaledMinimumFlingVelocity();
                int maximumVelocity = ViewConfiguration.get(getContext())
                        .getScaledMaximumFlingVelocity();
                
                if (Math.abs(velocityY) > minimumVelocity) {
                    // 限制最大速度
                    velocityY = Math.max(-maximumVelocity, 
                            Math.min(velocityY, maximumVelocity));
                    
                    // 开始 Fling
                    mScroller.fling(
                            getScrollX(), getScrollY(),  // 起始位置
                            (int) -velocityX, (int) -velocityY,  // 速度
                            0, getMaxScrollX(),  // X 范围
                            0, getMaxScrollY()   // Y 范围
                    );
                    invalidate();
                }
                
                // ★ 回收 VelocityTracker
                mVelocityTracker.recycle();
                mVelocityTracker = null;
                break;
                
            case MotionEvent.ACTION_CANCEL:
                // 取消时也要回收
                if (mVelocityTracker != null) {
                    mVelocityTracker.recycle();
                    mVelocityTracker = null;
                }
                break;
        }
        
        return true;
    }
    
    @Override
    public void computeScroll() {
        // 处理 Scroller 的滚动
        if (mScroller.computeScrollOffset()) {
            scrollTo(mScroller.getCurrX(), mScroller.getCurrY());
            postInvalidate();
        }
    }
    
    private int getMaxScrollX() {
        // 返回最大 X 滚动距离
        return 0;
    }
    
    private int getMaxScrollY() {
        // 返回最大 Y 滚动距离
        return 0;
    }
}
```


## 5. 常见面试题

### 5.1 基础概念题

#### Q1: 请描述 Android 事件分发的完整流程

**答案要点：**

1. **事件产生**：用户触摸屏幕，硬件产生触摸事件，通过 InputManagerService 传递到应用进程

2. **Activity 接收**：
   - `Activity.dispatchTouchEvent()` 首先接收事件
   - 调用 `getWindow().superDispatchTouchEvent()` 传递给 Window

3. **Window 传递**：
   - `PhoneWindow.superDispatchTouchEvent()` 将事件传递给 DecorView

4. **ViewGroup 分发**：
   - `ViewGroup.dispatchTouchEvent()` 负责分发
   - 首先调用 `onInterceptTouchEvent()` 判断是否拦截
   - 如果不拦截，遍历子 View，调用子 View 的 `dispatchTouchEvent()`
   - 如果拦截或没有子 View 消费，调用自己的 `onTouchEvent()`

5. **View 处理**：
   - `View.dispatchTouchEvent()` 接收事件
   - 先检查 `OnTouchListener`，如果返回 true 则消费
   - 否则调用 `onTouchEvent()` 处理

6. **事件回传**：
   - 如果所有 View 都不消费，事件回传给 Activity 的 `onTouchEvent()`

```
Activity.dispatchTouchEvent()
    ↓
PhoneWindow.superDispatchTouchEvent()
    ↓
DecorView.superDispatchTouchEvent()
    ↓
ViewGroup.dispatchTouchEvent()
    ├── onInterceptTouchEvent() → 拦截 → onTouchEvent()
    └── 不拦截 → 子View.dispatchTouchEvent()
                    ├── OnTouchListener.onTouch() → 消费
                    └── onTouchEvent() → 消费/不消费
    ↓
事件未消费 → Activity.onTouchEvent()
```

---

#### Q2: dispatchTouchEvent、onInterceptTouchEvent、onTouchEvent 三者的关系是什么？

**答案要点：**

| 方法 | 所属类 | 作用 | 返回值影响 |
|------|--------|------|------------|
| `dispatchTouchEvent` | Activity/ViewGroup/View | 分发事件 | true: 事件被消费，不再传递 |
| `onInterceptTouchEvent` | ViewGroup | 拦截事件 | true: 拦截，事件交给自己的 onTouchEvent |
| `onTouchEvent` | View/ViewGroup | 处理事件 | true: 消费事件；false: 不消费，回传给父 View |

**伪代码表示三者关系：**

```java
// ViewGroup 的 dispatchTouchEvent 伪代码
public boolean dispatchTouchEvent(MotionEvent ev) {
    boolean consume = false;
    
    if (onInterceptTouchEvent(ev)) {
        // 拦截，自己处理
        consume = onTouchEvent(ev);
    } else {
        // 不拦截，交给子 View
        consume = child.dispatchTouchEvent(ev);
    }
    
    return consume;
}

// View 的 dispatchTouchEvent 伪代码
public boolean dispatchTouchEvent(MotionEvent ev) {
    boolean consume = false;
    
    if (mOnTouchListener != null 
            && mOnTouchListener.onTouch(this, ev)) {
        consume = true;
    }
    
    if (!consume) {
        consume = onTouchEvent(ev);
    }
    
    return consume;
}
```

---

#### Q3: 为什么 View 的 onTouchEvent 默认返回 true（可点击时）？

**答案要点：**

1. **设计目的**：确保可点击的 View 能够接收完整的事件序列（DOWN → MOVE → UP）

2. **源码分析**：
```java
// View.onTouchEvent() 中
if (clickable || (viewFlags & TOOLTIP) == TOOLTIP) {
    // 只要可点击，就返回 true
    return true;
}
```

3. **如果返回 false 的后果**：
   - DOWN 事件不消费，后续 MOVE、UP 事件不会传递给该 View
   - onClick 回调永远不会触发

4. **特殊情况**：
   - 即使 View 是 DISABLED 状态，只要设置了 clickable，仍然返回 true
   - 只是不会触发点击回调

---

### 5.2 进阶原理题

#### Q4: 事件序列是如何保证传递给同一个 View 的？（字节、快手高频）

**答案要点：**

1. **TouchTarget 机制**：
   - ViewGroup 维护一个 `mFirstTouchTarget` 链表
   - 当子 View 消费 DOWN 事件时，会被添加到 TouchTarget 链表

2. **源码关键点**：
```java
// ViewGroup.dispatchTouchEvent() 中

// DOWN 事件时，寻找消费事件的子 View
if (actionMasked == MotionEvent.ACTION_DOWN) {
    // 清除之前的 TouchTarget
    cancelAndClearTouchTargets(ev);
    resetTouchState();
}

// 子 View 消费事件后，添加到 TouchTarget
if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
    newTouchTarget = addTouchTarget(child, idBitsToAssign);
}

// 后续事件直接分发给 TouchTarget
if (mFirstTouchTarget != null) {
    // 直接分发给 TouchTarget 中的 View
    dispatchTransformedTouchEvent(ev, cancelChild, target.child, ...);
}
```

3. **保证机制**：
   - DOWN 事件确定 TouchTarget
   - 后续 MOVE、UP 事件直接分发给 TouchTarget
   - 不再遍历子 View

---

#### Q5: requestDisallowInterceptTouchEvent 的原理是什么？为什么 DOWN 事件时会失效？（OPPO、vivo 高频）

**答案要点：**

1. **原理**：
   - 设置 `FLAG_DISALLOW_INTERCEPT` 标志位
   - ViewGroup 在 `dispatchTouchEvent` 中检查该标志
   - 如果设置了，跳过 `onInterceptTouchEvent` 调用

2. **源码分析**：
```java
// ViewGroup.dispatchTouchEvent() 中

// 检查是否禁止拦截
final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;

if (!disallowIntercept) {
    // 没有禁止，调用 onInterceptTouchEvent
    intercepted = onInterceptTouchEvent(ev);
} else {
    // 禁止拦截，不调用 onInterceptTouchEvent
    intercepted = false;
}
```

3. **DOWN 事件失效原因**：
```java
// ViewGroup.dispatchTouchEvent() 中

if (actionMasked == MotionEvent.ACTION_DOWN) {
    // ★ DOWN 事件时重置状态，包括 FLAG_DISALLOW_INTERCEPT
    cancelAndClearTouchTargets(ev);
    resetTouchState();  // 这里会清除 FLAG_DISALLOW_INTERCEPT
}

// resetTouchState() 实现
private void resetTouchState() {
    clearTouchTargets();
    resetCancelNextUpFlag(this);
    // ★ 清除 FLAG_DISALLOW_INTERCEPT 标志
    mGroupFlags &= ~FLAG_DISALLOW_INTERCEPT;
    mNestedScrollAxes = SCROLL_AXIS_NONE;
}
```

4. **设计原因**：
   - DOWN 是事件序列的开始，需要重新决定事件分发路径
   - 保证父 View 在每个事件序列开始时都有机会拦截


---

#### Q6: ACTION_CANCEL 事件什么时候会触发？（美团、字节高频）

**答案要点：**

1. **触发场景**：
   - 父 View 在 MOVE 过程中拦截了事件
   - 子 View 被从 View 树中移除
   - 窗口失去焦点
   - 手势被系统取消（如来电）

2. **源码分析**：
```java
// ViewGroup.dispatchTouchEvent() 中

// 当父 View 拦截时，给子 View 发送 CANCEL
final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted;

if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, ...)) {
    // cancelChild 为 true 时，会将事件 action 改为 ACTION_CANCEL
}

// dispatchTransformedTouchEvent() 中
if (cancel || oldAction == MotionEvent.ACTION_CANCEL) {
    event.setAction(MotionEvent.ACTION_CANCEL);
    // 分发 CANCEL 事件给子 View
    handled = child.dispatchTouchEvent(event);
}
```

3. **处理建议**：
```java
@Override
public boolean onTouchEvent(MotionEvent event) {
    switch (event.getAction()) {
        case MotionEvent.ACTION_CANCEL:
            // 重置状态，清理资源
            resetState();
            // 取消按下效果
            setPressed(false);
            // 移除长按回调
            removeLongPressCallback();
            break;
    }
    return super.onTouchEvent(event);
}
```

---

### 5.3 滑动冲突题

#### Q7: 如何解决 ScrollView 嵌套 RecyclerView 的滑动冲突？（美团、快手高频）

**答案要点：**

**方案一：使用 NestedScrollView 替代 ScrollView**
```xml
<androidx.core.widget.NestedScrollView
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical">
        
        <!-- 其他内容 -->
        
        <androidx.recyclerview.widget.RecyclerView
            android:id="@+id/recyclerView"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:nestedScrollingEnabled="true" />
            
    </LinearLayout>
</androidx.core.widget.NestedScrollView>
```

**方案二：禁用 RecyclerView 的嵌套滚动**
```java
// 让 RecyclerView 不参与嵌套滚动，完全由外层 ScrollView 控制
recyclerView.setNestedScrollingEnabled(false);
```

**方案三：自定义 ScrollView，外部拦截法**
```java
public class CustomScrollView extends ScrollView {
    
    private int mLastY;
    private int mTouchSlop;
    
    @Override
    public boolean onInterceptTouchEvent(MotionEvent ev) {
        int action = ev.getAction();
        int y = (int) ev.getY();
        
        switch (action) {
            case MotionEvent.ACTION_DOWN:
                mLastY = y;
                break;
            case MotionEvent.ACTION_MOVE:
                int deltaY = y - mLastY;
                // 判断 RecyclerView 是否可以滚动
                RecyclerView recyclerView = findRecyclerView();
                if (recyclerView != null) {
                    if (deltaY > 0 && !recyclerView.canScrollVertically(-1)) {
                        // 向下滑动，RecyclerView 到顶了，ScrollView 拦截
                        return true;
                    }
                    if (deltaY < 0 && !recyclerView.canScrollVertically(1)) {
                        // 向上滑动，RecyclerView 到底了，ScrollView 拦截
                        return true;
                    }
                    // RecyclerView 可以滚动，不拦截
                    return false;
                }
                break;
        }
        return super.onInterceptTouchEvent(ev);
    }
}
```

**方案四：给 RecyclerView 设置固定高度**
```java
// 计算 RecyclerView 的完整高度
recyclerView.post(() -> {
    ViewGroup.LayoutParams params = recyclerView.getLayoutParams();
    params.height = calculateTotalHeight(recyclerView);
    recyclerView.setLayoutParams(params);
});
```

---

#### Q8: ViewPager2 嵌套 RecyclerView 的滑动冲突如何解决？（字节高频）

**答案要点：**

**场景分析**：
- ViewPager2 水平滑动
- RecyclerView 垂直滑动
- 斜向滑动时容易冲突

**方案一：使用官方提供的 NestedScrollableHost**
```kotlin
/**
 * Google 官方示例中的 NestedScrollableHost
 * 包装 RecyclerView，处理与 ViewPager2 的滑动冲突
 */
class NestedScrollableHost : FrameLayout {
    
    private var touchSlop = 0
    private var initialX = 0f
    private var initialY = 0f
    
    private val parentViewPager: ViewPager2?
        get() {
            var v: View? = parent as? View
            while (v != null && v !is ViewPager2) {
                v = v.parent as? View
            }
            return v as? ViewPager2
        }
    
    private val child: View? get() = if (childCount > 0) getChildAt(0) else null
    
    init {
        touchSlop = ViewConfiguration.get(context).scaledTouchSlop
    }
    
    override fun onInterceptTouchEvent(e: MotionEvent): Boolean {
        handleInterceptTouchEvent(e)
        return super.onInterceptTouchEvent(e)
    }
    
    private fun handleInterceptTouchEvent(e: MotionEvent) {
        val orientation = parentViewPager?.orientation ?: return
        
        // 如果子 View 不能在 ViewPager2 的方向上滚动，不处理
        if (!canChildScroll(orientation, -1f) && !canChildScroll(orientation, 1f)) {
            return
        }
        
        when (e.action) {
            MotionEvent.ACTION_DOWN -> {
                initialX = e.x
                initialY = e.y
                parent.requestDisallowInterceptTouchEvent(true)
            }
            MotionEvent.ACTION_MOVE -> {
                val dx = e.x - initialX
                val dy = e.y - initialY
                val isVpHorizontal = orientation == ViewPager2.ORIENTATION_HORIZONTAL
                
                // 判断滑动方向
                val scaledDx = dx.absoluteValue * if (isVpHorizontal) .5f else 1f
                val scaledDy = dy.absoluteValue * if (isVpHorizontal) 1f else .5f
                
                if (scaledDx > touchSlop || scaledDy > touchSlop) {
                    if (isVpHorizontal == (scaledDy > scaledDx)) {
                        // 垂直滑动，子 View 处理
                        parent.requestDisallowInterceptTouchEvent(true)
                    } else {
                        // 水平滑动，检查子 View 是否能滚动
                        if (canChildScroll(orientation, if (isVpHorizontal) dx else dy)) {
                            parent.requestDisallowInterceptTouchEvent(true)
                        } else {
                            parent.requestDisallowInterceptTouchEvent(false)
                        }
                    }
                }
            }
        }
    }
    
    private fun canChildScroll(orientation: Int, delta: Float): Boolean {
        val direction = -delta.sign.toInt()
        return when (orientation) {
            ViewPager2.ORIENTATION_HORIZONTAL -> child?.canScrollHorizontally(direction) ?: false
            ViewPager2.ORIENTATION_VERTICAL -> child?.canScrollVertically(direction) ?: false
            else -> throw IllegalArgumentException()
        }
    }
}
```

**方案二：自定义 RecyclerView，内部拦截法**
```java
public class NestedRecyclerView extends RecyclerView {
    
    private int mTouchSlop;
    private float mInitialX, mInitialY;
    
    public NestedRecyclerView(Context context) {
        super(context);
        mTouchSlop = ViewConfiguration.get(context).getScaledTouchSlop();
    }
    
    @Override
    public boolean dispatchTouchEvent(MotionEvent ev) {
        switch (ev.getAction()) {
            case MotionEvent.ACTION_DOWN:
                mInitialX = ev.getX();
                mInitialY = ev.getY();
                // 禁止父 View 拦截
                getParent().requestDisallowInterceptTouchEvent(true);
                break;
                
            case MotionEvent.ACTION_MOVE:
                float dx = ev.getX() - mInitialX;
                float dy = ev.getY() - mInitialY;
                
                // 水平滑动距离大于垂直滑动，交给 ViewPager2
                if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > mTouchSlop) {
                    getParent().requestDisallowInterceptTouchEvent(false);
                }
                break;
        }
        return super.dispatchTouchEvent(ev);
    }
}
```


---

### 5.4 NestedScrolling 相关题

#### Q9: NestedScrolling 机制与传统事件分发有什么区别？（OPPO、vivo 高频）

**答案要点：**

| 特性 | 传统事件分发 | NestedScrolling |
|------|-------------|-----------------|
| 事件流向 | 单向（父→子或子→父） | 双向协作 |
| 滚动消费 | 只能一方消费 | 父子可以分别消费部分距离 |
| 拦截机制 | 父 View 拦截后，子 View 无法处理 | 子 View 可以先处理，再交给父 View |
| 适用场景 | 简单的滑动冲突 | 复杂的嵌套滚动（如 CoordinatorLayout） |
| API 版本 | 所有版本 | API 21+（兼容库支持更低版本） |

**核心区别**：

1. **传统方式**：事件只能被一方消费
```
父 View 拦截 → 子 View 收到 CANCEL → 后续事件全部给父 View
```

2. **NestedScrolling**：父子协作消费
```
子 View 准备滚动 100px
    ↓
父 View 先消费 30px（onNestedPreScroll）
    ↓
子 View 滚动 70px
    ↓
子 View 滚动到边界，剩余 20px
    ↓
父 View 消费剩余 20px（onNestedScroll）
```

**源码层面的区别**：
```java
// 传统方式：ViewGroup.dispatchTouchEvent
if (onInterceptTouchEvent(ev)) {
    // 拦截后，子 View 完全失去事件
    handled = onTouchEvent(ev);
}

// NestedScrolling：RecyclerView.scrollByInternal
// 滚动前先询问父 View
if (dispatchNestedPreScroll(dx, dy, consumed, null)) {
    dx -= consumed[0];
    dy -= consumed[1];
}
// 自己滚动
scrollInternal(dx, dy);
// 滚动后将未消费的交给父 View
dispatchNestedScroll(consumedX, consumedY, unconsumedX, unconsumedY, null);
```

---

#### Q10: CoordinatorLayout 是如何实现 AppBarLayout 的折叠效果的？（美团、字节高频）

**答案要点：**

1. **核心组件**：
   - `CoordinatorLayout`：实现 `NestedScrollingParent3`
   - `AppBarLayout`：实现 `NestedScrollingChild3`
   - `Behavior`：定义组件间的交互行为

2. **工作流程**：
```
RecyclerView 滚动
    ↓
CoordinatorLayout.onNestedPreScroll()
    ↓
遍历子 View 的 Behavior
    ↓
AppBarLayout.Behavior.onNestedPreScroll()
    ↓
AppBarLayout 根据滚动距离改变高度
    ↓
触发 CollapsingToolbarLayout 的视差效果
```

3. **关键源码**：
```java
// CoordinatorLayout.onNestedPreScroll()
@Override
public void onNestedPreScroll(View target, int dx, int dy, int[] consumed, int type) {
    int xConsumed = 0;
    int yConsumed = 0;
    boolean accepted = false;

    final int childCount = getChildCount();
    for (int i = 0; i < childCount; i++) {
        final View view = getChildAt(i);
        final LayoutParams lp = (LayoutParams) view.getLayoutParams();
        final Behavior viewBehavior = lp.getBehavior();
        
        if (viewBehavior != null) {
            // ★ 调用每个子 View 的 Behavior
            viewBehavior.onNestedPreScroll(this, view, target, dx, dy, consumed, type);
            
            xConsumed = dx > 0 ? Math.max(xConsumed, consumed[0])
                    : Math.min(xConsumed, consumed[0]);
            yConsumed = dy > 0 ? Math.max(yConsumed, consumed[1])
                    : Math.min(yConsumed, consumed[1]);
            accepted = true;
        }
    }

    consumed[0] = xConsumed;
    consumed[1] = yConsumed;
}

// AppBarLayout.BaseBehavior.onNestedPreScroll()
@Override
public void onNestedPreScroll(CoordinatorLayout coordinatorLayout, T child,
        View target, int dx, int dy, int[] consumed, int type) {
    if (dy != 0) {
        int min, max;
        if (dy < 0) {
            // 向下滚动，展开 AppBarLayout
            min = -child.getTotalScrollRange();
            max = min + child.getDownNestedPreScrollRange();
        } else {
            // 向上滚动，折叠 AppBarLayout
            min = -child.getUpNestedPreScrollRange();
            max = 0;
        }
        if (min != max) {
            // ★ 消费滚动距离，改变 AppBarLayout 的 offset
            consumed[1] = scroll(coordinatorLayout, child, dy, min, max);
        }
    }
}
```

4. **Behavior 机制**：
```java
// 自定义 Behavior 示例
public class CustomBehavior extends CoordinatorLayout.Behavior<View> {
    
    @Override
    public boolean layoutDependsOn(CoordinatorLayout parent, View child, View dependency) {
        // 声明依赖关系
        return dependency instanceof AppBarLayout;
    }
    
    @Override
    public boolean onDependentViewChanged(CoordinatorLayout parent, View child, 
            View dependency) {
        // 依赖的 View 变化时回调
        // 可以根据 AppBarLayout 的位置调整自己的位置
        float translationY = dependency.getY() + dependency.getHeight();
        child.setTranslationY(translationY);
        return true;
    }
    
    @Override
    public boolean onStartNestedScroll(CoordinatorLayout coordinatorLayout, View child,
            View directTargetChild, View target, int axes, int type) {
        // 是否参与嵌套滚动
        return (axes & ViewCompat.SCROLL_AXIS_VERTICAL) != 0;
    }
    
    @Override
    public void onNestedPreScroll(CoordinatorLayout coordinatorLayout, View child,
            View target, int dx, int dy, int[] consumed, int type) {
        // 预先消费滚动距离
    }
}
```


---

### 5.5 源码深度题

#### Q11: ViewGroup 是如何确定事件分发给哪个子 View 的？（OPPO、vivo Framework 高频）

**答案要点：**

1. **遍历顺序**：按照 Z 轴顺序从上到下（绘制顺序的逆序）

2. **判断条件**：
   - `canViewReceivePointerEvents()`：View 可见或正在动画
   - `isTransformedTouchPointInView()`：触摸点在 View 范围内

3. **源码分析**：
```java
// ViewGroup.dispatchTouchEvent() 中

// 获取按绘制顺序排序的子 View 列表
final ArrayList<View> preorderedList = buildTouchDispatchChildList();

// 从后往前遍历（Z 轴顺序，上层优先）
for (int i = childrenCount - 1; i >= 0; i--) {
    final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
    final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);

    // ★ 条件1：View 能否接收事件
    if (!child.canViewReceivePointerEvents()) {
        continue;
    }
    
    // ★ 条件2：触摸点是否在 View 范围内
    if (!isTransformedTouchPointInView(x, y, child, null)) {
        continue;
    }
    
    // 找到目标 View，尝试分发
    if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
        // 分发成功
        break;
    }
}

// canViewReceivePointerEvents() 实现
protected boolean canViewReceivePointerEvents() {
    // View 可见 或 正在执行动画
    return (mViewFlags & VISIBILITY_MASK) == VISIBLE
            || getAnimation() != null;
}

// isTransformedTouchPointInView() 实现
protected boolean isTransformedTouchPointInView(float x, float y, View child,
        PointF outLocalPoint) {
    // 将坐标转换到子 View 坐标系
    final float[] point = getTempLocationF();
    point[0] = x;
    point[1] = y;
    transformPointToViewLocal(point, child);
    
    // 判断点是否在 View 范围内
    final boolean isInView = child.pointInView(point[0], point[1]);
    
    if (isInView && outLocalPoint != null) {
        outLocalPoint.set(point[0], point[1]);
    }
    return isInView;
}

// View.pointInView() 实现
public boolean pointInView(float localX, float localY) {
    return pointInView(localX, localY, 0);
}

public boolean pointInView(float localX, float localY, float slop) {
    // slop 是触摸容差，可以扩大触摸区域
    return localX >= -slop && localY >= -slop 
            && localX < ((mRight - mLeft) + slop)
            && localY < ((mBottom - mTop) + slop);
}
```

4. **坐标转换**：
```java
// 父 View 坐标 → 子 View 坐标
public void transformPointToViewLocal(float[] point, View child) {
    // 减去滚动偏移
    point[0] += mScrollX - child.mLeft;
    point[1] += mScrollY - child.mTop;

    // 如果子 View 有变换矩阵（旋转、缩放等），应用逆矩阵
    if (!child.hasIdentityMatrix()) {
        child.getInverseMatrix().mapPoints(point);
    }
}
```

---

#### Q12: 多点触控时事件是如何分发的？（字节、快手高频）

**答案要点：**

1. **Pointer 概念**：
   - 每个手指对应一个 Pointer
   - 每个 Pointer 有唯一的 ID（`getPointerId()`）
   - 通过 `getPointerCount()` 获取当前触摸点数量

2. **多点触控事件类型**：
```java
// 第一个手指按下
ACTION_DOWN (pointerId = 0)

// 第二个手指按下
ACTION_POINTER_DOWN (pointerId = 1)
// 通过 getActionIndex() 获取是哪个手指

// 手指移动（所有手指的位置都在同一个事件中）
ACTION_MOVE
// 通过 getX(pointerIndex) 获取指定手指的坐标

// 第二个手指抬起
ACTION_POINTER_UP (pointerId = 1)

// 最后一个手指抬起
ACTION_UP (pointerId = 0)
```

3. **事件分割（Split）机制**：
```java
// ViewGroup 默认开启事件分割
// 不同手指的事件可以分发给不同的子 View

// ViewGroup.dispatchTouchEvent() 中
final boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0;

if (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN) {
    // 新手指按下，寻找新的触摸目标
    // 可能分发给不同的子 View
}

// 禁用事件分割
viewGroup.setMotionEventSplittingEnabled(false);
```

4. **TouchTarget 链表**：
```java
// 每个 TouchTarget 记录了子 View 和对应的 pointer ID
private static final class TouchTarget {
    public View child;
    public int pointerIdBits;  // 位掩码，记录哪些 pointer 分发给这个 View
    public TouchTarget next;   // 链表结构
}

// 添加触摸目标
private TouchTarget addTouchTarget(View child, int pointerIdBits) {
    final TouchTarget target = TouchTarget.obtain(child, pointerIdBits);
    target.next = mFirstTouchTarget;
    mFirstTouchTarget = target;
    return target;
}
```

5. **事件分割示例**：
```
手指1 按下 View A → TouchTarget: {A, pointer0}
手指2 按下 View B → TouchTarget: {B, pointer1} → {A, pointer0}

MOVE 事件分发：
- pointer0 的坐标分发给 View A
- pointer1 的坐标分发给 View B

// dispatchTransformedTouchEvent 中会分割事件
if (newPointerIdBits != oldPointerIdBits) {
    // 只包含目标 View 关心的 pointer
    transformedEvent = event.split(newPointerIdBits);
}
```

---

#### Q13: OnTouchListener、onTouchEvent、OnClickListener 的执行顺序和关系？（基础高频）

**答案要点：**

**执行顺序**：
```
OnTouchListener.onTouch() → onTouchEvent() → OnClickListener.onClick()
```

**源码分析**：
```java
// View.dispatchTouchEvent()
public boolean dispatchTouchEvent(MotionEvent event) {
    boolean result = false;
    
    // 1. 先执行 OnTouchListener
    ListenerInfo li = mListenerInfo;
    if (li != null && li.mOnTouchListener != null
            && (mViewFlags & ENABLED_MASK) == ENABLED
            && li.mOnTouchListener.onTouch(this, event)) {
        // OnTouchListener 返回 true，事件被消费
        result = true;
    }

    // 2. OnTouchListener 没消费，执行 onTouchEvent
    if (!result && onTouchEvent(event)) {
        result = true;
    }

    return result;
}

// View.onTouchEvent() 中触发 onClick
case MotionEvent.ACTION_UP:
    if (!mHasPerformedLongPress && !mIgnoreNextUpEvent) {
        // 3. 在 ACTION_UP 时触发 onClick
        performClickInternal();
    }
    break;

// performClickInternal() → performClick()
public boolean performClick() {
    ListenerInfo li = mListenerInfo;
    if (li != null && li.mOnClickListener != null) {
        li.mOnClickListener.onClick(this);
        return true;
    }
    return false;
}
```

**关键结论**：

| 场景 | OnTouchListener | onTouchEvent | OnClickListener |
|------|-----------------|--------------|-----------------|
| OnTouchListener 返回 true | ✅ 执行 | ❌ 不执行 | ❌ 不执行 |
| OnTouchListener 返回 false | ✅ 执行 | ✅ 执行 | ✅ 执行（如果可点击） |
| 没有设置 OnTouchListener | - | ✅ 执行 | ✅ 执行（如果可点击） |
| View 不可点击 | ✅ 执行 | ✅ 执行（返回 false） | ❌ 不执行 |


---

### 5.6 实战场景题

#### Q14: 如何实现一个可以同时响应点击和滑动的自定义 View？（美团、快手高频）

**答案要点：**

```java
/**
 * 同时支持点击和滑动的自定义 View
 * 关键：区分点击和滑动的判断
 */
public class ClickAndScrollView extends View {
    
    private int mTouchSlop;
    private float mDownX, mDownY;
    private float mLastX, mLastY;
    private boolean mIsBeingDragged = false;
    private VelocityTracker mVelocityTracker;
    
    public ClickAndScrollView(Context context) {
        super(context);
        mTouchSlop = ViewConfiguration.get(context).getScaledTouchSlop();
        // 设置可点击，确保能收到事件
        setClickable(true);
    }
    
    @Override
    public boolean onTouchEvent(MotionEvent event) {
        if (mVelocityTracker == null) {
            mVelocityTracker = VelocityTracker.obtain();
        }
        mVelocityTracker.addMovement(event);
        
        float x = event.getX();
        float y = event.getY();
        
        switch (event.getAction()) {
            case MotionEvent.ACTION_DOWN:
                mDownX = mLastX = x;
                mDownY = mLastY = y;
                mIsBeingDragged = false;
                // ★ 关键：DOWN 时返回 true，确保收到后续事件
                return true;
                
            case MotionEvent.ACTION_MOVE:
                float deltaX = x - mDownX;
                float deltaY = y - mDownY;
                
                // 判断是否开始滑动
                if (!mIsBeingDragged) {
                    if (Math.abs(deltaX) > mTouchSlop || Math.abs(deltaY) > mTouchSlop) {
                        mIsBeingDragged = true;
                        // 通知父 View 不要拦截
                        getParent().requestDisallowInterceptTouchEvent(true);
                    }
                }
                
                if (mIsBeingDragged) {
                    // 执行滑动
                    float dx = x - mLastX;
                    float dy = y - mLastY;
                    handleScroll(dx, dy);
                }
                
                mLastX = x;
                mLastY = y;
                return true;
                
            case MotionEvent.ACTION_UP:
                if (!mIsBeingDragged) {
                    // ★ 没有滑动，触发点击
                    performClick();
                } else {
                    // 滑动结束，处理 fling
                    mVelocityTracker.computeCurrentVelocity(1000);
                    float velocityX = mVelocityTracker.getXVelocity();
                    float velocityY = mVelocityTracker.getYVelocity();
                    handleFling(velocityX, velocityY);
                }
                
                // 重置状态
                mIsBeingDragged = false;
                if (mVelocityTracker != null) {
                    mVelocityTracker.recycle();
                    mVelocityTracker = null;
                }
                return true;
                
            case MotionEvent.ACTION_CANCEL:
                mIsBeingDragged = false;
                if (mVelocityTracker != null) {
                    mVelocityTracker.recycle();
                    mVelocityTracker = null;
                }
                return true;
        }
        
        return super.onTouchEvent(event);
    }
    
    private void handleScroll(float dx, float dy) {
        // 处理滑动逻辑
        scrollBy((int) -dx, (int) -dy);
    }
    
    private void handleFling(float velocityX, float velocityY) {
        // 处理 fling 逻辑
    }
}
```

---

#### Q15: 如何扩大 View 的点击区域而不改变其显示大小？（实战高频）

**答案要点：**

**方案一：使用 TouchDelegate**
```java
// 在父 View 中设置 TouchDelegate
public void expandTouchArea(final View view, final int extraPadding) {
    final View parent = (View) view.getParent();
    
    parent.post(() -> {
        // 获取 View 在父 View 中的位置
        Rect bounds = new Rect();
        view.getHitRect(bounds);
        
        // 扩大触摸区域
        bounds.left -= extraPadding;
        bounds.top -= extraPadding;
        bounds.right += extraPadding;
        bounds.bottom += extraPadding;
        
        // 设置 TouchDelegate
        TouchDelegate touchDelegate = new TouchDelegate(bounds, view);
        parent.setTouchDelegate(touchDelegate);
    });
}

// 使用
expandTouchArea(button, 50); // 扩大 50px
```

**方案二：重写 getHitRect**
```java
public class ExpandedTouchView extends View {
    
    private int mTouchExpand = 0;
    
    public void setTouchExpand(int expand) {
        mTouchExpand = expand;
    }
    
    @Override
    public void getHitRect(Rect outRect) {
        super.getHitRect(outRect);
        // 扩大触摸区域
        outRect.left -= mTouchExpand;
        outRect.top -= mTouchExpand;
        outRect.right += mTouchExpand;
        outRect.bottom += mTouchExpand;
    }
}
```

**方案三：使用 padding + 负 margin**
```xml
<Button
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:padding="20dp"
    android:layout_margin="-20dp"
    android:background="@drawable/button_bg" />
```

**方案四：自定义父 View 的事件分发**
```java
public class ExpandedTouchParent extends FrameLayout {
    
    private Map<View, Rect> mExpandedTouchAreas = new HashMap<>();
    
    public void setExpandedTouchArea(View child, int expand) {
        Rect rect = new Rect();
        child.getHitRect(rect);
        rect.left -= expand;
        rect.top -= expand;
        rect.right += expand;
        rect.bottom += expand;
        mExpandedTouchAreas.put(child, rect);
    }
    
    @Override
    public boolean dispatchTouchEvent(MotionEvent ev) {
        if (ev.getAction() == MotionEvent.ACTION_DOWN) {
            float x = ev.getX();
            float y = ev.getY();
            
            // 检查是否在扩展区域内
            for (Map.Entry<View, Rect> entry : mExpandedTouchAreas.entrySet()) {
                if (entry.getValue().contains((int) x, (int) y)) {
                    // 将事件坐标转换到目标 View 中心
                    View child = entry.getKey();
                    float centerX = child.getX() + child.getWidth() / 2f;
                    float centerY = child.getY() + child.getHeight() / 2f;
                    ev.setLocation(centerX, centerY);
                    break;
                }
            }
        }
        return super.dispatchTouchEvent(ev);
    }
}
```

---

## 6. 总结

### 6.1 事件分发核心要点

1. **分发流程**：Activity → Window → DecorView → ViewGroup → View
2. **三个核心方法**：dispatchTouchEvent、onInterceptTouchEvent、onTouchEvent
3. **事件序列**：DOWN 决定后续事件的接收者
4. **TouchTarget**：记录消费事件的子 View，保证事件序列一致性

### 6.2 滑动冲突解决方案

1. **外部拦截法**：父 View 在 onInterceptTouchEvent 中判断
2. **内部拦截法**：子 View 通过 requestDisallowInterceptTouchEvent 控制
3. **NestedScrolling**：父子协作消费滚动距离

### 6.3 面试重点

- 事件分发流程和源码
- 三个方法的关系和返回值影响
- 滑动冲突的解决方案
- NestedScrolling 机制
- 多点触控的处理
- 实际场景的解决方案

---

*文档版本：Android W (API 35)*
*最后更新：2024年*
*适用面试：字节、美团、快手、OPPO、vivo*
