# Android 渲染机制

## 1. 概述

Android 渲染机制是 Android 系统中最核心的部分之一，它决定了应用界面如何从代码转换为用户可见的像素。理解渲染机制对于性能优化、解决卡顿问题至关重要。本文将深入讲解屏幕刷新机制、VSYNC 信号、Choreographer 原理、双缓冲与三缓冲、RenderThread 与硬件加速，以及 SurfaceView 和 TextureView 的原理与选择。

## 2. 核心原理

### 2.1 屏幕刷新机制

#### 2.1.1 基本概念

屏幕刷新是指显示器将图像数据更新到屏幕上的过程。现代手机屏幕通常采用 60Hz、90Hz、120Hz 或更高的刷新率。

```
┌─────────────────────────────────────────────────────────────┐
│                    屏幕刷新基本概念                          │
├─────────────────────────────────────────────────────────────┤
│  刷新率 (Refresh Rate)                                      │
│  - 屏幕每秒刷新的次数                                        │
│  - 60Hz = 每秒刷新60次 = 每帧约16.67ms                       │
│  - 90Hz = 每秒刷新90次 = 每帧约11.11ms                       │
│  - 120Hz = 每秒刷新120次 = 每帧约8.33ms                      │
├─────────────────────────────────────────────────────────────┤
│  帧率 (Frame Rate / FPS)                                    │
│  - 应用每秒产生的帧数                                        │
│  - 理想情况：帧率 = 刷新率                                   │
│  - 帧率 < 刷新率 → 掉帧、卡顿                                │
└─────────────────────────────────────────────────────────────┘
```

#### 2.1.2 渲染流水线

Android 渲染流水线涉及多个组件协同工作：

```
┌─────────────────────────────────────────────────────────────────────┐
│                      Android 渲染流水线                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   App 进程                    System 进程                           │
│  ┌─────────────┐            ┌─────────────────┐                    │
│  │   UI Thread │            │ SurfaceFlinger  │                    │
│  │  (主线程)   │            │   (合成服务)     │                    │
│  │             │            │                 │                    │
│  │ measure     │            │  Layer 合成     │                    │
│  │ layout      │            │  送显           │                    │
│  │ draw        │            │                 │                    │
│  └──────┬──────┘            └────────┬────────┘                    │
│         │                            │                              │
│         ↓                            ↓                              │
│  ┌─────────────┐            ┌─────────────────┐    ┌──────────┐   │
│  │RenderThread │            │    Hardware     │    │  Display │   │
│  │  (渲染线程) │───────────→│   Composer      │───→│  (屏幕)  │   │
│  │             │            │   (HWC)         │    │          │   │
│  │ DisplayList │            │                 │    │          │   │
│  │ GPU 渲染    │            │                 │    │          │   │
│  └─────────────┘            └─────────────────┘    └──────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```


#### 2.1.3 一帧的渲染过程

```
┌─────────────────────────────────────────────────────────────────────┐
│                      一帧的完整渲染过程                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  VSYNC 信号                                                         │
│     │                                                               │
│     ↓                                                               │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │ 1. Input 处理 (InputReader/InputDispatcher)                  │  │
│  │    - 处理触摸、按键等输入事件                                 │  │
│  └──────────────────────────────────────────────────────────────┘  │
│     │                                                               │
│     ↓                                                               │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │ 2. Animation 处理                                            │  │
│  │    - 执行属性动画、View 动画                                  │  │
│  └──────────────────────────────────────────────────────────────┘  │
│     │                                                               │
│     ↓                                                               │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │ 3. Traversal 遍历 (measure → layout → draw)                  │  │
│  │    - 测量、布局、绘制 View 树                                 │  │
│  └──────────────────────────────────────────────────────────────┘  │
│     │                                                               │
│     ↓                                                               │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │ 4. RenderThread 渲染                                         │  │
│  │    - 执行 DisplayList，GPU 渲染                              │  │
│  └──────────────────────────────────────────────────────────────┘  │
│     │                                                               │
│     ↓                                                               │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │ 5. SurfaceFlinger 合成                                       │  │
│  │    - 合成多个 Layer，送显                                    │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 2.2 VSYNC 信号

#### 2.2.1 什么是 VSYNC

VSYNC（Vertical Synchronization，垂直同步）是一种同步机制，用于协调屏幕刷新和帧渲染的时机。

```
┌─────────────────────────────────────────────────────────────────────┐
│                         VSYNC 信号原理                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  没有 VSYNC 的情况（画面撕裂）:                                      │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │  屏幕刷新:  ──┬────────┬────────┬────────┬────────           │   │
│  │              │        │        │        │                    │   │
│  │  帧渲染:    ─┬──────┬───────┬──────┬───────                  │   │
│  │             │      │       │      │                          │   │
│  │             ↓      ↓       ↓      ↓                          │   │
│  │           帧1    帧2     帧3    帧4                           │   │
│  │                                                               │   │
│  │  问题：渲染和刷新不同步，导致画面撕裂                          │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  有 VSYNC 的情况:                                                   │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │  VSYNC:     ──┬────────┬────────┬────────┬────────           │   │
│  │              │        │        │        │                    │   │
│  │  屏幕刷新:   ─┼────────┼────────┼────────┼────────           │   │
│  │              │        │        │        │                    │   │
│  │  帧渲染:     ─┼────────┼────────┼────────┼────────           │   │
│  │              │        │        │        │                    │   │
│  │              ↓        ↓        ↓        ↓                    │   │
│  │            帧1      帧2      帧3      帧4                     │   │
│  │                                                               │   │
│  │  效果：渲染和刷新同步，画面流畅                                │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

#### 2.2.2 VSYNC 的分发

Android 4.1 (Jelly Bean) 引入了 Project Butter，通过 VSYNC 信号协调整个渲染流程：

```
┌─────────────────────────────────────────────────────────────────────┐
│                      VSYNC 信号分发流程                             │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│                    ┌─────────────────┐                              │
│                    │   HWC (硬件)    │                              │
│                    │  产生 VSYNC     │                              │
│                    └────────┬────────┘                              │
│                             │                                       │
│                             ↓                                       │
│                    ┌─────────────────┐                              │
│                    │ SurfaceFlinger  │                              │
│                    │  接收 VSYNC     │                              │
│                    └────────┬────────┘                              │
│                             │                                       │
│              ┌──────────────┼──────────────┐                        │
│              ↓              ↓              ↓                        │
│     ┌────────────┐  ┌────────────┐  ┌────────────┐                 │
│     │ VSYNC-app  │  │ VSYNC-sf   │  │ VSYNC-appSf│                 │
│     │ (应用渲染) │  │ (合成)     │  │ (同步)     │                 │
│     └─────┬──────┘  └─────┬──────┘  └────────────┘                 │
│           │               │                                         │
│           ↓               ↓                                         │
│     ┌────────────┐  ┌────────────┐                                 │
│     │Choreographer│  │SurfaceFlinger│                               │
│     │  (App)     │  │  合成 Layer │                                │
│     └────────────┘  └────────────┘                                 │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```


### 2.3 Choreographer 原理

#### 2.3.1 Choreographer 概述

Choreographer（编舞者）是 Android 渲染机制的核心调度器，负责协调输入、动画、绘制等操作的执行时机。

```
┌─────────────────────────────────────────────────────────────────────┐
│                      Choreographer 架构                             │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                    Choreographer                             │   │
│  │  ┌─────────────────────────────────────────────────────┐    │   │
│  │  │              CallbackQueue (回调队列)                │    │   │
│  │  │  ┌─────────┬─────────┬─────────┬─────────┐          │    │   │
│  │  │  │ INPUT   │ANIMATION│INSETS_  │TRAVERSAL│          │    │   │
│  │  │  │ (0)     │ (1)     │ANIMATION│ (3)     │          │    │   │
│  │  │  │         │         │ (2)     │         │          │    │   │
│  │  │  └─────────┴─────────┴─────────┴─────────┘          │    │   │
│  │  └─────────────────────────────────────────────────────┘    │   │
│  │                                                              │   │
│  │  ┌─────────────────────────────────────────────────────┐    │   │
│  │  │           FrameDisplayEventReceiver                  │    │   │
│  │  │           (接收 VSYNC 信号)                          │    │   │
│  │  └─────────────────────────────────────────────────────┘    │   │
│  │                                                              │   │
│  │  ┌─────────────────────────────────────────────────────┐    │   │
│  │  │           FrameHandler                               │    │   │
│  │  │           (处理帧回调)                               │    │   │
│  │  └─────────────────────────────────────────────────────┘    │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

#### 2.3.2 回调类型

Choreographer 定义了四种回调类型，按优先级顺序执行：

```
┌─────────────────────────────────────────────────────────────────────┐
│                    Choreographer 回调类型                           │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  优先级    类型                    说明                             │
│  ────────────────────────────────────────────────────────────────  │
│    0      CALLBACK_INPUT          输入事件回调                      │
│                                   - 处理触摸、按键等输入事件         │
│                                                                     │
│    1      CALLBACK_ANIMATION      动画回调                          │
│                                   - 执行属性动画                     │
│                                   - ValueAnimator.start()           │
│                                                                     │
│    2      CALLBACK_INSETS_ANIMATION  窗口插入动画回调               │
│                                   - 处理系统栏动画                   │
│                                   - Android 11+ 新增                │
│                                                                     │
│    3      CALLBACK_TRAVERSAL      遍历回调                          │
│                                   - View 的 measure/layout/draw     │
│                                   - ViewRootImpl.scheduleTraversals │
│                                                                     │
│    4      CALLBACK_COMMIT         提交回调                          │
│                                   - 帧提交后的回调                   │
│                                   - Android 6.0+ 新增               │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

#### 2.3.3 工作流程

```
┌─────────────────────────────────────────────────────────────────────┐
│                    Choreographer 工作流程                           │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  1. 注册回调                                                        │
│     ┌─────────────────────────────────────────────────────────┐    │
│     │ postCallback(CALLBACK_TRAVERSAL, runnable, token)       │    │
│     │ postFrameCallback(callback)                             │    │
│     └─────────────────────────────────────────────────────────┘    │
│                          │                                          │
│                          ↓                                          │
│  2. 请求 VSYNC                                                      │
│     ┌─────────────────────────────────────────────────────────┐    │
│     │ scheduleVsyncLocked()                                   │    │
│     │ → mDisplayEventReceiver.scheduleVsync()                 │    │
│     │ → native 层请求 VSYNC                                   │    │
│     └─────────────────────────────────────────────────────────┘    │
│                          │                                          │
│                          ↓                                          │
│  3. 接收 VSYNC                                                      │
│     ┌─────────────────────────────────────────────────────────┐    │
│     │ FrameDisplayEventReceiver.onVsync()                     │    │
│     │ → 发送 MSG_DO_FRAME 消息                                │    │
│     └─────────────────────────────────────────────────────────┘    │
│                          │                                          │
│                          ↓                                          │
│  4. 执行帧回调                                                      │
│     ┌─────────────────────────────────────────────────────────┐    │
│     │ doFrame(frameTimeNanos, frame)                          │    │
│     │ → doCallbacks(CALLBACK_INPUT)                           │    │
│     │ → doCallbacks(CALLBACK_ANIMATION)                       │    │
│     │ → doCallbacks(CALLBACK_INSETS_ANIMATION)                │    │
│     │ → doCallbacks(CALLBACK_TRAVERSAL)                       │    │
│     │ → doCallbacks(CALLBACK_COMMIT)                          │    │
│     └─────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```


### 2.4 双缓冲与三缓冲

#### 2.4.1 缓冲机制概述

缓冲机制用于解决渲染和显示之间的同步问题，避免画面撕裂和卡顿。

```
┌─────────────────────────────────────────────────────────────────────┐
│                         单缓冲问题                                  │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                      单缓冲                                  │   │
│  │                                                              │   │
│  │   GPU 渲染 ──→ ┌─────────┐ ──→ 屏幕显示                     │   │
│  │               │ Buffer  │                                   │   │
│  │               └─────────┘                                   │   │
│  │                                                              │   │
│  │   问题：GPU 正在写入时，屏幕可能正在读取                      │   │
│  │         导致画面撕裂 (Screen Tearing)                        │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

#### 2.4.2 双缓冲 (Double Buffering)

```
┌─────────────────────────────────────────────────────────────────────┐
│                         双缓冲机制                                  │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                      双缓冲                                  │   │
│  │                                                              │   │
│  │              ┌─────────────┐                                 │   │
│  │   GPU 渲染 ──→│ Back Buffer │                                │   │
│  │              └──────┬──────┘                                 │   │
│  │                     │ VSYNC 时交换                           │   │
│  │                     ↓                                        │   │
│  │              ┌─────────────┐                                 │   │
│  │              │Front Buffer │──→ 屏幕显示                     │   │
│  │              └─────────────┘                                 │   │
│  │                                                              │   │
│  │   工作原理：                                                 │   │
│  │   - Back Buffer：GPU 正在渲染的缓冲区                        │   │
│  │   - Front Buffer：屏幕正在显示的缓冲区                       │   │
│  │   - VSYNC 信号到来时，交换两个缓冲区                         │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  双缓冲的问题：                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                                                              │   │
│  │  时间轴:  ──┬────────┬────────┬────────┬────────             │   │
│  │  VSYNC:    V0       V1       V2       V3                     │   │
│  │                                                              │   │
│  │  Display:  ────A────────A────────B────────C────              │   │
│  │                                                              │   │
│  │  GPU:      ──B──────────C────────D────────E────              │   │
│  │                 ↑                                            │   │
│  │                 │                                            │   │
│  │            B 渲染超时，错过 V1                                │   │
│  │            导致 A 重复显示一帧（Jank）                        │   │
│  │                                                              │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

#### 2.4.3 三缓冲 (Triple Buffering)

```
┌─────────────────────────────────────────────────────────────────────┐
│                         三缓冲机制                                  │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                      三缓冲                                  │   │
│  │                                                              │   │
│  │              ┌─────────────┐                                 │   │
│  │   CPU 绘制 ──→│ Buffer A   │                                 │   │
│  │              └──────┬──────┘                                 │   │
│  │                     │                                        │   │
│  │              ┌─────────────┐                                 │   │
│  │   GPU 渲染 ──→│ Buffer B   │                                 │   │
│  │              └──────┬──────┘                                 │   │
│  │                     │ VSYNC 时交换                           │   │
│  │                     ↓                                        │   │
│  │              ┌─────────────┐                                 │   │
│  │              │ Buffer C   │──→ 屏幕显示                      │   │
│  │              └─────────────┘                                 │   │
│  │                                                              │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  三缓冲的优势：                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                                                              │   │
│  │  时间轴:  ──┬────────┬────────┬────────┬────────             │   │
│  │  VSYNC:    V0       V1       V2       V3                     │   │
│  │                                                              │   │
│  │  Display:  ────A────────A────────B────────C────              │   │
│  │                                                              │   │
│  │  GPU:      ──B──────────C────────D────────E────              │   │
│  │                                                              │   │
│  │  CPU:      ────C────────D────────E────────F────              │   │
│  │                 ↑                                            │   │
│  │                 │                                            │   │
│  │            虽然 B 渲染超时，但 CPU 可以继续绘制 C             │   │
│  │            减少后续帧的延迟                                  │   │
│  │                                                              │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  三缓冲的代价：                                                     │
│  - 增加一帧的延迟（约 16ms）                                       │
│  - 增加内存占用                                                    │
│  - Android 默认使用三缓冲                                          │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```


### 2.5 RenderThread 与硬件加速

#### 2.5.1 软件渲染 vs 硬件加速

```
┌─────────────────────────────────────────────────────────────────────┐
│                    软件渲染 vs 硬件加速                             │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  软件渲染 (Software Rendering):                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                                                              │   │
│  │   UI Thread                                                  │   │
│  │   ┌─────────────────────────────────────────────────────┐   │   │
│  │   │ measure → layout → draw (CPU 绑制到 Bitmap)         │   │   │
│  │   └─────────────────────────────────────────────────────┘   │   │
│  │                          │                                   │   │
│  │                          ↓                                   │   │
│  │                    ┌──────────┐                              │   │
│  │                    │  Bitmap  │ ──→ 屏幕                     │   │
│  │                    └──────────┘                              │   │
│  │                                                              │   │
│  │   特点：所有绑制操作在主线程完成，使用 CPU                    │   │
│  │   缺点：主线程负担重，容易卡顿                               │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  硬件加速 (Hardware Acceleration):                                  │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                                                              │   │
│  │   UI Thread                    RenderThread                  │   │
│  │   ┌───────────────────┐       ┌───────────────────┐         │   │
│  │   │ measure → layout  │       │ 执行 DisplayList  │         │   │
│  │   │ → 构建 DisplayList│ ────→ │ GPU 渲染          │         │   │
│  │   └───────────────────┘       └─────────┬─────────┘         │   │
│  │                                         │                    │   │
│  │                                         ↓                    │   │
│  │                                   ┌──────────┐               │   │
│  │                                   │   GPU    │ ──→ 屏幕      │   │
│  │                                   └──────────┘               │   │
│  │                                                              │   │
│  │   特点：绑制操作分离到 RenderThread，使用 GPU                 │   │
│  │   优点：主线程负担轻，渲染效率高                             │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

#### 2.5.2 RenderThread 工作原理

```
┌─────────────────────────────────────────────────────────────────────┐
│                    RenderThread 工作原理                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                    UI Thread (主线程)                        │   │
│  │                                                              │   │
│  │  1. View.draw() 被调用                                       │   │
│  │     ↓                                                        │   │
│  │  2. Canvas.drawXxx() 记录绘制命令                            │   │
│  │     ↓                                                        │   │
│  │  3. 构建 DisplayList (RenderNode)                            │   │
│  │     ↓                                                        │   │
│  │  4. 同步 DisplayList 到 RenderThread                         │   │
│  │                                                              │   │
│  └──────────────────────────┬──────────────────────────────────┘   │
│                             │                                       │
│                             ↓ sync                                  │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                    RenderThread (渲染线程)                   │   │
│  │                                                              │   │
│  │  5. 接收 DisplayList                                         │   │
│  │     ↓                                                        │   │
│  │  6. 遍历 DisplayList，转换为 GPU 命令                        │   │
│  │     ↓                                                        │   │
│  │  7. 通过 OpenGL ES / Vulkan 执行 GPU 渲染                    │   │
│  │     ↓                                                        │   │
│  │  8. 渲染结果写入 Surface 的 Buffer                           │   │
│  │     ↓                                                        │   │
│  │  9. 提交 Buffer 给 SurfaceFlinger                            │   │
│  │                                                              │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

#### 2.5.3 DisplayList (RenderNode)

```
┌─────────────────────────────────────────────────────────────────────┐
│                    DisplayList 结构                                 │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  DisplayList 是一个绘制命令的列表，记录了 View 的绘制操作：         │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │  RenderNode (View 的 DisplayList)                           │   │
│  │  ┌─────────────────────────────────────────────────────┐   │   │
│  │  │  DisplayListOp 1: Save                              │   │   │
│  │  │  DisplayListOp 2: ClipRect(0, 0, 1080, 1920)        │   │   │
│  │  │  DisplayListOp 3: DrawRect(0, 0, 100, 100, paint)   │   │   │
│  │  │  DisplayListOp 4: DrawText("Hello", 50, 50, paint)  │   │   │
│  │  │  DisplayListOp 5: DrawBitmap(bitmap, 0, 0)          │   │   │
│  │  │  DisplayListOp 6: Restore                           │   │   │
│  │  │  ...                                                │   │   │
│  │  └─────────────────────────────────────────────────────┘   │   │
│  │                                                              │   │
│  │  子 RenderNode (子 View 的 DisplayList)                      │   │
│  │  ┌─────────────────────────────────────────────────────┐   │   │
│  │  │  ...                                                │   │   │
│  │  └─────────────────────────────────────────────────────┘   │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  优势：                                                             │
│  - 可以缓存和复用，避免重复构建                                    │
│  - 支持局部更新，只更新变化的部分                                  │
│  - 可以在 RenderThread 异步执行                                    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

#### 2.5.4 硬件加速的限制

```
┌─────────────────────────────────────────────────────────────────────┐
│                    硬件加速的限制                                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  不支持硬件加速的操作：                                             │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │  Canvas 方法              │  API Level 限制                  │   │
│  │  ─────────────────────────────────────────────────────────  │   │
│  │  drawBitmapMesh()         │  不支持                          │   │
│  │  drawPicture()            │  不支持                          │   │
│  │  drawVertices()           │  不支持                          │   │
│  │  setDrawFilter()          │  不支持                          │   │
│  │  clipPath()               │  API 18+ 支持                    │   │
│  │  clipRegion()             │  API 18+ 支持                    │   │
│  │  drawTextOnPath()         │  API 16+ 支持                    │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  Paint 限制：                                                       │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │  - setMaskFilter() 中的 BlurMaskFilter 支持                 │   │
│  │  - setMaskFilter() 中的 EmbossMaskFilter 不支持             │   │
│  │  - setPathEffect() 部分效果不支持                           │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  检测是否支持硬件加速：                                             │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │  // 检查 View 是否启用硬件加速                              │   │
│  │  view.isHardwareAccelerated()                               │   │
│  │                                                              │   │
│  │  // 检查 Canvas 是否启用硬件加速                            │   │
│  │  canvas.isHardwareAccelerated()                             │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```


### 2.6 SurfaceView 原理

#### 2.6.1 SurfaceView 概述

SurfaceView 是一种特殊的 View，它拥有独立的 Surface，可以在独立的线程中进行绑制，适合视频播放、游戏、相机预览等场景。

```
┌─────────────────────────────────────────────────────────────────────┐
│                    SurfaceView 架构                                 │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  普通 View 的渲染：                                                 │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                                                              │   │
│  │   DecorView                                                  │   │
│  │   ┌─────────────────────────────────────────────────────┐   │   │
│  │   │  ViewGroup                                          │   │   │
│  │   │  ┌─────────┐ ┌─────────┐ ┌─────────┐               │   │   │
│  │   │  │  View   │ │  View   │ │  View   │               │   │   │
│  │   │  └─────────┘ └─────────┘ └─────────┘               │   │   │
│  │   └─────────────────────────────────────────────────────┘   │   │
│  │                          │                                   │   │
│  │                          ↓                                   │   │
│  │                    ┌──────────┐                              │   │
│  │                    │ Surface  │ (Window 的 Surface)          │   │
│  │                    └──────────┘                              │   │
│  │                                                              │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  SurfaceView 的渲染：                                               │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                                                              │   │
│  │   DecorView                                                  │   │
│  │   ┌─────────────────────────────────────────────────────┐   │   │
│  │   │  ViewGroup                                          │   │   │
│  │   │  ┌─────────┐ ┌─────────────┐ ┌─────────┐           │   │   │
│  │   │  │  View   │ │ SurfaceView │ │  View   │           │   │   │
│  │   │  └─────────┘ └──────┬──────┘ └─────────┘           │   │   │
│  │   └─────────────────────┼───────────────────────────────┘   │   │
│  │                         │                                    │   │
│  │            ┌────────────┴────────────┐                      │   │
│  │            ↓                         ↓                      │   │
│  │      ┌──────────┐              ┌──────────┐                 │   │
│  │      │ Surface  │              │ Surface  │                 │   │
│  │      │ (Window) │              │(独立的)  │                 │   │
│  │      └──────────┘              └──────────┘                 │   │
│  │                                                              │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

#### 2.6.2 SurfaceView 的双缓冲机制

```
┌─────────────────────────────────────────────────────────────────────┐
│                    SurfaceView 双缓冲                               │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                    SurfaceView                               │   │
│  │                                                              │   │
│  │   ┌─────────────────────────────────────────────────────┐   │   │
│  │   │                    Surface                           │   │   │
│  │   │   ┌─────────────┐      ┌─────────────┐              │   │   │
│  │   │   │ Back Buffer │ ←──→ │Front Buffer │              │   │   │
│  │   │   │  (绘制中)   │      │  (显示中)   │              │   │   │
│  │   │   └─────────────┘      └─────────────┘              │   │   │
│  │   │                                                      │   │   │
│  │   │   lockCanvas() → 获取 Back Buffer                    │   │   │
│  │   │   绑制操作...                                        │   │   │
│  │   │   unlockCanvasAndPost() → 交换 Buffer                │   │   │
│  │   └─────────────────────────────────────────────────────┘   │   │
│  │                                                              │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  注意事项：                                                         │
│  - lockCanvas() 返回的 Canvas 内容是不确定的（可能是上上帧）        │
│  - 每次绘制需要重绘整个 Surface，或者使用 lockCanvas(Rect) 局部绘制 │
│  - unlockCanvasAndPost() 后 Canvas 不能再使用                      │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

#### 2.6.3 SurfaceView 的 Z-Order

```
┌─────────────────────────────────────────────────────────────────────┐
│                    SurfaceView Z-Order                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  默认情况下，SurfaceView 的 Surface 在 Window Surface 之下：        │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                                                              │   │
│  │   用户视角 (从上往下看)                                      │   │
│  │                                                              │   │
│  │   ┌─────────────────────────────────────────────────────┐   │   │
│  │   │           Window Surface (View 层)                  │   │   │
│  │   │   ┌─────────────────────────────────────────────┐   │   │   │
│  │   │   │         透明区域 (SurfaceView 位置)         │   │   │   │
│  │   │   │              "挖洞" 效果                    │   │   │   │
│  │   │   └─────────────────────────────────────────────┘   │   │   │
│  │   └─────────────────────────────────────────────────────┘   │   │
│  │                          ↓                                   │   │
│  │   ┌─────────────────────────────────────────────────────┐   │   │
│  │   │        SurfaceView Surface (在下层)                 │   │   │
│  │   └─────────────────────────────────────────────────────┘   │   │
│  │                                                              │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  setZOrderOnTop(true) 后，SurfaceView 在 Window Surface 之上：      │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                                                              │   │
│  │   ┌─────────────────────────────────────────────────────┐   │   │
│  │   │        SurfaceView Surface (在上层)                 │   │   │
│  │   └─────────────────────────────────────────────────────┘   │   │
│  │                          ↓                                   │   │
│  │   ┌─────────────────────────────────────────────────────┐   │   │
│  │   │           Window Surface (View 层)                  │   │   │
│  │   └─────────────────────────────────────────────────────┘   │   │
│  │                                                              │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```


### 2.7 TextureView 原理

#### 2.7.1 TextureView 概述

TextureView 是 Android 4.0 引入的，它将内容渲染到一个 SurfaceTexture 上，然后作为普通 View 的一部分参与 View 层级的绑制。

```
┌─────────────────────────────────────────────────────────────────────┐
│                    TextureView 架构                                 │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                    TextureView                               │   │
│  │                                                              │   │
│  │   ┌─────────────────────────────────────────────────────┐   │   │
│  │   │              SurfaceTexture                          │   │   │
│  │   │                                                      │   │   │
│  │   │   - 接收图像流（相机、视频解码器等）                 │   │   │
│  │   │   - 将图像转换为 OpenGL ES 纹理                      │   │   │
│  │   │   - 可以进行变换（旋转、缩放、平移）                 │   │   │
│  │   └─────────────────────────────────────────────────────┘   │   │
│  │                          │                                   │   │
│  │                          ↓                                   │   │
│  │   ┌─────────────────────────────────────────────────────┐   │   │
│  │   │              作为纹理绘制到 View 层                  │   │   │
│  │   │              参与 View 的 draw() 流程                │   │   │
│  │   └─────────────────────────────────────────────────────┘   │   │
│  │                          │                                   │   │
│  │                          ↓                                   │   │
│  │   ┌─────────────────────────────────────────────────────┐   │   │
│  │   │              Window Surface                          │   │   │
│  │   │              (与其他 View 一起合成)                  │   │   │
│  │   └─────────────────────────────────────────────────────┘   │   │
│  │                                                              │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

#### 2.7.2 TextureView 工作流程

```
┌─────────────────────────────────────────────────────────────────────┐
│                    TextureView 工作流程                             │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  1. TextureView 创建 SurfaceTexture                                 │
│     ┌─────────────────────────────────────────────────────────┐    │
│     │ onAttachedToWindow() → 创建 SurfaceTexture              │    │
│     │ → 回调 onSurfaceTextureAvailable()                      │    │
│     └─────────────────────────────────────────────────────────┘    │
│                          │                                          │
│                          ↓                                          │
│  2. 生产者写入图像数据                                              │
│     ┌─────────────────────────────────────────────────────────┐    │
│     │ Camera / MediaCodec / 自定义渲染                        │    │
│     │ → 获取 Surface (从 SurfaceTexture)                      │    │
│     │ → 写入图像数据                                          │    │
│     └─────────────────────────────────────────────────────────┘    │
│                          │                                          │
│                          ↓                                          │
│  3. SurfaceTexture 接收图像                                         │
│     ┌─────────────────────────────────────────────────────────┐    │
│     │ SurfaceTexture.updateTexImage()                         │    │
│     │ → 将最新帧更新到 GL 纹理                                │    │
│     │ → 回调 onSurfaceTextureUpdated()                        │    │
│     └─────────────────────────────────────────────────────────┘    │
│                          │                                          │
│                          ↓                                          │
│  4. TextureView 绘制纹理                                            │
│     ┌─────────────────────────────────────────────────────────┐    │
│     │ TextureView.draw() → 将纹理绘制到 Canvas                │    │
│     │ → 参与 View 层级的合成                                  │    │
│     └─────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 2.8 SurfaceView vs TextureView 选择

```
┌─────────────────────────────────────────────────────────────────────┐
│                SurfaceView vs TextureView 对比                      │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  特性              │  SurfaceView          │  TextureView           │
│  ─────────────────────────────────────────────────────────────────  │
│  独立 Surface      │  ✓ 是                 │  ✗ 否                  │
│  渲染线程          │  独立线程             │  主线程/RenderThread   │
│  硬件加速要求      │  不需要               │  必须开启              │
│  View 动画         │  ✗ 不支持             │  ✓ 支持                │
│  View 变换         │  ✗ 不支持             │  ✓ 支持                │
│  透明度            │  ✗ 不支持             │  ✓ 支持                │
│  滚动/移动         │  有延迟               │  流畅                  │
│  内存占用          │  较低                 │  较高                  │
│  功耗              │  较低                 │  较高                  │
│  API Level         │  1+                   │  14+                   │
│                                                                     │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  使用场景建议：                                                     │
│                                                                     │
│  SurfaceView 适用于：                                               │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │  - 视频播放（全屏或固定位置）                               │   │
│  │  - 游戏渲染                                                 │   │
│  │  - 相机预览（不需要动画效果）                               │   │
│  │  - 高性能要求、低功耗场景                                   │   │
│  │  - 不需要 View 动画和变换的场景                             │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  TextureView 适用于：                                               │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │  - 需要 View 动画效果（如视频缩略图动画）                   │   │
│  │  - 需要透明度变化                                           │   │
│  │  - 需要在 RecyclerView/ViewPager 中使用                     │   │
│  │  - 需要截图功能                                             │   │
│  │  - 需要与其他 View 层级混合                                 │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  Android 7.0+ 推荐：                                                │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │  优先使用 SurfaceView，因为：                               │   │
│  │  - 性能更好，功耗更低                                       │   │
│  │  - Android 7.0 改进了 SurfaceView 的同步机制                │   │
│  │  - 减少了与 View 层级的同步问题                             │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```


## 3. 关键源码解析

### 3.1 Choreographer 核心源码

```java
/**
 * Choreographer 源码分析 (Android 14)
 * 源码位置: frameworks/base/core/java/android/view/Choreographer.java
 */
public final class Choreographer {
    
    // 回调类型常量
    public static final int CALLBACK_INPUT = 0;      // 输入事件
    public static final int CALLBACK_ANIMATION = 1;  // 动画
    public static final int CALLBACK_INSETS_ANIMATION = 2; // 窗口插入动画
    public static final int CALLBACK_TRAVERSAL = 3;  // View 遍历
    public static final int CALLBACK_COMMIT = 4;     // 提交
    
    private static final int CALLBACK_LAST = CALLBACK_COMMIT;
    
    // 回调队列数组，每种类型一个队列
    private final CallbackQueue[] mCallbackQueues;
    
    // 帧间隔时间（纳秒），60Hz 约为 16.67ms
    private long mFrameIntervalNanos;
    
    // VSYNC 信号接收器
    private final FrameDisplayEventReceiver mDisplayEventReceiver;
    
    // 主线程 Handler
    private final FrameHandler mHandler;
    
    // 是否已经请求了 VSYNC
    private boolean mFrameScheduled;
    
    /**
     * 获取主线程的 Choreographer 实例（单例）
     */
    public static Choreographer getInstance() {
        return sThreadInstance.get();
    }
    
    // ThreadLocal 保证每个线程有自己的 Choreographer
    private static final ThreadLocal<Choreographer> sThreadInstance =
            new ThreadLocal<Choreographer>() {
        @Override
        protected Choreographer initialValue() {
            Looper looper = Looper.myLooper();
            if (looper == null) {
                throw new IllegalStateException("The current thread must have a looper!");
            }
            // 主线程使用 VSYNC，其他线程不使用
            Choreographer choreographer = new Choreographer(looper, VSYNC_SOURCE_APP);
            if (looper == Looper.getMainLooper()) {
                mMainInstance = choreographer;
            }
            return choreographer;
        }
    };
    
    /**
     * 构造函数
     */
    private Choreographer(Looper looper, int vsyncSource) {
        mLooper = looper;
        mHandler = new FrameHandler(looper);
        
        // 创建 VSYNC 信号接收器（仅主线程）
        mDisplayEventReceiver = USE_VSYNC
                ? new FrameDisplayEventReceiver(looper, vsyncSource)
                : null;
        
        mLastFrameTimeNanos = Long.MIN_VALUE;
        
        // 计算帧间隔时间
        mFrameIntervalNanos = (long)(1000000000 / getRefreshRate());
        
        // 初始化回调队列
        mCallbackQueues = new CallbackQueue[CALLBACK_LAST + 1];
        for (int i = 0; i <= CALLBACK_LAST; i++) {
            mCallbackQueues[i] = new CallbackQueue();
        }
    }
    
    /**
     * 注册帧回调（常用于监控帧率）
     */
    public void postFrameCallback(FrameCallback callback) {
        postFrameCallbackDelayed(callback, 0);
    }
    
    public void postFrameCallbackDelayed(FrameCallback callback, long delayMillis) {
        postCallbackDelayedInternal(CALLBACK_ANIMATION,
                callback, FRAME_CALLBACK_TOKEN, delayMillis);
    }
    
    /**
     * 注册回调（内部方法）
     * @param callbackType 回调类型
     * @param action 回调动作（Runnable 或 FrameCallback）
     * @param token 标识符
     * @param delayMillis 延迟时间
     */
    private void postCallbackDelayedInternal(int callbackType,
            Object action, Object token, long delayMillis) {
        synchronized (mLock) {
            final long now = SystemClock.uptimeMillis();
            final long dueTime = now + delayMillis;
            
            // 将回调添加到对应类型的队列
            mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);
            
            if (dueTime <= now) {
                // 立即执行，请求 VSYNC
                scheduleFrameLocked(now);
            } else {
                // 延迟执行，发送延迟消息
                Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);
                msg.arg1 = callbackType;
                msg.setAsynchronous(true);
                mHandler.sendMessageAtTime(msg, dueTime);
            }
        }
    }
    
    /**
     * 请求 VSYNC 信号
     */
    private void scheduleFrameLocked(long now) {
        if (!mFrameScheduled) {
            mFrameScheduled = true;
            
            if (USE_VSYNC) {
                // 使用 VSYNC 同步
                if (isRunningOnLooperThreadLocked()) {
                    // 在主线程，直接请求 VSYNC
                    scheduleVsyncLocked();
                } else {
                    // 不在主线程，发送消息到主线程
                    Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);
                    msg.setAsynchronous(true);
                    mHandler.sendMessageAtFrontOfQueue(msg);
                }
            } else {
                // 不使用 VSYNC，直接发送 DO_FRAME 消息
                final long nextFrameTime = Math.max(
                        mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now);
                Message msg = mHandler.obtainMessage(MSG_DO_FRAME);
                msg.setAsynchronous(true);
                mHandler.sendMessageAtTime(msg, nextFrameTime);
            }
        }
    }
    
    /**
     * 请求 VSYNC 信号（native 层）
     */
    private void scheduleVsyncLocked() {
        mDisplayEventReceiver.scheduleVsync();
    }
}
```

### 3.2 FrameDisplayEventReceiver 源码

```java
/**
 * VSYNC 信号接收器
 * 继承自 DisplayEventReceiver，接收来自 SurfaceFlinger 的 VSYNC 信号
 */
private final class FrameDisplayEventReceiver extends DisplayEventReceiver
        implements Runnable {
    
    private boolean mHavePendingVsync;
    private long mTimestampNanos;
    private int mFrame;
    
    public FrameDisplayEventReceiver(Looper looper, int vsyncSource) {
        super(looper, vsyncSource, CONFIG_CHANGED_EVENT_SUPPRESS);
    }
    
    /**
     * 当 VSYNC 信号到来时回调（从 native 层调用）
     * @param timestampNanos VSYNC 时间戳（纳秒）
     * @param physicalDisplayId 物理显示器 ID
     * @param frame 帧号
     */
    @Override
    public void onVsync(long timestampNanos, long physicalDisplayId, int frame) {
        // 计算预期的 VSYNC 时间
        long now = System.nanoTime();
        if (timestampNanos > now) {
            // VSYNC 时间在未来，可能是时钟问题，使用当前时间
            timestampNanos = now;
        }
        
        if (mHavePendingVsync) {
            // 已经有待处理的 VSYNC，跳过
            Log.w(TAG, "Already have a pending vsync event. There should only be "
                    + "one at a time.");
        } else {
            mHavePendingVsync = true;
        }
        
        mTimestampNanos = timestampNanos;
        mFrame = frame;
        
        // 发送消息到主线程处理
        // 使用 setAsynchronous(true) 使消息不受同步屏障影响
        Message msg = Message.obtain(mHandler, this);
        msg.setAsynchronous(true);
        mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);
    }
    
    /**
     * 处理 VSYNC 信号（在主线程执行）
     */
    @Override
    public void run() {
        mHavePendingVsync = false;
        // 执行帧回调
        doFrame(mTimestampNanos, mFrame);
    }
}
```

### 3.3 doFrame 核心逻辑

```java
/**
 * 执行一帧的所有回调
 * @param frameTimeNanos 帧时间戳（纳秒）
 * @param frame 帧号
 */
void doFrame(long frameTimeNanos, int frame) {
    final long startNanos;
    synchronized (mLock) {
        if (!mFrameScheduled) {
            // 没有待处理的帧，直接返回
            return;
        }
        
        // 计算帧间隔
        long intendedFrameTimeNanos = frameTimeNanos;
        startNanos = System.nanoTime();
        
        // 计算跳过的帧数（用于检测卡顿）
        final long jitterNanos = startNanos - frameTimeNanos;
        if (jitterNanos >= mFrameIntervalNanos) {
            // 跳帧了！
            final long skippedFrames = jitterNanos / mFrameIntervalNanos;
            if (skippedFrames >= SKIPPED_FRAME_WARNING_LIMIT) {
                // 跳帧超过阈值，打印警告日志
                // "Skipped XX frames! The application may be doing too much work on its main thread."
                Log.i(TAG, "Skipped " + skippedFrames + " frames! "
                        + "The application may be doing too much work on its main thread.");
            }
            
            // 调整帧时间到最近的 VSYNC 边界
            final long lastFrameOffset = jitterNanos % mFrameIntervalNanos;
            frameTimeNanos = startNanos - lastFrameOffset;
        }
        
        if (frameTimeNanos < mLastFrameTimeNanos) {
            // 帧时间倒退，可能是时钟问题，请求下一个 VSYNC
            scheduleVsyncLocked();
            return;
        }
        
        // 记录帧信息
        mFrameInfo.setVsync(intendedFrameTimeNanos, frameTimeNanos);
        mFrameScheduled = false;
        mLastFrameTimeNanos = frameTimeNanos;
    }
    
    try {
        // 开始跟踪
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, "Choreographer#doFrame");
        
        // 设置帧时间（供动画使用）
        AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);
        
        // 记录帧开始时间
        mFrameInfo.markInputHandlingStart();
        // 1. 执行输入事件回调
        doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);
        
        // 记录动画开始时间
        mFrameInfo.markAnimationsStart();
        // 2. 执行动画回调
        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);
        
        // 3. 执行窗口插入动画回调
        doCallbacks(Choreographer.CALLBACK_INSETS_ANIMATION, frameTimeNanos);
        
        // 记录遍历开始时间
        mFrameInfo.markPerformTraversalsStart();
        // 4. 执行遍历回调（measure/layout/draw）
        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);
        
        // 5. 执行提交回调
        doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);
        
    } finally {
        AnimationUtils.unlockAnimationClock();
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    }
}

/**
 * 执行指定类型的所有回调
 */
void doCallbacks(int callbackType, long frameTimeNanos) {
    CallbackRecord callbacks;
    synchronized (mLock) {
        final long now = System.nanoTime();
        // 从队列中取出所有到期的回调
        callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked(
                now / TimeUtils.NANOS_PER_MS);
        if (callbacks == null) {
            return;
        }
        mCallbacksRunning = true;
    }
    
    try {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, CALLBACK_TRACE_TITLES[callbackType]);
        // 遍历执行所有回调
        for (CallbackRecord c = callbacks; c != null; c = c.next) {
            c.run(frameTimeNanos);
        }
    } finally {
        synchronized (mLock) {
            mCallbacksRunning = false;
            // 回收 CallbackRecord 对象
            do {
                final CallbackRecord next = callbacks.next;
                recycleCallbackLocked(callbacks);
                callbacks = next;
            } while (callbacks != null);
        }
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    }
}
```


### 3.4 ViewRootImpl 与 Choreographer 的交互

```java
/**
 * ViewRootImpl 源码分析
 * 源码位置: frameworks/base/core/java/android/view/ViewRootImpl.java
 * 
 * ViewRootImpl 是 View 层级的根，负责与 WindowManager 和 Choreographer 交互
 */
public final class ViewRootImpl implements ViewParent {
    
    // Choreographer 实例
    final Choreographer mChoreographer;
    
    // 遍历回调
    final TraversalRunnable mTraversalRunnable = new TraversalRunnable();
    
    // 是否已经请求了遍历
    boolean mTraversalScheduled;
    
    public ViewRootImpl(Context context, Display display) {
        // 获取主线程的 Choreographer
        mChoreographer = Choreographer.getInstance();
        // ...
    }
    
    /**
     * 请求布局（当 View 调用 requestLayout() 时）
     */
    @Override
    public void requestLayout() {
        if (!mHandlingLayoutInLayoutRequest) {
            checkThread(); // 检查是否在主线程
            mLayoutRequested = true;
            scheduleTraversals(); // 调度遍历
        }
    }
    
    /**
     * 调度遍历（measure/layout/draw）
     */
    void scheduleTraversals() {
        if (!mTraversalScheduled) {
            mTraversalScheduled = true;
            
            // 发送同步屏障，阻塞同步消息
            // 确保遍历回调优先执行
            mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();
            
            // 向 Choreographer 注册 TRAVERSAL 回调
            mChoreographer.postCallback(
                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);
            
            // 通知渲染线程
            notifyRendererOfFramePending();
            pokeDrawLockIfNeeded();
        }
    }
    
    /**
     * 取消遍历调度
     */
    void unscheduleTraversals() {
        if (mTraversalScheduled) {
            mTraversalScheduled = false;
            
            // 移除同步屏障
            mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);
            
            // 移除 Choreographer 回调
            mChoreographer.removeCallbacks(
                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);
        }
    }
    
    /**
     * 遍历回调
     */
    final class TraversalRunnable implements Runnable {
        @Override
        public void run() {
            doTraversal();
        }
    }
    
    /**
     * 执行遍历
     */
    void doTraversal() {
        if (mTraversalScheduled) {
            mTraversalScheduled = false;
            
            // 移除同步屏障
            mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);
            
            // 执行 measure/layout/draw
            performTraversals();
        }
    }
    
    /**
     * 执行 View 树的 measure/layout/draw
     * 这是 View 绑制的核心方法
     */
    private void performTraversals() {
        // 1. 预处理
        final View host = mView; // DecorView
        
        // 2. 测量阶段
        if (mFirst || windowShouldResize || ...) {
            // 执行测量
            performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);
        }
        
        // 3. 布局阶段
        final boolean didLayout = layoutRequested && ...;
        if (didLayout) {
            performLayout(lp, mWidth, mHeight);
        }
        
        // 4. 绘制阶段
        if (!cancelDraw) {
            // 执行绘制
            performDraw();
        }
    }
}
```

### 3.5 SurfaceView 核心源码

```java
/**
 * SurfaceView 源码分析
 * 源码位置: frameworks/base/core/java/android/view/SurfaceView.java
 */
public class SurfaceView extends View {
    
    // Surface 对象
    final Surface mSurface = new Surface();
    
    // SurfaceHolder 实现
    final SurfaceHolder mSurfaceHolder = new SurfaceHolder() {
        @Override
        public Surface getSurface() {
            return mSurface;
        }
        
        @Override
        public Canvas lockCanvas() {
            return internalLockCanvas(null, false);
        }
        
        @Override
        public Canvas lockCanvas(Rect inOutDirty) {
            return internalLockCanvas(inOutDirty, false);
        }
        
        @Override
        public Canvas lockHardwareCanvas() {
            return internalLockCanvas(null, true);
        }
        
        @Override
        public void unlockCanvasAndPost(Canvas canvas) {
            mSurface.unlockCanvasAndPost(canvas);
        }
    };
    
    // Surface 回调列表
    ArrayList<SurfaceHolder.Callback> mCallbacks = new ArrayList<>();
    
    /**
     * 锁定 Canvas 进行绘制
     */
    private Canvas internalLockCanvas(Rect dirty, boolean
 hardware) {
        if (mSurface.isValid()) {
            Canvas canvas;
            if (hardware) {
                // 硬件加速 Canvas
                canvas = mSurface.lockHardwareCanvas();
            } else {
                // 软件 Canvas
                canvas = mSurface.lockCanvas(dirty);
            }
            return canvas;
        }
        return null;
    }
    
    /**
     * 当 View 附加到窗口时
     */
    @Override
    protected void onAttachedToWindow() {
        super.onAttachedToWindow();
        
        // 请求创建 Surface
        getViewRootImpl().requestTransparentRegion(this);
        
        // 更新 Surface
        updateSurface();
    }
    
    /**
     * 更新 Surface
     */
    protected void updateSurface() {
        // ... 省略部分代码
        
        // 创建或更新 Surface
        if (creating) {
            // 通知回调 Surface 创建
            for (SurfaceHolder.Callback c : callbacks) {
                c.surfaceCreated(mSurfaceHolder);
            }
        }
        
        if (sizeChanged || creating || ...) {
            // 通知回调 Surface 大小改变
            for (SurfaceHolder.Callback c : callbacks) {
                c.surfaceChanged(mSurfaceHolder, format, myWidth, myHeight);
            }
        }
    }
    
    /**
     * 绘制方法 - SurfaceView 不参与 View 层级的绘制
     * 它的内容由独立的 Surface 绘制
     */
    @Override
    public void draw(Canvas canvas) {
        if (mDrawFinished && !isAboveParent()) {
            // 绘制背景（通常是透明的，形成"挖洞"效果）
            clearSurfaceViewPort(canvas);
        }
        super.draw(canvas);
    }
    
    /**
     * 清除 SurfaceView 区域（挖洞）
     */
    private void clearSurfaceViewPort(Canvas canvas) {
        // 将 SurfaceView 区域设置为透明
        // 这样下层的 Surface 内容就能显示出来
        canvas.drawColor(0, PorterDuff.Mode.CLEAR);
    }
}
```


### 3.6 TextureView 核心源码

```java
/**
 * TextureView 源码分析
 * 源码位置: frameworks/base/core/java/android/view/TextureView.java
 */
public class TextureView extends View {
    
    // SurfaceTexture 对象
    private SurfaceTexture mSurface;
    
    // Surface 监听器
    private SurfaceTextureListener mListener;
    
    // 用于绘制的 HardwareLayer
    private HardwareLayer mLayer;
    
    // 变换矩阵
    private final Matrix mMatrix = new Matrix();
    
    /**
     * 当 View 附加到窗口时
     */
    @Override
    protected void onAttachedToWindow() {
        super.onAttachedToWindow();
        
        // TextureView 必须开启硬件加速
        if (!isHardwareAccelerated()) {
            Log.w(LOG_TAG, "A TextureView or a subclass can only be "
                    + "used with hardware acceleration enabled.");
        }
    }
    
    /**
     * 获取 HardwareLayer（延迟创建）
     */
    HardwareLayer getHardwareLayer() {
        if (mLayer == null) {
            if (mAttachInfo == null || mAttachInfo.mThreadedRenderer == null) {
                return null;
            }
            
            // 创建 HardwareLayer
            mLayer = mAttachInfo.mThreadedRenderer.createTextureLayer();
            
            // 创建 SurfaceTexture
            if (!mUpdateSurface) {
                mSurface = new SurfaceTexture(false);
                nCreateNativeWindow(mSurface);
            }
            
            // 将 SurfaceTexture 关联到 Layer
            mLayer.setSurfaceTexture(mSurface);
            mSurface.setDefaultBufferSize(getWidth(), getHeight());
            mSurface.setOnFrameAvailableListener(mUpdateListener, mAttachInfo.mHandler);
            
            // 通知监听器 SurfaceTexture 可用
            if (mListener != null && !mUpdateSurface) {
                mListener.onSurfaceTextureAvailable(mSurface, getWidth(), getHeight());
            }
            
            mLayer.setLayerPaint(mLayerPaint);
        }
        
        // 更新纹理
        if (mUpdateSurface) {
            mUpdateSurface = false;
            updateLayer();
            mMatrixChanged = true;
        }
        
        // 应用变换矩阵
        applyTransformMatrix();
        
        return mLayer;
    }
    
    /**
     * 更新 Layer（当有新帧可用时）
     */
    private void updateLayer() {
        synchronized (mLock) {
            mUpdateLayer = false;
        }
        
        // 更新纹理
        mLayer.prepare(getWidth(), getHeight(), mOpaque);
        mLayer.updateSurfaceTexture();
        
        // 通知监听器
        if (mListener != null) {
            mListener.onSurfaceTextureUpdated(mSurface);
        }
    }
    
    /**
     * 绘制方法
     */
    @Override
    public final void draw(Canvas canvas) {
        // 强制使用 onDraw
        mPrivateFlags = (mPrivateFlags & ~PFLAG_SKIP_DRAW) | PFLAG_DRAWN;
        
        // 如果有 Layer，绘制 Layer
        if (canvas.isHardwareAccelerated()) {
            HardwareLayer layer = getHardwareLayer();
            if (layer != null) {
                applyUpdate();
                applyTransformMatrix();
            }
        }
    }
    
    /**
     * 帧可用监听器
     */
    private final SurfaceTexture.OnFrameAvailableListener mUpdateListener =
            new SurfaceTexture.OnFrameAvailableListener() {
        @Override
        public void onFrameAvailable(SurfaceTexture surfaceTexture) {
            // 标记需要更新
            synchronized (mLock) {
                mUpdateLayer = true;
            }
            // 请求重绘
            postInvalidate();
        }
    };
    
    /**
     * 获取 Bitmap（截图功能）
     */
    public Bitmap getBitmap() {
        return getBitmap(getWidth(), getHeight());
    }
    
    public Bitmap getBitmap(int width, int height) {
        if (isAvailable() && width > 0 && height > 0) {
            return getBitmap(Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888));
        }
        return null;
    }
    
    public Bitmap getBitmap(Bitmap bitmap) {
        if (bitmap != null && isAvailable()) {
            // 将 SurfaceTexture 内容绘制到 Bitmap
            applyTransformMatrix();
            
            // 锁定 Canvas 并绘制
            Canvas canvas = new Canvas(bitmap);
            mLayer.copyInto(bitmap);
        }
        return bitmap;
    }
}
```

## 4. 实战应用

### 4.1 使用 Choreographer 监控帧率

```kotlin
/**
 * 帧率监控工具
 * 通过 Choreographer 的 FrameCallback 监控每帧的耗时
 */
class FpsMonitor private constructor() {
    
    private val choreographer = Choreographer.getInstance()
    private var lastFrameTimeNanos = 0L
    private var frameCount = 0
    private var totalFrameTime = 0L
    
    // 帧率回调
    private val frameCallback = object : Choreographer.FrameCallback {
        override fun doFrame(frameTimeNanos: Long) {
            if (lastFrameTimeNanos != 0L) {
                // 计算帧间隔
                val frameInterval = frameTimeNanos - lastFrameTimeNanos
                val frameIntervalMs = frameInterval / 1_000_000f
                
                // 检测掉帧
                val droppedFrames = (frameInterval / FRAME_INTERVAL_NANOS).toInt() - 1
                if (droppedFrames > 0) {
                    Log.w(TAG, "Dropped $droppedFrames frames, frame time: ${frameIntervalMs}ms")
                }
                
                // 统计帧率
                frameCount++
                totalFrameTime += frameInterval
                
                if (frameCount >= SAMPLE_SIZE) {
                    val avgFrameTime = totalFrameTime / frameCount / 1_000_000f
                    val fps = 1000f / avgFrameTime
                    Log.i(TAG, "FPS: ${"%.1f".format(fps)}, avg frame time: ${"%.2f".format(avgFrameTime)}ms")
                    
                    // 重置统计
                    frameCount = 0
                    totalFrameTime = 0
                }
            }
            
            lastFrameTimeNanos = frameTimeNanos
            
            // 继续监控下一帧
            if (isMonitoring) {
                choreographer.postFrameCallback(this)
            }
        }
    }
    
    private var isMonitoring = false
    
    fun start() {
        if (!isMonitoring) {
            isMonitoring = true
            lastFrameTimeNanos = 0
            frameCount = 0
            totalFrameTime = 0
            choreographer.postFrameCallback(frameCallback)
        }
    }
    
    fun stop() {
        isMonitoring = false
        choreographer.removeFrameCallback(frameCallback)
    }
    
    companion object {
        private const val TAG = "FpsMonitor"
        
        // 60Hz 的帧间隔（纳秒）
        private const val FRAME_INTERVAL_NANOS = 16_666_666L
        
        // 采样大小
        private const val SAMPLE_SIZE = 60
        
        @Volatile
        private var instance: FpsMonitor? = null
        
        fun getInstance(): FpsMonitor {
            return instance ?: synchronized(this) {
                instance ?: FpsMonitor().also { instance = it }
            }
        }
    }
}

// 使用示例
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        // 开始监控帧率
        FpsMonitor.getInstance().start()
    }
    
    override fun onDestroy() {
        super.onDestroy()
        
        // 停止监控
        FpsMonitor.getInstance().stop()
    }
}
```


### 4.2 SurfaceView 实战：自定义绘制

```kotlin
/**
 * 自定义 SurfaceView 示例
 * 在独立线程中进行高频绘制
 */
class CustomSurfaceView @JvmOverloads constructor(
    context: Context,
    attrs: AttributeSet? = null,
    defStyleAttr: Int = 0
) : SurfaceView(context, attrs, defStyleAttr), SurfaceHolder.Callback, Runnable {
    
    private var drawThread: Thread? = null
    private var isRunning = false
    
    // 绘制相关
    private val paint = Paint(Paint.ANTI_ALIAS_FLAG).apply {
        color = Color.RED
        style = Paint.Style.FILL
    }
    
    private var circleX = 0f
    private var circleY = 0f
    private var velocityX = 10f
    private var velocityY = 10f
    private val circleRadius = 50f
    
    init {
        // 注册 Surface 回调
        holder.addCallback(this)
        
        // 设置透明背景（可选）
        // setZOrderOnTop(true)
        // holder.setFormat(PixelFormat.TRANSPARENT)
    }
    
    override fun surfaceCreated(holder: SurfaceHolder) {
        // Surface 创建，启动绘制线程
        isRunning = true
        drawThread = Thread(this).apply {
            name = "SurfaceView-DrawThread"
            start()
        }
    }
    
    override fun surfaceChanged(holder: SurfaceHolder, format: Int, width: Int, height: Int) {
        // Surface 大小改变，初始化位置
        circleX = width / 2f
        circleY = height / 2f
    }
    
    override fun surfaceDestroyed(holder: SurfaceHolder) {
        // Surface 销毁，停止绘制线程
        isRunning = false
        drawThread?.let {
            try {
                it.join(1000)
            } catch (e: InterruptedException) {
                e.printStackTrace()
            }
        }
        drawThread = null
    }
    
    override fun run() {
        while (isRunning) {
            val startTime = System.currentTimeMillis()
            
            // 更新状态
            updateState()
            
            // 绘制
            var canvas: Canvas? = null
            try {
                // 锁定 Canvas
                canvas = holder.lockCanvas()
                if (canvas != null) {
                    synchronized(holder) {
                        drawContent(canvas)
                    }
                }
            } catch (e: Exception) {
                e.printStackTrace()
            } finally {
                // 解锁并提交
                canvas?.let {
                    try {
                        holder.unlockCanvasAndPost(it)
                    } catch (e: Exception) {
                        e.printStackTrace()
                    }
                }
            }
            
            // 控制帧率（约 60fps）
            val frameTime = System.currentTimeMillis() - startTime
            val sleepTime = 16 - frameTime
            if (sleepTime > 0) {
                try {
                    Thread.sleep(sleepTime)
                } catch (e: InterruptedException) {
                    e.printStackTrace()
                }
            }
        }
    }
    
    private fun updateState() {
        // 更新圆的位置
        circleX += velocityX
        circleY += velocityY
        
        // 边界检测
        if (circleX - circleRadius < 0 || circleX + circleRadius > width) {
            velocityX = -velocityX
        }
        if (circleY - circleRadius < 0 || circleY + circleRadius > height) {
            velocityY = -velocityY
        }
    }
    
    private fun drawContent(canvas: Canvas) {
        // 清除背景
        canvas.drawColor(Color.WHITE)
        
        // 绘制圆
        canvas.drawCircle(circleX, circleY, circleRadius, paint)
    }
}
```

### 4.3 TextureView 实战：相机预览

```kotlin
/**
 * TextureView 相机预览示例
 */
class CameraPreviewActivity : AppCompatActivity(), TextureView.SurfaceTextureListener {
    
    private lateinit var textureView: TextureView
    private var cameraDevice: CameraDevice? = null
    private var captureSession: CameraCaptureSession? = null
    private var previewRequestBuilder: CaptureRequest.Builder? = null
    
    private val cameraManager by lazy {
        getSystemService(Context.CAMERA_SERVICE) as CameraManager
    }
    
    private val backgroundThread = HandlerThread("CameraBackground").apply { start() }
    private val backgroundHandler = Handler(backgroundThread.looper)
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        textureView = TextureView(this).apply {
            surfaceTextureListener = this@CameraPreviewActivity
        }
        setContentView(textureView)
    }
    
    override fun onSurfaceTextureAvailable(surface: SurfaceTexture, width: Int, height: Int) {
        // SurfaceTexture 可用，打开相机
        openCamera()
    }
    
    override fun onSurfaceTextureSizeChanged(surface: SurfaceTexture, width: Int, height: Int) {
        // 大小改变，可以在这里调整预览
    }
    
    override fun onSurfaceTextureDestroyed(surface: SurfaceTexture): Boolean {
        // 关闭相机
        closeCamera()
        return true
    }
    
    override fun onSurfaceTextureUpdated(surface: SurfaceTexture) {
        // 每帧更新时回调
    }
    
    @SuppressLint("MissingPermission")
    private fun openCamera() {
        try {
            val cameraId = cameraManager.cameraIdList[0]
            
            cameraManager.openCamera(cameraId, object : CameraDevice.StateCallback() {
                override fun onOpened(camera: CameraDevice) {
                    cameraDevice = camera
                    createPreviewSession()
                }
                
                override fun onDisconnected(camera: CameraDevice) {
                    camera.close()
                    cameraDevice = null
                }
                
                override fun onError(camera: CameraDevice, error: Int) {
                    camera.close()
                    cameraDevice = null
                }
            }, backgroundHandler)
        } catch (e: CameraAccessException) {
            e.printStackTrace()
        }
    }
    
    private fun createPreviewSession() {
        val surfaceTexture = textureView.surfaceTexture ?: return
        surfaceTexture.setDefaultBufferSize(textureView.width, textureView.height)
        
        val surface = Surface(surfaceTexture)
        
        try {
            previewRequestBuilder = cameraDevice?.createCaptureRequest(
                CameraDevice.TEMPLATE_PREVIEW
            )?.apply {
                addTarget(surface)
            }
            
            cameraDevice?.createCaptureSession(
                listOf(surface),
                object : CameraCaptureSession.StateCallback() {
                    override fun onConfigured(session: CameraCaptureSession) {
                        captureSession = session
                        previewRequestBuilder?.let {
                            session.setRepeatingRequest(
                                it.build(),
                                null,
                                backgroundHandler
                            )
                        }
                    }
                    
                    override fun onConfigureFailed(session: CameraCaptureSession) {
                        Log.e(TAG, "Camera session configuration failed")
                    }
                },
                backgroundHandler
            )
        } catch (e: CameraAccessException) {
            e.printStackTrace()
        }
    }
    
    private fun closeCamera() {
        captureSession?.close()
        captureSession = null
        cameraDevice?.close()
        cameraDevice = null
    }
    
    override fun onDestroy() {
        super.onDestroy()
        closeCamera()
        backgroundThread.quitSafely()
    }
    
    companion object {
        private const val TAG = "CameraPreview"
    }
}
```


### 4.4 渲染优化最佳实践

```kotlin
/**
 * 渲染优化最佳实践
 */

// 1. 避免在 onDraw 中创建对象
class OptimizedView(context: Context) : View(context) {
    
    // ✅ 正确：在构造函数中创建
    private val paint = Paint(Paint.ANTI_ALIAS_FLAG)
    private val rect = RectF()
    private val path = Path()
    
    override fun onDraw(canvas: Canvas) {
        // ❌ 错误：在 onDraw 中创建对象
        // val paint = Paint()
        // val rect = RectF(0f, 0f, width.toFloat(), height.toFloat())
        
        // ✅ 正确：复用对象
        rect.set(0f, 0f, width.toFloat(), height.toFloat())
        canvas.drawRect(rect, paint)
    }
}

// 2. 使用 invalidate(Rect) 局部刷新
class PartialInvalidateView(context: Context) : View(context) {
    
    private val dirtyRect = Rect()
    
    fun updateRegion(left: Int, top: Int, right: Int, bottom: Int) {
        dirtyRect.set(left, top, right, bottom)
        // ✅ 只刷新脏区域
        invalidate(dirtyRect)
    }
}

// 3. 使用硬件加速 Layer 缓存复杂绘制
class LayerCacheView(context: Context) : View(context) {
    
    init {
        // 开启硬件 Layer 缓存
        // 适用于内容不经常变化但需要频繁动画的 View
        setLayerType(LAYER_TYPE_HARDWARE, null)
    }
    
    override fun onDraw(canvas: Canvas) {
        // 复杂的绘制操作会被缓存到 GPU 纹理
        // 动画时只需要移动纹理，不需要重新绘制
    }
    
    // 当内容需要更新时
    fun updateContent() {
        // 清除 Layer 缓存，触发重绘
        setLayerType(LAYER_TYPE_NONE, null)
        setLayerType(LAYER_TYPE_HARDWARE, null)
        invalidate()
    }
}

// 4. 使用 RenderNode 进行高效绘制（API 29+）
@RequiresApi(Build.VERSION_CODES.Q)
class RenderNodeView(context: Context) : View(context) {
    
    private val renderNode = RenderNode("CustomNode").apply {
        setPosition(0, 0, 200, 200)
    }
    
    private fun updateRenderNode() {
        // 获取 RecordingCanvas 记录绘制命令
        val canvas = renderNode.beginRecording()
        try {
            // 绑制内容
            canvas.drawColor(Color.RED)
            canvas.drawCircle(100f, 100f, 50f, Paint())
        } finally {
            renderNode.endRecording()
        }
    }
    
    override fun onDraw(canvas: Canvas) {
        if (canvas.isHardwareAccelerated) {
            // 绘制 RenderNode
            canvas.drawRenderNode(renderNode)
        }
    }
}

// 5. 避免过度绘制
class OverdrawOptimizedView(context: Context) : View(context) {
    
    init {
        // 如果 View 完全不透明，设置背景可以避免绘制父 View 的背景
        setBackgroundColor(Color.WHITE)
    }
    
    override fun onDraw(canvas: Canvas) {
        // ❌ 错误：先绘制背景再绘制内容（过度绘制）
        // canvas.drawColor(Color.WHITE)
        // canvas.drawRect(...)
        
        // ✅ 正确：只绘制必要的内容
        // 背景已经通过 setBackgroundColor 设置
        canvas.drawRect(0f, 0f, 100f, 100f, Paint())
    }
}

// 6. 使用 clipRect 减少绘制区域
class ClipOptimizedView(context: Context) : View(context) {
    
    override fun onDraw(canvas: Canvas) {
        // 只绘制可见区域
        val clipBounds = canvas.clipBounds
        
        // 根据 clipBounds 判断哪些内容需要绘制
        // 跳过不在可见区域内的绘制操作
    }
}
```

### 4.5 常见坑点与解决方案

```
┌─────────────────────────────────────────────────────────────────────┐
│                    渲染常见坑点与解决方案                           │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  1. 主线程耗时操作导致掉帧                                          │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │  问题：在主线程执行耗时操作（IO、计算等）                    │   │
│  │  现象：界面卡顿、掉帧                                        │   │
│  │  解决：将耗时操作移到子线程，使用协程或线程池                │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  2. 布局层级过深                                                    │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │  问题：View 层级过深导致 measure/layout 耗时                 │   │
│  │  现象：界面渲染慢、滑动卡顿                                  │   │
│  │  解决：使用 ConstraintLayout 减少层级，使用 merge 标签       │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  3. 过度绘制                                                        │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │  问题：同一像素被多次绘制                                    │   │
│  │  现象：GPU 负载高、耗电                                      │   │
│  │  解决：移除不必要的背景，使用 clipRect 减少绘制区域          │   │
│  │  检测：开发者选项 → 调试 GPU 过度绘制                        │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  4. 频繁 requestLayout                                              │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │  问题：频繁调用 requestLayout 导致重复测量布局               │   │
│  │  现象：界面卡顿                                              │   │
│  │  解决：合并多次布局请求，使用 post 延迟执行                  │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  5. SurfaceView 与 View 动画不同步                                  │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │  问题：SurfaceView 不支持 View 动画                          │   │
│  │  现象：动画时 SurfaceView 位置不正确                         │   │
│  │  解决：使用 TextureView 或自行处理动画                       │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  6. TextureView 内存占用高                                          │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │  问题：TextureView 需要额外的 GPU 纹理内存                   │   │
│  │  现象：内存占用高、低端设备卡顿                              │   │
│  │  解决：优先使用 SurfaceView，或限制 TextureView 数量         │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```


## 5. 常见面试题

### 问题1：请详细描述 Android 的屏幕刷新机制和 VSYNC 信号的作用？

**答案要点**：

1. **屏幕刷新机制**：
   - 屏幕以固定频率刷新（60Hz/90Hz/120Hz）
   - 每次刷新从 FrameBuffer 读取数据显示
   - 刷新率决定了每帧的时间预算（60Hz = 16.67ms/帧）

2. **VSYNC 信号**：
   - 垂直同步信号，由硬件产生
   - 作用：协调渲染和显示的时机，避免画面撕裂
   - Android 4.1 引入 Project Butter，全面使用 VSYNC

3. **VSYNC 的分发**：
   - HWC 产生 VSYNC → SurfaceFlinger 接收
   - 分发 VSYNC-app（应用渲染）和 VSYNC-sf（合成）
   - Choreographer 接收 VSYNC-app，触发帧回调

4. **一帧的流程**：
   - VSYNC 到来 → Input 处理 → Animation → Traversal（measure/layout/draw）
   - RenderThread 执行 DisplayList → GPU 渲染 → SurfaceFlinger 合成 → 显示

---

### 问题2：Choreographer 的工作原理是什么？它是如何协调渲染的？（OPPO/vivo 重点）

**答案要点**：

1. **Choreographer 的作用**：
   - 编舞者，协调输入、动画、绘制的执行时机
   - 接收 VSYNC 信号，按顺序执行各类回调
   - 每个线程有自己的 Choreographer（ThreadLocal）

2. **回调类型（按优先级）**：
   ```
   CALLBACK_INPUT (0)      → 输入事件
   CALLBACK_ANIMATION (1)  → 动画
   CALLBACK_INSETS_ANIMATION (2) → 窗口插入动画
   CALLBACK_TRAVERSAL (3)  → View 遍历
   CALLBACK_COMMIT (4)     → 提交
   ```

3. **工作流程**：
   ```
   postCallback() → scheduleFrameLocked() → scheduleVsync()
   → onVsync() → doFrame() → doCallbacks()
   ```

4. **关键源码**：
   - `FrameDisplayEventReceiver.onVsync()`：接收 VSYNC
   - `doFrame()`：执行所有回调
   - `doCallbacks()`：按类型执行回调队列

5. **与 ViewRootImpl 的交互**：
   - `scheduleTraversals()` 注册 TRAVERSAL 回调
   - 使用同步屏障确保优先执行

---

### 问题3：双缓冲和三缓冲的区别是什么？Android 使用的是哪种？

**答案要点**：

1. **双缓冲**：
   - Back Buffer（渲染中）+ Front Buffer（显示中）
   - VSYNC 时交换两个 Buffer
   - 问题：如果渲染超时，会导致重复显示上一帧（Jank）

2. **三缓冲**：
   - 增加一个 Buffer，CPU/GPU 可以继续工作
   - 优势：减少后续帧的延迟，提高流畅度
   - 代价：增加一帧延迟（约 16ms），增加内存占用

3. **Android 的选择**：
   - 默认使用三缓冲
   - BufferQueue 管理多个 Buffer
   - 可以动态调整 Buffer 数量

4. **Buffer 状态**：
   ```
   FREE → DEQUEUED（生产者获取）→ QUEUED（生产者提交）
   → ACQUIRED（消费者获取）→ FREE
   ```

---

### 问题4：RenderThread 是什么？硬件加速的原理是什么？（字节/快手重点）

**答案要点**：

1. **RenderThread**：
   - Android 5.0 引入的渲染线程
   - 负责执行 DisplayList，进行 GPU 渲染
   - 与主线程并行工作，减轻主线程负担

2. **软件渲染 vs 硬件加速**：
   ```
   软件渲染：UI Thread 直接绑制到 Bitmap（CPU）
   硬件加速：UI Thread 构建 DisplayList → RenderThread 执行（GPU）
   ```

3. **DisplayList（RenderNode）**：
   - 记录绘制命令的列表
   - 可以缓存和复用，支持局部更新
   - 在 RenderThread 异步执行

4. **硬件加速的优势**：
   - 主线程只需构建 DisplayList，不阻塞
   - GPU 并行处理，效率高
   - 支持更多特效（阴影、圆角等）

5. **硬件加速的限制**：
   - 部分 Canvas 操作不支持（drawBitmapMesh 等）
   - 需要检查 `canvas.isHardwareAccelerated()`

---

### 问题5：SurfaceView 和 TextureView 的区别？如何选择？（美团/快手重点）

**答案要点**：

1. **SurfaceView**：
   - 拥有独立的 Surface，在 Window Surface 之下
   - 可以在独立线程绘制，不阻塞主线程
   - 不支持 View 动画和变换
   - 性能好，功耗低

2. **TextureView**：
   - 使用 SurfaceTexture，作为 View 层级的一部分
   - 支持 View 动画、变换、透明度
   - 必须开启硬件加速
   - 内存占用高，功耗高

3. **选择建议**：
   ```
   SurfaceView：视频播放、游戏、相机预览（不需要动画）
   TextureView：需要动画效果、在 RecyclerView 中使用、需要截图
   ```

4. **Android 7.0+ 改进**：
   - SurfaceView 同步机制改进
   - 官方推荐优先使用 SurfaceView

5. **Z-Order**：
   - SurfaceView 默认在 Window 之下（挖洞效果）
   - `setZOrderOnTop(true)` 可以置于 Window 之上

---

### 问题6：如何检测和解决卡顿问题？（字节/美团重点）

**答案要点**：

1. **卡顿检测方法**：
   - Choreographer.FrameCallback 监控帧率
   - Looper.setMessageLogging() 监控消息处理时间
   - BlockCanary 等开源工具
   - Perfetto/Systrace 分析

2. **Choreographer 掉帧检测**：
   ```kotlin
   choreographer.postFrameCallback { frameTimeNanos ->
       val jitter = System.nanoTime() - frameTimeNanos
       val droppedFrames = jitter / 16_666_666
       if (droppedFrames > 0) {
           Log.w(TAG, "Dropped $droppedFrames frames")
       }
   }
   ```

3. **常见卡顿原因**：
   - 主线程耗时操作（IO、计算）
   - 布局层级过深
   - 过度绘制
   - 频繁 GC
   - 锁竞争

4. **优化方案**：
   - 耗时操作移到子线程
   - 使用 ConstraintLayout 减少层级
   - 避免在 onDraw 中创建对象
   - 使用 RecyclerView 复用
   - 使用 Baseline Profile 优化启动

---

### 问题7：请解释 invalidate() 和 requestLayout() 的区别？

**答案要点**：

1. **invalidate()**：
   - 请求重绘，只触发 draw 流程
   - 不会触发 measure 和 layout
   - 适用于内容变化但大小位置不变的情况

2. **requestLayout()**：
   - 请求重新布局，触发 measure → layout → draw
   - 会向上传递到 ViewRootImpl
   - 适用于大小或位置需要改变的情况

3. **执行流程**：
   ```
   invalidate() → 标记 PFLAG_DIRTY → scheduleTraversals() → performDraw()
   
   requestLayout() → 标记 PFLAG_FORCE_LAYOUT → scheduleTraversals()
   → performMeasure() → performLayout() → performDraw()
   ```

4. **优化建议**：
   - 只需重绘时使用 invalidate()
   - 使用 invalidate(Rect) 局部刷新
   - 避免频繁调用 requestLayout()

---

### 问题8：同步屏障（Sync Barrier）在渲染中的作用是什么？（OPPO/vivo 重点）

**答案要点**：

1. **同步屏障的作用**：
   - 阻塞同步消息，让异步消息优先执行
   - 确保渲染相关的消息优先处理
   - 避免其他消息影响渲染时机

2. **在渲染中的应用**：
   ```java
   // ViewRootImpl.scheduleTraversals()
   mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();
   mChoreographer.postCallback(CALLBACK_TRAVERSAL, mTraversalRunnable, null);
   
   // ViewRootImpl.doTraversal()
   mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);
   ```

3. **工作原理**：
   - postSyncBarrier() 插入一个 target 为 null 的 Message
   - MessageQueue.next() 遇到屏障时，只返回异步消息
   - Choreographer 的回调消息设置了 setAsynchronous(true)

4. **注意事项**：
   - 必须成对使用 post 和 remove
   - 忘记移除会导致主线程卡死
   - 只有系统可以使用（@hide API）

---

### 问题9：如何实现一个高性能的自定义 View？

**答案要点**：

1. **避免在 onDraw 中创建对象**：
   ```kotlin
   // 在构造函数中创建
   private val paint = Paint()
   private val rect = RectF()
   ```

2. **使用硬件加速**：
   ```kotlin
   setLayerType(LAYER_TYPE_HARDWARE, null)
   ```

3. **局部刷新**：
   ```kotlin
   invalidate(dirtyRect)
   ```

4. **使用 clipRect 减少绘制**：
   ```kotlin
   canvas.clipRect(visibleRect)
   ```

5. **避免过度绘制**：
   - 移除不必要的背景
   - 使用 `canvas.quickReject()` 跳过不可见区域

6. **复用 Bitmap**：
   ```kotlin
   BitmapFactory.Options().apply {
       inBitmap = reusableBitmap
   }
   ```

7. **使用 RenderNode（API 29+）**：
   ```kotlin
   val renderNode = RenderNode("CustomNode")
   canvas.drawRenderNode(renderNode)
   ```

---

### 问题10：Android 高刷新率（90Hz/120Hz）对渲染有什么影响？

**答案要点**：

1. **帧时间预算减少**：
   ```
   60Hz: 16.67ms/帧
   90Hz: 11.11ms/帧
   120Hz: 8.33ms/帧
   ```

2. **对应用的影响**：
   - 更容易掉帧，对性能要求更高
   - 动画更流畅，但也更耗电
   - 需要更精细的性能优化

3. **适配建议**：
   - 使用 Choreographer 而不是固定延迟
   - 避免假设固定的帧率
   - 使用 `Display.getRefreshRate()` 获取实际刷新率

4. **动态刷新率**：
   - Android 11+ 支持动态刷新率
   - 可以根据内容类型调整刷新率
   - 静态内容降低刷新率省电

5. **代码适配**：
   ```kotlin
   val refreshRate = windowManager.defaultDisplay.refreshRate
   val frameIntervalMs = 1000f / refreshRate
   ```
