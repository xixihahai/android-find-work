# Android 内存泄漏

## 1. 概述

内存泄漏（Memory Leak）是指程序中已动态分配的堆内存由于某种原因未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。在 Android 开发中，内存泄漏是导致 OOM（Out Of Memory）的主要原因之一，也是各大厂面试的高频考点。

### 1.1 内存泄漏的本质

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        内存泄漏的本质                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  定义:                                                                  │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  当一个对象已经不再被使用，但仍然被其他对象持有引用，           │   │
│  │  导致 GC 无法回收该对象，这就是内存泄漏。                       │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  GC Root 引用链:                                                        │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │   GC Root ──→ 长生命周期对象 ──→ 短生命周期对象                 │   │
│  │      │              │                    │                      │   │
│  │   (静态变量)    (单例/Handler)      (Activity/Fragment)         │   │
│  │                                          │                      │   │
│  │                                     无法被回收!                 │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  GC Root 类型:                                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  • 虚拟机栈中引用的对象 (局部变量)                              │   │
│  │  • 方法区中类静态属性引用的对象 (static 变量)                   │   │
│  │  • 方法区中常量引用的对象 (final static)                        │   │
│  │  • 本地方法栈中 JNI 引用的对象 (Native 代码)                    │   │
│  │  • 活动线程 (Thread)                                            │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 1.2 内存泄漏的危害

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        内存泄漏的危害                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  直接危害:                                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  • 可用内存减少 → 频繁 GC → 应用卡顿                            │   │
│  │  • 内存持续增长 → 达到上限 → OOM 崩溃                           │   │
│  │  • 系统内存紧张 → LMK 杀进程 → 应用被杀                         │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  间接危害:                                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  • 用户体验下降 → 用户流失                                      │   │
│  │  • 应用评分降低 → 商店排名下降                                  │   │
│  │  • 功耗增加 → 电池消耗加快                                      │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  泄漏严重程度:                                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  Activity 泄漏 > Fragment 泄漏 > View 泄漏 > 普通对象泄漏       │   │
│  │       │                                                         │   │
│  │  Activity 持有大量资源 (View 树、Bitmap、Context 等)            │   │
│  │  一个 Activity 泄漏可能导致数 MB 内存无法释放                   │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 1.3 常见泄漏场景总览

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      常见内存泄漏场景                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌────────────────────┬────────────────────┬────────────────────────┐  │
│  │      泄漏类型      │      泄漏原因      │        解决方案        │  │
│  ├────────────────────┼────────────────────┼────────────────────────┤  │
│  │ Handler 泄漏       │ 非静态内部类持有   │ 静态内部类+弱引用      │  │
│  │                    │ 外部类引用         │                        │  │
│  ├────────────────────┼────────────────────┼────────────────────────┤  │
│  │ 静态变量泄漏       │ 静态变量持有       │ 使用 Application       │  │
│  │                    │ Activity 引用      │ Context                │  │
│  ├────────────────────┼────────────────────┼────────────────────────┤  │
│  │ 内部类/匿名类泄漏  │ 隐式持有外部类     │ 静态内部类或独立类     │  │
│  │                    │ 引用               │                        │  │
│  ├────────────────────┼────────────────────┼────────────────────────┤  │
│  │ 监听器未注销       │ 注册后未注销       │ 配对注册/注销          │  │
│  ├────────────────────┼────────────────────┼────────────────────────┤  │
│  │ 资源未关闭         │ Cursor/Stream      │ try-with-resources     │  │
│  │                    │ 未关闭             │                        │  │
│  ├────────────────────┼────────────────────┼────────────────────────┤  │
│  │ WebView 泄漏       │ WebView 持有       │ 独立进程/手动销毁      │  │
│  │                    │ Activity 引用      │                        │  │
│  ├────────────────────┼────────────────────┼────────────────────────┤  │
│  │ 单例持有 Context   │ 单例生命周期长     │ 使用 Application       │  │
│  │                    │                    │ Context                │  │
│  ├────────────────────┼────────────────────┼────────────────────────┤  │
│  │ 集合类泄漏         │ 只添加不移除       │ 及时清理集合           │  │
│  ├────────────────────┼────────────────────┼────────────────────────┤  │
│  │ 线程泄漏           │ 线程持有外部引用   │ 静态内部类+弱引用      │  │
│  └────────────────────┴────────────────────┴────────────────────────┘  │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```


## 2. 核心原理

### 2.1 Java 引用类型与内存泄漏

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      Java 四种引用类型                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌────────────┬──────────────┬──────────────┬──────────────────────┐   │
│  │  引用类型  │   回收时机   │   使用场景   │      内存泄漏关系    │   │
│  ├────────────┼──────────────┼──────────────┼──────────────────────┤   │
│  │ 强引用     │ 永不回收     │ 普通对象引用 │ 泄漏的根本原因       │   │
│  │ Strong     │ (除非置null) │              │                      │   │
│  ├────────────┼──────────────┼──────────────┼──────────────────────┤   │
│  │ 软引用     │ 内存不足时   │ 内存敏感缓存 │ 可用于解决泄漏       │   │
│  │ Soft       │              │              │                      │   │
│  ├────────────┼──────────────┼──────────────┼──────────────────────┤   │
│  │ 弱引用     │ GC 时        │ 解决内存泄漏 │ 常用解决方案         │   │
│  │ Weak       │              │              │                      │   │
│  ├────────────┼──────────────┼──────────────┼──────────────────────┤   │
│  │ 虚引用     │ 任何时候     │ 跟踪对象回收 │ 用于监控             │   │
│  │ Phantom    │              │              │                      │   │
│  └────────────┴──────────────┴──────────────┴──────────────────────┘   │
│                                                                         │
│  引用强度: 强引用 > 软引用 > 弱引用 > 虚引用                            │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.2 Android 组件生命周期与泄漏

```
┌─────────────────────────────────────────────────────────────────────────┐
│                   组件生命周期与泄漏关系                                 │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  Activity 生命周期:                                                     │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  onCreate ──→ onStart ──→ onResume ──→ [运行中]                │   │
│  │                                              │                  │   │
│  │                                              ↓                  │   │
│  │  onDestroy ←── onStop ←── onPause ←─────────┘                  │   │
│  │      │                                                          │   │
│  │      ↓                                                          │   │
│  │  [应该被回收] ←── 如果仍被引用 ←── 内存泄漏!                   │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  泄漏发生时机:                                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  Activity.onDestroy() 被调用后:                                 │   │
│  │                                                                 │   │
│  │  正常情况:                                                      │   │
│  │  Activity 对象 ──→ 无引用 ──→ GC 回收 ──→ 内存释放             │   │
│  │                                                                 │   │
│  │  泄漏情况:                                                      │   │
│  │  Activity 对象 ──→ 被其他对象引用 ──→ GC 无法回收 ──→ 泄漏     │   │
│  │                         │                                       │   │
│  │                    (Handler/Thread/                             │   │
│  │                     Listener/静态变量)                          │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.3 内存泄漏检测原理

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      内存泄漏检测原理                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  基于弱引用的检测原理 (LeakCanary 核心思想):                            │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  1. 监听 Activity/Fragment 销毁                                 │   │
│  │     │                                                           │   │
│  │     ↓                                                           │   │
│  │  2. 创建弱引用 WeakReference 指向被销毁对象                     │   │
│  │     │                                                           │   │
│  │     ↓                                                           │   │
│  │  3. 触发 GC                                                     │   │
│  │     │                                                           │   │
│  │     ↓                                                           │   │
│  │  4. 检查弱引用是否被清除                                        │   │
│  │     │                                                           │   │
│  │     ├──→ 已清除: 对象已被回收，无泄漏                          │   │
│  │     │                                                           │   │
│  │     └──→ 未清除: 对象仍存活，可能泄漏                          │   │
│  │              │                                                  │   │
│  │              ↓                                                  │   │
│  │           5. dump heap，分析引用链                              │   │
│  │              │                                                  │   │
│  │              ↓                                                  │   │
│  │           6. 找到 GC Root 到泄漏对象的最短路径                  │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```


## 3. 关键源码解析

### 3.1 Handler 泄漏原理与源码分析

```java
/**
 * Handler 内存泄漏示例
 * 这是最常见的内存泄漏场景之一
 */
public class LeakyActivity extends Activity {
    
    // ❌ 错误写法: 非静态内部类 Handler
    // 非静态内部类会隐式持有外部类 (Activity) 的引用
    private Handler mHandler = new Handler() {
        @Override
        public void handleMessage(Message msg) {
            // 处理消息
            // 这里可以访问外部类的成员，说明持有外部类引用
            updateUI();
        }
    };
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        
        // 发送延迟消息
        // 如果 Activity 在消息处理前被销毁，就会发生泄漏
        mHandler.postDelayed(new Runnable() {
            @Override
            public void run() {
                // 这个 Runnable 也是匿名内部类，也持有 Activity 引用
                doSomething();
            }
        }, 60000); // 60秒后执行
    }
    
    private void updateUI() { /* ... */ }
    private void doSomething() { /* ... */ }
}
```

**Handler 泄漏的引用链分析:**

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    Handler 泄漏引用链                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  GC Root (主线程)                                                       │
│       │                                                                 │
│       ↓                                                                 │
│  Looper.sMainLooper (静态变量)                                          │
│       │                                                                 │
│       ↓                                                                 │
│  MessageQueue.mMessages (消息队列)                                      │
│       │                                                                 │
│       ↓                                                                 │
│  Message.target (Handler 引用)                                          │
│       │                                                                 │
│       ↓                                                                 │
│  Handler (非静态内部类)                                                 │
│       │                                                                 │
│       ↓ (隐式引用 this$0)                                               │
│  Activity (被泄漏的对象)                                                │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

**Handler 源码分析 - 为什么会持有引用:**

```java
/**
 * Handler 构造函数源码分析
 * 源码位置: frameworks/base/core/java/android/os/Handler.java
 */
public class Handler {
    
    // Message 中的 target 字段指向 Handler
    // 这是泄漏链的关键一环
    
    public Handler() {
        this(null, false);
    }
    
    public Handler(@Nullable Callback callback, boolean async) {
        // 检测潜在的内存泄漏
        // 如果 Handler 是匿名类或非静态内部类，会打印警告
        if (FIND_POTENTIAL_LEAKS) {
            final Class<? extends Handler> klass = getClass();
            // 检查是否是匿名类、成员类(非静态内部类)、局部类
            if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &&
                    (klass.getModifiers() & Modifier.STATIC) == 0) {
                Log.w(TAG, "The following Handler class should be static or leaks might occur: " +
                    klass.getCanonicalName());
            }
        }
        
        // 获取当前线程的 Looper
        mLooper = Looper.myLooper();
        if (mLooper == null) {
            throw new RuntimeException(
                "Can't create handler inside thread " + Thread.currentThread()
                        + " that has not called Looper.prepare()");
        }
        mQueue = mLooper.mQueue;
        mCallback = callback;
        mAsynchronous = async;
    }
    
    /**
     * 发送消息时，Message.target 会被设置为当前 Handler
     */
    private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg,
            long uptimeMillis) {
        // 关键: Message 持有 Handler 引用
        msg.target = this;
        msg.workSourceUid = ThreadLocalWorkSource.getUid();
        
        if (mAsynchronous) {
            msg.setAsynchronous(true);
        }
        return queue.enqueueMessage(msg, uptimeMillis);
    }
}

/**
 * Message 源码分析
 * 源码位置: frameworks/base/core/java/android/os/Message.java
 */
public final class Message implements Parcelable {
    
    // target 字段持有 Handler 引用
    // 当 Message 在队列中等待处理时，会阻止 Handler 被回收
    // 进而阻止 Handler 持有的 Activity 被回收
    @UnsupportedAppUsage
    /*package*/ Handler target;
    
    // callback 字段持有 Runnable 引用
    // 如果 Runnable 是匿名内部类，也会持有外部类引用
    @UnsupportedAppUsage
    /*package*/ Runnable callback;
    
    // what、arg1、arg2、obj 等字段...
}
```

**正确的 Handler 写法:**

```java
/**
 * 正确写法: 静态内部类 + 弱引用
 */
public class SafeActivity extends Activity {
    
    // 使用静态内部类，不会隐式持有外部类引用
    private static class SafeHandler extends Handler {
        // 使用弱引用持有 Activity
        private final WeakReference<SafeActivity> mActivityRef;
        
        SafeHandler(SafeActivity activity) {
            mActivityRef = new WeakReference<>(activity);
        }
        
        @Override
        public void handleMessage(Message msg) {
            // 获取 Activity，可能为 null
            SafeActivity activity = mActivityRef.get();
            if (activity == null || activity.isFinishing() || activity.isDestroyed()) {
                // Activity 已销毁，不处理消息
                return;
            }
            
            // 安全地处理消息
            switch (msg.what) {
                case MSG_UPDATE_UI:
                    activity.updateUI();
                    break;
            }
        }
    }
    
    private static final int MSG_UPDATE_UI = 1;
    private SafeHandler mHandler;
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        mHandler = new SafeHandler(this);
        
        // 发送延迟消息
        mHandler.sendEmptyMessageDelayed(MSG_UPDATE_UI, 60000);
    }
    
    @Override
    protected void onDestroy() {
        super.onDestroy();
        // 移除所有消息和回调，防止泄漏
        mHandler.removeCallbacksAndMessages(null);
    }
    
    private void updateUI() { /* ... */ }
}
```


### 3.2 静态变量泄漏原理与源码分析

```java
/**
 * 静态变量泄漏示例
 * 静态变量的生命周期与应用进程相同
 */
public class StaticLeakExample {
    
    // ❌ 错误写法1: 静态变量直接持有 Activity
    private static Activity sActivity;
    
    // ❌ 错误写法2: 静态变量持有 View (View 持有 Context)
    private static View sView;
    
    // ❌ 错误写法3: 单例持有 Activity Context
    private static class Singleton {
        private static Singleton sInstance;
        private Context mContext;
        
        private Singleton(Context context) {
            // 错误: 直接保存传入的 Context
            // 如果传入的是 Activity，就会导致泄漏
            mContext = context;
        }
        
        public static Singleton getInstance(Context context) {
            if (sInstance == null) {
                sInstance = new Singleton(context);
            }
            return sInstance;
        }
    }
    
    public void leakActivity(Activity activity) {
        // 这会导致 Activity 无法被回收
        sActivity = activity;
        sView = activity.findViewById(R.id.some_view);
        Singleton.getInstance(activity);
    }
}
```

**静态变量泄漏的引用链:**

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    静态变量泄漏引用链                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  GC Root (Class 对象)                                                   │
│       │                                                                 │
│       ↓                                                                 │
│  StaticLeakExample.class (类对象，存在于方法区)                         │
│       │                                                                 │
│       ↓                                                                 │
│  sActivity / sView / sInstance (静态字段)                               │
│       │                                                                 │
│       ↓                                                                 │
│  Activity (被泄漏的对象)                                                │
│       │                                                                 │
│       ↓                                                                 │
│  View 树、Bitmap、各种资源... (大量内存)                                │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

**正确的单例写法:**

```java
/**
 * 正确写法: 使用 Application Context
 */
public class SafeSingleton {
    private static volatile SafeSingleton sInstance;
    private Context mContext;
    
    private SafeSingleton(Context context) {
        // 正确: 使用 Application Context
        // Application 的生命周期与进程相同，不会导致泄漏
        mContext = context.getApplicationContext();
    }
    
    public static SafeSingleton getInstance(Context context) {
        if (sInstance == null) {
            synchronized (SafeSingleton.class) {
                if (sInstance == null) {
                    sInstance = new SafeSingleton(context);
                }
            }
        }
        return sInstance;
    }
    
    public Context getContext() {
        return mContext;
    }
}

/**
 * Context 类型选择指南
 */
public class ContextGuide {
    
    /*
     * 使用 Application Context 的场景:
     * - 单例模式
     * - 静态工具类
     * - 后台服务
     * - 数据库操作
     * - SharedPreferences
     * - 网络请求
     * 
     * 必须使用 Activity Context 的场景:
     * - 启动 Activity (需要 Task 栈)
     * - 显示 Dialog
     * - 布局 inflate (需要 Theme)
     * - 获取系统服务 (部分需要)
     */
    
    public void demonstrateContextUsage(Activity activity) {
        // ✅ 正确: 单例使用 Application Context
        SafeSingleton.getInstance(activity.getApplicationContext());
        
        // ✅ 正确: 显示 Dialog 使用 Activity Context
        new AlertDialog.Builder(activity)
                .setTitle("Title")
                .show();
        
        // ✅ 正确: 布局 inflate 使用 Activity Context (获取正确的 Theme)
        LayoutInflater.from(activity).inflate(R.layout.some_layout, null);
    }
}
```

### 3.3 内部类/匿名类泄漏原理

```java
/**
 * 内部类泄漏原理分析
 * 非静态内部类会持有外部类的引用
 */
public class InnerClassLeakExample extends Activity {
    
    // ❌ 错误写法1: 非静态内部类
    private class InnerClass {
        // 编译器会自动添加: final InnerClassLeakExample this$0;
        // 这个隐式引用指向外部类实例
        
        public void doSomething() {
            // 可以直接访问外部类成员，说明持有外部类引用
            someMethod();
        }
    }
    
    // ❌ 错误写法2: 匿名内部类
    private Runnable mRunnable = new Runnable() {
        // 同样会持有外部类引用
        @Override
        public void run() {
            someMethod();
        }
    };
    
    // ❌ 错误写法3: 匿名内部类作为回调
    private void setCallback() {
        SomeManager.getInstance().setCallback(new SomeCallback() {
            @Override
            public void onCallback() {
                // 持有 Activity 引用
                updateUI();
            }
        });
    }
    
    private void someMethod() { /* ... */ }
    private void updateUI() { /* ... */ }
}
```

**编译后的字节码分析:**

```java
/**
 * 反编译后的内部类代码
 * 展示编译器如何处理内部类
 */

// 原始代码
public class Outer {
    private String name = "outer";
    
    private class Inner {
        public void printName() {
            System.out.println(name);
        }
    }
}

// 编译后的 Inner 类 (反编译)
class Outer$Inner {
    // 编译器自动添加的外部类引用
    final Outer this$0;
    
    // 编译器修改的构造函数
    Outer$Inner(Outer outer) {
        this.this$0 = outer;
    }
    
    public void printName() {
        // 通过 this$0 访问外部类成员
        System.out.println(this$0.name);
    }
}
```

**正确的写法:**

```java
/**
 * 正确写法: 静态内部类 + 弱引用
 */
public class SafeInnerClassExample extends Activity {
    
    // ✅ 正确写法1: 静态内部类
    private static class SafeInnerClass {
        // 静态内部类不会持有外部类引用
        // 如果需要访问外部类，使用弱引用
        private final WeakReference<SafeInnerClassExample> mOuterRef;
        
        SafeInnerClass(SafeInnerClassExample outer) {
            mOuterRef = new WeakReference<>(outer);
        }
        
        public void doSomething() {
            SafeInnerClassExample outer = mOuterRef.get();
            if (outer != null) {
                outer.someMethod();
            }
        }
    }
    
    // ✅ 正确写法2: 静态 Runnable
    private static class SafeRunnable implements Runnable {
        private final WeakReference<SafeInnerClassExample> mActivityRef;
        
        SafeRunnable(SafeInnerClassExample activity) {
            mActivityRef = new WeakReference<>(activity);
        }
        
        @Override
        public void run() {
            SafeInnerClassExample activity = mActivityRef.get();
            if (activity != null && !activity.isDestroyed()) {
                activity.someMethod();
            }
        }
    }
    
    // ✅ 正确写法3: Lambda 表达式 (Kotlin)
    // Kotlin 的 Lambda 如果不捕获外部变量，不会持有外部类引用
    
    private void someMethod() { /* ... */ }
}
```

### 3.4 监听器未注销泄漏

```java
/**
 * 监听器泄漏示例
 * 注册监听器后未注销，导致泄漏
 */
public class ListenerLeakExample extends Activity {
    
    private SensorManager mSensorManager;
    private SensorEventListener mSensorListener;
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        
        mSensorManager = (SensorManager) getSystemService(SENSOR_SERVICE);
        
        // ❌ 错误: 注册监听器但未注销
        mSensorListener = new SensorEventListener() {
            @Override
            public void onSensorChanged(SensorEvent event) {
                // 处理传感器数据
                // 这个匿名内部类持有 Activity 引用
                updateUI(event);
            }
            
            @Override
            public void onAccuracyChanged(Sensor sensor, int accuracy) { }
        };
        
        Sensor accelerometer = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
        mSensorManager.registerListener(mSensorListener, accelerometer, 
                SensorManager.SENSOR_DELAY_NORMAL);
        
        // ❌ 错误: 其他常见的监听器泄漏
        // 1. BroadcastReceiver 未注销
        registerReceiver(mReceiver, new IntentFilter("some_action"));
        
        // 2. ContentObserver 未注销
        getContentResolver().registerContentObserver(uri, true, mObserver);
        
        // 3. LocationManager 监听器未移除
        locationManager.requestLocationUpdates(provider, 0, 0, mLocationListener);
        
        // 4. 自定义回调未移除
        SomeManager.getInstance().addCallback(mCallback);
    }
    
    private void updateUI(SensorEvent event) { /* ... */ }
    
    // 缺少 onDestroy 中的注销操作!
}
```

**正确的写法:**

```java
/**
 * 正确写法: 配对注册/注销
 */
public class SafeListenerExample extends Activity {
    
    private SensorManager mSensorManager;
    private SensorEventListener mSensorListener;
    private BroadcastReceiver mReceiver;
    private ContentObserver mObserver;
    private LocationListener mLocationListener;
    private SomeCallback mCallback;
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        
        // 初始化监听器...
        initListeners();
    }
    
    @Override
    protected void onResume() {
        super.onResume();
        // 在 onResume 注册
        registerListeners();
    }
    
    @Override
    protected void onPause() {
        super.onPause();
        // 在 onPause 注销 (与 onResume 配对)
        unregisterListeners();
    }
    
    @Override
    protected void onDestroy() {
        super.onDestroy();
        // 确保所有监听器都被注销
        cleanupListeners();
    }
    
    private void initListeners() {
        mSensorManager = (SensorManager) getSystemService(SENSOR_SERVICE);
        
        // 使用静态内部类避免泄漏
        mSensorListener = new SafeSensorListener(this);
    }
    
    private void registerListeners() {
        // 注册传感器监听
        Sensor accelerometer = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
        if (accelerometer != null) {
            mSensorManager.registerListener(mSensorListener, accelerometer,
                    SensorManager.SENSOR_DELAY_NORMAL);
        }
    }
    
    private void unregisterListeners() {
        // 注销传感器监听
        if (mSensorManager != null && mSensorListener != null) {
            mSensorManager.unregisterListener(mSensorListener);
        }
    }
    
    private void cleanupListeners() {
        // 清理所有监听器引用
        mSensorListener = null;
        mReceiver = null;
        mObserver = null;
        mLocationListener = null;
        mCallback = null;
    }
    
    // 静态内部类监听器
    private static class SafeSensorListener implements SensorEventListener {
        private final WeakReference<SafeListenerExample> mActivityRef;
        
        SafeSensorListener(SafeListenerExample activity) {
            mActivityRef = new WeakReference<>(activity);
        }
        
        @Override
        public void onSensorChanged(SensorEvent event) {
            SafeListenerExample activity = mActivityRef.get();
            if (activity != null && !activity.isDestroyed()) {
                activity.handleSensorData(event);
            }
        }
        
        @Override
        public void onAccuracyChanged(Sensor sensor, int accuracy) { }
    }
    
    private void handleSensorData(SensorEvent event) { /* ... */ }
}
```


### 3.5 WebView 泄漏原理与解决方案

```java
/**
 * WebView 内存泄漏分析
 * WebView 是 Android 中最容易导致内存泄漏的组件之一
 */
public class WebViewLeakExample extends Activity {
    
    private WebView mWebView;
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_webview);
        
        // ❌ 错误写法: 直接在 XML 中声明 WebView
        // WebView 会持有 Activity 的引用
        mWebView = findViewById(R.id.webview);
        mWebView.loadUrl("https://www.example.com");
    }
    
    @Override
    protected void onDestroy() {
        super.onDestroy();
        // 即使调用 destroy()，WebView 仍可能导致泄漏
        // 因为 WebView 内部有很多异步操作和回调
        if (mWebView != null) {
            mWebView.destroy();
        }
    }
}
```

**WebView 泄漏的原因分析:**

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    WebView 泄漏原因                                      │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  1. Context 引用:                                                       │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  WebView 构造时传入 Activity Context                            │   │
│  │  WebView 内部多处保存 Context 引用                              │   │
│  │  即使 Activity 销毁，WebView 仍持有引用                         │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  2. 异步回调:                                                           │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  WebViewClient、WebChromeClient 回调                            │   │
│  │  JavaScript 接口回调                                            │   │
│  │  网络请求回调                                                   │   │
│  │  这些回调可能在 Activity 销毁后仍被调用                         │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  3. Native 层引用:                                                      │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  WebView 底层是 Chromium 内核                                   │   │
│  │  Native 层有大量资源和引用                                      │   │
│  │  Java 层 destroy() 不能完全释放 Native 资源                     │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  4. 线程问题:                                                           │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  WebView 有自己的线程池                                         │   │
│  │  渲染线程、网络线程等                                           │   │
│  │  这些线程可能持有 WebView 引用                                  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

**WebView 泄漏解决方案:**

```java
/**
 * 方案1: 动态创建 WebView，使用 Application Context
 */
public class SafeWebViewActivity1 extends Activity {
    
    private WebView mWebView;
    private ViewGroup mContainer;
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_webview_container);
        
        mContainer = findViewById(R.id.webview_container);
        
        // ✅ 使用 Application Context 创建 WebView
        // 注意: 这种方式可能导致某些功能异常 (如 Dialog 显示)
        mWebView = new WebView(getApplicationContext());
        mContainer.addView(mWebView, new ViewGroup.LayoutParams(
                ViewGroup.LayoutParams.MATCH_PARENT,
                ViewGroup.LayoutParams.MATCH_PARENT));
        
        // 配置 WebView
        configureWebView();
        
        mWebView.loadUrl("https://www.example.com");
    }
    
    private void configureWebView() {
        WebSettings settings = mWebView.getSettings();
        settings.setJavaScriptEnabled(true);
        settings.setDomStorageEnabled(true);
        // 其他配置...
    }
    
    @Override
    protected void onDestroy() {
        super.onDestroy();
        destroyWebView();
    }
    
    private void destroyWebView() {
        if (mWebView != null) {
            // 1. 从父容器移除
            mContainer.removeView(mWebView);
            
            // 2. 停止加载
            mWebView.stopLoading();
            
            // 3. 清除历史
            mWebView.clearHistory();
            
            // 4. 移除所有回调
            mWebView.setWebViewClient(null);
            mWebView.setWebChromeClient(null);
            
            // 5. 加载空白页
            mWebView.loadUrl("about:blank");
            
            // 6. 移除所有 View
            mWebView.removeAllViews();
            
            // 7. 销毁
            mWebView.destroy();
            
            mWebView = null;
        }
    }
}

/**
 * 方案2: 使用独立进程 (推荐)
 * 这是最彻底的解决方案
 */

// AndroidManifest.xml 配置
/*
<activity
    android:name=".WebViewActivity"
    android:process=":webview" />
*/

public class WebViewProcessActivity extends Activity {
    
    private WebView mWebView;
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        
        // 在独立进程中，WebView 泄漏不会影响主进程
        // 当 Activity 销毁时，整个进程会被回收
        mWebView = new WebView(this);
        setContentView(mWebView);
        
        mWebView.loadUrl(getIntent().getStringExtra("url"));
    }
    
    @Override
    protected void onDestroy() {
        super.onDestroy();
        if (mWebView != null) {
            mWebView.destroy();
        }
        
        // 可选: 主动结束进程
        // android.os.Process.killProcess(android.os.Process.myPid());
    }
}

/**
 * 方案3: 使用 MutableContextWrapper
 * 在销毁时替换 Context
 */
public class SafeWebViewActivity3 extends Activity {
    
    private WebView mWebView;
    private MutableContextWrapper mContextWrapper;
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        
        // 使用 MutableContextWrapper 包装 Activity Context
        mContextWrapper = new MutableContextWrapper(this);
        mWebView = new WebView(mContextWrapper);
        setContentView(mWebView);
        
        mWebView.loadUrl("https://www.example.com");
    }
    
    @Override
    protected void onDestroy() {
        super.onDestroy();
        
        if (mWebView != null) {
            // 将 Context 替换为 Application Context
            // 这样即使 WebView 泄漏，也不会持有 Activity
            mContextWrapper.setBaseContext(getApplicationContext());
            
            mWebView.stopLoading();
            mWebView.destroy();
            mWebView = null;
        }
    }
}

/**
 * MutableContextWrapper 实现
 */
public class MutableContextWrapper extends ContextWrapper {
    
    public MutableContextWrapper(Context base) {
        super(base);
    }
    
    public void setBaseContext(Context base) {
        attachBaseContext(base);
    }
}
```

### 3.6 LeakCanary 使用与原理深度分析

**LeakCanary 基本使用:**

```kotlin
/**
 * LeakCanary 集成 (2.x 版本)
 * 只需添加依赖，无需任何代码配置
 */

// build.gradle
/*
dependencies {
    // 只在 debug 版本中使用
    debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.12'
}
*/

/**
 * LeakCanary 2.x 自动初始化原理
 * 利用 ContentProvider 在 Application.onCreate() 之前初始化
 */

// LeakCanary 的 ContentProvider (自动注册)
// 源码位置: leakcanary-object-watcher-android/src/main/AndroidManifest.xml
/*
<provider
    android:name="leakcanary.internal.MainProcessAppWatcherInstaller"
    android:authorities="${applicationId}.leakcanary-installer"
    android:enabled="@bool/leak_canary_watcher_auto_install"
    android:exported="false" />
*/
```

**LeakCanary 核心原理:**

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    LeakCanary 工作流程                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  1. 监听对象销毁                                                │   │
│  │     - Activity: Application.ActivityLifecycleCallbacks          │   │
│  │     - Fragment: FragmentManager.FragmentLifecycleCallbacks      │   │
│  │     - ViewModel: 监听 onCleared()                               │   │
│  │     - Service: 监听 onDestroy()                                 │   │
│  │     - View: 监听 onViewDetachedFromWindow()                     │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                          │                                              │
│                          ↓                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  2. 创建 KeyedWeakReference                                     │   │
│  │     - 为被监控对象创建弱引用                                    │   │
│  │     - 关联 ReferenceQueue                                       │   │
│  │     - 生成唯一 key 标识对象                                     │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                          │                                              │
│                          ↓                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  3. 等待 5 秒后检查                                             │   │
│  │     - 给 GC 足够时间回收对象                                    │   │
│  │     - 避免误报                                                  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                          │                                              │
│                          ↓                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  4. 触发 GC 并检查                                              │   │
│  │     - 调用 Runtime.gc()                                         │   │
│  │     - 检查 ReferenceQueue 中是否有该弱引用                      │   │
│  │     - 如果有: 对象已被回收，无泄漏                              │   │
│  │     - 如果没有: 对象仍存活，可能泄漏                            │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                          │                                              │
│                          ↓ (可能泄漏)                                   │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  5. Dump Heap                                                   │   │
│  │     - 调用 Debug.dumpHprofData()                                │   │
│  │     - 生成 .hprof 文件                                          │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                          │                                              │
│                          ↓                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  6. 分析 Heap (使用 Shark 库)                                   │   │
│  │     - 解析 .hprof 文件                                          │   │
│  │     - 找到泄漏对象                                              │   │
│  │     - 计算 GC Root 到泄漏对象的最短路径                         │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                          │                                              │
│                          ↓                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  7. 展示泄漏信息                                                │   │
│  │     - 发送通知                                                  │   │
│  │     - 显示泄漏详情界面                                          │   │
│  │     - 展示引用链                                                │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

**LeakCanary 核心源码分析:**

```kotlin
/**
 * ObjectWatcher - 对象监控核心类
 * 源码位置: leakcanary-object-watcher/src/main/java/leakcanary/ObjectWatcher.kt
 */
class ObjectWatcher constructor(
    private val clock: Clock,
    private val checkRetainedExecutor: Executor,
    // 判断对象是否应该被回收的回调
    private val isEnabled: () -> Boolean = { true }
) : ReachabilityWatcher {

    // 存储所有被监控对象的弱引用
    // key: 唯一标识符, value: KeyedWeakReference
    private val watchedObjects = mutableMapOf<String, KeyedWeakReference>()
    
    // 引用队列，当弱引用指向的对象被回收时，弱引用会被加入此队列
    private val queue = ReferenceQueue<Any>()

    /**
     * 监控一个对象
     * 当对象应该被回收时调用此方法
     */
    @Synchronized
    override fun expectWeaklyReachable(
        watchedObject: Any,
        description: String
    ) {
        if (!isEnabled()) {
            return
        }
        
        // 先清理已经被回收的对象
        removeWeaklyReachableObjects()
        
        // 生成唯一 key
        val key = UUID.randomUUID().toString()
        
        // 记录监控开始时间
        val watchUptimeMillis = clock.uptimeMillis()
        
        // 创建 KeyedWeakReference，关联 ReferenceQueue
        val reference = KeyedWeakReference(
            watchedObject, 
            key, 
            description, 
            watchUptimeMillis, 
            queue
        )
        
        // 保存到 map 中
        watchedObjects[key] = reference
        
        // 延迟检查 (默认 5 秒后)
        checkRetainedExecutor.execute {
            moveToRetained(key)
        }
    }

    /**
     * 检查对象是否仍然存活
     */
    @Synchronized
    private fun moveToRetained(key: String) {
        // 再次清理已回收的对象
        removeWeaklyReachableObjects()
        
        // 检查对象是否仍在 watchedObjects 中
        val retainedRef = watchedObjects[key]
        if (retainedRef != null) {
            // 对象仍然存活，标记为 retained (可能泄漏)
            retainedRef.retainedUptimeMillis = clock.uptimeMillis()
            // 通知监听器
            onObjectRetainedListeners.forEach { it.onObjectRetained() }
        }
    }

    /**
     * 清理已被回收的对象
     * 通过检查 ReferenceQueue 实现
     */
    private fun removeWeaklyReachableObjects() {
        var ref: KeyedWeakReference?
        do {
            // 从队列中取出已被回收对象的弱引用
            ref = queue.poll() as KeyedWeakReference?
            if (ref != null) {
                // 从 watchedObjects 中移除
                watchedObjects.remove(ref.key)
            }
        } while (ref != null)
    }
}

/**
 * KeyedWeakReference - 带 key 的弱引用
 */
class KeyedWeakReference(
    referent: Any,
    val key: String,                    // 唯一标识符
    val description: String,            // 描述信息
    val watchUptimeMillis: Long,        // 开始监控时间
    referenceQueue: ReferenceQueue<Any> // 引用队列
) : WeakReference<Any>(referent, referenceQueue) {
    
    // 被标记为 retained 的时间
    @Volatile
    var retainedUptimeMillis = -1L
}
```

```kotlin
/**
 * ActivityWatcher - Activity 监控
 * 源码位置: leakcanary-object-watcher-android/src/main/java/leakcanary/internal/ActivityDestroyWatcher.kt
 */
internal class ActivityDestroyWatcher private constructor(
    private val objectWatcher: ObjectWatcher,
    private val configProvider: () -> Config
) {

    private val lifecycleCallbacks = object : Application.ActivityLifecycleCallbacks 
            by noOpDelegate() {
        
        override fun onActivityDestroyed(activity: Activity) {
            if (configProvider().watchActivities) {
                // Activity 销毁时，开始监控
                objectWatcher.expectWeaklyReachable(
                    activity, 
                    "${activity::class.java.name} received Activity#onDestroy() callback"
                )
            }
        }
    }

    companion object {
        fun install(
            application: Application,
            objectWatcher: ObjectWatcher,
            configProvider: () -> Config
        ) {
            val activityDestroyWatcher = ActivityDestroyWatcher(objectWatcher, configProvider)
            // 注册 Activity 生命周期回调
            application.registerActivityLifecycleCallbacks(
                activityDestroyWatcher.lifecycleCallbacks
            )
        }
    }
}
```

```kotlin
/**
 * HeapAnalyzerService - 堆分析服务
 * 在独立进程中分析 heap dump
 */
internal class HeapAnalyzerService : ForegroundService() {

    override fun onHandleIntentInForeground(intent: Intent?) {
        if (intent == null) return
        
        // 获取 heap dump 文件路径
        val heapDumpFile = intent.getSerializableExtra(HEAPDUMP_FILE_EXTRA) as File
        
        // 使用 Shark 库分析 heap
        val heapAnalyzer = HeapAnalyzer(this)
        
        // 分析泄漏
        val heapAnalysis = heapAnalyzer.analyze(
            heapDumpFile = heapDumpFile,
            leakingObjectFinder = FilteringLeakingObjectFinder(
                AndroidObjectInspectors.appLeakingObjectFilters
            ),
            referenceMatchers = AndroidReferenceMatchers.appDefaults,
            computeRetainedHeapSize = true,
            objectInspectors = AndroidObjectInspectors.appDefaults,
            proguardMapping = null
        )
        
        // 保存分析结果
        // 发送通知
        // ...
    }
}
```

```kotlin
/**
 * Shark 库 - 堆分析核心
 * 找到 GC Root 到泄漏对象的最短路径
 */
class HeapAnalyzer(
    private val listener: OnAnalysisProgressListener
) {

    fun analyze(
        heapDumpFile: File,
        leakingObjectFinder: LeakingObjectFinder,
        referenceMatchers: List<ReferenceMatcher>,
        computeRetainedHeapSize: Boolean,
        objectInspectors: List<ObjectInspector>,
        proguardMapping: ProguardMapping?
    ): HeapAnalysis {
        
        return try {
            listener.onAnalysisProgress(PARSING_HEAP_DUMP)
            
            // 1. 解析 hprof 文件
            val heapGraph = heapDumpFile.openHeapGraph(proguardMapping)
            
            // 2. 找到泄漏对象
            val leakingObjectIds = leakingObjectFinder.findLeakingObjectIds(heapGraph)
            
            // 3. 找到 GC Root 到泄漏对象的最短路径
            val (applicationLeaks, libraryLeaks) = findLeaks(
                heapGraph,
                leakingObjectIds,
                referenceMatchers,
                computeRetainedHeapSize,
                objectInspectors
            )
            
            // 4. 返回分析结果
            HeapAnalysisSuccess(
                heapDumpFile = heapDumpFile,
                createdAtTimeMillis = System.currentTimeMillis(),
                analysisDurationMillis = analysisStartNanoTime.elapsedNow().inWholeMilliseconds,
                metadata = metadata,
                applicationLeaks = applicationLeaks,
                libraryLeaks = libraryLeaks,
                unreachableObjects = unreachableObjects
            )
        } catch (exception: Throwable) {
            HeapAnalysisFailure(
                heapDumpFile = heapDumpFile,
                createdAtTimeMillis = System.currentTimeMillis(),
                analysisDurationMillis = 0,
                exception = HeapAnalysisException(exception)
            )
        }
    }
    
    /**
     * 使用广度优先搜索找到最短路径
     */
    private fun findLeaks(
        heapGraph: HeapGraph,
        leakingObjectIds: Set<Long>,
        referenceMatchers: List<ReferenceMatcher>,
        computeRetainedHeapSize: Boolean,
        objectInspectors: List<ObjectInspector>
    ): Pair<List<ApplicationLeak>, List<LibraryLeak>> {
        
        // 从 GC Root 开始 BFS
        val pathFinder = PathFinder(heapGraph, referenceMatchers)
        val pathFindingResults = pathFinder.findPathsFromGcRoots(leakingObjectIds)
        
        // 构建泄漏路径
        // ...
        
        return applicationLeaks to libraryLeaks
    }
}
```


## 4. 实战应用

### 4.1 内存泄漏排查流程

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    内存泄漏排查流程                                      │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  1. 发现问题                                                    │   │
│  │     - LeakCanary 报警                                           │   │
│  │     - Memory Profiler 观察内存持续增长                          │   │
│  │     - 用户反馈 OOM 崩溃                                         │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                          │                                              │
│                          ↓                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  2. 复现问题                                                    │   │
│  │     - 反复进入/退出可疑页面                                     │   │
│  │     - 执行特定操作流程                                          │   │
│  │     - 观察内存变化                                              │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                          │                                              │
│                          ↓                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  3. 获取 Heap Dump                                              │   │
│  │     - Android Studio Memory Profiler                            │   │
│  │     - adb shell am dumpheap <pid> /data/local/tmp/heap.hprof    │   │
│  │     - LeakCanary 自动 dump                                      │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                          │                                              │
│                          ↓                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  4. 分析 Heap Dump                                              │   │
│  │     - MAT (Memory Analyzer Tool)                                │   │
│  │     - Android Studio Profiler                                   │   │
│  │     - LeakCanary 分析结果                                       │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                          │                                              │
│                          ↓                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  5. 定位泄漏点                                                  │   │
│  │     - 查看 GC Root 到泄漏对象的引用链                           │   │
│  │     - 找到持有引用的对象                                        │   │
│  │     - 分析为什么引用没有被释放                                  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                          │                                              │
│                          ↓                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  6. 修复问题                                                    │   │
│  │     - 根据泄漏类型选择对应解决方案                              │   │
│  │     - 修改代码                                                  │   │
│  │     - 验证修复效果                                              │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 4.2 Memory Profiler 使用

```kotlin
/**
 * 使用 Memory Profiler 排查内存泄漏
 */

// 步骤1: 打开 Memory Profiler
// Android Studio → View → Tool Windows → Profiler → Memory

// 步骤2: 操作应用，观察内存变化
// - 反复进入/退出页面
// - 观察内存是否持续增长

// 步骤3: 手动触发 GC
// 点击 "Force garbage collection" 按钮

// 步骤4: Dump Java Heap
// 点击 "Dump Java heap" 按钮

// 步骤5: 分析 Heap Dump
// - 按 Package 筛选，找到自己的类
// - 查看 Activity/Fragment 实例数量
// - 如果销毁后仍有实例，说明泄漏

// 步骤6: 查看引用链
// 选中泄漏对象 → References → 查看谁持有引用
```

### 4.3 MAT 工具使用

```bash
# MAT (Memory Analyzer Tool) 使用步骤

# 1. 获取 hprof 文件
adb shell am dumpheap <pid> /data/local/tmp/heap.hprof
adb pull /data/local/tmp/heap.hprof

# 2. 转换格式 (Android hprof 需要转换)
# 使用 Android SDK 中的 hprof-conv 工具
hprof-conv heap.hprof heap-converted.hprof

# 3. 用 MAT 打开 heap-converted.hprof

# 4. 常用分析功能:
# - Histogram: 查看各类对象数量和大小
# - Dominator Tree: 查看对象支配树
# - Leak Suspects: 自动分析可疑泄漏
# - OQL: 使用查询语言查找对象

# 5. 查找 Activity 泄漏示例 (OQL)
# SELECT * FROM instanceof android.app.Activity

# 6. 查看引用链
# 右键对象 → Path to GC Roots → exclude weak/soft references
```

### 4.4 Kotlin 协程中的内存泄漏处理

```kotlin
/**
 * Kotlin 协程内存泄漏场景与解决方案
 */

// ❌ 错误写法: 在 Activity 中启动协程，未绑定生命周期
class LeakyCoroutineActivity : AppCompatActivity() {
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        // 错误: 使用 GlobalScope，协程不会随 Activity 销毁而取消
        GlobalScope.launch {
            delay(60000)
            // 60秒后执行，如果 Activity 已销毁，仍会执行
            // 如果访问 Activity 成员，可能导致泄漏或崩溃
            updateUI()
        }
    }
    
    private fun updateUI() { /* ... */ }
}

// ✅ 正确写法1: 使用 lifecycleScope
class SafeCoroutineActivity1 : AppCompatActivity() {
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        // 正确: 使用 lifecycleScope，协程会随 Activity 销毁而取消
        lifecycleScope.launch {
            delay(60000)
            // 如果 Activity 销毁，协程会被取消，不会执行到这里
            updateUI()
        }
    }
    
    private fun updateUI() { /* ... */ }
}

// ✅ 正确写法2: 使用 viewModelScope
class SafeViewModel : ViewModel() {
    
    fun loadData() {
        // 正确: 使用 viewModelScope，协程会随 ViewModel 清除而取消
        viewModelScope.launch {
            val data = repository.fetchData()
            _uiState.value = data
        }
    }
}

// ✅ 正确写法3: 使用 repeatOnLifecycle
class SafeCoroutineActivity3 : AppCompatActivity() {
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        lifecycleScope.launch {
            // 只在 STARTED 状态时收集 Flow
            // 当 Activity 进入 STOPPED 状态时，收集会暂停
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.uiState.collect { state ->
                    updateUI(state)
                }
            }
        }
    }
    
    private fun updateUI(state: UiState) { /* ... */ }
}

// ✅ 正确写法4: 自定义 CoroutineScope
class SafeCoroutineActivity4 : AppCompatActivity() {
    
    // 创建自己的 CoroutineScope
    private val scope = CoroutineScope(Dispatchers.Main + SupervisorJob())
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        scope.launch {
            // 执行协程任务
        }
    }
    
    override fun onDestroy() {
        super.onDestroy()
        // 取消所有协程
        scope.cancel()
    }
}
```

### 4.5 RxJava 中的内存泄漏处理

```kotlin
/**
 * RxJava 内存泄漏场景与解决方案
 */

// ❌ 错误写法: 未取消订阅
class LeakyRxActivity : AppCompatActivity() {
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        // 错误: 订阅后未取消，Observer 持有 Activity 引用
        Observable.interval(1, TimeUnit.SECONDS)
            .subscribe { count ->
                // 这个 lambda 持有 Activity 引用
                updateUI(count)
            }
    }
    
    private fun updateUI(count: Long) { /* ... */ }
}

// ✅ 正确写法1: 使用 CompositeDisposable
class SafeRxActivity1 : AppCompatActivity() {
    
    private val compositeDisposable = CompositeDisposable()
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        val disposable = Observable.interval(1, TimeUnit.SECONDS)
            .subscribe { count ->
                updateUI(count)
            }
        
        // 添加到 CompositeDisposable
        compositeDisposable.add(disposable)
    }
    
    override fun onDestroy() {
        super.onDestroy()
        // 取消所有订阅
        compositeDisposable.clear()
    }
    
    private fun updateUI(count: Long) { /* ... */ }
}

// ✅ 正确写法2: 使用 AutoDispose 库
class SafeRxActivity2 : AppCompatActivity() {
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        Observable.interval(1, TimeUnit.SECONDS)
            .autoDispose(this) // 自动绑定生命周期
            .subscribe { count ->
                updateUI(count)
            }
    }
    
    private fun updateUI(count: Long) { /* ... */ }
}

// ✅ 正确写法3: 使用 RxLifecycle 库
class SafeRxActivity3 : RxAppCompatActivity() {
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        Observable.interval(1, TimeUnit.SECONDS)
            .compose(bindToLifecycle()) // 绑定生命周期
            .subscribe { count ->
                updateUI(count)
            }
    }
    
    private fun updateUI(count: Long) { /* ... */ }
}
```

### 4.6 最佳实践总结

```kotlin
/**
 * 内存泄漏防范最佳实践
 */
class BestPracticeActivity : AppCompatActivity() {
    
    // 1. Handler 使用静态内部类 + 弱引用
    private class SafeHandler(activity: BestPracticeActivity) : Handler(Looper.getMainLooper()) {
        private val activityRef = WeakReference(activity)
        
        override fun handleMessage(msg: Message) {
            activityRef.get()?.handleMessage(msg)
        }
    }
    
    private val handler = SafeHandler(this)
    
    // 2. 使用 lifecycleScope 启动协程
    private fun loadData() {
        lifecycleScope.launch {
            val data = withContext(Dispatchers.IO) {
                repository.fetchData()
            }
            updateUI(data)
        }
    }
    
    // 3. 监听器配对注册/注销
    private var sensorListener: SensorEventListener? = null
    
    override fun onResume() {
        super.onResume()
        registerSensorListener()
    }
    
    override fun onPause() {
        super.onPause()
        unregisterSensorListener()
    }
    
    // 4. 资源使用 try-with-resources 或 use 扩展
    private fun readFile() {
        FileInputStream("file.txt").use { fis ->
            // 自动关闭
        }
    }
    
    // 5. 单例使用 Application Context
    private fun initSingleton() {
        MySingleton.getInstance(applicationContext)
    }
    
    // 6. 在 onDestroy 中清理资源
    override fun onDestroy() {
        super.onDestroy()
        
        // 移除 Handler 消息
        handler.removeCallbacksAndMessages(null)
        
        // 清理其他资源
        cleanup()
    }
    
    private fun handleMessage(msg: Message) { /* ... */ }
    private fun updateUI(data: Any) { /* ... */ }
    private fun registerSensorListener() { /* ... */ }
    private fun unregisterSensorListener() { /* ... */ }
    private fun cleanup() { /* ... */ }
}
```


## 5. 常见面试题

### 面试题 1：什么是内存泄漏？Android 中常见的内存泄漏场景有哪些？

**答案要点：**

```
1. 内存泄漏定义:
   - 对象已经不再被使用，但仍然被其他对象持有强引用
   - 导致 GC 无法回收该对象，造成内存浪费
   - 本质是长生命周期对象持有短生命周期对象的引用

2. 常见泄漏场景:
   
   (1) Handler 泄漏:
       - 非静态内部类 Handler 持有 Activity 引用
       - Message 在队列中等待时，阻止 Activity 回收
       - 解决: 静态内部类 + 弱引用 + onDestroy 移除消息
   
   (2) 静态变量泄漏:
       - 静态变量持有 Activity/View 引用
       - 单例持有 Activity Context
       - 解决: 使用 Application Context
   
   (3) 内部类/匿名类泄漏:
       - 非静态内部类隐式持有外部类引用
       - 匿名内部类作为回调
       - 解决: 静态内部类 + 弱引用
   
   (4) 监听器未注销:
       - 注册监听器后未在适当时机注销
       - 如 SensorListener、BroadcastReceiver 等
       - 解决: 配对注册/注销
   
   (5) 资源未关闭:
       - Cursor、Stream、Bitmap 等未关闭
       - 解决: try-with-resources 或 use 扩展
   
   (6) WebView 泄漏:
       - WebView 持有 Activity 引用
       - 解决: 独立进程或动态创建 + 手动销毁
   
   (7) 线程泄漏:
       - 线程持有外部类引用
       - 线程未结束，阻止外部类回收
       - 解决: 静态内部类 + 弱引用 + 及时停止线程
```

### 面试题 2：Handler 为什么会导致内存泄漏？如何解决？

**答案要点：**

```
1. Handler 泄漏原因:
   
   引用链分析:
   GC Root (主线程 Looper)
       ↓
   MessageQueue.mMessages
       ↓
   Message.target (Handler)
       ↓
   Handler (非静态内部类)
       ↓ (隐式引用 this$0)
   Activity (被泄漏)
   
   - 非静态内部类 Handler 隐式持有外部类 (Activity) 引用
   - 当 Handler 发送延迟消息时，Message 持有 Handler 引用
   - Message 在 MessageQueue 中等待处理
   - 如果 Activity 销毁时消息还未处理，Activity 无法被回收

2. 解决方案:
   
   (1) 静态内部类 + 弱引用:
       private static class SafeHandler extends Handler {
           private final WeakReference<Activity> mActivityRef;
           
           SafeHandler(Activity activity) {
               mActivityRef = new WeakReference<>(activity);
           }
           
           @Override
           public void handleMessage(Message msg) {
               Activity activity = mActivityRef.get();
               if (activity != null && !activity.isDestroyed()) {
                   // 处理消息
               }
           }
       }
   
   (2) 在 onDestroy 中移除消息:
       @Override
       protected void onDestroy() {
           super.onDestroy();
           handler.removeCallbacksAndMessages(null);
       }
   
   (3) 使用 Lifecycle 感知的方式:
       - 使用 lifecycleScope.launch 替代 Handler.postDelayed
       - 协程会随生命周期自动取消

3. 源码层面理解:
   - Handler 构造时会检测潜在泄漏 (FIND_POTENTIAL_LEAKS)
   - Message.target 字段持有 Handler 引用
   - enqueueMessage 时设置 msg.target = this
```

### 面试题 3：LeakCanary 的原理是什么？如何检测内存泄漏？

**答案要点：**

```
1. LeakCanary 核心原理:
   
   基于弱引用 + ReferenceQueue 的检测机制:
   
   (1) 监听对象销毁:
       - Activity: ActivityLifecycleCallbacks.onActivityDestroyed
       - Fragment: FragmentLifecycleCallbacks.onFragmentDestroyed
       - ViewModel: 监听 onCleared
       - View: onViewDetachedFromWindow
   
   (2) 创建弱引用:
       - 为被监控对象创建 KeyedWeakReference
       - 关联 ReferenceQueue
       - 生成唯一 key 标识对象
   
   (3) 延迟检查 (默认 5 秒):
       - 给 GC 足够时间回收对象
       - 避免误报
   
   (4) 触发 GC 并检查:
       - 调用 Runtime.gc()
       - 检查 ReferenceQueue 中是否有该弱引用
       - 如果有: 对象已被回收，无泄漏
       - 如果没有: 对象仍存活，可能泄漏
   
   (5) Dump Heap:
       - 调用 Debug.dumpHprofData()
       - 生成 .hprof 文件
   
   (6) 分析 Heap (Shark 库):
       - 解析 .hprof 文件
       - 使用 BFS 找到 GC Root 到泄漏对象的最短路径
       - 展示引用链

2. 关键源码:
   
   ObjectWatcher.expectWeaklyReachable():
   - 创建 KeyedWeakReference
   - 关联 ReferenceQueue
   - 延迟执行 moveToRetained()
   
   removeWeaklyReachableObjects():
   - 从 ReferenceQueue 中取出已回收对象的弱引用
   - 从 watchedObjects 中移除

3. LeakCanary 2.x 自动初始化:
   - 利用 ContentProvider 在 Application.onCreate() 之前初始化
   - 无需任何代码配置
```

### 面试题 4：如何检测和解决 WebView 内存泄漏？

**答案要点：**

```
1. WebView 泄漏原因:
   
   (1) Context 引用:
       - WebView 构造时传入 Activity Context
       - 内部多处保存 Context 引用
   
   (2) 异步回调:
       - WebViewClient、WebChromeClient 回调
       - JavaScript 接口回调
       - 网络请求回调
   
   (3) Native 层引用:
       - Chromium 内核有大量 Native 资源
       - Java 层 destroy() 不能完全释放
   
   (4) 线程问题:
       - WebView 有自己的线程池
       - 渲染线程、网络线程等

2. 解决方案:
   
   (1) 独立进程 (推荐):
       <activity
           android:name=".WebViewActivity"
           android:process=":webview" />
       
       - 最彻底的解决方案
       - WebView 泄漏不影响主进程
       - Activity 销毁时进程被回收
   
   (2) 动态创建 + Application Context:
       mWebView = new WebView(getApplicationContext());
       mContainer.addView(mWebView);
       
       - 注意: 可能导致某些功能异常
   
   (3) 手动销毁流程:
       // 从父容器移除
       mContainer.removeView(mWebView);
       // 停止加载
       mWebView.stopLoading();
       // 清除历史
       mWebView.clearHistory();
       // 移除回调
       mWebView.setWebViewClient(null);
       mWebView.setWebChromeClient(null);
       // 加载空白页
       mWebView.loadUrl("about:blank");
       // 移除所有 View
       mWebView.removeAllViews();
       // 销毁
       mWebView.destroy();
   
   (4) MutableContextWrapper:
       - 销毁时将 Context 替换为 Application Context
       - 即使泄漏也不持有 Activity
```

### 面试题 5：静态变量为什么会导致内存泄漏？单例模式如何避免内存泄漏？

**答案要点：**

```
1. 静态变量泄漏原因:
   
   - 静态变量的生命周期与应用进程相同
   - 静态变量作为 GC Root，其引用的对象不会被回收
   
   引用链:
   GC Root (Class 对象)
       ↓
   静态字段 (sActivity / sInstance)
       ↓
   Activity (被泄漏)
       ↓
   View 树、Bitmap、各种资源...

2. 常见错误写法:
   
   (1) 静态变量直接持有 Activity:
       private static Activity sActivity;
   
   (2) 静态变量持有 View:
       private static View sView; // View 持有 Context
   
   (3) 单例持有 Activity Context:
       private Singleton(Context context) {
           mContext = context; // 错误
       }

3. 单例避免泄漏的方法:
   
   (1) 使用 Application Context:
       private Singleton(Context context) {
           mContext = context.getApplicationContext();
       }
   
   (2) 不持有 Context:
       - 需要时通过参数传入
       - 用完即释放
   
   (3) 使用弱引用:
       private WeakReference<Context> mContextRef;

4. Context 使用指南:
   
   使用 Application Context:
   - 单例模式
   - 静态工具类
   - 后台服务
   - 数据库操作
   - SharedPreferences
   - 网络请求
   
   必须使用 Activity Context:
   - 启动 Activity
   - 显示 Dialog
   - 布局 inflate (需要 Theme)
```

### 面试题 6：如何在线上监控内存泄漏？

**答案要点：**

```
1. 线上监控方案:
   
   (1) 基于 LeakCanary 的线上方案:
       - LeakCanary 2.x 支持线上使用
       - 配置采样率，避免性能影响
       - 上报泄漏信息到服务端
   
   (2) 自定义监控方案:
       - 监听 Activity/Fragment 销毁
       - 创建弱引用
       - 延迟检查是否被回收
       - 如果未回收，上报泄漏信息
   
   (3) 内存阈值监控:
       - 定期检查内存使用情况
       - 超过阈值时 dump heap
       - 上传 hprof 文件到服务端分析

2. 自定义监控实现:
   
   class MemoryLeakMonitor {
       private val watchedObjects = mutableMapOf<String, WeakReference<Any>>()
       private val queue = ReferenceQueue<Any>()
       
       fun watch(obj: Any, description: String) {
           val key = UUID.randomUUID().toString()
           watchedObjects[key] = WeakReference(obj, queue)
           
           // 延迟检查
           handler.postDelayed({
               checkRetained(key, description)
           }, 5000)
       }
       
       private fun checkRetained(key: String, description: String) {
           // 清理已回收的对象
           removeWeaklyReachableObjects()
           
           // 检查是否仍存活
           if (watchedObjects.containsKey(key)) {
               // 可能泄漏，上报
               reportLeak(description)
           }
       }
   }

3. 注意事项:
   
   - 控制采样率，避免性能影响
   - 只在特定条件下触发 (如内存紧张)
   - hprof 文件较大，考虑压缩或裁剪
   - 保护用户隐私，脱敏处理
```

### 面试题 7：Kotlin 协程中如何避免内存泄漏？

**答案要点：**

```
1. 协程泄漏场景:
   
   (1) 使用 GlobalScope:
       GlobalScope.launch {
           // 协程不会随 Activity 销毁而取消
           // 如果访问 Activity 成员，可能导致泄漏
       }
   
   (2) 自定义 Scope 未取消:
       val scope = CoroutineScope(Dispatchers.Main)
       scope.launch { ... }
       // 忘记在 onDestroy 中调用 scope.cancel()

2. 解决方案:
   
   (1) 使用 lifecycleScope:
       lifecycleScope.launch {
           // 协程会随 Activity 销毁而取消
       }
   
   (2) 使用 viewModelScope:
       viewModelScope.launch {
           // 协程会随 ViewModel 清除而取消
       }
   
   (3) 使用 repeatOnLifecycle:
       lifecycleScope.launch {
           repeatOnLifecycle(Lifecycle.State.STARTED) {
               // 只在 STARTED 状态时执行
               // STOPPED 时暂停
           }
       }
   
   (4) 自定义 Scope 记得取消:
       private val scope = CoroutineScope(Dispatchers.Main + SupervisorJob())
       
       override fun onDestroy() {
           super.onDestroy()
           scope.cancel()
       }

3. 原理:
   
   - lifecycleScope 绑定 Lifecycle
   - 当 Lifecycle 进入 DESTROYED 状态时，自动取消所有协程
   - 内部使用 LifecycleEventObserver 监听生命周期
```

### 面试题 8：内部类为什么会导致内存泄漏？如何从字节码层面理解？

**答案要点：**

```
1. 内部类泄漏原因:
   
   - 非静态内部类会隐式持有外部类的引用
   - 编译器会自动添加 this$0 字段指向外部类
   - 当内部类对象存活时，外部类无法被回收

2. 字节码层面分析:
   
   原始代码:
   class Outer {
       private String name = "outer";
       
       private class Inner {
           public void printName() {
               System.out.println(name);
           }
       }
   }
   
   编译后的 Inner 类:
   class Outer$Inner {
       // 编译器自动添加的外部类引用
       final Outer this$0;
       
       // 编译器修改的构造函数
       Outer$Inner(Outer outer) {
           this.this$0 = outer;
       }
       
       public void printName() {
           // 通过 this$0 访问外部类成员
           System.out.println(this$0.name);
       }
   }

3. 匿名内部类同理:
   
   new Runnable() {
       @Override
       public void run() {
           someMethod(); // 访问外部类方法
       }
   }
   
   编译后也会持有外部类引用

4. 解决方案:
   
   (1) 使用静态内部类:
       private static class SafeInner {
           // 不会持有外部类引用
       }
   
   (2) 静态内部类 + 弱引用:
       private static class SafeInner {
           private final WeakReference<Outer> mOuterRef;
           
           SafeInner(Outer outer) {
               mOuterRef = new WeakReference<>(outer);
           }
       }
   
   (3) 使用 Lambda (Kotlin):
       - 如果 Lambda 不捕获外部变量，不会持有外部类引用
       - 编译器会优化为静态方法
```

---

## 聊天记录

### 2024-XX-XX
- 创建了 `docs/06-内存管理/内存泄漏.md` 文档
- 内容包括：
  1. 概述：内存泄漏的本质、危害、常见场景
  2. 核心原理：Java 引用类型、组件生命周期、检测原理
  3. 关键源码解析：Handler、静态变量、内部类、监听器、WebView、LeakCanary
  4. 实战应用：排查流程、工具使用、协程/RxJava 处理、最佳实践
  5. 常见面试题：8 道高频面试题，覆盖字节、美团、快手、OPPO、vivo 面试风格
