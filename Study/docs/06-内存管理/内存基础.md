# Android 内存基础

## 1. 概述

内存管理是 Android 性能优化的核心领域，也是大厂面试的高频考点。深入理解 Android 内存模型、进程内存分配机制、Low Memory Killer 等底层原理，对于解决内存泄漏、OOM 等问题至关重要。本文将从内存模型、进程内存分配、LMK 机制、内存指标、分析工具等方面全面讲解 Android 内存基础知识。

### 1.1 内存管理的重要性

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        内存管理的价值                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  用户体验影响:                                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  • 内存不足导致应用被杀死，用户体验中断                         │   │
│  │  • 内存泄漏导致应用越用越卡                                     │   │
│  │  • OOM 导致应用崩溃，用户流失                                   │   │
│  │  • 内存抖动导致频繁 GC，界面卡顿                                │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  系统层面影响:                                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  • 内存占用过高触发 LMK，影响后台保活                           │   │
│  │  • 内存压力导致系统整体性能下降                                 │   │
│  │  • 影响多任务切换体验                                           │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  大厂面试重点:                                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  • 字节: 内存优化实战经验、LeakCanary 原理                      │   │
│  │  • 美团: 内存泄漏排查、Bitmap 优化                              │   │
│  │  • 快手: 大图加载、内存监控体系                                 │   │
│  │  • OPPO/vivo: LMK 机制、Framework 内存管理源码                  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 1.2 Android 内存管理特点

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    Android 内存管理特点                                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  与传统 Linux 的区别:                                                   │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  传统 Linux:                                                    │   │
│  │  • 进程退出时释放所有内存                                       │   │
│  │  • 使用 Swap 分区进行内存交换                                   │   │
│  │  • OOM Killer 杀死进程释放内存                                  │   │
│  │                                                                 │   │
│  │  Android:                                                       │   │
│  │  • 进程退出后可能保留在内存中 (缓存)                            │   │
│  │  • 不使用传统 Swap，使用 zRAM 压缩                              │   │
│  │  • Low Memory Killer 更精细的进程管理                           │   │
│  │  • 每个应用有独立的 Dalvik/ART 堆                               │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```


## 2. 核心原理

### 2.1 Android 内存模型

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      Android 内存模型架构                                │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                        应用层 (App Layer)                       │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐             │   │
│  │  │   App 1     │  │   App 2     │  │   App 3     │             │   │
│  │  │  (Java/Kt)  │  │  (Java/Kt)  │  │  (Java/Kt)  │             │   │
│  │  └─────────────┘  └─────────────┘  └─────────────┘             │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                              │                                          │
│                              ↓                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                    运行时层 (Runtime Layer)                     │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │                    ART 虚拟机                            │   │   │
│  │  │  ┌───────────┐  ┌───────────┐  ┌───────────┐           │   │   │
│  │  │  │ Java Heap │  │  Native   │  │   Code    │           │   │   │
│  │  │  │  (托管堆) │  │   Heap    │  │   Cache   │           │   │   │
│  │  │  └───────────┘  └───────────┘  └───────────┘           │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                              │                                          │
│                              ↓                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                    Native 层 (Native Layer)                     │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐             │   │
│  │  │   libc      │  │   Binder    │  │   Graphics  │             │   │
│  │  │  (malloc)   │  │   Driver    │  │   (GPU)     │             │   │
│  │  └─────────────┘  └─────────────┘  └─────────────┘             │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                              │                                          │
│                              ↓                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                    内核层 (Kernel Layer)                        │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │              Linux Kernel Memory Management              │   │   │
│  │  │  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐    │   │   │
│  │  │  │  Page   │  │  Slab   │  │  zRAM   │  │   LMK   │    │   │   │
│  │  │  │ Allocator│  │ Allocator│  │(压缩)  │  │         │    │   │   │
│  │  │  └─────────┘  └─────────┘  └─────────┘  └─────────┘    │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                              │                                          │
│                              ↓                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                    硬件层 (Hardware Layer)                      │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │                    Physical RAM                          │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.2 进程内存空间布局

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    进程虚拟内存空间布局 (32位)                           │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  高地址 0xFFFFFFFF                                                      │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                    Kernel Space (1GB)                           │   │
│  │                    内核空间 (用户不可访问)                       │   │
│  ├─────────────────────────────────────────────────────────────────┤   │
│  │  0xC0000000                                                     │   │
│  ├─────────────────────────────────────────────────────────────────┤   │
│  │                    Stack (栈)                                   │   │
│  │                    ↓ 向下增长                                   │   │
│  │                    - 局部变量                                   │   │
│  │                    - 函数调用栈帧                               │   │
│  ├─────────────────────────────────────────────────────────────────┤   │
│  │                    Memory Mapping Segment                       │   │
│  │                    - mmap 映射区域                              │   │
│  │                    - 共享库 (.so)                               │   │
│  │                    - 匿名映射                                   │   │
│  ├─────────────────────────────────────────────────────────────────┤   │
│  │                    Heap (堆)                                    │   │
│  │                    ↑ 向上增长                                   │   │
│  │                    - malloc/new 分配                            │   │
│  │                    - Java Heap (ART 管理)                       │   │
│  ├─────────────────────────────────────────────────────────────────┤   │
│  │                    BSS Segment                                  │   │
│  │                    - 未初始化的全局变量                         │   │
│  ├─────────────────────────────────────────────────────────────────┤   │
│  │                    Data Segment                                 │   │
│  │                    - 已初始化的全局变量                         │   │
│  ├─────────────────────────────────────────────────────────────────┤   │
│  │                    Text Segment (代码段)                        │   │
│  │                    - 可执行代码                                 │   │
│  │                    - 只读                                       │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│  低地址 0x00000000                                                      │
│                                                                         │
│  注意: 64位系统地址空间更大，用户空间可达 128TB                         │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```


### 2.3 Android 进程内存分配

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    Android 进程内存组成                                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                    App 进程内存                                 │   │
│  │                                                                 │   │
│  │  ┌───────────────────────────────────────────────────────────┐ │   │
│  │  │                  Java Heap (托管堆)                        │ │   │
│  │  │  • 由 ART 虚拟机管理                                      │ │   │
│  │  │  • 存放 Java/Kotlin 对象                                  │ │   │
│  │  │  • 受 dalvik.vm.heapsize 限制                             │ │   │
│  │  │  • GC 自动回收                                            │ │   │
│  │  │  • 典型大小: 256MB - 512MB                                │ │   │
│  │  └───────────────────────────────────────────────────────────┘ │   │
│  │                                                                 │   │
│  │  ┌───────────────────────────────────────────────────────────┐ │   │
│  │  │                  Native Heap (本地堆)                      │ │   │
│  │  │  • 由 malloc/free 管理                                    │ │   │
│  │  │  • 存放 Native 对象、Bitmap 像素数据 (Android 8.0+)       │ │   │
│  │  │  • 不受 Java Heap 大小限制                                │ │   │
│  │  │  • 需要手动释放或依赖析构函数                             │ │   │
│  │  └───────────────────────────────────────────────────────────┘ │   │
│  │                                                                 │   │
│  │  ┌───────────────────────────────────────────────────────────┐ │   │
│  │  │                  Code (代码)                               │ │   │
│  │  │  • DEX 代码 (已编译为机器码)                              │ │   │
│  │  │  • OAT 文件                                               │ │   │
│  │  │  • JIT 编译缓存                                           │ │   │
│  │  └───────────────────────────────────────────────────────────┘ │   │
│  │                                                                 │   │
│  │  ┌───────────────────────────────────────────────────────────┐ │   │
│  │  │                  Stack (栈)                                │ │   │
│  │  │  • 每个线程独立的栈空间                                   │ │   │
│  │  │  • 默认大小: 主线程 8MB，子线程 1MB                       │ │   │
│  │  │  • 存放局部变量、方法调用栈帧                             │ │   │
│  │  └───────────────────────────────────────────────────────────┘ │   │
│  │                                                                 │   │
│  │  ┌───────────────────────────────────────────────────────────┐ │   │
│  │  │                  Graphics (图形)                           │ │   │
│  │  │  • GL 纹理、GL 命令缓冲区                                 │ │   │
│  │  │  • GPU 内存                                               │ │   │
│  │  │  • SurfaceFlinger 缓冲区                                  │ │   │
│  │  └───────────────────────────────────────────────────────────┘ │   │
│  │                                                                 │   │
│  │  ┌───────────────────────────────────────────────────────────┐ │   │
│  │  │                  Other (其他)                              │ │   │
│  │  │  • Ashmem (匿名共享内存)                                  │ │   │
│  │  │  • Cursor 缓冲区                                          │ │   │
│  │  │  • 其他映射                                               │ │   │
│  │  └───────────────────────────────────────────────────────────┘ │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.4 Java Heap 内存限制

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    Java Heap 内存限制机制                                │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  系统属性配置 (build.prop):                                             │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  # 单个应用 Java Heap 最大值                                    │   │
│  │  dalvik.vm.heapsize=512m                                        │   │
│  │                                                                 │   │
│  │  # 应用启动时的初始堆大小                                       │   │
│  │  dalvik.vm.heapstartsize=8m                                     │   │
│  │                                                                 │   │
│  │  # 堆增长的上限 (达到后触发 GC)                                 │   │
│  │  dalvik.vm.heapgrowthlimit=256m                                 │   │
│  │                                                                 │   │
│  │  # 堆的最小空闲比例                                             │   │
│  │  dalvik.vm.heapminfree=512k                                     │   │
│  │                                                                 │   │
│  │  # 堆的最大空闲比例                                             │   │
│  │  dalvik.vm.heapmaxfree=8m                                       │   │
│  │                                                                 │   │
│  │  # 堆利用率目标                                                 │   │
│  │  dalvik.vm.heaptargetutilization=0.75                           │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  heapgrowthlimit vs heapsize:                                           │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  普通应用:                                                      │   │
│  │  • 受 heapgrowthlimit 限制 (如 256MB)                           │   │
│  │  • 超过限制触发 OOM                                             │   │
│  │                                                                 │   │
│  │  大堆应用 (android:largeHeap="true"):                           │   │
│  │  • 受 heapsize 限制 (如 512MB)                                  │   │
│  │  • 可使用更多内存，但不推荐滥用                                 │   │
│  │  • 会影响系统整体性能                                           │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```


### 2.5 Low Memory Killer (LMK) 机制

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    Low Memory Killer 机制详解                            │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  LMK 概述:                                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  • Android 特有的内存管理机制                                   │   │
│  │  • 基于 Linux OOM Killer 改进                                   │   │
│  │  • 在内存不足时按优先级杀死进程                                 │   │
│  │  • 保证前台应用和系统服务的正常运行                             │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  进程优先级 (oom_adj / oom_score_adj):                                  │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  优先级值    │  进程类型              │  说明                   │   │
│  │  ───────────┼────────────────────────┼─────────────────────────│   │
│  │  -1000      │  Native 进程           │  不会被杀死             │   │
│  │  -900       │  System 进程           │  系统核心进程           │   │
│  │  -800       │  Persistent 进程       │  常驻进程               │   │
│  │  0          │  Foreground 进程       │  前台进程 (最高保护)    │   │
│  │  100        │  Visible 进程          │  可见进程               │   │
│  │  200        │  Perceptible 进程      │  可感知进程             │   │
│  │  300        │  Backup 进程           │  备份进程               │   │
│  │  400        │  Heavy Weight 进程     │  重量级后台进程         │   │
│  │  500        │  Service 进程          │  服务进程               │   │
│  │  600        │  Home 进程             │  桌面进程               │   │
│  │  700        │  Previous 进程         │  上一个进程             │   │
│  │  800        │  Service B 进程        │  B 类服务进程           │   │
│  │  900        │  Cached 进程           │  缓存进程 (最易被杀)    │   │
│  │                                                                 │   │
│  │  值越大，优先级越低，越容易被杀死                               │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  LMK 触发阈值 (minfree):                                                │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  内存阈值 (页数)  │  对应 adj 值  │  说明                       │   │
│  │  ─────────────────┼───────────────┼─────────────────────────────│   │
│  │  18432 (72MB)     │  0            │  前台进程阈值               │   │
│  │  23040 (90MB)     │  100          │  可见进程阈值               │   │
│  │  27648 (108MB)    │  200          │  可感知进程阈值             │   │
│  │  32256 (126MB)    │  300          │  备份进程阈值               │   │
│  │  55296 (216MB)    │  900          │  缓存进程阈值               │   │
│  │  80640 (315MB)    │  906          │  空进程阈值                 │   │
│  │                                                                 │   │
│  │  当可用内存低于阈值时，杀死对应 adj 及以上的进程                │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.6 LMK 工作流程

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    LMK 工作流程图                                        │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                    内存压力检测                                 │   │
│  │                         │                                       │   │
│  │                         ↓                                       │   │
│  │              ┌─────────────────────┐                           │   │
│  │              │  可用内存 < 阈值?   │                           │   │
│  │              └─────────────────────┘                           │   │
│  │                    │         │                                  │   │
│  │                   是         否                                 │   │
│  │                    │         │                                  │   │
│  │                    ↓         ↓                                  │   │
│  │         ┌──────────────┐  ┌──────────────┐                     │   │
│  │         │  触发 LMK    │  │  继续监控    │                     │   │
│  │         └──────────────┘  └──────────────┘                     │   │
│  │                │                                                │   │
│  │                ↓                                                │   │
│  │         ┌──────────────────────────────────┐                   │   │
│  │         │  遍历进程列表                     │                   │   │
│  │         │  按 oom_score_adj 排序            │                   │   │
│  │         └──────────────────────────────────┘                   │   │
│  │                │                                                │   │
│  │                ↓                                                │   │
│  │         ┌──────────────────────────────────┐                   │   │
│  │         │  选择 adj 值最大的进程            │                   │   │
│  │         │  (同 adj 选择内存占用最大的)      │                   │   │
│  │         └──────────────────────────────────┘                   │   │
│  │                │                                                │   │
│  │                ↓                                                │   │
│  │         ┌──────────────────────────────────┐                   │   │
│  │         │  发送 SIGKILL 信号杀死进程        │                   │   │
│  │         └──────────────────────────────────┘                   │   │
│  │                │                                                │   │
│  │                ↓                                                │   │
│  │         ┌──────────────────────────────────┐                   │   │
│  │         │  检查内存是否充足                 │                   │   │
│  │         │  不足则继续杀死下一个进程         │                   │   │
│  │         └──────────────────────────────────┘                   │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  Android 10+ 使用 lmkd (用户空间守护进程) 替代内核 LMK                  │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```


### 2.7 PSS、RSS、USS 内存指标

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    内存指标详解                                          │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                    内存指标对比                                 │   │
│  │                                                                 │   │
│  │  指标  │  全称                      │  说明                     │   │
│  │  ──────┼────────────────────────────┼───────────────────────────│   │
│  │  VSS   │  Virtual Set Size          │  虚拟内存大小             │   │
│  │        │                            │  包含未分配的虚拟地址空间 │   │
│  │        │                            │  意义不大                 │   │
│  │  ──────┼────────────────────────────┼───────────────────────────│   │
│  │  RSS   │  Resident Set Size         │  常驻内存大小             │   │
│  │        │                            │  实际占用的物理内存       │   │
│  │        │                            │  包含共享库的全部内存     │   │
│  │  ──────┼────────────────────────────┼───────────────────────────│   │
│  │  PSS   │  Proportional Set Size     │  比例内存大小             │   │
│  │        │                            │  私有内存 + 共享内存/N    │   │
│  │        │                            │  最常用的指标             │   │
│  │  ──────┼────────────────────────────┼───────────────────────────│   │
│  │  USS   │  Unique Set Size           │  独占内存大小             │   │
│  │        │                            │  进程独占的物理内存       │   │
│  │        │                            │  不包含任何共享内存       │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  内存大小关系: VSS >= RSS >= PSS >= USS                                 │
│                                                                         │
│  示意图:                                                                │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │     进程 A                              进程 B                  │   │
│  │  ┌───────────────┐                  ┌───────────────┐          │   │
│  │  │               │                  │               │          │   │
│  │  │  私有内存     │                  │  私有内存     │          │   │
│  │  │  (USS_A)      │                  │  (USS_B)      │          │   │
│  │  │               │                  │               │          │   │
│  │  ├───────────────┤                  ├───────────────┤          │   │
│  │  │               │                  │               │          │   │
│  │  │  共享内存     │←────────────────→│  共享内存     │          │   │
│  │  │  (如 libc.so) │   同一块物理内存  │  (如 libc.so) │          │   │
│  │  │               │                  │               │          │   │
│  │  └───────────────┘                  └───────────────┘          │   │
│  │                                                                 │   │
│  │  RSS_A = USS_A + 共享内存全部                                   │   │
│  │  PSS_A = USS_A + 共享内存/2  (假设只有 A、B 两个进程共享)       │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  为什么 PSS 最常用:                                                     │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  • RSS 会重复计算共享内存，所有进程 RSS 之和 > 实际物理内存     │   │
│  │  • USS 不包含共享内存，无法反映进程真实内存贡献                 │   │
│  │  • PSS 按比例分摊共享内存，所有进程 PSS 之和 ≈ 实际物理内存    │   │
│  │  • PSS 是衡量进程内存占用的最佳指标                             │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.8 ART 垃圾回收机制

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    ART GC 机制概述                                       │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  GC 类型:                                                               │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  类型              │  触发条件              │  暂停时间         │   │
│  │  ──────────────────┼────────────────────────┼───────────────────│   │
│  │  Concurrent GC     │  堆内存达到阈值        │  < 5ms            │   │
│  │  (并发 GC)         │  后台自动触发          │  (大部分并发执行) │   │
│  │  ──────────────────┼────────────────────────┼───────────────────│   │
│  │  Alloc GC          │  分配内存失败时        │  较长             │   │
│  │  (分配 GC)         │  需要立即回收          │  (阻塞分配线程)   │   │
│  │  ──────────────────┼────────────────────────┼───────────────────│   │
│  │  Explicit GC       │  调用 System.gc()      │  较长             │   │
│  │  (显式 GC)         │  或 Runtime.gc()       │  (不推荐调用)     │   │
│  │  ──────────────────┼────────────────────────┼───────────────────│   │
│  │  NativeAlloc GC    │  Native 内存压力       │  中等             │   │
│  │  (Native 分配 GC)  │  Bitmap 等分配触发     │                   │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  GC 算法:                                                               │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  • 标记-清除 (Mark-Sweep): 标记存活对象，清除未标记对象         │   │
│  │  • 标记-整理 (Mark-Compact): 标记后整理内存，减少碎片           │   │
│  │  • 复制算法 (Copying): 将存活对象复制到新区域                   │   │
│  │  • 分代收集: 新生代用复制算法，老年代用标记-清除/整理           │   │
│  │                                                                 │   │
│  │  ART 使用 Concurrent Copying GC (CC GC):                        │   │
│  │  • 并发复制，减少暂停时间                                       │   │
│  │  • 支持堆压缩，减少内存碎片                                     │   │
│  │  • Android 10+ 默认使用                                         │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```


## 3. 关键源码解析

### 3.1 ActivityManager 获取内存信息

```java
/**
 * ActivityManager.getMemoryInfo() - 获取系统内存信息
 * 源码位置: frameworks/base/core/java/android/app/ActivityManager.java
 */
public void getMemoryInfo(MemoryInfo outInfo) {
    try {
        // 通过 Binder 调用 AMS 获取内存信息
        getService().getMemoryInfo(outInfo);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}

/**
 * MemoryInfo 类 - 系统内存信息
 */
public static class MemoryInfo implements Parcelable {
    /**
     * 可用内存大小 (bytes)
     * 包括空闲内存和可回收的缓存
     */
    public long availMem;
    
    /**
     * 总内存大小 (bytes)
     */
    public long totalMem;
    
    /**
     * 内存低阈值 (bytes)
     * 当 availMem < threshold 时，系统处于低内存状态
     */
    public long threshold;
    
    /**
     * 是否处于低内存状态
     */
    public boolean lowMemory;
}

// 使用示例
public void checkMemoryStatus(Context context) {
    ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
    ActivityManager.MemoryInfo memInfo = new ActivityManager.MemoryInfo();
    am.getMemoryInfo(memInfo);
    
    // 可用内存 (MB)
    long availableMB = memInfo.availMem / (1024 * 1024);
    // 总内存 (MB)
    long totalMB = memInfo.totalMem / (1024 * 1024);
    // 内存使用率
    float usagePercent = (1 - (float) memInfo.availMem / memInfo.totalMem) * 100;
    // 是否低内存
    boolean isLowMemory = memInfo.lowMemory;
    
    Log.d("Memory", String.format(
        "可用: %dMB, 总计: %dMB, 使用率: %.1f%%, 低内存: %b",
        availableMB, totalMB, usagePercent, isLowMemory));
}
```

### 3.2 获取应用内存限制

```java
/**
 * 获取应用 Java Heap 内存限制
 * 源码位置: frameworks/base/core/java/android/app/ActivityManager.java
 */
public class ActivityManager {
    
    /**
     * 获取普通应用的堆内存限制 (heapgrowthlimit)
     * @return 内存限制，单位 MB
     */
    public int getMemoryClass() {
        return staticGetMemoryClass();
    }
    
    /** @hide */
    static public int staticGetMemoryClass() {
        // 从系统属性读取 dalvik.vm.heapgrowthlimit
        String vmHeapSize = SystemProperties.get("dalvik.vm.heapgrowthlimit", "");
        if (vmHeapSize != null && !"".equals(vmHeapSize)) {
            return Integer.parseInt(vmHeapSize.substring(0, vmHeapSize.length() - 1));
        }
        // 默认返回 heapsize
        return staticGetLargeMemoryClass();
    }
    
    /**
     * 获取大堆应用的内存限制 (heapsize)
     * 需要在 AndroidManifest.xml 中声明 android:largeHeap="true"
     * @return 内存限制，单位 MB
     */
    public int getLargeMemoryClass() {
        return staticGetLargeMemoryClass();
    }
    
    /** @hide */
    static public int staticGetLargeMemoryClass() {
        // 从系统属性读取 dalvik.vm.heapsize
        String vmHeapSize = SystemProperties.get("dalvik.vm.heapsize", "16m");
        return Integer.parseInt(vmHeapSize.substring(0, vmHeapSize.length() - 1));
    }
}

// 使用示例
public void getHeapLimit(Context context) {
    ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
    
    // 普通应用堆限制
    int normalHeapMB = am.getMemoryClass();
    // 大堆应用限制
    int largeHeapMB = am.getLargeMemoryClass();
    
    // 当前应用的堆限制
    Runtime runtime = Runtime.getRuntime();
    long maxHeapMB = runtime.maxMemory() / (1024 * 1024);
    long totalHeapMB = runtime.totalMemory() / (1024 * 1024);
    long freeHeapMB = runtime.freeMemory() / (1024 * 1024);
    long usedHeapMB = totalHeapMB - freeHeapMB;
    
    Log.d("Heap", String.format(
        "普通限制: %dMB, 大堆限制: %dMB, 当前最大: %dMB, 已用: %dMB",
        normalHeapMB, largeHeapMB, maxHeapMB, usedHeapMB));
}
```

### 3.3 Debug.MemoryInfo 详细内存信息

```java
/**
 * Debug.MemoryInfo - 获取进程详细内存信息
 * 源码位置: frameworks/base/core/java/android/os/Debug.java
 */
public static class MemoryInfo implements Parcelable {
    // ==================== PSS 内存 ====================
    /** Dalvik 堆 PSS */
    public int dalvikPss;
    /** Native 堆 PSS */
    public int nativePss;
    /** 其他 PSS */
    public int otherPss;
    
    // ==================== 私有脏页 (Private Dirty) ====================
    /** Dalvik 私有脏页 - 进程独占且已修改的内存 */
    public int dalvikPrivateDirty;
    /** Native 私有脏页 */
    public int nativePrivateDirty;
    /** 其他私有脏页 */
    public int otherPrivateDirty;
    
    // ==================== 共享脏页 (Shared Dirty) ====================
    /** Dalvik 共享脏页 - 多进程共享且已修改的内存 */
    public int dalvikSharedDirty;
    /** Native 共享脏页 */
    public int nativeSharedDirty;
    /** 其他共享脏页 */
    public int otherSharedDirty;
    
    // ==================== 私有干净页 (Private Clean) ====================
    /** Dalvik 私有干净页 - 进程独占且未修改的内存 */
    public int dalvikPrivateClean;
    /** Native 私有干净页 */
    public int nativePrivateClean;
    /** 其他私有干净页 */
    public int otherPrivateClean;
    
    // ==================== 共享干净页 (Shared Clean) ====================
    /** Dalvik 共享干净页 */
    public int dalvikSharedClean;
    /** Native 共享干净页 */
    public int nativeSharedClean;
    /** 其他共享干净页 */
    public int otherSharedClean;
    
    /**
     * 获取总 PSS
     */
    public int getTotalPss() {
        return dalvikPss + nativePss + otherPss + getTotalSwappedOutPss();
    }
    
    /**
     * 获取总私有脏页 (USS 的主要组成部分)
     */
    public int getTotalPrivateDirty() {
        return dalvikPrivateDirty + nativePrivateDirty + otherPrivateDirty;
    }
    
    /**
     * 获取总私有干净页
     */
    public int getTotalPrivateClean() {
        return dalvikPrivateClean + nativePrivateClean + otherPrivateClean;
    }
    
    /**
     * 获取总共享脏页
     */
    public int getTotalSharedDirty() {
        return dalvikSharedDirty + nativeSharedDirty + otherSharedDirty;
    }
    
    /**
     * 获取 Java Heap 内存
     * 包括 Dalvik Heap 和 .art mmap
     */
    public int getMemoryStat(String statName) {
        switch (statName) {
            case "summary.java-heap":
                return dalvikPrivateDirty + getOtherPrivate(OTHER_ART);
            case "summary.native-heap":
                return nativePrivateDirty;
            case "summary.code":
                return getOtherPrivate(OTHER_SO) + getOtherPrivate(OTHER_JAR)
                        + getOtherPrivate(OTHER_APK) + getOtherPrivate(OTHER_TTF)
                        + getOtherPrivate(OTHER_DEX) + getOtherPrivate(OTHER_OAT)
                        + getOtherPrivate(OTHER_ART);
            case "summary.stack":
                return getOtherPrivateDirty(OTHER_STACK);
            case "summary.graphics":
                return getOtherPrivate(OTHER_GL_DEV) + getOtherPrivate(OTHER_GRAPHICS)
                        + getOtherPrivate(OTHER_GL);
            case "summary.private-other":
                return getTotalPrivateClean() + getTotalPrivateDirty()
                        - getMemoryStat("summary.java-heap")
                        - getMemoryStat("summary.native-heap")
                        - getMemoryStat("summary.code")
                        - getMemoryStat("summary.stack")
                        - getMemoryStat("summary.graphics");
            case "summary.system":
                return getTotalPss() - getTotalPrivateClean() - getTotalPrivateDirty();
            case "summary.total-pss":
                return getTotalPss();
            case "summary.total-swap":
                return getTotalSwappedOut();
            default:
                return 0;
        }
    }
}

// 使用示例
public void getDetailedMemoryInfo() {
    Debug.MemoryInfo memInfo = new Debug.MemoryInfo();
    Debug.getMemoryInfo(memInfo);
    
    // 获取各类内存 (单位: KB)
    int javaHeap = memInfo.getMemoryStat("summary.java-heap");
    int nativeHeap = memInfo.getMemoryStat("summary.native-heap");
    int code = memInfo.getMemoryStat("summary.code");
    int stack = memInfo.getMemoryStat("summary.stack");
    int graphics = memInfo.getMemoryStat("summary.graphics");
    int privateOther = memInfo.getMemoryStat("summary.private-other");
    int system = memInfo.getMemoryStat("summary.system");
    int totalPss = memInfo.getMemoryStat("summary.total-pss");
    
    Log.d("MemoryDetail", String.format(
        "Java Heap: %dKB, Native Heap: %dKB, Code: %dKB, " +
        "Stack: %dKB, Graphics: %dKB, Total PSS: %dKB",
        javaHeap, nativeHeap, code, stack, graphics, totalPss));
}
```


### 3.4 LMK 相关源码分析

```java
/**
 * ProcessList.java - 进程优先级管理
 * 源码位置: frameworks/base/services/core/java/com/android/server/am/ProcessList.java
 */
public final class ProcessList {
    
    // ==================== oom_adj 常量定义 ====================
    
    /** 不可见的缓存进程 (最容易被杀) */
    static final int CACHED_APP_MAX_ADJ = 999;
    static final int CACHED_APP_MIN_ADJ = 900;
    
    /** 服务 B 类进程 */
    static final int SERVICE_B_ADJ = 800;
    
    /** 上一个应用进程 */
    static final int PREVIOUS_APP_ADJ = 700;
    
    /** Home 桌面进程 */
    static final int HOME_APP_ADJ = 600;
    
    /** 服务进程 */
    static final int SERVICE_ADJ = 500;
    
    /** 重量级后台进程 */
    static final int HEAVY_WEIGHT_APP_ADJ = 400;
    
    /** 备份进程 */
    static final int BACKUP_APP_ADJ = 300;
    
    /** 可感知进程 (如后台音乐播放) */
    static final int PERCEPTIBLE_APP_ADJ = 200;
    
    /** 可见进程 (如弹窗后面的 Activity) */
    static final int VISIBLE_APP_ADJ = 100;
    
    /** 可感知的最近任务进程 */
    static final int PERCEPTIBLE_RECENT_FOREGROUND_APP_ADJ = 50;
    
    /** 前台进程 (用户正在交互) */
    static final int FOREGROUND_APP_ADJ = 0;
    
    /** 持久化进程 */
    static final int PERSISTENT_SERVICE_ADJ = -700;
    static final int PERSISTENT_PROC_ADJ = -800;
    
    /** 系统进程 */
    static final int SYSTEM_ADJ = -900;
    
    /** Native 进程 (不会被杀) */
    static final int NATIVE_ADJ = -1000;
    
    // ==================== LMK 阈值配置 ====================
    
    /** 
     * minfree 阈值数组 (单位: 4KB 页)
     * 对应不同 adj 级别的内存阈值
     */
    private final int[] mOomMinFree = new int[]{
        // 前台进程阈值
        12288,   // 48MB - FOREGROUND_APP_ADJ
        // 可见进程阈值
        18432,   // 72MB - VISIBLE_APP_ADJ
        // 可感知进程阈值
        24576,   // 96MB - PERCEPTIBLE_APP_ADJ
        // 备份进程阈值
        36864,   // 144MB - BACKUP_APP_ADJ
        // 缓存进程阈值
        49152,   // 192MB - CACHED_APP_MIN_ADJ
        // 空进程阈值
        61440    // 240MB - CACHED_APP_MAX_ADJ
    };
    
    /**
     * 更新进程的 oom_adj 值
     * 写入 /proc/<pid>/oom_score_adj
     */
    public static void setOomAdj(int pid, int uid, int amt) {
        // 边界检查
        if (amt == UNKNOWN_ADJ) {
            return;
        }
        
        long start = SystemClock.elapsedRealtime();
        ByteBuffer buf = ByteBuffer.allocate(4 * 3);
        buf.putInt(LMK_PROCPRIO);  // 命令类型
        buf.putInt(pid);           // 进程 ID
        buf.putInt(uid);           // 用户 ID
        buf.putInt(amt);           // oom_adj 值
        
        // 通过 socket 发送给 lmkd 守护进程
        writeLmkd(buf, null);
        
        long now = SystemClock.elapsedRealtime();
        if ((now - start) > 250) {
            Slog.w(TAG, "SLOW OOM ADJ: " + (now - start) + "ms for pid " + pid 
                    + " = " + amt);
        }
    }
}

/**
 * OomAdjuster.java - oom_adj 计算器
 * 源码位置: frameworks/base/services/core/java/com/android/server/am/OomAdjuster.java
 */
public class OomAdjuster {
    
    /**
     * 计算进程的 oom_adj 值
     * 这是 LMK 决定杀死哪个进程的核心依据
     */
    private boolean computeOomAdjLSP(ProcessRecord app, int cachedAdj,
            ProcessRecord topApp, boolean doingAll, long now,
            boolean cycleReEval, boolean computeClients) {
        
        // 1. 检查是否是系统进程
        if (app.isPersistent()) {
            app.setAdj(ProcessList.PERSISTENT_PROC_ADJ);
            app.setCurSchedGroup(ProcessList.SCHED_GROUP_DEFAULT);
            return false;
        }
        
        // 2. 检查是否是前台进程
        if (app == topApp) {
            // 正在与用户交互的进程
            app.setAdj(ProcessList.FOREGROUND_APP_ADJ);
            app.setCurSchedGroup(ProcessList.SCHED_GROUP_TOP_APP);
            return false;
        }
        
        // 3. 检查是否有前台服务
        if (app.hasForegroundServices()) {
            // 有前台服务的进程
            app.setAdj(ProcessList.PERCEPTIBLE_APP_ADJ);
            return false;
        }
        
        // 4. 检查是否有可见 Activity
        for (int i = app.mWindowProcessController.mActivities.size() - 1; i >= 0; i--) {
            ActivityRecord r = app.mWindowProcessController.mActivities.get(i);
            if (r.isVisible()) {
                // 有可见 Activity
                app.setAdj(ProcessList.VISIBLE_APP_ADJ);
                return false;
            }
        }
        
        // 5. 检查是否是上一个应用
        if (app == mService.mPreviousProcess && app.hasActivities()) {
            app.setAdj(ProcessList.PREVIOUS_APP_ADJ);
            return false;
        }
        
        // 6. 检查是否有服务绑定
        // ... 复杂的服务绑定计算逻辑
        
        // 7. 默认为缓存进程
        app.setAdj(cachedAdj);
        return true;
    }
}
```

### 3.5 内存回调机制源码

```java
/**
 * ComponentCallbacks2 - 内存回调接口
 * 源码位置: frameworks/base/core/java/android/content/ComponentCallbacks2.java
 */
public interface ComponentCallbacks2 extends ComponentCallbacks {
    
    // ==================== 内存级别常量 ====================
    
    /**
     * 进程处于后台 LRU 列表的开始位置
     * 虽然不会立即被杀，但系统已开始回收内存
     */
    static final int TRIM_MEMORY_BACKGROUND = 40;
    
    /**
     * 进程处于后台 LRU 列表的中间位置
     * 应该释放不需要的资源
     */
    static final int TRIM_MEMORY_MODERATE = 60;
    
    /**
     * 进程处于后台 LRU 列表的末尾
     * 即将被杀死，应该释放所有可释放的资源
     */
    static final int TRIM_MEMORY_COMPLETE = 80;
    
    /**
     * 进程正在运行且不可被杀死
     * 但系统内存不足，应该释放不需要的资源
     */
    static final int TRIM_MEMORY_RUNNING_MODERATE = 5;
    
    /**
     * 进程正在运行且不可被杀死
     * 系统内存很低，应该释放更多资源
     */
    static final int TRIM_MEMORY_RUNNING_LOW = 10;
    
    /**
     * 进程正在运行且不可被杀死
     * 系统内存极低，应该释放所有不必要的资源
     */
    static final int TRIM_MEMORY_RUNNING_CRITICAL = 15;
    
    /**
     * 进程的 UI 已经隐藏
     * 这是释放 UI 相关资源的好时机
     */
    static final int TRIM_MEMORY_UI_HIDDEN = 20;
    
    /**
     * 内存回调方法
     * @param level 内存级别
     */
    void onTrimMemory(int level);
}

/**
 * Application 中处理内存回调
 */
public class MyApplication extends Application {
    
    @Override
    public void onTrimMemory(int level) {
        super.onTrimMemory(level);
        
        switch (level) {
            case TRIM_MEMORY_UI_HIDDEN:
                // UI 隐藏，释放 UI 相关资源
                releaseUIResources();
                break;
                
            case TRIM_MEMORY_RUNNING_MODERATE:
            case TRIM_MEMORY_RUNNING_LOW:
                // 前台运行但内存不足，释放非必要缓存
                clearNonEssentialCache();
                break;
                
            case TRIM_MEMORY_RUNNING_CRITICAL:
                // 前台运行但内存极低，释放所有缓存
                clearAllCache();
                break;
                
            case TRIM_MEMORY_BACKGROUND:
                // 后台进程，开始释放资源
                releaseBackgroundResources();
                break;
                
            case TRIM_MEMORY_MODERATE:
                // 后台进程，内存中等紧张
                releaseMoreResources();
                break;
                
            case TRIM_MEMORY_COMPLETE:
                // 后台进程，即将被杀
                releaseAllResources();
                break;
        }
    }
    
    @Override
    public void onLowMemory() {
        super.onLowMemory();
        // 系统内存极低，释放所有可释放的资源
        // 这是最后的警告，之后可能被杀死
        releaseAllResources();
    }
    
    private void releaseUIResources() {
        // 释放 UI 相关资源
        // 如 Bitmap 缓存、View 缓存等
    }
    
    private void clearNonEssentialCache() {
        // 清除非必要缓存
        // 如图片缓存、网络缓存等
    }
    
    private void clearAllCache() {
        // 清除所有缓存
    }
    
    private void releaseBackgroundResources() {
        // 释放后台资源
    }
    
    private void releaseMoreResources() {
        // 释放更多资源
    }
    
    private void releaseAllResources() {
        // 释放所有可释放的资源
    }
}
```


## 4. 实战应用

### 4.1 内存分析工具

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    内存分析工具对比                                      │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌────────────────┬──────────────┬──────────────┬────────────────────┐ │
│  │     工具       │    类型      │    优点      │      适用场景      │ │
│  ├────────────────┼──────────────┼──────────────┼────────────────────┤ │
│  │ Memory Profiler│  Android     │  实时监控    │  日常开发调试      │ │
│  │ (AS 内置)      │  Studio      │  可视化好    │  快速定位问题      │ │
│  ├────────────────┼──────────────┼──────────────┼────────────────────┤ │
│  │ MAT            │  独立工具    │  功能强大    │  深度分析          │ │
│  │ (Eclipse)      │              │  支持 OQL    │  复杂泄漏排查      │ │
│  ├────────────────┼──────────────┼──────────────┼────────────────────┤ │
│  │ LeakCanary     │  三方库      │  自动检测    │  开发阶段          │ │
│  │                │              │  无需手动    │  内存泄漏检测      │ │
│  ├────────────────┼──────────────┼──────────────┼────────────────────┤ │
│  │ dumpsys        │  命令行      │  无需工具    │  线上问题排查      │ │
│  │ meminfo        │              │  信息全面    │  快速查看内存      │ │
│  ├────────────────┼──────────────┼──────────────┼────────────────────┤ │
│  │ Perfetto       │  系统级      │  精度最高    │  系统级分析        │ │
│  │                │              │  信息最全    │  性能优化          │ │
│  └────────────────┴──────────────┴──────────────┴────────────────────┘ │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 4.2 Memory Profiler 使用

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    Memory Profiler 功能详解                              │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  主要功能:                                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  1. 实时内存监控                                                │   │
│  │     • 查看 Java Heap、Native Heap、Graphics 等内存变化          │   │
│  │     • 观察内存分配和回收趋势                                    │   │
│  │     • 识别内存抖动 (频繁分配回收)                               │   │
│  │                                                                 │   │
│  │  2. Heap Dump 分析                                              │   │
│  │     • 捕获某一时刻的堆快照                                      │   │
│  │     • 查看所有对象及其引用关系                                  │   │
│  │     • 按类名、包名、大小排序                                    │   │
│  │                                                                 │   │
│  │  3. Allocation Tracking                                         │   │
│  │     • 记录一段时间内的内存分配                                  │   │
│  │     • 查看分配调用栈                                            │   │
│  │     • 定位频繁分配的代码                                        │   │
│  │                                                                 │   │
│  │  4. 内存泄漏检测                                                │   │
│  │     • 自动检测 Activity/Fragment 泄漏                           │   │
│  │     • 显示泄漏对象的引用链                                      │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  使用步骤:                                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  1. 打开 Android Studio → View → Tool Windows → Profiler        │   │
│  │  2. 选择设备和进程                                              │   │
│  │  3. 点击 Memory 区域进入内存分析                                │   │
│  │  4. 点击 "Capture heap dump" 捕获堆快照                         │   │
│  │  5. 分析对象分布和引用关系                                      │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 4.3 MAT (Memory Analyzer Tool) 使用

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    MAT 工具使用指南                                      │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  获取 HPROF 文件:                                                       │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  方法1: Android Studio Memory Profiler 导出                     │   │
│  │  方法2: adb shell am dumpheap <pid> /data/local/tmp/heap.hprof  │   │
│  │  方法3: Debug.dumpHprofData(filePath) 代码触发                  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  转换 HPROF 格式:                                                       │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  # Android HPROF 需要转换为标准格式                             │   │
│  │  hprof-conv input.hprof output.hprof                            │   │
│  │                                                                 │   │
│  │  # hprof-conv 位于 Android SDK platform-tools 目录              │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  MAT 核心功能:                                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  1. Histogram (直方图)                                          │   │
│  │     • 按类统计对象数量和大小                                    │   │
│  │     • 快速发现异常多的对象                                      │   │
│  │                                                                 │   │
│  │  2. Dominator Tree (支配树)                                     │   │
│  │     • 显示对象的支配关系                                        │   │
│  │     • 找出占用内存最多的对象                                    │   │
│  │                                                                 │   │
│  │  3. Leak Suspects (泄漏嫌疑)                                    │   │
│  │     • 自动分析可能的内存泄漏                                    │   │
│  │     • 生成泄漏报告                                              │   │
│  │                                                                 │   │
│  │  4. OQL (Object Query Language)                                 │   │
│  │     • 使用类 SQL 语法查询对象                                   │   │
│  │     • 灵活筛选目标对象                                          │   │
│  │                                                                 │   │
│  │  5. Path to GC Roots                                            │   │
│  │     • 查看对象到 GC Root 的引用链                               │   │
│  │     • 定位泄漏原因                                              │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  常用 OQL 查询:                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  # 查找所有 Activity 实例                                       │   │
│  │  SELECT * FROM instanceof android.app.Activity                  │   │
│  │                                                                 │   │
│  │  # 查找所有 Bitmap 实例                                         │   │
│  │  SELECT * FROM android.graphics.Bitmap                          │   │
│  │                                                                 │   │
│  │  # 查找大于 1MB 的对象                                          │   │
│  │  SELECT * FROM INSTANCEOF java.lang.Object o                    │   │
│  │  WHERE o.@retainedHeapSize > 1048576                            │   │
│  │                                                                 │   │
│  │  # 查找特定包名的类                                             │   │
│  │  SELECT * FROM "com.example.app.*"                              │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 4.4 dumpsys meminfo 命令

```bash
# ==================== dumpsys meminfo 使用 ====================

# 查看所有进程内存概览
adb shell dumpsys meminfo

# 查看指定应用的详细内存信息
adb shell dumpsys meminfo com.example.app

# 输出示例:
# Applications Memory Usage (in Kilobytes):
# Uptime: 123456789 Realtime: 123456789
#
# ** MEMINFO in pid 12345 [com.example.app] **
#                    Pss  Private  Private  SwapPss     Heap     Heap     Heap
#                  Total    Dirty    Clean    Dirty     Size    Alloc     Free
#                 ------   ------   ------   ------   ------   ------   ------
#   Native Heap    15234    15180       0        0    32768    28456     4312
#   Dalvik Heap    12456    12400       0        0    24576    18234     6342
#  Dalvik Other     1234     1200       0        0
#         Stack      512      512       0        0
#        Ashmem      128      128       0        0
#       Gfx dev     8192     8192       0        0
#     Other dev       12        0      12        0
#      .so mmap     4567      234     2345        0
#     .jar mmap      123        0       0        0
#     .apk mmap     2345        0     1234        0
#     .ttf mmap      456        0      234        0
#     .dex mmap     3456       12     2345        0
#     .oat mmap     1234        0      567        0
#     .art mmap     2345     1234      456        0
#    Other mmap      567       12      234        0
#     GL mtrack    12345    12345       0        0
#       Unknown     1234     1200       0        0
#
#         TOTAL    66440    52649     7427        0    57344    46690    10654
#
#  App Summary
#                        Pss(KB)
#                         ------
#            Java Heap:    13634
#          Native Heap:    15180
#                 Code:     6789
#                Stack:      512
#             Graphics:    20537
#        Private Other:     2456
#               System:     7332
#
#                TOTAL:    66440       TOTAL SWAP PSS:        0

# 关键指标解读:
# - Java Heap: Java 堆内存，受 heapgrowthlimit 限制
# - Native Heap: Native 堆内存，Bitmap 像素数据 (Android 8.0+)
# - Code: 代码占用内存 (.so, .dex, .oat 等)
# - Stack: 线程栈内存
# - Graphics: 图形相关内存 (GL, GPU)
# - Private Other: 其他私有内存
# - System: 系统共享内存

# 查看系统整体内存状态
adb shell dumpsys meminfo -s

# 查看内存按进程排序
adb shell dumpsys meminfo --sort pss

# 查看 Native 内存详情
adb shell dumpsys meminfo -a com.example.app
```

### 4.5 内存监控最佳实践

```kotlin
/**
 * 内存监控工具类
 * 用于实时监控应用内存状态
 */
object MemoryMonitor {
    
    private const val TAG = "MemoryMonitor"
    
    /**
     * 获取当前内存状态
     */
    fun getMemoryStatus(context: Context): MemoryStatus {
        val activityManager = context.getSystemService(Context.ACTIVITY_SERVICE) 
            as ActivityManager
        
        // 系统内存信息
        val systemMemInfo = ActivityManager.MemoryInfo()
        activityManager.getMemoryInfo(systemMemInfo)
        
        // 应用内存信息
        val runtime = Runtime.getRuntime()
        val javaMax = runtime.maxMemory()
        val javaTotal = runtime.totalMemory()
        val javaFree = runtime.freeMemory()
        val javaUsed = javaTotal - javaFree
        
        // 详细内存信息
        val debugMemInfo = Debug.MemoryInfo()
        Debug.getMemoryInfo(debugMemInfo)
        
        return MemoryStatus(
            // 系统内存
            systemAvailable = systemMemInfo.availMem,
            systemTotal = systemMemInfo.totalMem,
            systemLowMemory = systemMemInfo.lowMemory,
            
            // Java Heap
            javaHeapMax = javaMax,
            javaHeapUsed = javaUsed,
            javaHeapFree = javaMax - javaUsed,
            
            // PSS 内存
            totalPss = debugMemInfo.totalPss * 1024L,
            javaPss = debugMemInfo.getMemoryStat("summary.java-heap").toLong() * 1024,
            nativePss = debugMemInfo.getMemoryStat("summary.native-heap").toLong() * 1024,
            graphicsPss = debugMemInfo.getMemoryStat("summary.graphics").toLong() * 1024
        )
    }
    
    /**
     * 打印内存状态日志
     */
    fun logMemoryStatus(context: Context) {
        val status = getMemoryStatus(context)
        
        Log.i(TAG, """
            |==================== 内存状态 ====================
            |系统内存: ${formatSize(status.systemAvailable)} / ${formatSize(status.systemTotal)}
            |系统低内存: ${status.systemLowMemory}
            |--------------------------------------------------
            |Java Heap: ${formatSize(status.javaHeapUsed)} / ${formatSize(status.javaHeapMax)}
            |Java Heap 使用率: ${status.javaHeapUsed * 100 / status.javaHeapMax}%
            |--------------------------------------------------
            |Total PSS: ${formatSize(status.totalPss)}
            |Java PSS: ${formatSize(status.javaPss)}
            |Native PSS: ${formatSize(status.nativePss)}
            |Graphics PSS: ${formatSize(status.graphicsPss)}
            |==================================================
        """.trimMargin())
    }
    
    /**
     * 检查是否接近 OOM
     */
    fun isNearOOM(context: Context, threshold: Float = 0.85f): Boolean {
        val runtime = Runtime.getRuntime()
        val used = runtime.totalMemory() - runtime.freeMemory()
        val max = runtime.maxMemory()
        return used.toFloat() / max > threshold
    }
    
    /**
     * 格式化内存大小
     */
    private fun formatSize(bytes: Long): String {
        return when {
            bytes >= 1024 * 1024 * 1024 -> 
                String.format("%.2f GB", bytes / (1024.0 * 1024 * 1024))
            bytes >= 1024 * 1024 -> 
                String.format("%.2f MB", bytes / (1024.0 * 1024))
            bytes >= 1024 -> 
                String.format("%.2f KB", bytes / 1024.0)
            else -> "$bytes B"
        }
    }
    
    /**
     * 内存状态数据类
     */
    data class MemoryStatus(
        // 系统内存
        val systemAvailable: Long,
        val systemTotal: Long,
        val systemLowMemory: Boolean,
        
        // Java Heap
        val javaHeapMax: Long,
        val javaHeapUsed: Long,
        val javaHeapFree: Long,
        
        // PSS 内存
        val totalPss: Long,
        val javaPss: Long,
        val nativePss: Long,
        val graphicsPss: Long
    )
}

/**
 * 在 Application 中注册内存监控
 */
class MyApplication : Application() {
    
    override fun onCreate() {
        super.onCreate()
        
        // 定期打印内存状态 (仅 Debug 模式)
        if (BuildConfig.DEBUG) {
            val handler = Handler(Looper.getMainLooper())
            handler.postDelayed(object : Runnable {
                override fun run() {
                    MemoryMonitor.logMemoryStatus(this@MyApplication)
                    handler.postDelayed(this, 30_000) // 每 30 秒打印一次
                }
            }, 10_000)
        }
    }
    
    override fun onTrimMemory(level: Int) {
        super.onTrimMemory(level)
        
        // 记录内存回调
        Log.w("Memory", "onTrimMemory: level=$level")
        MemoryMonitor.logMemoryStatus(this)
        
        // 根据级别释放资源
        when (level) {
            TRIM_MEMORY_UI_HIDDEN -> {
                // 释放 UI 资源
            }
            TRIM_MEMORY_RUNNING_LOW,
            TRIM_MEMORY_RUNNING_CRITICAL -> {
                // 清理缓存
                clearImageCache()
            }
            TRIM_MEMORY_BACKGROUND,
            TRIM_MEMORY_MODERATE,
            TRIM_MEMORY_COMPLETE -> {
                // 释放所有可释放资源
                clearAllCache()
            }
        }
    }
    
    private fun clearImageCache() {
        // 清理图片缓存
    }
    
    private fun clearAllCache() {
        // 清理所有缓存
    }
}
```


## 5. 常见面试题

### 面试题 1：请详细介绍 Android 的内存模型，以及 Java Heap 和 Native Heap 的区别？

**答案要点：**

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    Java Heap vs Native Heap                              │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌────────────────────┬─────────────────────┬─────────────────────────┐│
│  │       特性         │     Java Heap       │      Native Heap        ││
│  ├────────────────────┼─────────────────────┼─────────────────────────┤│
│  │  管理方式          │  ART 虚拟机管理     │  malloc/free 手动管理   ││
│  │  大小限制          │  受 heapgrowthlimit │  受系统内存限制         ││
│  │                    │  限制 (如 256MB)    │  理论上无上限           ││
│  │  存储内容          │  Java/Kotlin 对象   │  Native 对象、Bitmap    ││
│  │                    │                     │  像素数据 (8.0+)        ││
│  │  内存回收          │  GC 自动回收        │  需手动释放或析构       ││
│  │  OOM 触发          │  超过限制触发 OOM   │  系统内存不足时触发     ││
│  │  分析工具          │  Memory Profiler    │  Native 内存分析工具    ││
│  │                    │  MAT                │  AddressSanitizer       ││
│  └────────────────────┴─────────────────────┴─────────────────────────┘│
│                                                                         │
│  Android 8.0 Bitmap 内存变化:                                           │
│  • 8.0 之前: Bitmap 像素数据存储在 Java Heap                            │
│  • 8.0 及之后: Bitmap 像素数据存储在 Native Heap                        │
│  • 好处: 不占用 Java Heap 配额，减少 OOM 风险                           │
│  • 注意: 仍需关注 Native 内存泄漏                                       │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

**深入追问：为什么 Android 8.0 要把 Bitmap 像素数据移到 Native Heap？**

- Java Heap 有大小限制，大量 Bitmap 容易触发 OOM
- Native Heap 不受 Java Heap 限制，可以使用更多内存
- Native 内存分配效率更高
- 配合 Hardware Bitmap，可以直接在 GPU 内存中存储

---

### 面试题 2：请详细解释 Low Memory Killer (LMK) 的工作原理，以及进程优先级是如何确定的？

**答案要点：**

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    LMK 工作原理                                          │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  1. LMK 概述:                                                           │
│     • Android 特有的内存管理机制，基于 Linux OOM Killer 改进            │
│     • 在内存不足时按优先级杀死进程，释放内存                            │
│     • Android 10+ 使用用户空间 lmkd 守护进程替代内核 LMK                │
│                                                                         │
│  2. 进程优先级 (oom_adj/oom_score_adj):                                 │
│     • 值越小，优先级越高，越不容易被杀                                  │
│     • 前台进程: 0 (最高保护)                                            │
│     • 可见进程: 100                                                     │
│     • 服务进程: 500                                                     │
│     • 缓存进程: 900 (最容易被杀)                                        │
│                                                                         │
│  3. 优先级计算因素:                                                     │
│     • 是否有前台 Activity                                               │
│     • 是否有前台服务                                                    │
│     • 是否有可见 Activity                                               │
│     • 是否被其他进程绑定                                                │
│     • 最近使用时间                                                      │
│                                                                         │
│  4. LMK 触发条件:                                                       │
│     • 系统可用内存低于设定阈值                                          │
│     • 不同阈值对应不同 adj 级别                                         │
│     • 优先杀死 adj 值最大的进程                                         │
│     • 同 adj 优先杀死内存占用最大的进程                                 │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

**深入追问：如何提高应用的进程优先级，减少被杀的概率？**

- 使用前台服务 (Foreground Service)
- 保持 Activity 可见
- 被系统服务绑定
- 减少内存占用
- 注意：不推荐使用各种保活黑科技，影响用户体验

---

### 面试题 3：请解释 PSS、RSS、USS 的区别，为什么 PSS 是最常用的内存指标？

**答案要点：**

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    内存指标详解                                          │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  1. 各指标定义:                                                         │
│     • VSS (Virtual Set Size): 虚拟内存大小，包含未分配的虚拟地址空间    │
│     • RSS (Resident Set Size): 常驻内存，实际占用的物理内存             │
│     • PSS (Proportional Set Size): 比例内存，私有内存 + 共享内存/N      │
│     • USS (Unique Set Size): 独占内存，进程独占的物理内存               │
│                                                                         │
│  2. 大小关系: VSS >= RSS >= PSS >= USS                                  │
│                                                                         │
│  3. 为什么 PSS 最常用:                                                  │
│     • RSS 问题: 共享内存被重复计算，所有进程 RSS 之和 > 实际物理内存    │
│     • USS 问题: 不包含共享内存，无法反映进程真实内存贡献                │
│     • PSS 优势: 按比例分摊共享内存，所有进程 PSS 之和 ≈ 实际物理内存   │
│                                                                         │
│  4. 示例说明:                                                           │
│     假设进程 A 和 B 共享 10MB 的 libc.so:                               │
│     • A 的 RSS = A 私有内存 + 10MB (共享库全部)                         │
│     • A 的 PSS = A 私有内存 + 5MB (共享库的一半)                        │
│     • A 的 USS = A 私有内存 (不包含共享库)                              │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

**深入追问：如何获取应用的 PSS 内存？**

```kotlin
// 方法1: Debug.MemoryInfo
val memInfo = Debug.MemoryInfo()
Debug.getMemoryInfo(memInfo)
val totalPss = memInfo.totalPss // 单位 KB

// 方法2: ActivityManager
val am = getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager
val memInfos = am.getProcessMemoryInfo(intArrayOf(Process.myPid()))
val pss = memInfos[0].totalPss // 单位 KB

// 方法3: dumpsys 命令
// adb shell dumpsys meminfo com.example.app
```

---

### 面试题 4：Android 应用的 Java Heap 大小限制是多少？如何获取？largeHeap 有什么作用？

**答案要点：**

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    Java Heap 限制详解                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  1. 堆大小限制:                                                         │
│     • 由系统属性 dalvik.vm.heapgrowthlimit 决定                         │
│     • 不同设备不同，通常 256MB - 512MB                                  │
│     • 超过限制会触发 OOM                                                │
│                                                                         │
│  2. 获取堆限制:                                                         │
│     // 普通应用堆限制                                                   │
│     val normalHeap = activityManager.getMemoryClass() // 单位 MB        │
│                                                                         │
│     // 大堆应用限制                                                     │
│     val largeHeap = activityManager.getLargeMemoryClass() // 单位 MB    │
│                                                                         │
│     // 当前应用实际堆限制                                               │
│     val maxHeap = Runtime.getRuntime().maxMemory() // 单位 bytes        │
│                                                                         │
│  3. largeHeap 作用:                                                     │
│     • 在 AndroidManifest.xml 中声明: android:largeHeap="true"           │
│     • 可以使用更大的堆内存 (heapsize 而非 heapgrowthlimit)              │
│     • 通常是普通限制的 2-4 倍                                           │
│                                                                         │
│  4. largeHeap 注意事项:                                                 │
│     • 不推荐滥用，会影响系统整体性能                                    │
│     • 增加 GC 时间，可能导致卡顿                                        │
│     • 应该优先优化内存使用，而非增加限制                                │
│     • 适用场景: 图片编辑、视频处理等确实需要大内存的应用                │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

### 面试题 5：请介绍 onTrimMemory() 回调的各个级别，以及应该如何响应？

**答案要点：**

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    onTrimMemory 级别详解                                 │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  前台运行时的级别:                                                      │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  TRIM_MEMORY_RUNNING_MODERATE (5)                               │   │
│  │  • 系统内存开始不足                                             │   │
│  │  • 建议: 释放非必要缓存                                         │   │
│  │                                                                 │   │
│  │  TRIM_MEMORY_RUNNING_LOW (10)                                   │   │
│  │  • 系统内存较低                                                 │   │
│  │  • 建议: 释放更多缓存                                           │   │
│  │                                                                 │   │
│  │  TRIM_MEMORY_RUNNING_CRITICAL (15)                              │   │
│  │  • 系统内存极低                                                 │   │
│  │  • 建议: 释放所有非必要资源                                     │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  UI 隐藏时:                                                             │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  TRIM_MEMORY_UI_HIDDEN (20)                                     │   │
│  │  • 应用 UI 不再可见                                             │   │
│  │  • 建议: 释放 UI 相关资源 (如大图缓存)                          │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  后台运行时的级别:                                                      │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  TRIM_MEMORY_BACKGROUND (40)                                    │   │
│  │  • 进程在后台 LRU 列表开始位置                                  │   │
│  │  • 建议: 释放可重建的资源                                       │   │
│  │                                                                 │   │
│  │  TRIM_MEMORY_MODERATE (60)                                      │   │
│  │  • 进程在后台 LRU 列表中间位置                                  │   │
│  │  • 建议: 释放更多资源                                           │   │
│  │                                                                 │   │
│  │  TRIM_MEMORY_COMPLETE (80)                                      │   │
│  │  • 进程在后台 LRU 列表末尾，即将被杀                            │   │
│  │  • 建议: 释放所有可释放的资源                                   │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  最佳实践:                                                              │
│  • 在 Application、Activity、Service、Fragment 中都可以接收回调        │
│  • 根据级别渐进式释放资源                                               │
│  • 配合图片加载框架 (如 Glide) 的 trimMemory 方法                       │
│  • 清理自定义缓存 (如 LruCache)                                         │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

### 面试题 6：如何使用 Memory Profiler 和 MAT 分析内存问题？请描述具体步骤。

**答案要点：**

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    内存分析工具使用步骤                                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  Memory Profiler 使用步骤:                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  1. 打开 Android Studio → View → Tool Windows → Profiler        │   │
│  │  2. 选择设备和目标进程                                          │   │
│  │  3. 点击 Memory 区域进入内存分析界面                            │   │
│  │  4. 观察内存曲线，识别内存增长趋势                              │   │
│  │  5. 点击 "Capture heap dump" 捕获堆快照                         │   │
│  │  6. 在 Heap Dump 中按 "Retained Size" 排序                      │   │
│  │  7. 查找异常大的对象或数量异常多的对象                          │   │
│  │  8. 右键选择 "Jump to Source" 定位代码                          │   │
│  │  9. 使用 "Show nearest GC root" 查看引用链                      │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  MAT 使用步骤:                                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  1. 获取 HPROF 文件 (Memory Profiler 导出或 adb 命令)           │   │
│  │  2. 使用 hprof-conv 转换格式                                    │   │
│  │  3. 用 MAT 打开转换后的文件                                     │   │
│  │  4. 查看 "Leak Suspects" 自动分析报告                           │   │
│  │  5. 使用 "Histogram" 查看对象分布                               │   │
│  │  6. 使用 "Dominator Tree" 查看内存占用大户                      │   │
│  │  7. 右键选择 "Path to GC Roots" 查看引用链                      │   │
│  │  8. 使用 OQL 查询特定对象                                       │   │
│  │     例: SELECT * FROM instanceof android.app.Activity           │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  常见问题定位:                                                          │
│  • Activity 泄漏: 查找 Activity 实例数量是否异常                       │
│  • Bitmap 泄漏: 查找 Bitmap 对象及其引用链                             │
│  • 集合泄漏: 查找异常大的 ArrayList、HashMap 等                        │
│  • 监听器泄漏: 查找未注销的 Listener、Callback                         │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

### 面试题 7：(OPPO/vivo 重点) 请从 Framework 源码角度分析 AMS 是如何管理进程优先级的？

**答案要点：**

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    AMS 进程优先级管理源码分析                            │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  核心类:                                                                │
│  • ProcessList.java: 定义 oom_adj 常量和阈值                            │
│  • OomAdjuster.java: 计算进程的 oom_adj 值                              │
│  • ProcessRecord.java: 进程信息记录                                     │
│                                                                         │
│  优先级计算流程:                                                        │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  1. AMS 在以下时机触发优先级更新:                               │   │
│  │     • Activity 生命周期变化                                     │   │
│  │     • Service 状态变化                                          │   │
│  │     • 进程绑定关系变化                                          │   │
│  │                                                                 │   │
│  │  2. OomAdjuster.computeOomAdjLSP() 计算优先级:                  │   │
│  │     • 检查是否是系统进程 → SYSTEM_ADJ                           │   │
│  │     • 检查是否是前台进程 → FOREGROUND_APP_ADJ                   │   │
│  │     • 检查是否有前台服务 → PERCEPTIBLE_APP_ADJ                  │   │
│  │     • 检查是否有可见 Activity → VISIBLE_APP_ADJ                 │   │
│  │     • 检查服务绑定关系 → 根据绑定方优先级计算                   │   │
│  │     • 默认为缓存进程 → CACHED_APP_*_ADJ                         │   │
│  │                                                                 │   │
│  │  3. ProcessList.setOomAdj() 写入优先级:                         │   │
│  │     • 通过 socket 发送给 lmkd 守护进程                          │   │
│  │     • lmkd 写入 /proc/<pid>/oom_score_adj                       │   │
│  │                                                                 │   │
│  │  4. lmkd 根据内存压力杀死进程:                                  │   │
│  │     • 监控系统内存状态                                          │   │
│  │     • 内存低于阈值时，杀死高 adj 进程                           │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  关键源码路径:                                                          │
│  • frameworks/base/services/core/java/com/android/server/am/           │
│  • system/memory/lmkd/                                                  │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

### 面试题 8：Android 8.0 之后 Bitmap 内存管理有什么变化？这对内存优化有什么影响？

**答案要点：**

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    Bitmap 内存管理变化                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  Android 8.0 之前:                                                      │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  • Bitmap 像素数据存储在 Java Heap                              │   │
│  │  • 受 dalvik.vm.heapgrowthlimit 限制                            │   │
│  │  • 大量 Bitmap 容易触发 OOM                                     │   │
│  │  • 可以通过 Memory Profiler 直接看到 Bitmap 内存                │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  Android 8.0 及之后:                                                    │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  • Bitmap 像素数据存储在 Native Heap                            │   │
│  │  • 不受 Java Heap 限制，可以使用更多内存                        │   │
│  │  • 减少了 Java Heap OOM 的风险                                  │   │
│  │  • 需要关注 Native 内存泄漏                                     │   │
│  │  • GC 时会触发 Native 内存回收                                  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  对内存优化的影响:                                                      │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  优点:                                                          │   │
│  │  • Java Heap OOM 风险降低                                       │   │
│  │  • 可以加载更多/更大的图片                                      │   │
│  │  • Native 内存分配效率更高                                      │   │
│  │                                                                 │   │
│  │  注意事项:                                                      │   │
│  │  • 仍需关注总内存占用，避免被 LMK 杀死                          │   │
│  │  • Native 内存泄漏更难排查                                      │   │
│  │  • 需要使用 Native 内存分析工具                                 │   │
│  │  • dumpsys meminfo 中查看 Native Heap 大小                      │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  Hardware Bitmap (Android 8.0+):                                        │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  • 像素数据直接存储在 GPU 内存                                  │   │
│  │  • 渲染效率更高，无需 CPU 到 GPU 的数据传输                     │   │
│  │  • 不可修改像素数据                                             │   │
│  │  • Glide 默认使用 Hardware Bitmap                               │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 6. 总结

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    内存基础知识总结                                      │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  核心知识点:                                                            │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  1. Android 内存模型                                            │   │
│  │     • 应用层 → 运行时层 (ART) → Native 层 → 内核层 → 硬件层     │   │
│  │     • Java Heap + Native Heap + Code + Stack + Graphics         │   │
│  │                                                                 │   │
│  │  2. 进程内存分配                                                │   │
│  │     • Java Heap 受 heapgrowthlimit 限制                         │   │
│  │     • Native Heap 受系统内存限制                                │   │
│  │     • largeHeap 可以使用更大的堆                                │   │
│  │                                                                 │   │
│  │  3. Low Memory Killer                                           │   │
│  │     • 按 oom_adj 优先级杀死进程                                 │   │
│  │     • 前台进程优先级最高，缓存进程最低                          │   │
│  │     • Android 10+ 使用 lmkd 用户空间守护进程                    │   │
│  │                                                                 │   │
│  │  4. 内存指标                                                    │   │
│  │     • PSS 是最常用的指标                                        │   │
│  │     • VSS >= RSS >= PSS >= USS                                  │   │
│  │                                                                 │   │
│  │  5. 内存分析工具                                                │   │
│  │     • Memory Profiler: 实时监控、Heap Dump                      │   │
│  │     • MAT: 深度分析、OQL 查询                                   │   │
│  │     • dumpsys meminfo: 命令行快速查看                           │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  面试重点:                                                              │
│  • 字节/美团: 内存优化实战经验、工具使用                               │
│  • 快手: 大图加载、内存监控体系                                        │
│  • OPPO/vivo: LMK 源码、AMS 进程管理源码                               │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

*文档版本: v1.0*  
*更新时间: 2025-01-01*  
*适用版本: Android W*
