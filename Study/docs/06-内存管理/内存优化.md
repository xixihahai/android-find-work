# Android 内存优化

## 1. 概述

内存优化是 Android 性能优化的核心领域之一，直接影响应用的流畅度、稳定性和用户体验。在大厂面试中，内存优化是高频考点，尤其是 Bitmap 内存管理、缓存策略、大图加载等方面。

### 1.1 内存优化的重要性

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        内存优化的价值                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  用户体验影响:                                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  • 内存不足导致应用被系统杀死，用户需要重新启动                 │   │
│  │  • 频繁 GC 导致界面卡顿，影响流畅度                             │   │
│  │  • OOM 崩溃直接影响用户体验和应用评分                           │   │
│  │  • 内存占用过高影响其他应用运行                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  业务指标影响:                                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  • 内存优化 → 应用稳定性提升 → 用户留存率提升                   │   │
│  │  • 内存优化 → 减少 OOM 崩溃 → 崩溃率下降                        │   │
│  │  • 内存优化 → 减少被系统杀死 → 后台存活率提升                   │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  内存优化目标:                                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  • 降低内存峰值，避免 OOM                                       │   │
│  │  • 减少内存抖动，避免频繁 GC                                    │   │
│  │  • 及时释放不需要的内存                                         │   │
│  │  • 合理使用缓存，平衡内存与性能                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 1.2 内存优化核心方向

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      内存优化核心方向                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                     Bitmap 内存优化                             │   │
│  │  • Bitmap 内存计算与管理                                        │   │
│  │  • 采样压缩 (inSampleSize)                                      │   │
│  │  • Bitmap 复用 (inBitmap)                                       │   │
│  │  • 大图加载 (BitmapRegionDecoder)                               │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                           │                                             │
│                           ↓                                             │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                     缓存策略优化                                │   │
│  │  • LruCache 内存缓存                                            │   │
│  │  • DiskLruCache 磁盘缓存                                        │   │
│  │  • 多级缓存架构                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                           │                                             │
│                           ↓                                             │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                     对象复用优化                                │   │
│  │  • 对象池 (Object Pool)                                         │   │
│  │  • Message 复用池                                               │   │
│  │  • RecyclerView 复用机制                                        │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                           │                                             │
│                           ↓                                             │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                   图片加载框架优化                              │   │
│  │  • Glide 内存管理                                               │   │
│  │  • Coil 内存优化                                                │   │
│  │  • 自定义图片加载策略                                           │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```


## 2. 核心原理

### 2.1 Bitmap 内存计算

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      Bitmap 内存计算公式                                 │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  基本公式:                                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  内存大小 = 宽度 × 高度 × 每像素字节数                          │   │
│  │                                                                 │   │
│  │  例如: 1920 × 1080 × 4 (ARGB_8888) = 8,294,400 字节 ≈ 7.9 MB   │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  从资源加载时的计算公式:                                                │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  缩放后宽度 = 原始宽度 × (设备 DPI / 资源目录 DPI)              │   │
│  │  缩放后高度 = 原始高度 × (设备 DPI / 资源目录 DPI)              │   │
│  │                                                                 │   │
│  │  内存大小 = 缩放后宽度 × 缩放后高度 × 每像素字节数              │   │
│  │                                                                 │   │
│  │  例如: 100×100 图片放在 mdpi (160) 目录                         │   │
│  │       在 xxhdpi (480) 设备上加载:                               │   │
│  │       宽度 = 100 × (480/160) = 300                              │   │
│  │       高度 = 100 × (480/160) = 300                              │   │
│  │       内存 = 300 × 300 × 4 = 360,000 字节 = 351.5 KB            │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  像素格式与内存占用:                                                    │
│  ┌────────────────┬──────────────┬─────────────────────────────────┐   │
│  │    格式        │  每像素字节  │           说明                  │   │
│  ├────────────────┼──────────────┼─────────────────────────────────┤   │
│  │  ARGB_8888     │     4        │  默认格式，质量最高             │   │
│  ├────────────────┼──────────────┼─────────────────────────────────┤   │
│  │  RGB_565       │     2        │  无透明通道，内存减半           │   │
│  ├────────────────┼──────────────┼─────────────────────────────────┤   │
│  │  ARGB_4444     │     2        │  已废弃，质量差                 │   │
│  ├────────────────┼──────────────┼─────────────────────────────────┤   │
│  │  ALPHA_8       │     1        │  仅透明通道                     │   │
│  ├────────────────┼──────────────┼─────────────────────────────────┤   │
│  │  RGBA_F16      │     8        │  HDR 图片，Android 8.0+         │   │
│  ├────────────────┼──────────────┼─────────────────────────────────┤   │
│  │  HARDWARE      │     0*       │  存储在 GPU 内存，Android 8.0+  │   │
│  └────────────────┴──────────────┴─────────────────────────────────┘   │
│  * HARDWARE 格式不占用 Java Heap，但占用 GPU 内存                       │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.2 Bitmap 内存分配演进

```
┌─────────────────────────────────────────────────────────────────────────┐
│                   Bitmap 内存分配演进历史                                │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  Android 2.3 及以前:                                                    │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  • 像素数据存储在 Native 内存                                   │   │
│  │  • Bitmap 对象在 Java Heap                                      │   │
│  │  • 需要手动调用 recycle() 释放 Native 内存                      │   │
│  │  • GC 无法自动回收 Native 内存                                  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  Android 3.0 - 7.1:                                                     │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  • 像素数据存储在 Java Heap                                     │   │
│  │  • GC 可以自动回收                                              │   │
│  │  • 容易导致 OOM (占用 Java Heap 空间)                           │   │
│  │  • 支持 inBitmap 复用                                           │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  Android 8.0+:                                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  • 像素数据重新存储在 Native 内存                               │   │
│  │  • 使用 NativeAllocationRegistry 注册释放回调                   │   │
│  │  • GC 时自动释放 Native 内存                                    │   │
│  │  • 不再容易导致 Java Heap OOM                                   │   │
│  │  • 但仍需注意 Native 内存限制                                   │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  Android 8.0+ HARDWARE 配置:                                            │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  • 像素数据存储在 GPU 内存                                      │   │
│  │  • 不占用 Java Heap 和 Native Heap                              │   │
│  │  • 渲染效率更高                                                 │   │
│  │  • 限制: 不能获取/修改像素，不能在 Canvas 上绑制                │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.3 Bitmap 采样原理

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      Bitmap 采样原理                                     │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  inSampleSize 采样原理:                                                 │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  原始图片 (4000 × 3000)                                         │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │  ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ...          │   │   │
│  │  │  ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ...          │   │   │
│  │  │  ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ...          │   │   │
│  │  │  ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ...          │   │   │
│  │  │  ...                                                    │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │                           │                                     │   │
│  │                           ↓ inSampleSize = 4                    │   │
│  │                                                                 │   │
│  │  采样后图片 (1000 × 750)                                        │   │
│  │  ┌─────────────────────────────────┐                           │   │
│  │  │  ■   ■   ■   ■   ■   ...        │  每 4×4 像素取 1 个       │   │
│  │  │  ■   ■   ■   ■   ■   ...        │                           │   │
│  │  │  ■   ■   ■   ■   ■   ...        │  内存: 原来的 1/16        │   │
│  │  │  ...                            │                           │   │
│  │  └─────────────────────────────────┘                           │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  inSampleSize 规则:                                                     │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  • 必须是 2 的幂次方 (1, 2, 4, 8, 16...)                        │   │
│  │  • 非 2 的幂次方会向下取整到最近的 2 的幂次方                   │   │
│  │  • inSampleSize = 1 表示不采样                                  │   │
│  │  • 采样后尺寸 = 原始尺寸 / inSampleSize                         │   │
│  │  • 内存占用 = 原始内存 / (inSampleSize × inSampleSize)          │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.4 Bitmap 复用原理 (inBitmap)

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      inBitmap 复用原理                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  传统方式 (无复用):                                                     │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  加载图片A → 分配内存A → 使用 → 释放内存A                       │   │
│  │  加载图片B → 分配内存B → 使用 → 释放内存B                       │   │
│  │  加载图片C → 分配内存C → 使用 → 释放内存C                       │   │
│  │                                                                 │   │
│  │  问题: 频繁分配/释放内存，导致内存抖动和 GC                     │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  inBitmap 复用方式:                                                     │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  分配内存 (复用池)                                              │   │
│  │       │                                                         │   │
│  │       ↓                                                         │   │
│  │  加载图片A → 使用复用池内存 → 使用                              │   │
│  │       │                                                         │   │
│  │       ↓ (不释放，归还复用池)                                    │   │
│  │  加载图片B → 使用复用池内存 → 使用                              │   │
│  │       │                                                         │   │
│  │       ↓ (不释放，归还复用池)                                    │   │
│  │  加载图片C → 使用复用池内存 → 使用                              │   │
│  │                                                                 │   │
│  │  优势: 减少内存分配，避免内存抖动                               │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  inBitmap 使用条件:                                                     │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  Android 4.4 以前:                                              │   │
│  │  • 新图片尺寸必须与复用 Bitmap 完全相同                         │   │
│  │  • 像素格式必须相同                                             │   │
│  │                                                                 │   │
│  │  Android 4.4+:                                                  │   │
│  │  • 新图片字节数 ≤ 复用 Bitmap 的字节数                          │   │
│  │  • 像素格式必须相同 (或兼容)                                    │   │
│  │                                                                 │   │
│  │  通用条件:                                                      │   │
│  │  • 复用 Bitmap 必须是 mutable (可变的)                          │   │
│  │  • 复用 Bitmap 不能是 HARDWARE 配置                             │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```


### 2.5 大图加载原理 (BitmapRegionDecoder)

```
┌─────────────────────────────────────────────────────────────────────────┐
│                   BitmapRegionDecoder 原理                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  问题场景:                                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  • 加载超大图片 (如 10000 × 10000 像素的地图)                   │   │
│  │  • 完整加载需要 10000 × 10000 × 4 = 381 MB 内存                 │   │
│  │  • 直接加载会导致 OOM                                           │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  BitmapRegionDecoder 解决方案:                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  超大图片 (10000 × 10000)                                       │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │                                                         │   │   │
│  │  │     ┌───────────┐                                       │   │   │
│  │  │     │  可见区域  │  只加载可见区域                       │   │   │
│  │  │     │ 1080×1920 │  内存: 1080×1920×4 = 7.9 MB           │   │   │
│  │  │     └───────────┘                                       │   │   │
│  │  │                                                         │   │   │
│  │  │                                                         │   │   │
│  │  │                                                         │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │                                                                 │   │
│  │  原理:                                                          │   │
│  │  • 不将整张图片加载到内存                                       │   │
│  │  • 只解码用户可见的区域                                         │   │
│  │  • 用户滑动时，动态解码新的可见区域                             │   │
│  │  • 配合手势缩放，实现大图浏览                                   │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  工作流程:                                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  1. 创建 BitmapRegionDecoder (不加载像素数据)                   │   │
│  │       │                                                         │   │
│  │       ↓                                                         │   │
│  │  2. 获取图片原始尺寸                                            │   │
│  │       │                                                         │   │
│  │       ↓                                                         │   │
│  │  3. 根据可见区域计算需要解码的 Rect                             │   │
│  │       │                                                         │   │
│  │       ↓                                                         │   │
│  │  4. 调用 decodeRegion(rect, options) 解码指定区域               │   │
│  │       │                                                         │   │
│  │       ↓                                                         │   │
│  │  5. 显示解码后的 Bitmap                                         │   │
│  │       │                                                         │   │
│  │       ↓                                                         │   │
│  │  6. 用户滑动/缩放时，重复步骤 3-5                               │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.6 LruCache 原理

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        LruCache 原理                                     │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  LRU (Least Recently Used) 算法:                                        │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  核心思想: 最近最少使用的数据最先被淘汰                         │   │
│  │                                                                 │   │
│  │  数据结构: LinkedHashMap (accessOrder = true)                   │   │
│  │                                                                 │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │  最近使用 ←──────────────────────────────→ 最久未使用   │   │   │
│  │  │                                                         │   │   │
│  │  │  [D] ←→ [C] ←→ [B] ←→ [A] ←→ [E]                       │   │   │
│  │  │   ↑                           ↑                         │   │   │
│  │  │  头部                        尾部                       │   │   │
│  │  │  (最新访问)                  (最久未访问，优先淘汰)     │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  LruCache 操作流程:                                                     │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  put(key, value):                                               │   │
│  │  1. 将新元素添加到链表头部                                      │   │
│  │  2. 更新当前缓存大小                                            │   │
│  │  3. 如果超过最大容量，从尾部移除元素                            │   │
│  │                                                                 │   │
│  │  get(key):                                                      │   │
│  │  1. 查找元素                                                    │   │
│  │  2. 如果找到，将元素移动到链表头部                              │   │
│  │  3. 返回元素                                                    │   │
│  │                                                                 │   │
│  │  trimToSize(maxSize):                                           │   │
│  │  1. 循环检查当前大小是否超过 maxSize                            │   │
│  │  2. 如果超过，移除尾部元素                                      │   │
│  │  3. 调用 entryRemoved() 回调                                    │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  LruCache vs LinkedHashMap:                                             │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  LruCache 在 LinkedHashMap 基础上增加了:                        │   │
│  │  • 线程安全 (synchronized)                                      │   │
│  │  • 大小限制和自动淘汰                                           │   │
│  │  • sizeOf() 方法计算元素大小                                    │   │
│  │  • entryRemoved() 回调                                          │   │
│  │  • create() 方法支持缓存未命中时创建                            │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.7 对象池原理

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        对象池原理                                        │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  问题场景:                                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  • 频繁创建和销毁对象 (如 Message、Rect、Paint)                 │   │
│  │  • 导致内存抖动 (Memory Churn)                                  │   │
│  │  • 触发频繁 GC，影响性能                                        │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  对象池解决方案:                                                        │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │                    对象池                               │   │   │
│  │  │  ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐              │   │   │
│  │  │  │ Obj │ │ Obj │ │ Obj │ │ Obj │ │ Obj │              │   │   │
│  │  │  └─────┘ └─────┘ └─────┘ └─────┘ └─────┘              │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │       ↑ 归还                    │ 获取                         │   │
│  │       │                         ↓                               │   │
│  │  ┌─────────┐              ┌─────────┐                          │   │
│  │  │ 使用完毕 │              │ 需要对象 │                          │   │
│  │  └─────────┘              └─────────┘                          │   │
│  │                                                                 │   │
│  │  流程:                                                          │   │
│  │  1. 需要对象时，从池中获取 (obtain)                             │   │
│  │  2. 如果池为空，创建新对象                                      │   │
│  │  3. 使用完毕后，重置对象状态                                    │   │
│  │  4. 将对象归还到池中 (recycle)                                  │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  Android 中的对象池实现:                                                │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  Message 复用池:                                                │   │
│  │  • 使用链表实现                                                 │   │
│  │  • 最大容量 50 个                                               │   │
│  │  • Message.obtain() 获取                                        │   │
│  │  • Message.recycle() 归还                                       │   │
│  │                                                                 │   │
│  │  Pools.Pool<T>:                                                 │   │
│  │  • Android 提供的通用对象池                                     │   │
│  │  • SimplePool: 非线程安全                                       │   │
│  │  • SynchronizedPool: 线程安全                                   │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```


## 3. 关键源码解析

### 3.1 Bitmap 内存计算源码

```java
/**
 * Bitmap 内存大小计算
 * 源码位置: frameworks/base/graphics/java/android/graphics/Bitmap.java
 */
public final int getByteCount() {
    // 如果已经回收，返回 0
    if (mRecycled) {
        Log.w(TAG, "Called getByteCount() on a recycle()'d bitmap! "
                + "This is undefined behavior!");
        return 0;
    }
    // 计算公式: 每行字节数 × 高度
    return getRowBytes() * getHeight();
}

/**
 * 获取每行字节数
 * 每行字节数 = 宽度 × 每像素字节数
 */
public final int getRowBytes() {
    if (mRecycled) {
        Log.w(TAG, "Called getRowBytes() on a recycle()'d bitmap!");
        return 0;
    }
    return nativeRowBytes(mNativePtr);
}

/**
 * 获取分配的字节数 (用于 inBitmap 复用判断)
 * Android 4.4+ 支持复用更大的 Bitmap
 */
public final int getAllocationByteCount() {
    if (mRecycled) {
        Log.w(TAG, "Called getAllocationByteCount() on a recycle()'d bitmap!");
        return 0;
    }
    return nativeGetAllocationByteCount(mNativePtr);
}

/**
 * BitmapFactory 解码时的内存计算
 * 源码位置: frameworks/base/graphics/java/android/graphics/BitmapFactory.java
 */
public static Bitmap decodeResource(Resources res, int id, Options opts) {
    // ...
    
    // 获取资源的密度
    final TypedValue value = new TypedValue();
    is = res.openRawResource(id, value);
    
    // 计算缩放比例
    // inDensity: 资源所在目录的密度 (如 mdpi=160, xxhdpi=480)
    // inTargetDensity: 设备屏幕密度
    // 缩放比例 = inTargetDensity / inDensity
    
    if (opts == null) {
        opts = new Options();
    }
    
    if (opts.inDensity == 0 && value.density > 0 
            && value.density != TypedValue.DENSITY_NONE) {
        opts.inDensity = value.density;  // 资源密度
    }
    
    if (opts.inTargetDensity == 0) {
        opts.inTargetDensity = res.getDisplayMetrics().densityDpi;  // 设备密度
    }
    
    return decodeResourceStream(res, value, is, null, opts);
}

/**
 * Native 层内存分配 (Android 8.0+)
 * 源码位置: frameworks/base/libs/hwui/jni/Bitmap.cpp
 */
// 简化的 Native 代码逻辑
static jobject Bitmap_creator(JNIEnv* env, jobject, jintArray jColors,
                              jint offset, jint stride, jint width, jint height,
                              jint configHandle, jboolean isMutable,
                              jlong colorSpacePtr) {
    // 计算所需内存大小
    SkImageInfo info = SkImageInfo::Make(width, height, colorType, alphaType, colorSpace);
    size_t size = info.computeByteSize(info.minRowBytes());
    
    // 在 Native 堆分配内存
    sk_sp<Bitmap> nativeBitmap = Bitmap::allocateHeapBitmap(size, info, rowBytes);
    
    // 注册到 NativeAllocationRegistry，GC 时自动释放
    // ...
    
    return createBitmap(env, nativeBitmap.release(), ...);
}
```

### 3.2 Bitmap 采样加载源码

```kotlin
/**
 * Bitmap 采样加载最佳实践
 * 计算合适的 inSampleSize 并加载
 */
object BitmapSampler {
    
    /**
     * 从资源加载采样后的 Bitmap
     * @param res Resources 对象
     * @param resId 资源 ID
     * @param reqWidth 目标宽度
     * @param reqHeight 目标高度
     */
    fun decodeSampledBitmapFromResource(
        res: Resources,
        resId: Int,
        reqWidth: Int,
        reqHeight: Int
    ): Bitmap {
        // 第一步: 只获取图片尺寸，不加载像素数据
        val options = BitmapFactory.Options().apply {
            inJustDecodeBounds = true  // 关键: 只解码边界信息
        }
        BitmapFactory.decodeResource(res, resId, options)
        
        // 第二步: 计算采样率
        options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight)
        
        // 第三步: 使用计算出的采样率加载图片
        options.inJustDecodeBounds = false  // 关闭只解码边界
        
        return BitmapFactory.decodeResource(res, resId, options)
    }
    
    /**
     * 计算合适的 inSampleSize
     * 
     * 算法说明:
     * 1. 获取图片原始宽高
     * 2. 计算宽度和高度分别需要的采样率
     * 3. 取较小值，确保采样后图片不小于目标尺寸
     * 4. 向下取整到 2 的幂次方
     */
    fun calculateInSampleSize(
        options: BitmapFactory.Options,
        reqWidth: Int,
        reqHeight: Int
    ): Int {
        // 原始图片尺寸
        val (height, width) = options.outHeight to options.outWidth
        var inSampleSize = 1
        
        // 如果原始尺寸大于目标尺寸，需要采样
        if (height > reqHeight || width > reqWidth) {
            val halfHeight = height / 2
            val halfWidth = width / 2
            
            // 计算最大的 inSampleSize，使得采样后尺寸仍大于目标尺寸
            // 使用 2 的幂次方，因为解码器会向下取整
            while ((halfHeight / inSampleSize) >= reqHeight
                && (halfWidth / inSampleSize) >= reqWidth) {
                inSampleSize *= 2
            }
        }
        
        return inSampleSize
    }
    
    /**
     * 从文件加载采样后的 Bitmap
     */
    fun decodeSampledBitmapFromFile(
        filePath: String,
        reqWidth: Int,
        reqHeight: Int
    ): Bitmap? {
        val options = BitmapFactory.Options().apply {
            inJustDecodeBounds = true
        }
        BitmapFactory.decodeFile(filePath, options)
        
        options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight)
        options.inJustDecodeBounds = false
        
        // 可选: 使用 RGB_565 进一步减少内存
        // options.inPreferredConfig = Bitmap.Config.RGB_565
        
        return BitmapFactory.decodeFile(filePath, options)
    }
    
    /**
     * 从 InputStream 加载采样后的 Bitmap
     * 注意: InputStream 需要支持 mark/reset
     */
    fun decodeSampledBitmapFromStream(
        inputStream: InputStream,
        reqWidth: Int,
        reqHeight: Int
    ): Bitmap? {
        // 使用 BufferedInputStream 支持 mark/reset
        val bufferedStream = if (inputStream.markSupported()) {
            inputStream
        } else {
            BufferedInputStream(inputStream)
        }
        
        bufferedStream.mark(bufferedStream.available())
        
        val options = BitmapFactory.Options().apply {
            inJustDecodeBounds = true
        }
        BitmapFactory.decodeStream(bufferedStream, null, options)
        
        bufferedStream.reset()
        
        options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight)
        options.inJustDecodeBounds = false
        
        return BitmapFactory.decodeStream(bufferedStream, null, options)
    }
}
```

### 3.3 Bitmap 复用 (inBitmap) 源码

```kotlin
/**
 * Bitmap 复用池实现
 * 用于减少 Bitmap 内存分配，避免内存抖动
 */
class BitmapPool(private val maxSize: Int) {
    
    // 使用 LruCache 管理可复用的 Bitmap
    // Key: Bitmap 的字节大小
    // Value: 相同大小的 Bitmap 集合
    private val bitmapPool = object : LruCache<Int, MutableSet<Bitmap>>(maxSize) {
        
        override fun sizeOf(key: Int, value: MutableSet<Bitmap>): Int {
            // 计算该组 Bitmap 的总大小
            return value.sumOf { it.allocationByteCount }
        }
        
        override fun entryRemoved(
            evicted: Boolean,
            key: Int,
            oldValue: MutableSet<Bitmap>,
            newValue: MutableSet<Bitmap>?
        ) {
            // 被淘汰时回收 Bitmap
            if (evicted) {
                oldValue.forEach { bitmap ->
                    if (!bitmap.isRecycled) {
                        bitmap.recycle()
                    }
                }
            }
        }
    }
    
    /**
     * 获取可复用的 Bitmap
     * @param width 目标宽度
     * @param height 目标高度
     * @param config 像素格式
     */
    @Synchronized
    fun getBitmap(width: Int, height: Int, config: Bitmap.Config): Bitmap? {
        // 计算所需字节数
        val bytesPerPixel = when (config) {
            Bitmap.Config.ARGB_8888 -> 4
            Bitmap.Config.RGB_565 -> 2
            Bitmap.Config.ALPHA_8 -> 1
            else -> 4
        }
        val requiredSize = width * height * bytesPerPixel
        
        // 查找大小合适的 Bitmap (Android 4.4+ 支持复用更大的 Bitmap)
        for (size in requiredSize..maxSize) {
            val bitmaps = bitmapPool.get(size)
            if (bitmaps != null && bitmaps.isNotEmpty()) {
                val iterator = bitmaps.iterator()
                while (iterator.hasNext()) {
                    val bitmap = iterator.next()
                    // 检查是否可复用
                    if (canUseForInBitmap(bitmap, width, height, config)) {
                        iterator.remove()
                        // 如果集合为空，从缓存中移除
                        if (bitmaps.isEmpty()) {
                            bitmapPool.remove(size)
                        }
                        return bitmap
                    }
                }
            }
        }
        return null
    }
    
    /**
     * 将 Bitmap 放入复用池
     */
    @Synchronized
    fun putBitmap(bitmap: Bitmap) {
        // 检查是否可以复用
        if (bitmap.isRecycled || !bitmap.isMutable) {
            return
        }
        
        // HARDWARE 配置的 Bitmap 不能复用
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O 
            && bitmap.config == Bitmap.Config.HARDWARE) {
            return
        }
        
        val size = bitmap.allocationByteCount
        var bitmaps = bitmapPool.get(size)
        if (bitmaps == null) {
            bitmaps = mutableSetOf()
            bitmapPool.put(size, bitmaps)
        }
        bitmaps.add(bitmap)
    }
    
    /**
     * 检查 Bitmap 是否可以被复用
     */
    private fun canUseForInBitmap(
        candidate: Bitmap,
        targetWidth: Int,
        targetHeight: Int,
        targetConfig: Bitmap.Config
    ): Boolean {
        // Android 4.4+ 只需要字节数足够
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
            val bytesPerPixel = when (targetConfig) {
                Bitmap.Config.ARGB_8888 -> 4
                Bitmap.Config.RGB_565 -> 2
                Bitmap.Config.ALPHA_8 -> 1
                else -> 4
            }
            val requiredByteCount = targetWidth * targetHeight * bytesPerPixel
            return candidate.allocationByteCount >= requiredByteCount
        }
        
        // Android 4.4 以前需要尺寸完全相同
        return candidate.width == targetWidth 
            && candidate.height == targetHeight 
            && candidate.config == targetConfig
    }
    
    /**
     * 清空复用池
     */
    @Synchronized
    fun clear() {
        bitmapPool.evictAll()
    }
}

/**
 * 使用 inBitmap 加载图片
 */
fun loadBitmapWithReuse(
    bitmapPool: BitmapPool,
    filePath: String,
    reqWidth: Int,
    reqHeight: Int
): Bitmap? {
    val options = BitmapFactory.Options().apply {
        // 第一步: 获取图片尺寸
        inJustDecodeBounds = true
    }
    BitmapFactory.decodeFile(filePath, options)
    
    // 第二步: 计算采样率
    options.inSampleSize = BitmapSampler.calculateInSampleSize(options, reqWidth, reqHeight)
    
    // 计算采样后的尺寸
    val sampledWidth = options.outWidth / options.inSampleSize
    val sampledHeight = options.outHeight / options.inSampleSize
    
    // 第三步: 尝试获取可复用的 Bitmap
    val reuseBitmap = bitmapPool.getBitmap(
        sampledWidth, 
        sampledHeight, 
        Bitmap.Config.ARGB_8888
    )
    
    options.apply {
        inJustDecodeBounds = false
        inMutable = true  // 必须设置为可变，才能被复用
        inBitmap = reuseBitmap  // 设置复用的 Bitmap
    }
    
    return try {
        BitmapFactory.decodeFile(filePath, options)
    } catch (e: IllegalArgumentException) {
        // inBitmap 复用失败，重新加载
        options.inBitmap = null
        BitmapFactory.decodeFile(filePath, options)
    }
}
```


### 3.4 大图加载 (BitmapRegionDecoder) 源码

```kotlin
/**
 * 大图加载实现
 * 使用 BitmapRegionDecoder 实现超大图片的分区加载
 */
class BigImageView @JvmOverloads constructor(
    context: Context,
    attrs: AttributeSet? = null,
    defStyleAttr: Int = 0
) : View(context, attrs, defStyleAttr) {
    
    // 区域解码器
    private var decoder: BitmapRegionDecoder? = null
    
    // 图片原始尺寸
    private var imageWidth = 0
    private var imageHeight = 0
    
    // 当前显示区域
    private val visibleRect = Rect()
    
    // 解码选项
    private val options = BitmapFactory.Options().apply {
        inPreferredConfig = Bitmap.Config.RGB_565  // 使用 RGB_565 减少内存
        inMutable = true  // 支持复用
    }
    
    // 当前显示的 Bitmap
    private var currentBitmap: Bitmap? = null
    
    // 复用的 Bitmap
    private var reuseBitmap: Bitmap? = null
    
    // 手势检测器
    private val gestureDetector = GestureDetector(context, GestureListener())
    private val scaleGestureDetector = ScaleGestureDetector(context, ScaleListener())
    
    // 当前缩放比例
    private var scaleFactor = 1f
    private val minScale = 0.5f
    private val maxScale = 3f
    
    // 当前偏移量
    private var offsetX = 0f
    private var offsetY = 0f
    
    // 绑制矩阵
    private val matrix = Matrix()
    
    /**
     * 设置图片输入流
     */
    fun setImageStream(inputStream: InputStream) {
        // 创建区域解码器
        decoder = BitmapRegionDecoder.newInstance(inputStream, false)
        
        decoder?.let {
            imageWidth = it.width
            imageHeight = it.height
            
            // 计算初始缩放比例，使图片适应 View
            post {
                calculateInitialScale()
                updateVisibleRect()
                decodeVisibleRegion()
                invalidate()
            }
        }
    }
    
    /**
     * 设置图片文件路径
     */
    fun setImageFile(filePath: String) {
        val inputStream = FileInputStream(filePath)
        setImageStream(inputStream)
    }
    
    /**
     * 计算初始缩放比例
     */
    private fun calculateInitialScale() {
        if (width == 0 || height == 0 || imageWidth == 0 || imageHeight == 0) {
            return
        }
        
        // 计算适应 View 的缩放比例
        val scaleX = width.toFloat() / imageWidth
        val scaleY = height.toFloat() / imageHeight
        scaleFactor = minOf(scaleX, scaleY)
        
        // 居中显示
        offsetX = (width - imageWidth * scaleFactor) / 2
        offsetY = (height - imageHeight * scaleFactor) / 2
    }
    
    /**
     * 更新可见区域
     */
    private fun updateVisibleRect() {
        // 计算当前可见的图片区域 (图片坐标系)
        val left = (-offsetX / scaleFactor).toInt().coerceIn(0, imageWidth)
        val top = (-offsetY / scaleFactor).toInt().coerceIn(0, imageHeight)
        val right = ((width - offsetX) / scaleFactor).toInt().coerceIn(0, imageWidth)
        val bottom = ((height - offsetY) / scaleFactor).toInt().coerceIn(0, imageHeight)
        
        visibleRect.set(left, top, right, bottom)
    }
    
    /**
     * 解码可见区域
     * 这是核心方法，只解码当前可见的图片区域
     */
    private fun decodeVisibleRegion() {
        decoder?.let { decoder ->
            if (visibleRect.isEmpty) {
                return
            }
            
            // 计算采样率
            // 当缩放比例较小时，使用更大的采样率减少内存
            val sampleSize = calculateSampleSize()
            options.inSampleSize = sampleSize
            
            // 设置复用 Bitmap
            options.inBitmap = reuseBitmap
            
            try {
                // 解码指定区域
                currentBitmap = decoder.decodeRegion(visibleRect, options)
                
                // 保存用于下次复用
                reuseBitmap = currentBitmap
                
            } catch (e: IllegalArgumentException) {
                // 复用失败，重新解码
                options.inBitmap = null
                currentBitmap = decoder.decodeRegion(visibleRect, options)
                reuseBitmap = currentBitmap
            }
        }
    }
    
    /**
     * 计算采样率
     */
    private fun calculateSampleSize(): Int {
        var sampleSize = 1
        
        // 当缩放比例小于 1 时，增加采样率
        if (scaleFactor < 1) {
            sampleSize = (1 / scaleFactor).toInt()
            // 向上取整到 2 的幂次方
            sampleSize = Integer.highestOneBit(sampleSize)
            if (sampleSize < 1) sampleSize = 1
        }
        
        return sampleSize
    }
    
    override fun onDraw(canvas: Canvas) {
        super.onDraw(canvas)
        
        currentBitmap?.let { bitmap ->
            if (!bitmap.isRecycled) {
                // 计算绘制位置
                matrix.reset()
                
                // 考虑采样率的影响
                val sampleScale = options.inSampleSize.toFloat()
                
                // 设置缩放和位移
                matrix.postScale(scaleFactor * sampleScale, scaleFactor * sampleScale)
                matrix.postTranslate(
                    offsetX + visibleRect.left * scaleFactor,
                    offsetY + visibleRect.top * scaleFactor
                )
                
                canvas.drawBitmap(bitmap, matrix, null)
            }
        }
    }
    
    override fun onTouchEvent(event: MotionEvent): Boolean {
        // 处理缩放手势
        scaleGestureDetector.onTouchEvent(event)
        // 处理滑动手势
        gestureDetector.onTouchEvent(event)
        return true
    }
    
    /**
     * 手势监听器 - 处理滑动
     */
    private inner class GestureListener : GestureDetector.SimpleOnGestureListener() {
        
        override fun onScroll(
            e1: MotionEvent?,
            e2: MotionEvent,
            distanceX: Float,
            distanceY: Float
        ): Boolean {
            // 更新偏移量
            offsetX -= distanceX
            offsetY -= distanceY
            
            // 限制边界
            constrainOffset()
            
            // 更新可见区域并重新解码
            updateVisibleRect()
            decodeVisibleRegion()
            invalidate()
            
            return true
        }
        
        override fun onDoubleTap(e: MotionEvent): Boolean {
            // 双击缩放
            scaleFactor = if (scaleFactor < 1.5f) 2f else 1f
            constrainOffset()
            updateVisibleRect()
            decodeVisibleRegion()
            invalidate()
            return true
        }
    }
    
    /**
     * 缩放手势监听器
     */
    private inner class ScaleListener : ScaleGestureDetector.SimpleOnScaleGestureListener() {
        
        override fun onScale(detector: ScaleGestureDetector): Boolean {
            // 更新缩放比例
            scaleFactor *= detector.scaleFactor
            scaleFactor = scaleFactor.coerceIn(minScale, maxScale)
            
            // 以手指中心点为缩放中心
            val focusX = detector.focusX
            val focusY = detector.focusY
            
            offsetX = focusX - (focusX - offsetX) * detector.scaleFactor
            offsetY = focusY - (focusY - offsetY) * detector.scaleFactor
            
            constrainOffset()
            updateVisibleRect()
            decodeVisibleRegion()
            invalidate()
            
            return true
        }
    }
    
    /**
     * 限制偏移量，防止图片移出 View 边界
     */
    private fun constrainOffset() {
        val scaledWidth = imageWidth * scaleFactor
        val scaledHeight = imageHeight * scaleFactor
        
        // 水平方向
        if (scaledWidth <= width) {
            offsetX = (width - scaledWidth) / 2
        } else {
            offsetX = offsetX.coerceIn(width - scaledWidth, 0f)
        }
        
        // 垂直方向
        if (scaledHeight <= height) {
            offsetY = (height - scaledHeight) / 2
        } else {
            offsetY = offsetY.coerceIn(height - scaledHeight, 0f)
        }
    }
    
    /**
     * 释放资源
     */
    fun recycle() {
        decoder?.recycle()
        decoder = null
        
        currentBitmap?.recycle()
        currentBitmap = null
        
        reuseBitmap?.recycle()
        reuseBitmap = null
    }
    
    override fun onDetachedFromWindow() {
        super.onDetachedFromWindow()
        recycle()
    }
}
```

### 3.5 LruCache 源码解析

```java
/**
 * LruCache 核心源码解析
 * 源码位置: frameworks/base/core/java/android/util/LruCache.java
 */
public class LruCache<K, V> {
    // 使用 LinkedHashMap 实现 LRU
    // accessOrder = true 表示按访问顺序排序
    private final LinkedHashMap<K, V> map;
    
    // 当前缓存大小
    private int size;
    // 最大缓存大小
    private int maxSize;
    
    // 统计信息
    private int putCount;      // put 次数
    private int createCount;   // create 次数
    private int evictionCount; // 淘汰次数
    private int hitCount;      // 命中次数
    private int missCount;     // 未命中次数
    
    /**
     * 构造函数
     * @param maxSize 最大缓存大小
     */
    public LruCache(int maxSize) {
        if (maxSize <= 0) {
            throw new IllegalArgumentException("maxSize <= 0");
        }
        this.maxSize = maxSize;
        // 关键: accessOrder = true，按访问顺序排序
        this.map = new LinkedHashMap<K, V>(0, 0.75f, true);
    }
    
    /**
     * 获取缓存
     */
    public final V get(K key) {
        if (key == null) {
            throw new NullPointerException("key == null");
        }
        
        V mapValue;
        synchronized (this) {
            // 从 LinkedHashMap 获取
            // 如果存在，会自动移动到链表尾部 (最近访问)
            mapValue = map.get(key);
            if (mapValue != null) {
                hitCount++;  // 命中
                return mapValue;
            }
            missCount++;  // 未命中
        }
        
        // 尝试创建缺失的值
        V createdValue = create(key);
        if (createdValue == null) {
            return null;
        }
        
        // 将创建的值放入缓存
        synchronized (this) {
            createCount++;
            mapValue = map.put(key, createdValue);
            
            if (mapValue != null) {
                // 有冲突，恢复原值
                map.put(key, mapValue);
            } else {
                size += safeSizeOf(key, createdValue);
            }
        }
        
        if (mapValue != null) {
            entryRemoved(false, key, createdValue, mapValue);
            return mapValue;
        } else {
            // 检查是否需要淘汰
            trimToSize(maxSize);
            return createdValue;
        }
    }
    
    /**
     * 放入缓存
     */
    public final V put(K key, V value) {
        if (key == null || value == null) {
            throw new NullPointerException("key == null || value == null");
        }
        
        V previous;
        synchronized (this) {
            putCount++;
            // 计算新值大小
            size += safeSizeOf(key, value);
            // 放入 LinkedHashMap
            previous = map.put(key, value);
            if (previous != null) {
                // 如果有旧值，减去旧值大小
                size -= safeSizeOf(key, previous);
            }
        }
        
        // 通知旧值被移除
        if (previous != null) {
            entryRemoved(false, key, previous, value);
        }
        
        // 关键: 检查是否需要淘汰
        trimToSize(maxSize);
        return previous;
    }
    
    /**
     * 淘汰到指定大小
     * 这是 LRU 算法的核心实现
     */
    public void trimToSize(int maxSize) {
        while (true) {
            K key;
            V value;
            synchronized (this) {
                if (size < 0 || (map.isEmpty() && size != 0)) {
                    throw new IllegalStateException(
                        getClass().getName() + ".sizeOf() is reporting inconsistent results!");
                }
                
                // 如果当前大小未超过最大值，退出
                if (size <= maxSize || map.isEmpty()) {
                    break;
                }
                
                // 获取最老的元素 (链表头部)
                // LinkedHashMap 的 eldest() 方法返回最老的元素
                Map.Entry<K, V> toEvict = map.entrySet().iterator().next();
                key = toEvict.getKey();
                value = toEvict.getValue();
                
                // 移除最老的元素
                map.remove(key);
                size -= safeSizeOf(key, value);
                evictionCount++;
            }
            
            // 通知元素被淘汰
            entryRemoved(true, key, value, null);
        }
    }
    
    /**
     * 移除缓存
     */
    public final V remove(K key) {
        if (key == null) {
            throw new NullPointerException("key == null");
        }
        
        V previous;
        synchronized (this) {
            previous = map.remove(key);
            if (previous != null) {
                size -= safeSizeOf(key, previous);
            }
        }
        
        if (previous != null) {
            entryRemoved(false, key, previous, null);
        }
        
        return previous;
    }
    
    /**
     * 计算元素大小
     * 子类需要重写此方法
     */
    protected int sizeOf(K key, V value) {
        return 1;  // 默认每个元素大小为 1
    }
    
    private int safeSizeOf(K key, V value) {
        int result = sizeOf(key, value);
        if (result < 0) {
            throw new IllegalStateException("Negative size: " + key + "=" + value);
        }
        return result;
    }
    
    /**
     * 元素被移除时的回调
     * @param evicted true 表示被淘汰，false 表示被 put/remove 替换
     */
    protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) {
        // 子类可以重写此方法，处理被移除的元素
        // 例如: 回收 Bitmap
    }
    
    /**
     * 缓存未命中时创建值
     * 子类可以重写此方法
     */
    protected V create(K key) {
        return null;  // 默认不创建
    }
    
    /**
     * 清空缓存
     */
    public final void evictAll() {
        trimToSize(-1);  // -1 会清空所有元素
    }
}
```


### 3.6 DiskLruCache 核心实现

```kotlin
/**
 * DiskLruCache 使用示例
 * 磁盘缓存，用于持久化存储
 */
class DiskBitmapCache(
    private val cacheDir: File,
    private val maxSize: Long = 50 * 1024 * 1024  // 50MB
) {
    
    private var diskLruCache: DiskLruCache? = null
    
    init {
        openCache()
    }
    
    /**
     * 打开磁盘缓存
     */
    private fun openCache() {
        if (!cacheDir.exists()) {
            cacheDir.mkdirs()
        }
        
        // 参数说明:
        // directory: 缓存目录
        // appVersion: 应用版本，版本变化时清空缓存
        // valueCount: 每个 key 对应的文件数量
        // maxSize: 最大缓存大小
        diskLruCache = DiskLruCache.open(cacheDir, 1, 1, maxSize)
    }
    
    /**
     * 生成缓存 key
     * 使用 MD5 将 URL 转换为合法的文件名
     */
    private fun hashKeyForDisk(key: String): String {
        return try {
            val digest = MessageDigest.getInstance("MD5")
            digest.update(key.toByteArray())
            bytesToHexString(digest.digest())
        } catch (e: NoSuchAlgorithmException) {
            key.hashCode().toString()
        }
    }
    
    private fun bytesToHexString(bytes: ByteArray): String {
        val sb = StringBuilder()
        for (byte in bytes) {
            val hex = Integer.toHexString(0xFF and byte.toInt())
            if (hex.length == 1) {
                sb.append('0')
            }
            sb.append(hex)
        }
        return sb.toString()
    }
    
    /**
     * 从磁盘缓存获取 Bitmap
     */
    fun getBitmap(url: String): Bitmap? {
        val key = hashKeyForDisk(url)
        
        return try {
            val snapshot = diskLruCache?.get(key) ?: return null
            val inputStream = snapshot.getInputStream(0)
            
            // 解码 Bitmap
            val bitmap = BitmapFactory.decodeStream(inputStream)
            
            // 关闭 snapshot
            snapshot.close()
            
            bitmap
        } catch (e: IOException) {
            e.printStackTrace()
            null
        }
    }
    
    /**
     * 将 Bitmap 存入磁盘缓存
     */
    fun putBitmap(url: String, bitmap: Bitmap): Boolean {
        val key = hashKeyForDisk(url)
        
        return try {
            // 获取编辑器
            val editor = diskLruCache?.edit(key) ?: return false
            
            // 获取输出流
            val outputStream = editor.newOutputStream(0)
            
            // 压缩并写入
            val success = bitmap.compress(
                Bitmap.CompressFormat.PNG,
                100,
                outputStream
            )
            
            if (success) {
                editor.commit()  // 提交
            } else {
                editor.abort()   // 放弃
            }
            
            // 刷新
            diskLruCache?.flush()
            
            success
        } catch (e: IOException) {
            e.printStackTrace()
            false
        }
    }
    
    /**
     * 移除缓存
     */
    fun remove(url: String): Boolean {
        val key = hashKeyForDisk(url)
        return try {
            diskLruCache?.remove(key) ?: false
        } catch (e: IOException) {
            false
        }
    }
    
    /**
     * 获取缓存大小
     */
    fun size(): Long {
        return diskLruCache?.size() ?: 0
    }
    
    /**
     * 清空缓存
     */
    fun clear() {
        try {
            diskLruCache?.delete()
            openCache()  // 重新打开
        } catch (e: IOException) {
            e.printStackTrace()
        }
    }
    
    /**
     * 关闭缓存
     */
    fun close() {
        try {
            diskLruCache?.close()
        } catch (e: IOException) {
            e.printStackTrace()
        }
    }
}

/**
 * 多级缓存管理器
 * 内存缓存 + 磁盘缓存
 */
class ImageCacheManager(context: Context) {
    
    // 内存缓存 (使用可用内存的 1/8)
    private val memoryCache: LruCache<String, Bitmap>
    
    // 磁盘缓存
    private val diskCache: DiskBitmapCache
    
    init {
        // 计算内存缓存大小
        val maxMemory = (Runtime.getRuntime().maxMemory() / 1024).toInt()
        val cacheSize = maxMemory / 8
        
        memoryCache = object : LruCache<String, Bitmap>(cacheSize) {
            override fun sizeOf(key: String, bitmap: Bitmap): Int {
                // 返回 Bitmap 大小 (KB)
                return bitmap.byteCount / 1024
            }
            
            override fun entryRemoved(
                evicted: Boolean,
                key: String,
                oldValue: Bitmap,
                newValue: Bitmap?
            ) {
                // 可选: 将被淘汰的 Bitmap 放入复用池
            }
        }
        
        // 初始化磁盘缓存
        val cacheDir = File(context.cacheDir, "image_cache")
        diskCache = DiskBitmapCache(cacheDir)
    }
    
    /**
     * 获取 Bitmap (先内存，后磁盘)
     */
    fun getBitmap(url: String): Bitmap? {
        // 1. 先从内存缓存获取
        memoryCache.get(url)?.let { return it }
        
        // 2. 从磁盘缓存获取
        diskCache.getBitmap(url)?.let { bitmap ->
            // 放入内存缓存
            memoryCache.put(url, bitmap)
            return bitmap
        }
        
        return null
    }
    
    /**
     * 存入 Bitmap (同时存入内存和磁盘)
     */
    fun putBitmap(url: String, bitmap: Bitmap) {
        // 存入内存缓存
        memoryCache.put(url, bitmap)
        
        // 异步存入磁盘缓存
        Thread {
            diskCache.putBitmap(url, bitmap)
        }.start()
    }
    
    /**
     * 清空内存缓存
     */
    fun clearMemoryCache() {
        memoryCache.evictAll()
    }
    
    /**
     * 清空所有缓存
     */
    fun clearAllCache() {
        memoryCache.evictAll()
        diskCache.clear()
    }
}
```

### 3.7 对象池实现

```kotlin
/**
 * 通用对象池实现
 * 参考 Android Pools.Pool 接口
 */
interface ObjectPool<T> {
    /**
     * 从池中获取对象
     */
    fun acquire(): T?
    
    /**
     * 将对象归还到池中
     */
    fun release(instance: T): Boolean
}

/**
 * 简单对象池 (非线程安全)
 */
class SimplePool<T>(private val maxPoolSize: Int) : ObjectPool<T> {
    
    private val pool = arrayOfNulls<Any>(maxPoolSize)
    private var poolSize = 0
    
    @Suppress("UNCHECKED_CAST")
    override fun acquire(): T? {
        if (poolSize > 0) {
            val lastIndex = poolSize - 1
            val instance = pool[lastIndex] as T
            pool[lastIndex] = null
            poolSize--
            return instance
        }
        return null
    }
    
    override fun release(instance: T): Boolean {
        // 检查是否已在池中 (防止重复归还)
        for (i in 0 until poolSize) {
            if (pool[i] === instance) {
                throw IllegalStateException("Already in the pool!")
            }
        }
        
        if (poolSize < maxPoolSize) {
            pool[poolSize] = instance
            poolSize++
            return true
        }
        return false
    }
}

/**
 * 线程安全对象池
 */
class SynchronizedPool<T>(private val maxPoolSize: Int) : ObjectPool<T> {
    
    private val lock = Any()
    private val pool = arrayOfNulls<Any>(maxPoolSize)
    private var poolSize = 0
    
    @Suppress("UNCHECKED_CAST")
    override fun acquire(): T? {
        synchronized(lock) {
            if (poolSize > 0) {
                val lastIndex = poolSize - 1
                val instance = pool[lastIndex] as T
                pool[lastIndex] = null
                poolSize--
                return instance
            }
        }
        return null
    }
    
    override fun release(instance: T): Boolean {
        synchronized(lock) {
            // 检查是否已在池中
            for (i in 0 until poolSize) {
                if (pool[i] === instance) {
                    throw IllegalStateException("Already in the pool!")
                }
            }
            
            if (poolSize < maxPoolSize) {
                pool[poolSize] = instance
                poolSize++
                return true
            }
        }
        return false
    }
}

/**
 * 带工厂方法的对象池
 * 当池为空时自动创建新对象
 */
class FactoryPool<T>(
    private val maxPoolSize: Int,
    private val factory: () -> T,
    private val reset: (T) -> Unit = {}
) : ObjectPool<T> {
    
    private val pool = SynchronizedPool<T>(maxPoolSize)
    
    /**
     * 获取对象 (池为空时创建新对象)
     */
    override fun acquire(): T {
        return pool.acquire() ?: factory()
    }
    
    /**
     * 归还对象 (先重置状态)
     */
    override fun release(instance: T): Boolean {
        reset(instance)  // 重置对象状态
        return pool.release(instance)
    }
}

/**
 * 使用示例: Rect 对象池
 */
object RectPool {
    
    private val pool = FactoryPool(
        maxPoolSize = 20,
        factory = { Rect() },
        reset = { it.setEmpty() }
    )
    
    fun obtain(): Rect = pool.acquire()
    
    fun recycle(rect: Rect) {
        pool.release(rect)
    }
}

/**
 * 使用示例: Paint 对象池
 */
object PaintPool {
    
    private val pool = FactoryPool(
        maxPoolSize = 10,
        factory = { Paint() },
        reset = { paint ->
            paint.reset()
        }
    )
    
    fun obtain(): Paint = pool.acquire()
    
    fun recycle(paint: Paint) {
        pool.release(paint)
    }
}

/**
 * Message 复用池源码分析
 * 源码位置: frameworks/base/core/java/android/os/Message.java
 */
/*
public final class Message implements Parcelable {
    
    // 复用池 (链表实现)
    private static Message sPool;
    private static int sPoolSize = 0;
    private static final int MAX_POOL_SIZE = 50;  // 最大容量
    
    // 链表下一个节点
    Message next;
    
    // 标记是否正在使用
    private static final int FLAG_IN_USE = 1 << 0;
    int flags;
    
    /**
     * 从复用池获取 Message
     */
    public static Message obtain() {
        synchronized (sPoolSync) {
            if (sPool != null) {
                // 从链表头部取出
                Message m = sPool;
                sPool = m.next;
                m.next = null;
                m.flags = 0;  // 清除标记
                sPoolSize--;
                return m;
            }
        }
        // 池为空，创建新对象
        return new Message();
    }
    
    /**
     * 回收 Message 到复用池
     */
    void recycleUnchecked() {
        // 清除所有数据
        flags = FLAG_IN_USE;
        what = 0;
        arg1 = 0;
        arg2 = 0;
        obj = null;
        replyTo = null;
        sendingUid = UID_NONE;
        workSourceUid = UID_NONE;
        when = 0;
        target = null;
        callback = null;
        data = null;
        
        synchronized (sPoolSync) {
            if (sPoolSize < MAX_POOL_SIZE) {
                // 放入链表头部
                next = sPool;
                sPool = this;
                sPoolSize++;
            }
        }
    }
}
*/
```


## 4. 实战应用

### 4.1 Bitmap 内存优化最佳实践

```kotlin
/**
 * Bitmap 内存优化工具类
 * 整合各种优化策略
 */
object BitmapOptimizer {
    
    /**
     * 优化策略1: 选择合适的像素格式
     */
    fun decodeWithOptimalConfig(
        filePath: String,
        hasAlpha: Boolean = false
    ): Bitmap? {
        val options = BitmapFactory.Options().apply {
            // 不需要透明通道时使用 RGB_565，内存减半
            inPreferredConfig = if (hasAlpha) {
                Bitmap.Config.ARGB_8888
            } else {
                Bitmap.Config.RGB_565
            }
        }
        return BitmapFactory.decodeFile(filePath, options)
    }
    
    /**
     * 优化策略2: 按需加载 (采样)
     */
    fun decodeScaled(
        filePath: String,
        targetWidth: Int,
        targetHeight: Int
    ): Bitmap? {
        // 第一步: 获取原始尺寸
        val options = BitmapFactory.Options().apply {
            inJustDecodeBounds = true
        }
        BitmapFactory.decodeFile(filePath, options)
        
        // 第二步: 计算采样率
        options.inSampleSize = calculateInSampleSize(
            options.outWidth, options.outHeight,
            targetWidth, targetHeight
        )
        
        // 第三步: 加载采样后的图片
        options.inJustDecodeBounds = false
        return BitmapFactory.decodeFile(filePath, options)
    }
    
    private fun calculateInSampleSize(
        srcWidth: Int, srcHeight: Int,
        targetWidth: Int, targetHeight: Int
    ): Int {
        var inSampleSize = 1
        if (srcHeight > targetHeight || srcWidth > targetWidth) {
            val halfHeight = srcHeight / 2
            val halfWidth = srcWidth / 2
            while ((halfHeight / inSampleSize) >= targetHeight
                && (halfWidth / inSampleSize) >= targetWidth) {
                inSampleSize *= 2
            }
        }
        return inSampleSize
    }
    
    /**
     * 优化策略3: 使用 HARDWARE 配置 (Android 8.0+)
     * 适用于只需要显示、不需要修改的图片
     */
    @RequiresApi(Build.VERSION_CODES.O)
    fun decodeAsHardware(filePath: String): Bitmap? {
        val options = BitmapFactory.Options().apply {
            inPreferredConfig = Bitmap.Config.HARDWARE
        }
        return BitmapFactory.decodeFile(filePath, options)
    }
    
    /**
     * 优化策略4: 及时回收
     */
    fun recycleBitmap(bitmap: Bitmap?) {
        bitmap?.let {
            if (!it.isRecycled) {
                it.recycle()
            }
        }
    }
    
    /**
     * 优化策略5: 使用 inBitmap 复用
     */
    fun decodeWithReuse(
        filePath: String,
        reuseBitmap: Bitmap?
    ): Bitmap? {
        val options = BitmapFactory.Options().apply {
            inMutable = true
            inBitmap = reuseBitmap
        }
        
        return try {
            BitmapFactory.decodeFile(filePath, options)
        } catch (e: IllegalArgumentException) {
            // 复用失败，重新加载
            options.inBitmap = null
            BitmapFactory.decodeFile(filePath, options)
        }
    }
}

/**
 * 图片加载最佳实践示例
 */
class ImageLoadingBestPractice {
    
    private val bitmapPool = BitmapPool(10 * 1024 * 1024)  // 10MB 复用池
    private val memoryCache: LruCache<String, Bitmap>
    
    init {
        // 使用可用内存的 1/8 作为缓存
        val maxMemory = Runtime.getRuntime().maxMemory() / 1024
        val cacheSize = (maxMemory / 8).toInt()
        
        memoryCache = object : LruCache<String, Bitmap>(cacheSize) {
            override fun sizeOf(key: String, bitmap: Bitmap): Int {
                return bitmap.byteCount / 1024
            }
            
            override fun entryRemoved(
                evicted: Boolean,
                key: String,
                oldValue: Bitmap,
                newValue: Bitmap?
            ) {
                // 被淘汰的 Bitmap 放入复用池
                if (evicted && oldValue.isMutable) {
                    bitmapPool.putBitmap(oldValue)
                }
            }
        }
    }
    
    /**
     * 加载图片到 ImageView
     */
    fun loadImage(imageView: ImageView, url: String) {
        // 1. 先从内存缓存获取
        memoryCache.get(url)?.let {
            imageView.setImageBitmap(it)
            return
        }
        
        // 2. 异步加载
        loadAsync(url) { bitmap ->
            bitmap?.let {
                // 存入缓存
                memoryCache.put(url, it)
                // 显示
                imageView.post {
                    imageView.setImageBitmap(it)
                }
            }
        }
    }
    
    private fun loadAsync(url: String, callback: (Bitmap?) -> Unit) {
        Thread {
            // 获取 ImageView 尺寸
            val targetWidth = 1080  // 实际应该获取 ImageView 尺寸
            val targetHeight = 1920
            
            // 下载并解码
            val bitmap = downloadAndDecode(url, targetWidth, targetHeight)
            callback(bitmap)
        }.start()
    }
    
    private fun downloadAndDecode(
        url: String,
        targetWidth: Int,
        targetHeight: Int
    ): Bitmap? {
        // 这里简化处理，实际需要网络下载
        // 使用采样和复用加载
        return null
    }
}
```

### 4.2 RecyclerView 图片加载优化

```kotlin
/**
 * RecyclerView 图片加载优化
 */
class OptimizedImageAdapter(
    private val imageUrls: List<String>
) : RecyclerView.Adapter<OptimizedImageAdapter.ViewHolder>() {
    
    // 图片加载器 (使用 Glide/Coil)
    private lateinit var recyclerView: RecyclerView
    
    override fun onAttachedToRecyclerView(recyclerView: RecyclerView) {
        super.onAttachedToRecyclerView(recyclerView)
        this.recyclerView = recyclerView
        
        // 优化1: 监听滑动状态，快速滑动时暂停加载
        recyclerView.addOnScrollListener(object : RecyclerView.OnScrollListener() {
            override fun onScrollStateChanged(recyclerView: RecyclerView, newState: Int) {
                when (newState) {
                    RecyclerView.SCROLL_STATE_IDLE -> {
                        // 停止滑动，恢复加载
                        Glide.with(recyclerView.context).resumeRequests()
                    }
                    RecyclerView.SCROLL_STATE_DRAGGING,
                    RecyclerView.SCROLL_STATE_SETTLING -> {
                        // 快速滑动，暂停加载
                        Glide.with(recyclerView.context).pauseRequests()
                    }
                }
            }
        })
    }
    
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val view = LayoutInflater.from(parent.context)
            .inflate(R.layout.item_image, parent, false)
        return ViewHolder(view)
    }
    
    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val url = imageUrls[position]
        
        // 优化2: 使用 Glide 加载，自动处理缓存和复用
        Glide.with(holder.itemView.context)
            .load(url)
            // 优化3: 指定尺寸，避免加载过大图片
            .override(holder.imageView.width, holder.imageView.height)
            // 优化4: 使用缩略图，先显示低质量图片
            .thumbnail(0.1f)
            // 优化5: 禁用动画，减少内存占用
            .dontAnimate()
            // 优化6: 使用 RGB_565 格式
            .format(DecodeFormat.PREFER_RGB_565)
            // 优化7: 设置占位图
            .placeholder(R.drawable.placeholder)
            .error(R.drawable.error)
            .into(holder.imageView)
    }
    
    override fun onViewRecycled(holder: ViewHolder) {
        super.onViewRecycled(holder)
        // 优化8: View 回收时清除图片请求
        Glide.with(holder.itemView.context).clear(holder.imageView)
    }
    
    override fun getItemCount() = imageUrls.size
    
    class ViewHolder(view: View) : RecyclerView.ViewHolder(view) {
        val imageView: ImageView = view.findViewById(R.id.imageView)
    }
}

/**
 * RecyclerView 预加载优化
 */
class PreloadingImageAdapter(
    private val imageUrls: List<String>
) : RecyclerView.Adapter<PreloadingImageAdapter.ViewHolder>() {
    
    private var preloader: RecyclerViewPreloader<String>? = null
    
    fun setupPreloading(recyclerView: RecyclerView) {
        // 创建预加载器
        val preloadModelProvider = object : ListPreloader.PreloadModelProvider<String> {
            override fun getPreloadItems(position: Int): List<String> {
                return listOf(imageUrls[position])
            }
            
            override fun getPreloadRequestBuilder(item: String): RequestBuilder<*> {
                return Glide.with(recyclerView.context)
                    .load(item)
                    .override(300, 300)
            }
        }
        
        val preloadSizeProvider = FixedPreloadSizeProvider<String>(300, 300)
        
        preloader = RecyclerViewPreloader(
            Glide.with(recyclerView.context),
            preloadModelProvider,
            preloadSizeProvider,
            10  // 预加载数量
        )
        
        recyclerView.addOnScrollListener(preloader!!)
    }
    
    // ... 其他方法同上
    
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        TODO("Not yet implemented")
    }

    override fun getItemCount(): Int {
        TODO("Not yet implemented")
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        TODO("Not yet implemented")
    }

    class ViewHolder(view: View) : RecyclerView.ViewHolder(view)
}
```

### 4.3 内存监控与优化

```kotlin
/**
 * 内存监控工具
 */
object MemoryMonitor {
    
    /**
     * 获取当前内存使用情况
     */
    fun getMemoryInfo(context: Context): MemoryInfo {
        val activityManager = context.getSystemService(Context.ACTIVITY_SERVICE) 
            as ActivityManager
        val memoryInfo = ActivityManager.MemoryInfo()
        activityManager.getMemoryInfo(memoryInfo)
        
        val runtime = Runtime.getRuntime()
        
        return MemoryInfo(
            // 系统可用内存
            availableSystemMemory = memoryInfo.availMem,
            // 系统总内存
            totalSystemMemory = memoryInfo.totalMem,
            // 是否低内存
            isLowMemory = memoryInfo.lowMemory,
            // 低内存阈值
            lowMemoryThreshold = memoryInfo.threshold,
            // Java Heap 最大值
            javaHeapMax = runtime.maxMemory(),
            // Java Heap 已分配
            javaHeapAllocated = runtime.totalMemory(),
            // Java Heap 空闲
            javaHeapFree = runtime.freeMemory(),
            // Java Heap 已使用
            javaHeapUsed = runtime.totalMemory() - runtime.freeMemory()
        )
    }
    
    /**
     * 获取 Native 内存使用情况 (Android 8.0+)
     */
    @RequiresApi(Build.VERSION_CODES.M)
    fun getNativeMemoryInfo(): NativeMemoryInfo {
        return NativeMemoryInfo(
            nativeHeapSize = Debug.getNativeHeapSize(),
            nativeHeapAllocated = Debug.getNativeHeapAllocatedSize(),
            nativeHeapFree = Debug.getNativeHeapFreeSize()
        )
    }
    
    /**
     * 打印内存使用日志
     */
    fun logMemoryUsage(context: Context, tag: String = "MemoryMonitor") {
        val info = getMemoryInfo(context)
        
        Log.d(tag, """
            ========== Memory Usage ==========
            System Available: ${formatSize(info.availableSystemMemory)}
            System Total: ${formatSize(info.totalSystemMemory)}
            Is Low Memory: ${info.isLowMemory}
            
            Java Heap Max: ${formatSize(info.javaHeapMax)}
            Java Heap Used: ${formatSize(info.javaHeapUsed)}
            Java Heap Free: ${formatSize(info.javaHeapFree)}
            Usage: ${info.javaHeapUsed * 100 / info.javaHeapMax}%
            ==================================
        """.trimIndent())
        
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            val nativeInfo = getNativeMemoryInfo()
            Log.d(tag, """
                Native Heap Size: ${formatSize(nativeInfo.nativeHeapSize)}
                Native Heap Allocated: ${formatSize(nativeInfo.nativeHeapAllocated)}
                Native Heap Free: ${formatSize(nativeInfo.nativeHeapFree)}
            """.trimIndent())
        }
    }
    
    private fun formatSize(bytes: Long): String {
        return when {
            bytes >= 1024 * 1024 * 1024 -> "%.2f GB".format(bytes / (1024.0 * 1024 * 1024))
            bytes >= 1024 * 1024 -> "%.2f MB".format(bytes / (1024.0 * 1024))
            bytes >= 1024 -> "%.2f KB".format(bytes / 1024.0)
            else -> "$bytes B"
        }
    }
    
    data class MemoryInfo(
        val availableSystemMemory: Long,
        val totalSystemMemory: Long,
        val isLowMemory: Boolean,
        val lowMemoryThreshold: Long,
        val javaHeapMax: Long,
        val javaHeapAllocated: Long,
        val javaHeapFree: Long,
        val javaHeapUsed: Long
    )
    
    data class NativeMemoryInfo(
        val nativeHeapSize: Long,
        val nativeHeapAllocated: Long,
        val nativeHeapFree: Long
    )
}

/**
 * 低内存回调处理
 */
class MemoryCallbackHandler : ComponentCallbacks2 {
    
    override fun onTrimMemory(level: Int) {
        when (level) {
            // 应用在后台，系统内存不足
            ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE -> {
                // 释放不必要的资源
                clearNonEssentialCache()
            }
            ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW -> {
                // 释放更多资源
                clearModeratePriorityCache()
            }
            ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL -> {
                // 尽可能释放资源
                clearAllCache()
            }
            
            // 应用 UI 不可见
            ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN -> {
                // 释放 UI 相关资源
                clearUICache()
            }
            
            // 应用在后台，可能被杀死
            ComponentCallbacks2.TRIM_MEMORY_BACKGROUND -> {
                clearNonEssentialCache()
            }
            ComponentCallbacks2.TRIM_MEMORY_MODERATE -> {
                clearModeratePriorityCache()
            }
            ComponentCallbacks2.TRIM_MEMORY_COMPLETE -> {
                // 即将被杀死，释放所有可释放的资源
                clearAllCache()
            }
        }
    }
    
    override fun onConfigurationChanged(newConfig: Configuration) {
        // 配置变化处理
    }
    
    override fun onLowMemory() {
        // 系统内存严重不足
        clearAllCache()
    }
    
    private fun clearNonEssentialCache() {
        // 清除非必要缓存
        Glide.get(App.context).clearMemory()
    }
    
    private fun clearModeratePriorityCache() {
        // 清除中等优先级缓存
        clearNonEssentialCache()
        // 清除其他缓存...
    }
    
    private fun clearUICache() {
        // 清除 UI 相关缓存
    }
    
    private fun clearAllCache() {
        // 清除所有缓存
        clearModeratePriorityCache()
        clearUICache()
    }
}
```


### 4.4 Glide 内存优化配置

```kotlin
/**
 * Glide 自定义配置
 * 优化内存使用
 */
@GlideModule
class CustomGlideModule : AppGlideModule() {
    
    override fun applyOptions(context: Context, builder: GlideBuilder) {
        // 1. 自定义内存缓存大小
        val calculator = MemorySizeCalculator.Builder(context)
            .setMemoryCacheScreens(2f)  // 缓存 2 屏图片
            .setBitmapPoolScreens(3f)   // Bitmap 复用池 3 屏
            .build()
        
        builder.setMemoryCache(LruResourceCache(calculator.memoryCacheSize.toLong()))
        builder.setBitmapPool(LruBitmapPool(calculator.bitmapPoolSize.toLong()))
        
        // 2. 自定义磁盘缓存
        builder.setDiskCache(
            InternalCacheDiskCacheFactory(
                context,
                "glide_cache",
                100 * 1024 * 1024  // 100MB
            )
        )
        
        // 3. 设置默认请求选项
        builder.setDefaultRequestOptions(
            RequestOptions()
                .format(DecodeFormat.PREFER_RGB_565)  // 默认使用 RGB_565
                .disallowHardwareConfig()  // 禁用 HARDWARE 配置 (如需修改像素)
        )
        
        // 4. 设置日志级别
        builder.setLogLevel(Log.ERROR)
    }
    
    override fun registerComponents(context: Context, glide: Glide, registry: Registry) {
        // 注册自定义组件
    }
    
    override fun isManifestParsingEnabled(): Boolean {
        return false  // 禁用 Manifest 解析，提升启动速度
    }
}

/**
 * Glide 使用最佳实践
 */
object GlideBestPractice {
    
    /**
     * 加载图片到 ImageView
     */
    fun loadImage(
        context: Context,
        imageView: ImageView,
        url: String,
        width: Int = Target.SIZE_ORIGINAL,
        height: Int = Target.SIZE_ORIGINAL
    ) {
        Glide.with(context)
            .load(url)
            // 指定尺寸，避免加载过大图片
            .override(width, height)
            // 使用缩略图
            .thumbnail(0.25f)
            // 缓存策略
            .diskCacheStrategy(DiskCacheStrategy.AUTOMATIC)
            // 占位图
            .placeholder(R.drawable.placeholder)
            .error(R.drawable.error)
            // 淡入动画 (可选)
            .transition(DrawableTransitionOptions.withCrossFade())
            .into(imageView)
    }
    
    /**
     * 预加载图片
     */
    fun preload(context: Context, url: String, width: Int, height: Int) {
        Glide.with(context)
            .load(url)
            .override(width, height)
            .preload()
    }
    
    /**
     * 清除内存缓存 (必须在主线程)
     */
    fun clearMemoryCache(context: Context) {
        Glide.get(context).clearMemory()
    }
    
    /**
     * 清除磁盘缓存 (必须在子线程)
     */
    fun clearDiskCache(context: Context) {
        Thread {
            Glide.get(context).clearDiskCache()
        }.start()
    }
    
    /**
     * 低内存时释放资源
     */
    fun trimMemory(context: Context, level: Int) {
        Glide.get(context).trimMemory(level)
    }
}
```

### 4.5 Coil 内存优化配置

```kotlin
/**
 * Coil 自定义配置
 * Kotlin 优先的图片加载库
 */
class CoilImageLoaderFactory : ImageLoaderFactory {
    
    override fun newImageLoader(): ImageLoader {
        return ImageLoader.Builder(App.context)
            // 1. 内存缓存配置
            .memoryCache {
                MemoryCache.Builder(App.context)
                    .maxSizePercent(0.25)  // 使用 25% 可用内存
                    .build()
            }
            // 2. 磁盘缓存配置
            .diskCache {
                DiskCache.Builder()
                    .directory(App.context.cacheDir.resolve("coil_cache"))
                    .maxSizePercent(0.02)  // 使用 2% 磁盘空间
                    .build()
            }
            // 3. 默认请求配置
            .crossfade(true)  // 淡入动画
            .allowRgb565(true)  // 允许使用 RGB_565
            // 4. 组件配置
            .components {
                // 添加 SVG 解码器
                // add(SvgDecoder.Factory())
            }
            // 5. 日志配置
            .logger(DebugLogger())
            .build()
    }
}

/**
 * Coil 使用示例
 */
object CoilBestPractice {
    
    /**
     * 加载图片
     */
    fun loadImage(imageView: ImageView, url: String) {
        imageView.load(url) {
            crossfade(true)
            placeholder(R.drawable.placeholder)
            error(R.drawable.error)
            // 指定尺寸
            size(imageView.width, imageView.height)
            // 缓存策略
            memoryCachePolicy(CachePolicy.ENABLED)
            diskCachePolicy(CachePolicy.ENABLED)
        }
    }
    
    /**
     * 加载圆形图片
     */
    fun loadCircleImage(imageView: ImageView, url: String) {
        imageView.load(url) {
            crossfade(true)
            transformations(CircleCropTransformation())
        }
    }
    
    /**
     * 预加载
     */
    suspend fun preload(context: Context, url: String) {
        val request = ImageRequest.Builder(context)
            .data(url)
            .build()
        context.imageLoader.enqueue(request)
    }
}
```

## 5. 常见面试题

### 面试题 1：Bitmap 内存大小如何计算？从资源目录加载时有什么特殊情况？

**答案要点：**

```
1. 基本计算公式:
   内存大小 = 宽度 × 高度 × 每像素字节数
   
   像素格式对应字节数:
   - ARGB_8888: 4 字节 (默认)
   - RGB_565: 2 字节
   - ALPHA_8: 1 字节
   - RGBA_F16: 8 字节 (HDR)

2. 从资源目录加载时的缩放:
   缩放后宽度 = 原始宽度 × (设备 DPI / 资源目录 DPI)
   缩放后高度 = 原始高度 × (设备 DPI / 资源目录 DPI)
   
   例如: 100×100 图片放在 mdpi (160) 目录
        在 xxhdpi (480) 设备上加载:
        实际尺寸 = 300×300
        内存 = 300 × 300 × 4 = 360KB

3. 资源目录 DPI 对应关系:
   - ldpi: 120
   - mdpi: 160
   - hdpi: 240
   - xhdpi: 320
   - xxhdpi: 480
   - xxxhdpi: 640

4. 优化建议:
   - 将图片放在合适的资源目录
   - 使用 nodpi 目录避免缩放
   - 使用 inSampleSize 采样加载
```

### 面试题 2：inBitmap 复用的原理和使用条件是什么？

**答案要点：**

```
1. inBitmap 原理:
   - 解码新图片时复用已有 Bitmap 的内存空间
   - 避免频繁分配/释放内存，减少内存抖动
   - 减少 GC 次数，提升性能

2. 使用条件:
   Android 4.4 以前:
   - 新图片尺寸必须与复用 Bitmap 完全相同
   - 像素格式必须相同
   
   Android 4.4+:
   - 新图片字节数 ≤ 复用 Bitmap 的 getAllocationByteCount()
   - 像素格式兼容即可

3. 通用条件:
   - 复用 Bitmap 必须是 mutable (可变的)
   - 复用 Bitmap 不能是 HARDWARE 配置
   - 复用 Bitmap 不能已被 recycle

4. 使用方式:
   BitmapFactory.Options options = new BitmapFactory.Options();
   options.inMutable = true;
   options.inBitmap = reuseBitmap;
   Bitmap newBitmap = BitmapFactory.decodeFile(path, options);

5. 注意事项:
   - 复用失败会抛出 IllegalArgumentException
   - 需要 try-catch 处理复用失败的情况
   - Glide 等框架已内置 Bitmap 复用池
```

### 面试题 3：如何加载一张超大图片（如 10000×10000）而不 OOM？

**答案要点：**

```
1. 问题分析:
   - 10000×10000×4 = 381MB，直接加载必然 OOM
   - 需要分区域加载，只加载可见部分

2. 解决方案: BitmapRegionDecoder
   - 不将整张图片加载到内存
   - 只解码当前可见的区域
   - 用户滑动时动态解码新区域

3. 实现步骤:
   // 1. 创建区域解码器
   BitmapRegionDecoder decoder = BitmapRegionDecoder.newInstance(inputStream, false);
   
   // 2. 获取图片原始尺寸
   int width = decoder.getWidth();
   int height = decoder.getHeight();
   
   // 3. 解码指定区域
   Rect rect = new Rect(left, top, right, bottom);
   Bitmap bitmap = decoder.decodeRegion(rect, options);

4. 优化技巧:
   - 配合 inSampleSize 使用，缩小时增加采样率
   - 使用 inBitmap 复用解码后的 Bitmap
   - 使用 RGB_565 格式减少内存
   - 实现手势缩放和滑动

5. 开源方案:
   - SubsamplingScaleImageView
   - PhotoView + 自定义大图加载
```

### 面试题 4：LruCache 的实现原理是什么？为什么用 LinkedHashMap？

**答案要点：**

```
1. LRU 算法原理:
   - Least Recently Used (最近最少使用)
   - 最近访问的数据放在最前面
   - 缓存满时淘汰最久未访问的数据

2. 为什么用 LinkedHashMap:
   - LinkedHashMap 支持按访问顺序排序 (accessOrder = true)
   - 每次 get() 操作会将元素移动到链表尾部
   - 链表头部就是最久未访问的元素
   - 淘汰时直接移除头部元素，时间复杂度 O(1)

3. LruCache 核心实现:
   // 构造时设置 accessOrder = true
   this.map = new LinkedHashMap<K, V>(0, 0.75f, true);
   
   // put 时检查是否需要淘汰
   public V put(K key, V value) {
       size += safeSizeOf(key, value);
       previous = map.put(key, value);
       trimToSize(maxSize);  // 淘汰超出部分
   }
   
   // 淘汰逻辑
   public void trimToSize(int maxSize) {
       while (size > maxSize) {
           // 获取最老的元素 (链表头部)
           Map.Entry<K, V> toEvict = map.entrySet().iterator().next();
           map.remove(toEvict.getKey());
           size -= safeSizeOf(key, value);
       }
   }

4. LruCache 特点:
   - 线程安全 (synchronized)
   - 支持自定义 sizeOf() 计算元素大小
   - 支持 entryRemoved() 回调处理被淘汰元素
   - 支持 create() 方法在缓存未命中时创建
```

### 面试题 5：Glide 的内存缓存机制是怎样的？如何优化？

**答案要点：**

```
1. Glide 内存缓存架构:
   ┌─────────────────────────────────────────┐
   │           ActiveResources               │  正在使用的资源 (弱引用)
   ├─────────────────────────────────────────┤
   │           MemoryCache (LruCache)        │  内存缓存
   ├─────────────────────────────────────────┤
   │           BitmapPool                    │  Bitmap 复用池
   ├─────────────────────────────────────────┤
   │           DiskCache                     │  磁盘缓存
   └─────────────────────────────────────────┘

2. 缓存查找顺序:
   ActiveResources → MemoryCache → DiskCache → 网络

3. ActiveResources:
   - 存储正在使用的资源
   - 使用弱引用，不阻止 GC
   - 资源不再使用时移入 MemoryCache

4. BitmapPool:
   - 存储可复用的 Bitmap
   - 解码新图片时优先从池中获取
   - 减少内存分配，避免内存抖动

5. 优化配置:
   @GlideModule
   class CustomGlideModule : AppGlideModule() {
       override fun applyOptions(context: Context, builder: GlideBuilder) {
           // 自定义缓存大小
           builder.setMemoryCache(LruResourceCache(cacheSize))
           builder.setBitmapPool(LruBitmapPool(poolSize))
           
           // 默认使用 RGB_565
           builder.setDefaultRequestOptions(
               RequestOptions().format(DecodeFormat.PREFER_RGB_565)
           )
       }
   }

6. 使用优化:
   - 指定 override() 尺寸，避免加载过大图片
   - 快速滑动时 pauseRequests()
   - 低内存时调用 trimMemory()
   - 使用 thumbnail() 先显示缩略图
```

### 面试题 6：对象池的作用是什么？Android 中有哪些对象池的应用？

**答案要点：**

```
1. 对象池的作用:
   - 复用对象，减少频繁创建/销毁
   - 避免内存抖动 (Memory Churn)
   - 减少 GC 次数，提升性能

2. 适用场景:
   - 频繁创建的小对象
   - 创建成本较高的对象
   - 生命周期短的对象

3. Android 中的对象池应用:

   Message 复用池:
   - 最大容量 50 个
   - Message.obtain() 获取
   - Message.recycle() 归还
   - 链表实现

   RecyclerView ViewHolder 复用:
   - 四级缓存机制
   - Scrap、Cache、ViewCacheExtension、RecycledViewPool
   - 减少 View 创建和绑定

   Glide BitmapPool:
   - 复用 Bitmap 内存
   - 减少内存分配
   - LruBitmapPool 实现

   Pools.Pool<T>:
   - Android 提供的通用对象池
   - SimplePool: 非线程安全
   - SynchronizedPool: 线程安全

4. 自定义对象池实现:
   class ObjectPool<T>(
       private val maxSize: Int,
       private val factory: () -> T,
       private val reset: (T) -> Unit
   ) {
       private val pool = SynchronizedPool<T>(maxSize)
       
       fun acquire(): T = pool.acquire() ?: factory()
       
       fun release(obj: T) {
           reset(obj)  // 重置状态
           pool.release(obj)
       }
   }
```

### 面试题 7：Android 8.0 前后 Bitmap 内存分配有什么变化？

**答案要点：**

```
1. Android 2.3 及以前:
   - 像素数据存储在 Native 内存
   - Bitmap 对象在 Java Heap
   - 需要手动调用 recycle() 释放
   - GC 无法自动回收 Native 内存
   - 容易导致 Native 内存泄漏

2. Android 3.0 - 7.1:
   - 像素数据存储在 Java Heap
   - GC 可以自动回收
   - 容易导致 Java Heap OOM
   - 支持 inBitmap 复用

3. Android 8.0+:
   - 像素数据重新存储在 Native 内存
   - 使用 NativeAllocationRegistry 注册释放回调
   - GC 时自动释放 Native 内存
   - 不再容易导致 Java Heap OOM
   - 但仍需注意 Native 内存限制

4. Android 8.0+ HARDWARE 配置:
   - 像素数据存储在 GPU 内存
   - 不占用 Java Heap 和 Native Heap
   - 渲染效率更高
   - 限制: 不能获取/修改像素

5. 实际影响:
   - Android 8.0+ 应用不容易因 Bitmap 导致 OOM
   - 但 Native 内存仍有限制
   - 仍需要合理管理 Bitmap 内存
   - 使用 Memory Profiler 监控 Native 内存
```

### 面试题 8：如何检测和优化内存抖动？

**答案要点：**

```
1. 内存抖动定义:
   - 短时间内频繁分配和释放内存
   - 导致频繁 GC
   - 造成界面卡顿

2. 检测方法:
   
   Memory Profiler:
   - 观察内存曲线是否呈锯齿状
   - 查看 Allocations 数量
   - 分析频繁分配的对象类型
   
   Perfetto/Systrace:
   - 查看 GC 事件频率
   - 分析 GC 耗时
   - 定位触发 GC 的代码

3. 常见原因:
   - 循环中创建对象
   - onDraw() 中创建对象
   - 字符串拼接 (使用 StringBuilder)
   - 自动装箱 (int → Integer)
   - 频繁创建临时对象

4. 优化方案:

   使用对象池:
   // 复用 Rect、Paint 等对象
   private val rect = Rect()  // 成员变量复用
   
   避免在循环中创建对象:
   // Bad
   for (i in 0..1000) {
       val point = Point(i, i)
   }
   // Good
   val point = Point()
   for (i in 0..1000) {
       point.set(i, i)
   }
   
   使用 StringBuilder:
   // Bad
   var str = ""
   for (i in 0..100) {
       str += i.toString()
   }
   // Good
   val sb = StringBuilder()
   for (i in 0..100) {
       sb.append(i)
   }
   
   避免自动装箱:
   // 使用 SparseArray 代替 HashMap<Integer, Object>
   // 使用 SparseBooleanArray 代替 HashMap<Integer, Boolean>
```

---

## 聊天记录

### 2024-XX-XX

**用户请求：** 创建 Android 高级开发面试知识库文件：docs/06-内存管理/内存优化.md

**完成内容：**
1. 创建了完整的内存优化文档，包含以下章节：
   - 概述：内存优化的重要性和核心方向
   - 核心原理：Bitmap 内存计算、采样原理、复用原理、大图加载原理、LruCache 原理、对象池原理
   - 关键源码解析：Bitmap 内存计算、采样加载、inBitmap 复用、BitmapRegionDecoder、LruCache、DiskLruCache、对象池实现
   - 实战应用：Bitmap 优化最佳实践、RecyclerView 图片加载优化、内存监控、Glide/Coil 配置
   - 常见面试题：8 道高频面试题，涵盖 Bitmap 内存计算、inBitmap 复用、大图加载、LruCache 原理、Glide 缓存、对象池、Android 8.0 变化、内存抖动优化

2. 文档特点：
   - 符合大纲规范的文档结构
   - 包含详细的流程图和示意图
   - 关键源码带有详细注释
   - 面试题贴合字节、美团、快手、OPPO、vivo 面试风格
   - 重点突出 Bitmap 内存计算和优化
