# 集合框架原理

## 1. 概述

Java 集合框架是 Java 编程中最常用的数据结构实现，主要包括 List、Set、Map 三大类。本文将深入分析 HashMap、ConcurrentHashMap、ArrayList、LinkedList 等核心集合类的实现原理。

## 2. 核心原理

### 2.1 集合框架体系

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        Java 集合框架体系                                 │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│                         Collection                                      │
│                             │                                           │
│           ┌─────────────────┼─────────────────┐                        │
│           ↓                 ↓                 ↓                         │
│         List               Set              Queue                       │
│           │                 │                 │                         │
│     ┌─────┴─────┐     ┌────┴────┐      ┌────┴────┐                    │
│     ↓           ↓     ↓         ↓      ↓         ↓                     │
│ ArrayList  LinkedList HashSet TreeSet  PriorityQueue Deque             │
│                           │                                             │
│                       LinkedHashSet                                     │
│                                                                         │
│                           Map                                           │
│                             │                                           │
│           ┌─────────────────┼─────────────────┐                        │
│           ↓                 ↓                 ↓                         │
│        HashMap          TreeMap         LinkedHashMap                   │
│           │                                                             │
│     ConcurrentHashMap                                                   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.2 HashMap 原理

#### 2.2.1 数据结构演进

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    HashMap 数据结构演进                                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  JDK 1.7: 数组 + 链表                                                   │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  table[]                                                        │   │
│  │  ┌───┬───┬───┬───┬───┬───┬───┬───┐                             │   │
│  │  │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │                             │   │
│  │  └─┬─┴───┴─┬─┴───┴───┴─┬─┴───┴───┘                             │   │
│  │    ↓       ↓           ↓                                        │   │
│  │  [E1]    [E3]        [E5]                                       │   │
│  │    ↓       ↓           ↓                                        │   │
│  │  [E2]    [E4]        [E6]                                       │   │
│  │            ↓                                                    │   │
│  │          [E7]                                                   │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  JDK 1.8: 数组 + 链表 + 红黑树                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  table[]                                                        │   │
│  │  ┌───┬───┬───┬───┬───┬───┬───┬───┐                             │   │
│  │  │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │                             │   │
│  │  └─┬─┴───┴─┬─┴───┴───┴─┬─┴───┴───┘                             │   │
│  │    ↓       ↓           ↓                                        │   │
│  │  [E1]    [E3]      ┌───────┐                                    │   │
│  │    ↓       ↓       │红黑树  │  ← 链表长度 >= 8 时转换            │   │
│  │  [E2]    [E4]      │       │                                    │   │
│  │                    └───────┘                                    │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  转换条件:                                                              │
│  - 链表 → 红黑树: 链表长度 >= 8 且 数组长度 >= 64                       │
│  - 红黑树 → 链表: 红黑树节点数 <= 6                                     │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

#### 2.2.2 核心参数

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    HashMap 核心参数                                      │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  参数                    │  默认值  │  说明                             │
│  ─────────────────────────────────────────────────────────────────────  │
│  DEFAULT_INITIAL_CAPACITY│  16     │  默认初始容量 (必须是 2 的幂)      │
│  MAXIMUM_CAPACITY        │  2^30   │  最大容量                          │
│  DEFAULT_LOAD_FACTOR     │  0.75f  │  默认负载因子                      │
│  TREEIFY_THRESHOLD       │  8      │  链表转红黑树的阈值                │
│  UNTREEIFY_THRESHOLD     │  6      │  红黑树转链表的阈值                │
│  MIN_TREEIFY_CAPACITY    │  64     │  转红黑树的最小数组容量            │
│                                                                         │
│  扩容时机: size > capacity * loadFactor                                 │
│  例如: 16 * 0.75 = 12，当元素数量超过 12 时触发扩容                     │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

#### 2.2.3 哈希计算与定位

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    哈希计算与数组定位                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  JDK 1.8 hash() 方法:                                                   │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  static final int hash(Object key) {                            │   │
│  │      int h;                                                     │   │
│  │      return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);│  │
│  │  }                                                              │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  扰动函数原理:                                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  原始 hashCode:  1111 1111 1111 1111 0000 0000 0000 0001        │   │
│  │  右移 16 位:     0000 0000 0000 0000 1111 1111 1111 1111        │   │
│  │  异或结果:       1111 1111 1111 1111 1111 1111 1111 1110        │   │
│  │                                                                 │   │
│  │  目的: 让高位也参与运算，减少哈希冲突                            │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  数组下标计算:                                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  index = (n - 1) & hash                                         │   │
│  │                                                                 │   │
│  │  为什么用 & 而不是 %?                                           │   │
│  │  - 位运算效率更高                                               │   │
│  │  - 当 n 是 2 的幂时，(n-1) & hash 等价于 hash % n               │   │
│  │                                                                 │   │
│  │  例如 n = 16:                                                   │   │
│  │  n - 1 = 15 = 0000 1111                                        │   │
│  │  hash & 15 只保留低 4 位，结果范围 [0, 15]                      │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

#### 2.2.4 扩容机制

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    HashMap 扩容机制                                      │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  JDK 1.7 扩容 (头插法):                                                 │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  问题: 多线程环境下可能形成环形链表，导致死循环                   │   │
│  │                                                                 │   │
│  │  原链表: A → B → C                                              │   │
│  │  线程1扩容后: C → B → A                                         │   │
│  │  线程2扩容后: 可能形成 A → B → A 的环                           │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  JDK 1.8 扩容 (尾插法):                                                 │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  优化: 不需要重新计算 hash，根据 hash & oldCap 判断新位置        │   │
│  │                                                                 │   │
│  │  原容量 oldCap = 16 (0001 0000)                                 │   │
│  │  新容量 newCap = 32 (0010 0000)                                 │   │
│  │                                                                 │   │
│  │  hash & oldCap == 0: 位置不变                                   │   │
│  │  hash & oldCap != 0: 新位置 = 原位置 + oldCap                   │   │
│  │                                                                 │   │
│  │  示例:                                                          │   │
│  │  hash = 5  (0000 0101) & 16 (0001 0000) = 0  → 位置不变         │   │
│  │  hash = 21 (0001 0101) & 16 (0001 0000) = 16 → 新位置 = 5 + 16  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  扩容流程:                                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  1. 创建新数组，容量为原来的 2 倍                                │   │
│  │  2. 遍历原数组的每个桶                                          │   │
│  │     - 单个节点: 直接计算新位置                                  │   │
│  │     - 链表: 拆分为两个链表 (低位链表、高位链表)                  │   │
│  │     - 红黑树: 拆分为两个树/链表                                 │   │
│  │  3. 将节点放入新数组                                            │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.3 ConcurrentHashMap 原理

```
┌─────────────────────────────────────────────────────────────────────────┐
│                ConcurrentHashMap 实现演进                                │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  JDK 1.7: 分段锁 (Segment)                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  Segment[] (默认 16 个)                                         │   │
│  │  ┌─────────┬─────────┬─────────┬─────────┐                     │   │
│  │  │Segment0 │Segment1 │Segment2 │   ...   │                     │   │
│  │  │ (Lock)  │ (Lock)  │ (Lock)  │         │                     │   │
│  │  └────┬────┴────┬────┴────┬────┴─────────┘                     │   │
│  │       ↓         ↓         ↓                                     │   │
│  │  HashEntry[] HashEntry[] HashEntry[]                            │   │
│  │                                                                 │   │
│  │  - 每个 Segment 是一个小的 HashMap                              │   │
│  │  - 不同 Segment 可以并发访问                                    │   │
│  │  - 并发度 = Segment 数量 (默认 16)                              │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  JDK 1.8: CAS + synchronized                                            │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  Node[] table                                                   │   │
│  │  ┌───┬───┬───┬───┬───┬───┬───┬───┐                             │   │
│  │  │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │                             │   │
│  │  └─┬─┴───┴─┬─┴───┴───┴─┬─┴───┴───┘                             │   │
│  │    ↓       ↓           ↓                                        │   │
│  │  [N1]    [N3]      ┌───────┐                                    │   │
│  │    ↓       ↓       │红黑树  │                                    │   │
│  │  [N2]    [N4]      └───────┘                                    │   │
│  │                                                                 │   │
│  │  - 锁粒度更细: 锁单个桶 (链表头节点)                            │   │
│  │  - 空桶使用 CAS 插入                                            │   │
│  │  - 非空桶使用 synchronized 锁住头节点                           │   │
│  │  - 并发度 = 数组长度                                            │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.4 ArrayList vs LinkedList

```
┌─────────────────────────────────────────────────────────────────────────┐
│                ArrayList vs LinkedList                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ArrayList (动态数组):                                                  │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  Object[] elementData                                           │   │
│  │  ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐                     │   │
│  │  │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │ 9 │                     │   │
│  │  │ A │ B │ C │ D │ E │   │   │   │   │   │                     │   │
│  │  └───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘                     │   │
│  │  size = 5, capacity = 10                                        │   │
│  │                                                                 │   │
│  │  特点:                                                          │   │
│  │  - 随机访问 O(1)                                                │   │
│  │  - 尾部插入/删除 O(1)                                           │   │
│  │  - 中间插入/删除 O(n) (需要移动元素)                            │   │
│  │  - 扩容: 1.5 倍 (newCapacity = oldCapacity + oldCapacity >> 1)  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  LinkedList (双向链表):                                                 │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  first                                              last        │   │
│  │    ↓                                                  ↓         │   │
│  │  ┌───┐    ┌───┐    ┌───┐    ┌───┐    ┌───┐                     │   │
│  │  │ A │ ←→ │ B │ ←→ │ C │ ←→ │ D │ ←→ │ E │                     │   │
│  │  └───┘    └───┘    └───┘    └───┘    └───┘                     │   │
│  │                                                                 │   │
│  │  特点:                                                          │   │
│  │  - 随机访问 O(n) (需要遍历)                                     │   │
│  │  - 头尾插入/删除 O(1)                                           │   │
│  │  - 中间插入/删除 O(n) (需要先找到位置)                          │   │
│  │  - 每个节点额外存储两个指针，内存开销大                         │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  性能对比:                                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  操作              │ ArrayList │ LinkedList                     │   │
│  │  ─────────────────────────────────────────────────────────────  │   │
│  │  get(index)        │ O(1)      │ O(n)                           │   │
│  │  add(E)            │ O(1)*     │ O(1)                           │   │
│  │  add(index, E)     │ O(n)      │ O(n)                           │   │
│  │  remove(index)     │ O(n)      │ O(n)                           │   │
│  │  contains(E)       │ O(n)      │ O(n)                           │   │
│  │  内存占用          │ 较小      │ 较大                           │   │
│  │  * 可能触发扩容                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.5 LinkedHashMap 与 LRU

```
┌─────────────────────────────────────────────────────────────────────────┐
│                LinkedHashMap 实现 LRU 缓存                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  LinkedHashMap 结构:                                                    │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  HashMap 的数组 + 链表/红黑树结构                                │   │
│  │           +                                                     │   │
│  │  双向链表维护插入/访问顺序                                       │   │
│  │                                                                 │   │
│  │  head                                              tail         │   │
│  │    ↓                                                 ↓          │   │
│  │  ┌───┐    ┌───┐    ┌───┐    ┌───┐    ┌───┐                     │   │
│  │  │ A │ ←→ │ B │ ←→ │ C │ ←→ │ D │ ←→ │ E │                     │   │
│  │  └───┘    └───┘    └───┘    └───┘    └───┘                     │   │
│  │    ↑                                                            │   │
│  │  最老的元素                              最新的元素 ↑            │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  两种顺序模式:                                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  accessOrder = false (默认): 按插入顺序                         │   │
│  │  accessOrder = true: 按访问顺序 (LRU)                           │   │
│  │                                                                 │   │
│  │  当 accessOrder = true 时:                                      │   │
│  │  - get() 操作会将访问的节点移到链表尾部                         │   │
│  │  - put() 操作会将新/更新的节点移到链表尾部                      │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.6 CopyOnWriteArrayList

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    CopyOnWriteArrayList 原理                             │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  写时复制 (Copy-On-Write):                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  读操作:                                                        │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │  直接读取当前数组，无需加锁                              │   │   │
│  │  │  volatile Object[] array; // 保证可见性                  │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │                                                                 │   │
│  │  写操作:                                                        │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │  1. 加锁 (ReentrantLock)                                │   │   │
│  │  │  2. 复制原数组到新数组                                  │   │   │
│  │  │  3. 在新数组上修改                                      │   │   │
│  │  │  4. 将 array 引用指向新数组                             │   │   │
│  │  │  5. 释放锁                                              │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  适用场景:                                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  - 读多写少的场景                                               │   │
│  │  - 允许短暂的数据不一致 (弱一致性)                              │   │
│  │  - 例如: 监听器列表、配置信息                                   │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  缺点:                                                                  │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  - 写操作开销大 (复制整个数组)                                  │   │
│  │  - 内存占用高 (写时需要两份数组)                                │   │
│  │  - 数据一致性弱 (读到的可能是旧数据)                            │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

## 3. 关键源码解析

### 3.1 HashMap put 方法

```java
/**
 * HashMap put 方法源码 (JDK 8)
 */
public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}

/**
 * 计算 hash 值
 * 扰动函数：高 16 位与低 16 位异或，让高位也参与运算
 */
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}

/**
 * put 核心实现
 */
final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {
    Node<K,V>[] tab; Node<K,V> p; int n, i;
    
    // 1. 数组为空，初始化
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    
    // 2. 计算下标，如果该位置为空，直接插入
    if ((p = tab[i = (n - 1) & hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    else {
        Node<K,V> e; K k;
        
        // 3. key 相同，准备覆盖
        if (p.hash == hash &&
            ((k = p.key) == key || (key != null && key.equals(k))))
            e = p;
        
        // 4. 红黑树节点
        else if (p instanceof TreeNode)
            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
        
        // 5. 链表节点
        else {
            for (int binCount = 0; ; ++binCount) {
                // 到达链表尾部，插入新节点
                if ((e = p.next) == null) {
                    p.next = newNode(hash, key, value, null);
                    // 链表长度 >= 8，转换为红黑树
                    if (binCount >= TREEIFY_THRESHOLD - 1)
                        treeifyBin(tab, hash);
                    break;
                }
                // 找到相同 key，准备覆盖
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    break;
                p = e;
            }
        }
        
        // 6. 存在相同 key，覆盖旧值
        if (e != null) {
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);  // LinkedHashMap 回调
            return oldValue;
        }
    }
    
    ++modCount;
    // 7. 超过阈值，扩容
    if (++size > threshold)
        resize();
    afterNodeInsertion(evict);  // LinkedHashMap 回调
    return null;
}
```

### 3.2 HashMap resize 方法

```java
/**
 * HashMap 扩容方法 (JDK 8)
 */
final Node<K,V>[] resize() {
    Node<K,V>[] oldTab = table;
    int oldCap = (oldTab == null) ? 0 : oldTab.length;
    int oldThr = threshold;
    int newCap, newThr = 0;
    
    // 1. 计算新容量和新阈值
    if (oldCap > 0) {
        // 已达最大容量，不再扩容
        if (oldCap >= MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            return oldTab;
        }
        // 容量和阈值都翻倍
        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&
                 oldCap >= DEFAULT_INITIAL_CAPACITY)
            newThr = oldThr << 1;
    }
    else if (oldThr > 0)
        newCap = oldThr;
    else {
        // 初始化默认值
        newCap = DEFAULT_INITIAL_CAPACITY;
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    }
    
    if (newThr == 0) {
        float ft = (float)newCap * loadFactor;
        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?
                  (int)ft : Integer.MAX_VALUE);
    }
    threshold = newThr;
    
    // 2. 创建新数组
    @SuppressWarnings({"rawtypes","unchecked"})
    Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
    table = newTab;
    
    // 3. 迁移数据
    if (oldTab != null) {
        for (int j = 0; j < oldCap; ++j) {
            Node<K,V> e;
            if ((e = oldTab[j]) != null) {
                oldTab[j] = null;  // help GC
                
                // 单个节点，直接计算新位置
                if (e.next == null)
                    newTab[e.hash & (newCap - 1)] = e;
                
                // 红黑树节点
                else if (e instanceof TreeNode)
                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
                
                // 链表节点，拆分为两个链表
                else {
                    // 低位链表 (位置不变)
                    Node<K,V> loHead = null, loTail = null;
                    // 高位链表 (位置 + oldCap)
                    Node<K,V> hiHead = null, hiTail = null;
                    Node<K,V> next;
                    
                    do {
                        next = e.next;
                        // hash & oldCap == 0，放入低位链表
                        if ((e.hash & oldCap) == 0) {
                            if (loTail == null)
                                loHead = e;
                            else
                                loTail.next = e;
                            loTail = e;
                        }
                        // hash & oldCap != 0，放入高位链表
                        else {
                            if (hiTail == null)
                                hiHead = e;
                            else
                                hiTail.next = e;
                            hiTail = e;
                        }
                    } while ((e = next) != null);
                    
                    // 低位链表放在原位置
                    if (loTail != null) {
                        loTail.next = null;
                        newTab[j] = loHead;
                    }
                    // 高位链表放在 原位置 + oldCap
                    if (hiTail != null) {
                        hiTail.next = null;
                        newTab[j + oldCap] = hiHead;
                    }
                }
            }
        }
    }
    return newTab;
}
```

### 3.3 ConcurrentHashMap put 方法 (JDK 8)

```java
/**
 * ConcurrentHashMap put 方法 (JDK 8)
 */
public V put(K key, V value) {
    return putVal(key, value, false);
}

final V putVal(K key, V value, boolean onlyIfAbsent) {
    // key 和 value 都不能为 null
    if (key == null || value == null) throw new NullPointerException();
    
    // 计算 hash
    int hash = spread(key.hashCode());
    int binCount = 0;
    
    // 自旋
    for (Node<K,V>[] tab = table;;) {
        Node<K,V> f; int n, i, fh;
        
        // 1. 数组为空，初始化
        if (tab == null || (n = tab.length) == 0)
            tab = initTable();
        
        // 2. 该位置为空，CAS 插入
        else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {
            // CAS 操作，无需加锁
            if (casTabAt(tab, i, null, new Node<K,V>(hash, key, value, null)))
                break;
        }
        
        // 3. 正在扩容，帮助扩容
        else if ((fh = f.hash) == MOVED)
            tab = helpTransfer(tab, f);
        
        // 4. 该位置有节点，加锁插入
        else {
            V oldVal = null;
            // synchronized 锁住头节点
            synchronized (f) {
                // 再次检查头节点是否变化
                if (tabAt(tab, i) == f) {
                    // 链表
                    if (fh >= 0) {
                        binCount = 1;
                        for (Node<K,V> e = f;; ++binCount) {
                            K ek;
                            // 找到相同 key，更新
                            if (e.hash == hash &&
                                ((ek = e.key) == key ||
                                 (ek != null && key.equals(ek)))) {
                                oldVal = e.val;
                                if (!onlyIfAbsent)
                                    e.val = value;
                                break;
                            }
                            Node<K,V> pred = e;
                            // 到达尾部，插入新节点
                            if ((e = e.next) == null) {
                                pred.next = new Node<K,V>(hash, key, value, null);
                                break;
                            }
                        }
                    }
                    // 红黑树
                    else if (f instanceof TreeBin) {
                        Node<K,V> p;
                        binCount = 2;
                        if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key, value)) != null) {
                            oldVal = p.val;
                            if (!onlyIfAbsent)
                                p.val = value;
                        }
                    }
                }
            }
            
            if (binCount != 0) {
                // 链表长度 >= 8，转换为红黑树
                if (binCount >= TREEIFY_THRESHOLD)
                    treeifyBin(tab, i);
                if (oldVal != null)
                    return oldVal;
                break;
            }
        }
    }
    
    // 更新计数
    addCount(1L, binCount);
    return null;
}
```

### 3.4 LinkedHashMap 实现 LRU

```java
/**
 * 使用 LinkedHashMap 实现 LRU 缓存
 */
public class LRUCache<K, V> extends LinkedHashMap<K, V> {
    
    private final int maxCapacity;
    
    public LRUCache(int maxCapacity) {
        // accessOrder = true 表示按访问顺序排序
        super(maxCapacity, 0.75f, true);
        this.maxCapacity = maxCapacity;
    }
    
    /**
     * 重写此方法，当返回 true 时删除最老的元素
     */
    @Override
    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
        return size() > maxCapacity;
    }
}

/**
 * LinkedHashMap afterNodeAccess 源码
 * 访问节点后，将其移到链表尾部
 */
void afterNodeAccess(Node<K,V> e) {
    LinkedHashMap.Entry<K,V> last;
    // accessOrder 为 true 且 e 不是尾节点
    if (accessOrder && (last = tail) != e) {
        LinkedHashMap.Entry<K,V> p = (LinkedHashMap.Entry<K,V>)e;
        LinkedHashMap.Entry<K,V> b = p.before;  // 前驱
        LinkedHashMap.Entry<K,V> a = p.after;   // 后继
        
        p.after = null;
        
        // 处理前驱
        if (b == null)
            head = a;
        else
            b.after = a;
        
        // 处理后继
        if (a != null)
            a.before = b;
        else
            last = b;
        
        // 将 p 移到尾部
        if (last == null)
            head = p;
        else {
            p.before = last;
            last.after = p;
        }
        tail = p;
        ++modCount;
    }
}
```

## 4. 实战应用

### 4.1 Android 中的 LruCache

```java
/**
 * Android LruCache 使用示例
 * 内部使用 LinkedHashMap 实现
 */
public class ImageCache {
    
    private LruCache<String, Bitmap> memoryCache;
    
    public ImageCache() {
        // 获取应用可用最大内存的 1/8 作为缓存大小
        int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);
        int cacheSize = maxMemory / 8;
        
        memoryCache = new LruCache<String, Bitmap>(cacheSize) {
            @Override
            protected int sizeOf(String key, Bitmap bitmap) {
                // 返回图片大小，单位 KB
                return bitmap.getByteCount() / 1024;
            }
            
            @Override
            protected void entryRemoved(boolean evicted, String key,
                    Bitmap oldValue, Bitmap newValue) {
                // 可以在这里回收 Bitmap
                if (evicted && oldValue != null && !oldValue.isRecycled()) {
                    // oldValue.recycle(); // 谨慎使用
                }
            }
        };
    }
    
    public void put(String key, Bitmap bitmap) {
        if (key != null && bitmap != null) {
            memoryCache.put(key, bitmap);
        }
    }
    
    public Bitmap get(String key) {
        return memoryCache.get(key);
    }
}
```

### 4.2 选择合适的集合类

```java
/**
 * 集合类选择指南
 */
public class CollectionGuide {
    
    // 1. 需要快速随机访问 → ArrayList
    public void randomAccess() {
        List<String> list = new ArrayList<>();
        list.get(100);  // O(1)
    }
    
    // 2. 频繁在头部插入/删除 → LinkedList
    public void frequentInsertAtHead() {
        LinkedList<String> list = new LinkedList<>();
        list.addFirst("item");  // O(1)
    }
    
    // 3. 需要去重 → HashSet
    public void removeDuplicates() {
        Set<String> set = new HashSet<>();
        set.add("item");  // O(1)
    }
    
    // 4. 需要排序的去重集合 → TreeSet
    public void sortedSet() {
        Set<String> set = new TreeSet<>();
        // 自动排序
    }
    
    // 5. 键值对存储 → HashMap
    public void keyValueStore() {
        Map<String, Object> map = new HashMap<>();
        map.put("key", "value");  // O(1)
    }
    
    // 6. 需要保持插入顺序 → LinkedHashMap
    public void orderedMap() {
        Map<String, Object> map = new LinkedHashMap<>();
    }
    
    // 7. 线程安全的 Map → ConcurrentHashMap
    public void threadSafeMap() {
        Map<String, Object> map = new ConcurrentHashMap<>();
    }
    
    // 8. 读多写少的线程安全 List → CopyOnWriteArrayList
    public void readMostlyList() {
        List<String> list = new CopyOnWriteArrayList<>();
    }
}
```

### 4.3 常见坑点

1. **HashMap 的 key 必须正确实现 hashCode 和 equals**
2. **ConcurrentHashMap 不允许 null key 和 null value**
3. **ArrayList 扩容会复制数组，预估容量可以提高性能**
4. **遍历时修改集合会抛出 ConcurrentModificationException**
5. **LinkedList 随机访问性能差，不要用 for(int i) 遍历**

## 5. 常见面试题

### 问题1：HashMap 的实现原理？JDK 1.7 和 1.8 有什么区别？

**答案要点**：
- **数据结构**：
  - JDK 1.7：数组 + 链表
  - JDK 1.8：数组 + 链表 + 红黑树（链表长度 >= 8 且数组长度 >= 64）
- **插入方式**：
  - JDK 1.7：头插法（多线程可能形成环）
  - JDK 1.8：尾插法
- **扩容**：
  - JDK 1.7：重新计算 hash
  - JDK 1.8：hash & oldCap 判断位置
- **hash 计算**：JDK 1.8 简化了扰动函数

### 问题2：HashMap 为什么线程不安全？

**答案要点**：
- **JDK 1.7**：多线程扩容时，头插法可能形成环形链表，导致死循环
- **JDK 1.8**：
  - put 时可能覆盖其他线程的数据
  - size 计算不准确
  - 扩容时数据丢失

### 问题3：ConcurrentHashMap 如何保证线程安全？

**答案要点**：
- **JDK 1.7**：分段锁（Segment），每个 Segment 是一个小的 HashMap
- **JDK 1.8**：
  - 空桶：CAS 插入
  - 非空桶：synchronized 锁住头节点
  - 锁粒度更细，并发度更高

### 问题4：HashMap 的扩容机制？

**答案要点**：
- **触发条件**：size > capacity * loadFactor
- **扩容大小**：2 倍
- **JDK 1.8 优化**：
  - 不需要重新计算 hash
  - hash & oldCap == 0：位置不变
  - hash & oldCap != 0：新位置 = 原位置 + oldCap

### 问题5：ArrayList 和 LinkedList 的区别？

**答案要点**：
| 特性 | ArrayList | LinkedList |
|------|-----------|------------|
| 数据结构 | 动态数组 | 双向链表 |
| 随机访问 | O(1) | O(n) |
| 头部插入 | O(n) | O(1) |
| 尾部插入 | O(1)* | O(1) |
| 内存占用 | 较小 | 较大（额外指针） |
| 适用场景 | 随机访问多 | 频繁插入删除 |

### 问题6：如何实现 LRU 缓存？

**答案要点**：
1. **LinkedHashMap**：设置 accessOrder = true，重写 removeEldestEntry
2. **手动实现**：HashMap + 双向链表
3. **Android LruCache**：内部使用 LinkedHashMap

### 问题7：HashMap 的 key 可以是 null 吗？ConcurrentHashMap 呢？

**答案要点**：
- **HashMap**：key 和 value 都可以是 null
  - null key 的 hash 值为 0，存放在数组第一个位置
- **ConcurrentHashMap**：key 和 value 都不能是 null
  - 原因：无法区分是 key 不存在还是 value 为 null

### 问题8：为什么 HashMap 的容量必须是 2 的幂？

**答案要点**：
1. **计算下标效率高**：(n-1) & hash 等价于 hash % n，位运算更快
2. **扩容时位置计算简单**：hash & oldCap 判断位置是否变化
3. **减少哈希冲突**：2 的幂减 1 后所有位都是 1，hash 值分布更均匀
