# 类加载机制

## 1. 概述

Java 类加载机制是 JVM 将类的字节码文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型的过程。理解类加载机制对于掌握 Android 热修复、插件化等技术至关重要。

## 2. 核心原理

### 2.1 类的生命周期

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          类的生命周期                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌────────┐  ┌────────┐  ┌────────┐  ┌────────┐  ┌────────┐           │
│  │  加载   │→│  验证   │→│  准备   │→│  解析   │→│  初始化  │           │
│  │Loading │  │Verify  │  │Prepare │  │Resolve │  │ Init   │           │
│  └────────┘  └────────┘  └────────┘  └────────┘  └────────┘           │
│                    ↑                       ↑                            │
│                    └───────────────────────┘                            │
│                          连接 (Linking)                                 │
│                                                                         │
│  ┌────────┐  ┌────────┐                                                │
│  │  使用   │→│  卸载   │                                                │
│  │ Using  │  │Unload  │                                                │
│  └────────┘  └────────┘                                                │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.2 类加载过程详解

#### 2.2.1 加载 (Loading)

**主要工作**：
1. 通过类的全限定名获取定义此类的二进制字节流
2. 将字节流代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成代表这个类的 `java.lang.Class` 对象

```
┌─────────────────────────────────────────────────────────────┐
│                      加载阶段                                │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  字节码来源:                                                 │
│  ┌─────────────────────────────────────────────────────┐   │
│  │  - 本地文件系统 (.class 文件)                        │   │
│  │  - JAR/WAR/EAR 包                                   │   │
│  │  - 网络下载 (Applet)                                │   │
│  │  - 运行时动态生成 (动态代理、CGLib)                  │   │
│  │  - 其他文件生成 (JSP → Servlet)                     │   │
│  │  - 数据库读取                                       │   │
│  │  - 加密文件解密后加载                               │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  加载结果:                                                   │
│  ┌─────────────────────────────────────────────────────┐   │
│  │  方法区: 类的元数据 (类信息、字段、方法等)            │   │
│  │  堆:    java.lang.Class 对象 (类的访问入口)          │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

#### 2.2.2 验证 (Verification)

**目的**：确保 Class 文件的字节流符合 JVM 规范，不会危害虚拟机安全

```
┌─────────────────────────────────────────────────────────────┐
│                      验证阶段                                │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. 文件格式验证                                             │
│     ┌─────────────────────────────────────────────────┐    │
│     │  - 魔数是否为 0xCAFEBABE                         │    │
│     │  - 主次版本号是否在当前 JVM 支持范围内            │    │
│     │  - 常量池中的常量是否有不支持的类型               │    │
│     │  - 指向常量的索引是否指向不存在或不符合类型的常量  │    │
│     └─────────────────────────────────────────────────┘    │
│                                                             │
│  2. 元数据验证                                               │
│     ┌─────────────────────────────────────────────────┐    │
│     │  - 是否有父类 (除 Object 外都必须有)              │    │
│     │  - 父类是否继承了 final 类                       │    │
│     │  - 非抽象类是否实现了所有抽象方法                 │    │
│     │  - 字段、方法是否与父类矛盾                      │    │
│     └─────────────────────────────────────────────────┘    │
│                                                             │
│  3. 字节码验证                                               │
│     ┌─────────────────────────────────────────────────┐    │
│     │  - 操作数栈的数据类型与指令是否匹配               │    │
│     │  - 跳转指令是否跳转到合法位置                    │    │
│     │  - 类型转换是否有效                             │    │
│     └─────────────────────────────────────────────────┘    │
│                                                             │
│  4. 符号引用验证                                             │
│     ┌─────────────────────────────────────────────────┐    │
│     │  - 符号引用中的类、字段、方法是否存在             │    │
│     │  - 访问权限是否可被当前类访问                    │    │
│     └─────────────────────────────────────────────────┘    │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

#### 2.2.3 准备 (Preparation)

**主要工作**：为类的静态变量分配内存并设置初始值（零值）

```
┌─────────────────────────────────────────────────────────────┐
│                      准备阶段                                │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  数据类型默认初始值:                                         │
│  ┌─────────────────────────────────────────────────────┐   │
│  │  数据类型      │  默认值                             │   │
│  ├─────────────────────────────────────────────────────┤   │
│  │  byte         │  (byte) 0                          │   │
│  │  short        │  (short) 0                         │   │
│  │  int          │  0                                 │   │
│  │  long         │  0L                                │   │
│  │  float        │  0.0f                              │   │
│  │  double       │  0.0d                              │   │
│  │  char         │  '\u0000'                          │   │
│  │  boolean      │  false                             │   │
│  │  reference    │  null                              │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  示例:                                                       │
│  public static int value = 123;                             │
│  准备阶段: value = 0  (不是 123)                             │
│  初始化阶段: value = 123                                     │
│                                                             │
│  特例 (ConstantValue):                                       │
│  public static final int value = 123;                       │
│  准备阶段: value = 123 (编译时常量，直接赋值)                 │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

#### 2.2.4 解析 (Resolution)

**主要工作**：将常量池中的符号引用替换为直接引用

```
┌─────────────────────────────────────────────────────────────┐
│                      解析阶段                                │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  符号引用 vs 直接引用:                                       │
│  ┌─────────────────────────────────────────────────────┐   │
│  │  符号引用 (Symbolic Reference):                      │   │
│  │  - 以一组符号描述引用的目标                          │   │
│  │  - 与虚拟机内存布局无关                             │   │
│  │  - 例如: "java/lang/Object"                        │   │
│  │                                                     │   │
│  │  直接引用 (Direct Reference):                       │   │
│  │  - 直接指向目标的指针、相对偏移量或句柄              │   │
│  │  - 与虚拟机内存布局相关                             │   │
│  │  - 例如: 0x7f3a2b4c (内存地址)                     │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  解析内容:                                                   │
│  ┌─────────────────────────────────────────────────────┐   │
│  │  1. 类或接口的解析                                   │   │
│  │  2. 字段解析                                        │   │
│  │  3. 方法解析                                        │   │
│  │  4. 接口方法解析                                    │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

#### 2.2.5 初始化 (Initialization)

**主要工作**：执行类构造器 `<clinit>()` 方法

```
┌─────────────────────────────────────────────────────────────┐
│                      初始化阶段                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  <clinit>() 方法:                                           │
│  ┌─────────────────────────────────────────────────────┐   │
│  │  - 由编译器自动收集类中所有静态变量的赋值动作         │   │
│  │  - 和静态代码块 (static {}) 中的语句合并产生          │   │
│  │  - 顺序由源文件中出现的顺序决定                      │   │
│  │  - 父类的 <clinit>() 先于子类执行                   │   │
│  │  - JVM 保证多线程环境下的同步加锁                    │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  触发初始化的情况 (有且仅有):                                │
│  ┌─────────────────────────────────────────────────────┐   │
│  │  1. new、getstatic、putstatic、invokestatic 指令    │   │
│  │     - new 创建对象                                  │   │
│  │     - 读取/设置静态字段 (非 final)                  │   │
│  │     - 调用静态方法                                  │   │
│  │  2. 反射调用 (Class.forName())                      │   │
│  │  3. 初始化子类时，先初始化父类                       │   │
│  │  4. 虚拟机启动时，初始化主类 (main 方法所在类)       │   │
│  │  5. JDK 7+ 动态语言支持                             │   │
│  │  6. JDK 8+ 接口默认方法，实现类初始化时              │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 2.3 双亲委派模型

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        双亲委派模型                                      │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│                    ┌─────────────────────────┐                         │
│                    │  Bootstrap ClassLoader  │  ← 启动类加载器          │
│                    │  (C++ 实现，无父加载器)   │    加载 JAVA_HOME/lib   │
│                    └───────────┬─────────────┘                         │
│                                │ 父                                     │
│                                ↓                                        │
│                    ┌─────────────────────────┐                         │
│                    │  Extension ClassLoader  │  ← 扩展类加载器          │
│                    │  (ExtClassLoader)       │    加载 JAVA_HOME/lib/ext│
│                    └───────────┬─────────────┘                         │
│                                │ 父                                     │
│                                ↓                                        │
│                    ┌─────────────────────────┐                         │
│                    │ Application ClassLoader │  ← 应用类加载器          │
│                    │  (AppClassLoader)       │    加载 classpath        │
│                    └───────────┬─────────────┘                         │
│                                │ 父                                     │
│                                ↓                                        │
│                    ┌─────────────────────────┐                         │
│                    │  Custom ClassLoader     │  ← 自定义类加载器        │
│                    │  (用户自定义)            │                         │
│                    └─────────────────────────┘                         │
│                                                                         │
│  工作流程:                                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  1. 收到类加载请求                                               │   │
│  │  2. 先委派给父类加载器加载                                       │   │
│  │  3. 父类加载器无法加载时，才自己尝试加载                          │   │
│  │  4. 如果都无法加载，抛出 ClassNotFoundException                  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

**双亲委派的优点**：
1. **安全性**：防止核心类被篡改（如自定义 java.lang.String）
2. **避免重复加载**：父类加载过的类，子类不会重复加载
3. **保证类的唯一性**：同一个类只会被加载一次

### 2.4 打破双亲委派

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      打破双亲委派的场景                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  1. SPI 机制 (Service Provider Interface)                              │
│     ┌─────────────────────────────────────────────────────────────┐    │
│     │  问题: 核心类需要调用第三方实现 (如 JDBC)                     │    │
│     │  解决: 使用线程上下文类加载器 (Thread Context ClassLoader)   │    │
│     │                                                             │    │
│     │  Bootstrap ClassLoader 加载 java.sql.Driver 接口            │    │
│     │           ↓                                                 │    │
│     │  通过 Thread.currentThread().getContextClassLoader()        │    │
│     │           ↓                                                 │    │
│     │  Application ClassLoader 加载 com.mysql.jdbc.Driver 实现    │    │
│     └─────────────────────────────────────────────────────────────┘    │
│                                                                         │
│  2. OSGi 模块化                                                         │
│     ┌─────────────────────────────────────────────────────────────┐    │
│     │  - 每个模块 (Bundle) 有自己的类加载器                        │    │
│     │  - 类加载器之间是网状结构，不是树状                          │    │
│     │  - 可以实现模块热替换                                       │    │
│     └─────────────────────────────────────────────────────────────┘    │
│                                                                         │
│  3. 热修复/热部署                                                       │
│     ┌─────────────────────────────────────────────────────────────┐    │
│     │  - 自定义类加载器加载修复后的类                              │    │
│     │  - 绕过双亲委派，优先加载补丁类                              │    │
│     │  - Android 热修复框架: Tinker、Sophix、Robust               │    │
│     └─────────────────────────────────────────────────────────────┘    │
│                                                                         │
│  4. Tomcat 类加载                                                       │
│     ┌─────────────────────────────────────────────────────────────┐    │
│     │  - 每个 Web 应用有独立的类加载器                             │    │
│     │  - 实现应用隔离，不同应用可以使用不同版本的类库               │    │
│     └─────────────────────────────────────────────────────────────┘    │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.5 Android 类加载器

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      Android 类加载器体系                                │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│                    ┌─────────────────────────┐                         │
│                    │    BootClassLoader      │  ← 加载 Android SDK 核心类│
│                    │    (Java 实现)          │                         │
│                    └───────────┬─────────────┘                         │
│                                │                                        │
│              ┌─────────────────┼─────────────────┐                     │
│              ↓                 ↓                 ↓                      │
│  ┌───────────────────┐ ┌───────────────┐ ┌───────────────┐            │
│  │ PathClassLoader   │ │DexClassLoader │ │InMemoryDexCL  │            │
│  │ 加载已安装的 APK   │ │加载未安装的 DEX│ │加载内存中的DEX │            │
│  └───────────────────┘ └───────────────┘ └───────────────┘            │
│                                                                         │
│  继承关系:                                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  ClassLoader                                                    │   │
│  │      ↑                                                          │   │
│  │  BaseDexClassLoader                                             │   │
│  │      ↑                                                          │   │
│  │  ├── PathClassLoader (加载 /data/app/xxx.apk)                   │   │
│  │  ├── DexClassLoader  (加载任意路径的 dex/apk/jar/zip)           │   │
│  │  └── InMemoryDexClassLoader (Android 8.0+, 加载内存中的 dex)    │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

## 3. 关键源码解析

### 3.1 ClassLoader.loadClass() 源码

```java
/**
 * ClassLoader.loadClass() 源码 (JDK 8)
 * 双亲委派模型的核心实现
 */
public abstract class ClassLoader {
    
    // 父类加载器
    private final ClassLoader parent;
    
    /**
     * 加载类的入口方法
     * @param name 类的全限定名，如 "java.lang.String"
     * @param resolve 是否进行解析
     */
    protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException {
        
        synchronized (getClassLoadingLock(name)) {
            // 1. 首先检查该类是否已经被加载
            Class<?> c = findLoadedClass(name);
            
            if (c == null) {
                long t0 = System.nanoTime();
                try {
                    // 2. 如果有父类加载器，委派给父类加载器加载
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                        // 3. 如果没有父类加载器，委派给 Bootstrap ClassLoader
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // 父类加载器无法加载，不做处理
                }

                if (c == null) {
                    // 4. 父类加载器无法加载，自己尝试加载
                    long t1 = System.nanoTime();
                    c = findClass(name);  // 子类需要重写此方法
                    
                    // 记录统计信息
                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                    sun.misc.PerfCounter.getFindClasses().increment();
                }
            }
            
            // 5. 如果需要解析，进行解析
            if (resolve) {
                resolveClass(c);
            }
            return c;
        }
    }
    
    /**
     * 查找类的方法，子类需要重写
     * 这是打破双亲委派的关键点
     */
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        throw new ClassNotFoundException(name);
    }
    
    /**
     * 定义类，将字节数组转换为 Class 对象
     */
    protected final Class<?> defineClass(String name, byte[] b, int off, int len)
        throws ClassFormatError {
        return defineClass(name, b, off, len, null);
    }
}
```

### 3.2 Android BaseDexClassLoader 源码

```java
/**
 * BaseDexClassLoader 源码 (Android 8.0)
 * Android 类加载器的基类
 * 源码位置: libcore/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.java
 */
public class BaseDexClassLoader extends ClassLoader {
    
    // DexPathList 管理所有的 dex 文件
    private final DexPathList pathList;
    
    /**
     * 构造函数
     * @param dexPath dex 文件路径，多个用 File.pathSeparator 分隔
     * @param optimizedDirectory dex 优化后的输出目录 (Android 8.0 后废弃)
     * @param librarySearchPath native 库搜索路径
     * @param parent 父类加载器
     */
    public BaseDexClassLoader(String dexPath, File optimizedDirectory,
            String librarySearchPath, ClassLoader parent) {
        super(parent);
        // 创建 DexPathList，解析 dex 文件
        this.pathList = new DexPathList(this, dexPath, librarySearchPath, null);
    }
    
    /**
     * 查找类
     * 遍历 DexPathList 中的所有 DexFile 查找类
     */
    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        List<Throwable> suppressedExceptions = new ArrayList<Throwable>();
        
        // 从 DexPathList 中查找类
        Class c = pathList.findClass(name, suppressedExceptions);
        
        if (c == null) {
            ClassNotFoundException cnfe = new ClassNotFoundException(
                    "Didn't find class \"" + name + "\" on path: " + pathList);
            for (Throwable t : suppressedExceptions) {
                cnfe.addSuppressed(t);
            }
            throw cnfe;
        }
        return c;
    }
}

/**
 * DexPathList 源码
 * 管理 dex 文件列表
 */
final class DexPathList {
    
    // Element 数组，每个 Element 对应一个 dex 文件
    private Element[] dexElements;
    
    /**
     * 查找类
     * 按顺序遍历 dexElements，找到即返回
     * 这是热修复的关键：将补丁 dex 插入到数组前面
     */
    public Class<?> findClass(String name, List<Throwable> suppressed) {
        // 遍历所有 dex 文件
        for (Element element : dexElements) {
            // 从当前 dex 文件中查找类
            Class<?> clazz = element.findClass(name, definingContext, suppressed);
            if (clazz != null) {
                return clazz;  // 找到即返回，不再继续查找
            }
        }
        return null;
    }
    
    /**
     * Element 内部类
     * 封装单个 dex 文件
     */
    static class Element {
        private final DexFile dexFile;
        
        public Class<?> findClass(String name, ClassLoader definingContext,
                List<Throwable> suppressed) {
            // 从 DexFile 中加载类
            return dexFile != null 
                ? dexFile.loadClassBinaryName(name, definingContext, suppressed)
                : null;
        }
    }
}
```

### 3.3 热修复原理 - 插入补丁 dex

```java
/**
 * 热修复核心原理
 * 将补丁 dex 插入到 dexElements 数组的最前面
 */
public class HotFixUtil {
    
    /**
     * 加载补丁 dex
     * @param context 上下文
     * @param patchDexPath 补丁 dex 文件路径
     */
    public static void loadPatchDex(Context context, String patchDexPath) 
            throws Exception {
        
        // 1. 获取应用的 PathClassLoader
        PathClassLoader pathClassLoader = 
            (PathClassLoader) context.getClassLoader();
        
        // 2. 创建补丁的 DexClassLoader
        File optimizedDir = context.getDir("dex", Context.MODE_PRIVATE);
        DexClassLoader patchClassLoader = new DexClassLoader(
            patchDexPath,
            optimizedDir.getAbsolutePath(),
            null,
            pathClassLoader
        );
        
        // 3. 获取两个 ClassLoader 的 DexPathList
        Object pathPathList = getPathList(pathClassLoader);
        Object patchPathList = getPathList(patchClassLoader);
        
        // 4. 获取两个 DexPathList 的 dexElements
        Object pathDexElements = getDexElements(pathPathList);
        Object patchDexElements = getDexElements(patchPathList);
        
        // 5. 合并数组，补丁 dex 放在前面
        Object combinedDexElements = combineArray(patchDexElements, pathDexElements);
        
        // 6. 将合并后的数组设置回 PathClassLoader 的 DexPathList
        setDexElements(pathPathList, combinedDexElements);
    }
    
    /**
     * 通过反射获取 ClassLoader 的 pathList 字段
     */
    private static Object getPathList(ClassLoader classLoader) throws Exception {
        Field pathListField = BaseDexClassLoader.class.getDeclaredField("pathList");
        pathListField.setAccessible(true);
        return pathListField.get(classLoader);
    }
    
    /**
     * 通过反射获取 DexPathList 的 dexElements 字段
     */
    private static Object getDexElements(Object pathList) throws Exception {
        Field dexElementsField = pathList.getClass().getDeclaredField("dexElements");
        dexElementsField.setAccessible(true);
        return dexElementsField.get(pathList);
    }
    
    /**
     * 合并两个数组
     */
    private static Object combineArray(Object firstArray, Object secondArray) {
        Class<?> componentType = firstArray.getClass().getComponentType();
        int firstLength = Array.getLength(firstArray);
        int secondLength = Array.getLength(secondArray);
        
        // 创建新数组
        Object newArray = Array.newInstance(componentType, firstLength + secondLength);
        
        // 补丁 dex 放在前面
        System.arraycopy(firstArray, 0, newArray, 0, firstLength);
        System.arraycopy(secondArray, 0, newArray, firstLength, secondLength);
        
        return newArray;
    }
}
```

### 3.4 线程上下文类加载器

```java
/**
 * 线程上下文类加载器示例
 * 用于打破双亲委派，实现 SPI 机制
 */
public class ThreadContextClassLoaderDemo {
    
    public static void main(String[] args) {
        // 获取当前线程的上下文类加载器
        // 默认是 AppClassLoader
        ClassLoader contextClassLoader = 
            Thread.currentThread().getContextClassLoader();
        System.out.println("Context ClassLoader: " + contextClassLoader);
        
        // 设置自定义的上下文类加载器
        Thread.currentThread().setContextClassLoader(new CustomClassLoader());
        
        // SPI 机制使用示例 (JDBC)
        // ServiceLoader 内部使用线程上下文类加载器加载实现类
        ServiceLoader<Driver> drivers = ServiceLoader.load(Driver.class);
        for (Driver driver : drivers) {
            System.out.println("Driver: " + driver.getClass().getName());
        }
    }
}

/**
 * ServiceLoader.load() 源码
 * 使用线程上下文类加载器
 */
public final class ServiceLoader<S> implements Iterable<S> {
    
    public static <S> ServiceLoader<S> load(Class<S> service) {
        // 获取线程上下文类加载器
        ClassLoader cl = Thread.currentThread().getContextClassLoader();
        return ServiceLoader.load(service, cl);
    }
}
```

## 4. 实战应用

### 4.1 自定义类加载器

```java
/**
 * 自定义类加载器示例
 * 从指定目录加载加密的 class 文件
 */
public class EncryptedClassLoader extends ClassLoader {
    
    private String classDir;  // class 文件目录
    private byte[] key;       // 解密密钥
    
    public EncryptedClassLoader(String classDir, byte[] key, ClassLoader parent) {
        super(parent);
        this.classDir = classDir;
        this.key = key;
    }
    
    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        try {
            // 1. 构建 class 文件路径
            String fileName = name.replace('.', File.separatorChar) + ".class";
            File classFile = new File(classDir, fileName);
            
            // 2. 读取加密的 class 文件
            byte[] encryptedData = Files.readAllBytes(classFile.toPath());
            
            // 3. 解密
            byte[] classData = decrypt(encryptedData, key);
            
            // 4. 定义类
            return defineClass(name, classData, 0, classData.length);
            
        } catch (IOException e) {
            throw new ClassNotFoundException(name, e);
        }
    }
    
    private byte[] decrypt(byte[] data, byte[] key) {
        // 简单的异或解密示例
        byte[] result = new byte[data.length];
        for (int i = 0; i < data.length; i++) {
            result[i] = (byte) (data[i] ^ key[i % key.length]);
        }
        return result;
    }
}
```

### 4.2 Android 插件化类加载

```java
/**
 * Android 插件化类加载示例
 * 加载未安装的 APK 中的类
 */
public class PluginManager {
    
    private static Map<String, DexClassLoader> pluginClassLoaders = new HashMap<>();
    
    /**
     * 加载插件
     * @param context 上下文
     * @param pluginPath 插件 APK 路径
     * @param pluginId 插件标识
     */
    public static void loadPlugin(Context context, String pluginPath, String pluginId) {
        // 创建优化目录
        File optimizedDir = context.getDir("plugin_dex_" + pluginId, Context.MODE_PRIVATE);
        
        // 获取 native 库目录
        File libDir = context.getDir("plugin_lib_" + pluginId, Context.MODE_PRIVATE);
        
        // 创建 DexClassLoader
        DexClassLoader classLoader = new DexClassLoader(
            pluginPath,
            optimizedDir.getAbsolutePath(),
            libDir.getAbsolutePath(),
            context.getClassLoader()  // 父类加载器
        );
        
        pluginClassLoaders.put(pluginId, classLoader);
    }
    
    /**
     * 从插件中加载类
     */
    public static Class<?> loadClass(String pluginId, String className) 
            throws ClassNotFoundException {
        DexClassLoader classLoader = pluginClassLoaders.get(pluginId);
        if (classLoader == null) {
            throw new IllegalStateException("Plugin not loaded: " + pluginId);
        }
        return classLoader.loadClass(className);
    }
    
    /**
     * 创建插件中的对象
     */
    public static Object createInstance(String pluginId, String className) 
            throws Exception {
        Class<?> clazz = loadClass(pluginId, className);
        return clazz.newInstance();
    }
}
```

### 4.3 常见坑点

1. **类的唯一性**：同一个类被不同类加载器加载，会被认为是不同的类
2. **ClassNotFoundException vs NoClassDefFoundError**：
   - ClassNotFoundException：动态加载类时找不到
   - NoClassDefFoundError：编译时存在，运行时找不到
3. **热修复的 CLASS_ISPREVERIFIED 问题**：Android 在安装时会对类进行预校验，需要特殊处理
4. **Android N 混合编译**：Android 7.0 引入混合编译，影响热修复方案

## 5. 常见面试题

### 问题1：类加载的过程是什么？

**答案要点**：
- **加载**：读取字节码，生成 Class 对象
- **验证**：确保字节码符合 JVM 规范（文件格式、元数据、字节码、符号引用）
- **准备**：为静态变量分配内存，设置零值
- **解析**：将符号引用转换为直接引用
- **初始化**：执行 `<clinit>()` 方法，真正赋值静态变量

### 问题2：什么是双亲委派模型？为什么需要它？

**答案要点**：
- **定义**：类加载器收到加载请求时，先委派给父类加载器，父类无法加载时才自己加载
- **优点**：
  - 安全性：防止核心类被篡改
  - 避免重复加载：保证类的唯一性
- **类加载器层次**：Bootstrap → Extension → Application → Custom

### 问题3：如何打破双亲委派模型？

**答案要点**：
1. **重写 loadClass() 方法**：不先委派给父类
2. **线程上下文类加载器**：SPI 机制，如 JDBC
3. **OSGi 模块化**：网状类加载器结构
4. **热修复/热部署**：自定义类加载器优先加载补丁类

### 问题4：Android 中 PathClassLoader 和 DexClassLoader 的区别？

**答案要点**：
| 特性 | PathClassLoader | DexClassLoader |
|------|-----------------|----------------|
| 用途 | 加载已安装的 APK | 加载任意路径的 dex |
| 路径限制 | 只能加载 /data/app 下的 | 可以加载任意路径 |
| 使用场景 | 系统默认使用 | 插件化、热修复 |
| Android 8.0+ | 两者功能基本相同 | 两者功能基本相同 |

### 问题5：热修复的原理是什么？

**答案要点**：
1. **类加载方案**（Tinker、QZone）：
   - 将补丁 dex 插入到 dexElements 数组最前面
   - 利用类加载的顺序性，优先加载补丁类
   - 需要重启生效
2. **底层替换方案**（AndFix、Sophix）：
   - 直接修改 ArtMethod 结构
   - 即时生效，无需重启
3. **Instant Run 方案**（Robust）：
   - 编译时插桩，运行时替换
   - 即时生效

### 问题6：什么情况下会触发类的初始化？

**答案要点**：
1. new 创建对象
2. 访问类的静态字段（非 final）
3. 调用类的静态方法
4. 反射调用（Class.forName()）
5. 初始化子类时，先初始化父类
6. 虚拟机启动时，初始化 main 方法所在类

**不会触发初始化的情况**：
- 通过子类引用父类的静态字段
- 定义类数组
- 引用类的常量（final static，编译期常量）

### 问题7：ClassNotFoundException 和 NoClassDefFoundError 的区别？

**答案要点**：
| 特性 | ClassNotFoundException | NoClassDefFoundError |
|------|------------------------|---------------------|
| 类型 | Exception（受检异常） | Error |
| 触发时机 | 动态加载类时 | 编译时存在，运行时不存在 |
| 常见场景 | Class.forName()、ClassLoader.loadClass() | 依赖的类被删除、JAR 包缺失 |
| 处理方式 | 可以 catch 处理 | 通常无法恢复 |

### 问题8：如何实现类的热替换？

**答案要点**：
1. **创建新的类加载器**：每次热替换创建新的 ClassLoader
2. **加载新版本的类**：用新 ClassLoader 加载修改后的类
3. **替换引用**：将旧类的引用替换为新类的实例
4. **注意事项**：
   - 旧类加载器需要被 GC 回收
   - 静态变量会丢失
   - 需要处理类之间的依赖关系
