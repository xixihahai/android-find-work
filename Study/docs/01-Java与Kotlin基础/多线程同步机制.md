# 多线程同步机制

## 1. 概述

多线程同步是 Java 并发编程的核心内容，主要解决多线程环境下的数据一致性和线程安全问题。本文将深入讲解 synchronized、volatile、Lock 等同步机制的原理，以及 AQS 框架的实现。

## 2. 核心原理

### 2.1 Java 内存模型 (JMM)

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        Java 内存模型 (JMM)                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                         主内存 (Main Memory)                     │   │
│  │                    存放共享变量的真实值                           │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                    ↑↓ read/write    ↑↓ read/write                      │
│  ┌──────────────────────┐        ┌──────────────────────┐             │
│  │   线程1 工作内存       │        │   线程2 工作内存       │             │
│  │  ┌────────────────┐  │        │  ┌────────────────┐  │             │
│  │  │  变量副本       │  │        │  │  变量副本       │  │             │
│  │  └────────────────┘  │        │  └────────────────┘  │             │
│  │         ↑↓           │        │         ↑↓           │             │
│  │  ┌────────────────┐  │        │  ┌────────────────┐  │             │
│  │  │   执行引擎      │  │        │  │   执行引擎      │  │             │
│  │  └────────────────┘  │        │  └────────────────┘  │             │
│  └──────────────────────┘        └──────────────────────┘             │
│                                                                         │
│  JMM 定义的 8 种原子操作:                                               │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  lock    → 锁定主内存变量                                        │   │
│  │  unlock  → 解锁主内存变量                                        │   │
│  │  read    → 从主内存读取到工作内存                                 │   │
│  │  load    → 将 read 的值放入工作内存的变量副本                     │   │
│  │  use     → 将工作内存的值传递给执行引擎                           │   │
│  │  assign  → 将执行引擎的值赋给工作内存的变量                       │   │
│  │  store   → 将工作内存的值传送到主内存                             │   │
│  │  write   → 将 store 的值写入主内存的变量                          │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.2 synchronized 原理

#### 2.2.1 对象头结构

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        对象头 (Object Header)                            │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  32位 JVM Mark Word 结构:                                               │
│  ┌────────────────────────────────────────────────────────────────┐    │
│  │ 锁状态        │ 25bit          │ 4bit      │ 1bit   │ 2bit    │    │
│  │              │ hashcode       │ 分代年龄   │ 偏向锁  │ 锁标志位 │    │
│  ├────────────────────────────────────────────────────────────────┤    │
│  │ 无锁         │ hashcode (25)  │ age (4)   │   0    │   01    │    │
│  │ 偏向锁       │ threadId (23)  │ epoch (2) │ age(4) │ 1 │ 01  │    │
│  │ 轻量级锁     │ 指向栈中锁记录的指针 (30)              │   00    │    │
│  │ 重量级锁     │ 指向 Monitor 的指针 (30)               │   10    │    │
│  │ GC 标记      │                                       │   11    │    │
│  └────────────────────────────────────────────────────────────────┘    │
│                                                                         │
│  64位 JVM Mark Word 结构:                                               │
│  ┌────────────────────────────────────────────────────────────────┐    │
│  │ 锁状态   │ 56bit                    │ 1bit │ 4bit │ 1bit │ 2bit│    │
│  ├────────────────────────────────────────────────────────────────┤    │
│  │ 无锁    │ unused(25)│hashcode(31)  │ cms  │ age  │ 偏向 │ 01  │    │
│  │ 偏向锁  │ threadId(54)│epoch(2)    │ cms  │ age  │  1  │ 01  │    │
│  │ 轻量级锁│ 指向栈中锁记录的指针 (62)                    │ 00  │    │
│  │ 重量级锁│ 指向 Monitor 的指针 (62)                     │ 10  │    │
│  └────────────────────────────────────────────────────────────────┘    │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

#### 2.2.2 Monitor 机制

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        Monitor (管程/监视器)                             │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                      ObjectMonitor 结构                          │   │
│  │  ┌─────────────────────────────────────────────────────────┐    │   │
│  │  │  _owner        → 指向持有锁的线程                        │    │   │
│  │  │  _count        → 重入次数                                │    │   │
│  │  │  _EntryList    → 阻塞等待锁的线程队列                    │    │   │
│  │  │  _WaitSet      → 调用 wait() 后等待的线程队列            │    │   │
│  │  │  _recursions   → 锁的重入次数                            │    │   │
│  │  └─────────────────────────────────────────────────────────┘    │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  Monitor 工作流程:                                                      │
│                                                                         │
│       线程A                    Monitor                    线程B         │
│         │                        │                          │          │
│         │──── monitorenter ─────→│                          │          │
│         │     (获取锁成功)        │                          │          │
│         │                        │←── monitorenter ─────────│          │
│         │                        │    (获取锁失败，进入EntryList)       │
│         │                        │                          │          │
│         │──── wait() ───────────→│                          │          │
│         │     (释放锁，进入WaitSet)│                          │          │
│         │                        │──── 唤醒线程B ───────────→│          │
│         │                        │     (从EntryList获取锁)   │          │
│         │                        │                          │          │
│         │                        │←── notify() ─────────────│          │
│         │←── 从WaitSet移到EntryList                          │          │
│         │                        │                          │          │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

#### 2.2.3 锁升级过程

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          锁升级过程                                      │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐         │
│  │   无锁    │ →  │  偏向锁   │ →  │ 轻量级锁  │ →  │ 重量级锁  │         │
│  └──────────┘    └──────────┘    └──────────┘    └──────────┘         │
│       │              │               │               │                 │
│       ↓              ↓               ↓               ↓                 │
│  ┌──────────────────────────────────────────────────────────────┐     │
│  │ 无竞争        单线程访问       多线程交替访问    多线程同时竞争  │     │
│  │              (无竞争)         (轻度竞争)        (激烈竞争)      │     │
│  └──────────────────────────────────────────────────────────────┘     │
│                                                                         │
│  详细升级流程:                                                          │
│                                                                         │
│  1. 偏向锁                                                              │
│     ┌─────────────────────────────────────────────────────────────┐   │
│     │  - 第一个线程访问同步块时，在 Mark Word 中记录线程 ID         │   │
│     │  - 后续该线程再次进入，只需比较线程 ID，无需 CAS 操作         │   │
│     │  - 适用于只有一个线程访问同步块的场景                        │   │
│     │  - 当有其他线程尝试获取锁时，偏向锁撤销，升级为轻量级锁       │   │
│     └─────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  2. 轻量级锁                                                            │
│     ┌─────────────────────────────────────────────────────────────┐   │
│     │  - 在当前线程栈帧中创建锁记录 (Lock Record)                  │   │
│     │  - 使用 CAS 将 Mark Word 复制到锁记录，并将 Mark Word        │   │
│     │    更新为指向锁记录的指针                                    │   │
│     │  - 如果 CAS 失败，说明有竞争，进入自旋                       │   │
│     │  - 自旋超过一定次数，升级为重量级锁                          │   │
│     └─────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  3. 重量级锁                                                            │
│     ┌─────────────────────────────────────────────────────────────┐   │
│     │  - 使用操作系统的 Mutex Lock 实现                            │   │
│     │  - 线程阻塞，需要操作系统介入，上下文切换开销大               │   │
│     │  - Mark Word 指向 Monitor 对象                               │   │
│     └─────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.3 volatile 原理

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          volatile 原理                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  volatile 的两个特性:                                                   │
│                                                                         │
│  1. 可见性                                                              │
│     ┌─────────────────────────────────────────────────────────────┐   │
│     │  - 写 volatile 变量时，会将工作内存中的值刷新到主内存         │   │
│     │  - 读 volatile 变量时，会从主内存重新读取最新值               │   │
│     │  - 保证一个线程的修改对其他线程立即可见                       │   │
│     └─────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  2. 禁止指令重排序                                                      │
│     ┌─────────────────────────────────────────────────────────────┐   │
│     │  - 编译器和处理器不会对 volatile 变量的读写进行重排序         │   │
│     │  - 通过内存屏障 (Memory Barrier) 实现                        │   │
│     └─────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  内存屏障 (Memory Barrier):                                             │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  屏障类型        │  说明                                        │   │
│  ├─────────────────────────────────────────────────────────────────┤   │
│  │  LoadLoad       │  确保 Load1 数据装载先于 Load2                │   │
│  │  StoreStore     │  确保 Store1 数据刷新到主内存先于 Store2      │   │
│  │  LoadStore      │  确保 Load1 数据装载先于 Store2 刷新到主内存  │   │
│  │  StoreLoad      │  确保 Store1 刷新到主内存先于 Load2 装载      │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  volatile 写操作:                                                       │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  普通写                                                         │   │
│  │  StoreStore 屏障  ← 禁止上面的普通写与下面的 volatile 写重排序   │   │
│  │  volatile 写                                                    │   │
│  │  StoreLoad 屏障   ← 禁止上面的 volatile 写与下面的读写重排序     │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  volatile 读操作:                                                       │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  volatile 读                                                    │   │
│  │  LoadLoad 屏障    ← 禁止下面的普通读与上面的 volatile 读重排序   │   │
│  │  LoadStore 屏障   ← 禁止下面的普通写与上面的 volatile 读重排序   │   │
│  │  普通读写                                                       │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.4 Lock 与 ReentrantLock

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    Lock 接口与 ReentrantLock                             │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  Lock 接口方法:                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  void lock()              → 获取锁，阻塞直到获取成功             │   │
│  │  void lockInterruptibly() → 可中断地获取锁                      │   │
│  │  boolean tryLock()        → 尝试获取锁，立即返回                 │   │
│  │  boolean tryLock(time)    → 超时获取锁                          │   │
│  │  void unlock()            → 释放锁                              │   │
│  │  Condition newCondition() → 创建条件变量                        │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ReentrantLock vs synchronized:                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  特性              │ synchronized │ ReentrantLock              │   │
│  ├─────────────────────────────────────────────────────────────────┤   │
│  │  实现方式          │ JVM 内置      │ Java 代码实现              │   │
│  │  锁的获取/释放     │ 自动          │ 手动 lock()/unlock()       │   │
│  │  可中断            │ 不支持        │ lockInterruptibly()        │   │
│  │  超时获取          │ 不支持        │ tryLock(timeout)           │   │
│  │  公平锁            │ 不支持        │ 支持                       │   │
│  │  条件变量          │ 单个 (wait)   │ 多个 Condition             │   │
│  │  性能              │ JDK6 后优化   │ 相当                       │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  公平锁 vs 非公平锁:                                                    │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  公平锁:                                                        │   │
│  │  - 按照请求锁的顺序获取锁 (FIFO)                                │   │
│  │  - 不会产生饥饿                                                 │   │
│  │  - 吞吐量较低                                                   │   │
│  │                                                                 │   │
│  │  非公平锁 (默认):                                               │   │
│  │  - 允许插队，新来的线程可能直接获取锁                           │   │
│  │  - 可能产生饥饿                                                 │   │
│  │  - 吞吐量较高 (减少线程切换)                                    │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.5 AQS 原理

```
┌─────────────────────────────────────────────────────────────────────────┐
│              AQS (AbstractQueuedSynchronizer) 原理                       │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  AQS 核心结构:                                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │  state (int)  → 同步状态                                 │   │   │
│  │  │  - 0: 锁空闲                                            │   │   │
│  │  │  - 1: 锁被占用                                          │   │   │
│  │  │  - >1: 重入次数                                         │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │                                                                 │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │  CLH 队列 (双向链表)                                     │   │   │
│  │  │                                                         │   │   │
│  │  │  head → [Node] ←→ [Node] ←→ [Node] ←→ [Node] ← tail    │   │   │
│  │  │          ↑                                              │   │   │
│  │  │        哨兵节点                                          │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  Node 节点结构:                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  waitStatus  → 等待状态                                         │   │
│  │    - CANCELLED (1)  : 取消                                      │   │
│  │    - SIGNAL (-1)    : 后继节点需要被唤醒                        │   │
│  │    - CONDITION (-2) : 在条件队列中等待                          │   │
│  │    - PROPAGATE (-3) : 共享模式下传播                            │   │
│  │  prev        → 前驱节点                                         │   │
│  │  next        → 后继节点                                         │   │
│  │  thread      → 等待的线程                                       │   │
│  │  nextWaiter  → 条件队列中的下一个节点                           │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  获取锁流程 (非公平锁):                                                 │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  1. CAS 尝试将 state 从 0 改为 1                                │   │
│  │  2. 成功 → 获取锁，设置 exclusiveOwnerThread                    │   │
│  │  3. 失败 → 调用 acquire(1)                                      │   │
│  │     3.1 tryAcquire() 再次尝试获取                               │   │
│  │     3.2 失败 → addWaiter() 加入 CLH 队列                        │   │
│  │     3.3 acquireQueued() 自旋等待                                │   │
│  │         - 前驱是 head 时尝试获取锁                              │   │
│  │         - 否则 park 阻塞                                        │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  释放锁流程:                                                            │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  1. tryRelease() 将 state 减 1                                  │   │
│  │  2. state 为 0 时，清除 exclusiveOwnerThread                    │   │
│  │  3. unparkSuccessor() 唤醒后继节点                              │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.6 死锁

```
┌─────────────────────────────────────────────────────────────────────────┐
│                            死锁                                          │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  死锁的四个必要条件:                                                    │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  1. 互斥条件    → 资源只能被一个线程占用                        │   │
│  │  2. 请求与保持  → 持有资源的同时请求其他资源                    │   │
│  │  3. 不可剥夺    → 已获得的资源不能被强制剥夺                    │   │
│  │  4. 循环等待    → 形成等待环路                                  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  死锁示例:                                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                 │   │
│  │    线程A                              线程B                     │   │
│  │      │                                  │                       │   │
│  │      │── 获取锁A ──→                    │                       │   │
│  │      │                    ←── 获取锁B ──│                       │   │
│  │      │                                  │                       │   │
│  │      │── 请求锁B (阻塞) ──→             │                       │   │
│  │      │                    ←── 请求锁A (阻塞)                    │   │
│  │      │                                  │                       │   │
│  │      ↓         死锁！                   ↓                       │   │
│  │                                                                 │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  避免死锁的方法:                                                        │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  1. 固定加锁顺序    → 所有线程按相同顺序获取锁                  │   │
│  │  2. 超时获取锁      → tryLock(timeout)，超时放弃                │   │
│  │  3. 死锁检测        → 定期检测是否存在死锁                      │   │
│  │  4. 减少锁的粒度    → 使用更细粒度的锁                          │   │
│  │  5. 使用无锁数据结构 → CAS、原子类                              │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

## 3. 关键源码解析

### 3.1 synchronized 字节码

```java
/**
 * synchronized 同步块的字节码
 */
public class SynchronizedDemo {
    private Object lock = new Object();
    
    public void syncBlock() {
        synchronized (lock) {
            // 同步代码
        }
    }
}

// 对应的字节码:
// monitorenter     ← 进入同步块，获取 monitor
// ... 同步代码 ...
// monitorexit      ← 正常退出，释放 monitor
// monitorexit      ← 异常退出，释放 monitor (编译器自动生成)
```

### 3.2 ReentrantLock 源码分析

```java
/**
 * ReentrantLock 非公平锁获取锁源码 (JDK 8)
 */
public class ReentrantLock implements Lock {
    
    private final Sync sync;
    
    // 非公平锁实现
    static final class NonfairSync extends Sync {
        
        /**
         * 获取锁
         */
        final void lock() {
            // 1. 直接尝试 CAS 获取锁 (非公平的体现：不管队列中是否有等待线程)
            if (compareAndSetState(0, 1))
                // 获取成功，设置当前线程为锁的持有者
                setExclusiveOwnerThread(Thread.currentThread());
            else
                // 获取失败，进入 AQS 的获取流程
                acquire(1);
        }
        
        /**
         * 尝试获取锁
         */
        protected final boolean tryAcquire(int acquires) {
            return nonfairTryAcquire(acquires);
        }
    }
    
    // Sync 基类
    abstract static class Sync extends AbstractQueuedSynchronizer {
        
        /**
         * 非公平方式尝试获取锁
         */
        final boolean nonfairTryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
            
            // state 为 0，锁空闲
            if (c == 0) {
                // CAS 尝试获取锁
                if (compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            // 当前线程已持有锁，重入
            else if (current == getExclusiveOwnerThread()) {
                int nextc = c + acquires;
                if (nextc < 0) // overflow
                    throw new Error("Maximum lock count exceeded");
                setState(nextc);  // 不需要 CAS，因为当前线程已持有锁
                return true;
            }
            return false;
        }
        
        /**
         * 释放锁
         */
        protected final boolean tryRelease(int releases) {
            int c = getState() - releases;
            
            // 只有持有锁的线程才能释放
            if (Thread.currentThread() != getExclusiveOwnerThread())
                throw new IllegalMonitorStateException();
            
            boolean free = false;
            // state 为 0，完全释放锁
            if (c == 0) {
                free = true;
                setExclusiveOwnerThread(null);
            }
            setState(c);
            return free;
        }
    }
}
```

### 3.3 AQS acquire 流程源码

```java
/**
 * AQS 获取锁核心流程 (JDK 8)
 */
public abstract class AbstractQueuedSynchronizer {
    
    /**
     * 获取锁入口
     */
    public final void acquire(int arg) {
        // 1. tryAcquire 尝试获取锁 (子类实现)
        // 2. 获取失败，addWaiter 加入队列
        // 3. acquireQueued 自旋等待获取锁
        if (!tryAcquire(arg) &&
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            // 如果在等待过程中被中断，重新设置中断标志
            selfInterrupt();
    }
    
    /**
     * 将当前线程包装成 Node 加入队列尾部
     */
    private Node addWaiter(Node mode) {
        Node node = new Node(Thread.currentThread(), mode);
        
        // 快速尝试在尾部添加
        Node pred = tail;
        if (pred != null) {
            node.prev = pred;
            // CAS 设置尾节点
            if (compareAndSetTail(pred, node)) {
                pred.next = node;
                return node;
            }
        }
        // 快速添加失败，进入完整的入队流程
        enq(node);
        return node;
    }
    
    /**
     * 完整的入队流程 (自旋 + CAS)
     */
    private Node enq(final Node node) {
        for (;;) {
            Node t = tail;
            // 队列为空，初始化
            if (t == null) {
                // 创建哨兵节点作为 head
                if (compareAndSetHead(new Node()))
                    tail = head;
            } else {
                node.prev = t;
                // CAS 设置尾节点
                if (compareAndSetTail(t, node)) {
                    t.next = node;
                    return t;
                }
            }
        }
    }
    
    /**
     * 在队列中自旋等待获取锁
     */
    final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
            // 自旋
            for (;;) {
                // 获取前驱节点
                final Node p = node.predecessor();
                
                // 前驱是 head，说明轮到当前节点，尝试获取锁
                if (p == head && tryAcquire(arg)) {
                    // 获取成功，将当前节点设为 head
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return interrupted;
                }
                
                // 判断是否需要阻塞
                if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
    
    /**
     * 判断获取锁失败后是否需要阻塞
     */
    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
        int ws = pred.waitStatus;
        
        // 前驱状态为 SIGNAL，当前节点可以安全阻塞
        if (ws == Node.SIGNAL)
            return true;
        
        // 前驱被取消，跳过取消的节点
        if (ws > 0) {
            do {
                node.prev = pred = pred.prev;
            } while (pred.waitStatus > 0);
            pred.next = node;
        } else {
            // 将前驱状态设为 SIGNAL
            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
        }
        return false;
    }
    
    /**
     * 阻塞当前线程并检查中断
     */
    private final boolean parkAndCheckInterrupt() {
        LockSupport.park(this);  // 阻塞
        return Thread.interrupted();  // 返回并清除中断标志
    }
}
```

### 3.4 volatile 实现原理 (HotSpot)

```cpp
/**
 * volatile 写操作的汇编实现
 * 在 x86 架构下，volatile 写会生成 lock 前缀指令
 */

// Java 代码
volatile int value;
value = 1;

// 对应的汇编代码 (x86)
// mov    $0x1, 0x10(%rsi)     ; 将 1 写入内存
// lock addl $0x0, (%rsp)      ; lock 前缀指令，触发内存屏障

/**
 * lock 前缀指令的作用:
 * 1. 将当前处理器缓存行的数据写回主内存
 * 2. 使其他 CPU 缓存了该内存地址的数据无效 (MESI 协议)
 */
```

## 4. 实战应用

### 4.1 双重检查锁定单例

```java
/**
 * 双重检查锁定 (DCL) 单例模式
 * 必须使用 volatile 防止指令重排序
 */
public class Singleton {
    
    // volatile 防止指令重排序
    private static volatile Singleton instance;
    
    private Singleton() {}
    
    public static Singleton getInstance() {
        // 第一次检查，避免不必要的同步
        if (instance == null) {
            synchronized (Singleton.class) {
                // 第二次检查，防止重复创建
                if (instance == null) {
                    // 这里可能发生指令重排序:
                    // 1. 分配内存空间
                    // 2. 初始化对象
                    // 3. 将 instance 指向内存空间
                    // 如果 2 和 3 重排序，其他线程可能获取到未初始化的对象
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}

/**
 * 更推荐的单例实现：静态内部类
 * 利用类加载机制保证线程安全
 */
public class Singleton {
    
    private Singleton() {}
    
    // 静态内部类，只有在使用时才会加载
    private static class Holder {
        private static final Singleton INSTANCE = new Singleton();
    }
    
    public static Singleton getInstance() {
        return Holder.INSTANCE;
    }
}
```

### 4.2 生产者消费者模式

```java
/**
 * 使用 ReentrantLock + Condition 实现生产者消费者
 */
public class ProducerConsumer<T> {
    
    private final Queue<T> queue = new LinkedList<>();
    private final int capacity;
    
    private final Lock lock = new ReentrantLock();
    private final Condition notFull = lock.newCondition();   // 队列不满
    private final Condition notEmpty = lock.newCondition();  // 队列不空
    
    public ProducerConsumer(int capacity) {
        this.capacity = capacity;
    }
    
    /**
     * 生产者
     */
    public void produce(T item) throws InterruptedException {
        lock.lock();
        try {
            // 队列满，等待
            while (queue.size() == capacity) {
                notFull.await();
            }
            
            queue.offer(item);
            System.out.println("生产: " + item + ", 队列大小: " + queue.size());
            
            // 通知消费者
            notEmpty.signal();
            
        } finally {
            lock.unlock();
        }
    }
    
    /**
     * 消费者
     */
    public T consume() throws InterruptedException {
        lock.lock();
        try {
            // 队列空，等待
            while (queue.isEmpty()) {
                notEmpty.await();
            }
            
            T item = queue.poll();
            System.out.println("消费: " + item + ", 队列大小: " + queue.size());
            
            // 通知生产者
            notFull.signal();
            
            return item;
            
        } finally {
            lock.unlock();
        }
    }
}
```

### 4.3 读写锁应用

```java
/**
 * 使用 ReentrantReadWriteLock 实现缓存
 * 读多写少场景，提高并发性能
 */
public class CacheWithReadWriteLock<K, V> {
    
    private final Map<K, V> cache = new HashMap<>();
    private final ReadWriteLock rwLock = new ReentrantReadWriteLock();
    private final Lock readLock = rwLock.readLock();
    private final Lock writeLock = rwLock.writeLock();
    
    /**
     * 读取缓存 - 使用读锁
     * 多个线程可以同时读取
     */
    public V get(K key) {
        readLock.lock();
        try {
            return cache.get(key);
        } finally {
            readLock.unlock();
        }
    }
    
    /**
     * 写入缓存 - 使用写锁
     * 写入时独占，其他读写都阻塞
     */
    public void put(K key, V value) {
        writeLock.lock();
        try {
            cache.put(key, value);
        } finally {
            writeLock.unlock();
        }
    }
    
    /**
     * 读取，如果不存在则加载
     * 锁降级：写锁 → 读锁
     */
    public V getOrLoad(K key, Function<K, V> loader) {
        // 先尝试读取
        readLock.lock();
        try {
            V value = cache.get(key);
            if (value != null) {
                return value;
            }
        } finally {
            readLock.unlock();
        }
        
        // 不存在，获取写锁加载
        writeLock.lock();
        try {
            // 双重检查
            V value = cache.get(key);
            if (value == null) {
                value = loader.apply(key);
                cache.put(key, value);
            }
            
            // 锁降级：在释放写锁前获取读锁
            readLock.lock();
            return value;
            
        } finally {
            writeLock.unlock();
            readLock.unlock();  // 最后释放读锁
        }
    }
}
```

### 4.4 Android 中的同步实践

```java
/**
 * Android 中常见的同步场景
 */
public class AndroidSyncDemo {
    
    // 1. 使用 volatile 保证可见性
    private volatile boolean isRunning = true;
    
    public void stopTask() {
        isRunning = false;  // 其他线程立即可见
    }
    
    // 2. 使用 synchronized 保护共享数据
    private final List<String> dataList = new ArrayList<>();
    
    public void addData(String data) {
        synchronized (dataList) {
            dataList.add(data);
        }
    }
    
    // 3. 使用 AtomicInteger 实现无锁计数
    private final AtomicInteger counter = new AtomicInteger(0);
    
    public int incrementAndGet() {
        return counter.incrementAndGet();
    }
    
    // 4. 使用 CopyOnWriteArrayList 实现线程安全的列表
    // 适合读多写少的场景
    private final CopyOnWriteArrayList<Observer> observers = new CopyOnWriteArrayList<>();
    
    public void addObserver(Observer observer) {
        observers.add(observer);
    }
    
    public void notifyObservers() {
        // 遍历时不需要加锁
        for (Observer observer : observers) {
            observer.onUpdate();
        }
    }
}
```

### 4.5 常见坑点

1. **synchronized 锁的是对象，不是代码**：同一个对象的 synchronized 方法互斥
2. **volatile 不保证原子性**：i++ 不是原子操作，volatile 无法保证线程安全
3. **Lock 必须在 finally 中释放**：防止异常导致锁无法释放
4. **避免在锁中调用外部方法**：可能导致死锁
5. **注意锁的粒度**：锁粒度太大影响性能，太小可能无法保证安全

## 5. 常见面试题

### 问题1：synchronized 的实现原理？

**答案要点**：
- **对象头 Mark Word**：存储锁状态、线程 ID 等信息
- **Monitor**：每个对象关联一个 Monitor，包含 EntryList、WaitSet、Owner
- **字节码**：monitorenter 获取锁，monitorexit 释放锁
- **锁升级**：无锁 → 偏向锁 → 轻量级锁 → 重量级锁

### 问题2：synchronized 和 ReentrantLock 的区别？

**答案要点**：
| 特性 | synchronized | ReentrantLock |
|------|--------------|---------------|
| 实现 | JVM 内置 | Java API |
| 释放锁 | 自动 | 手动 unlock() |
| 可中断 | 不支持 | lockInterruptibly() |
| 超时 | 不支持 | tryLock(timeout) |
| 公平锁 | 不支持 | 支持 |
| 条件变量 | 单个 | 多个 Condition |

### 问题3：volatile 的作用和原理？

**答案要点**：
- **可见性**：写操作立即刷新到主内存，读操作从主内存读取
- **禁止重排序**：通过内存屏障实现
- **不保证原子性**：复合操作（如 i++）不是原子的
- **实现原理**：lock 前缀指令，触发缓存一致性协议（MESI）

### 问题4：什么是 AQS？

**答案要点**：
- **定义**：AbstractQueuedSynchronizer，并发包的基础框架
- **核心**：state 状态变量 + CLH 队列
- **模式**：独占模式（ReentrantLock）、共享模式（Semaphore、CountDownLatch）
- **实现**：子类重写 tryAcquire/tryRelease 方法

### 问题5：什么是死锁？如何避免？

**答案要点**：
- **四个必要条件**：互斥、请求与保持、不可剥夺、循环等待
- **避免方法**：
  - 固定加锁顺序
  - 超时获取锁 tryLock(timeout)
  - 死锁检测
  - 减少锁粒度
  - 使用无锁数据结构

### 问题6：偏向锁、轻量级锁、重量级锁的区别？

**答案要点**：
| 锁类型 | 适用场景 | 实现方式 | 性能 |
|--------|----------|----------|------|
| 偏向锁 | 单线程访问 | Mark Word 记录线程 ID | 最高 |
| 轻量级锁 | 多线程交替访问 | CAS + 自旋 | 较高 |
| 重量级锁 | 多线程竞争 | Monitor + 阻塞 | 较低 |

### 问题7：CAS 的原理和问题？

**答案要点**：
- **原理**：Compare And Swap，比较并交换，CPU 原子指令
- **三个操作数**：内存地址 V、期望值 A、新值 B
- **问题**：
  - ABA 问题：使用版本号解决（AtomicStampedReference）
  - 自旋开销：竞争激烈时 CPU 消耗大
  - 只能保证单个变量原子性

### 问题8：ThreadLocal 的原理？会导致内存泄漏吗？

**答案要点**：
- **原理**：每个线程有自己的 ThreadLocalMap，key 是 ThreadLocal 对象（弱引用），value 是存储的值
- **内存泄漏**：
  - ThreadLocal 被回收后，key 变为 null，但 value 还在
  - 如果线程长期存活（如线程池），value 无法被回收
- **解决**：使用完后调用 remove() 方法
