# 系统启动流程

## 1. 概述

Android 系统启动是一个复杂的过程，从按下电源键到显示 Launcher 界面，涉及多个关键进程的启动和初始化。

### 启动流程概览

```
┌─────────────────────────────────────────────────────────────┐
│                    Android 系统启动流程                       │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   ┌──────────┐                                              │
│   │ BootROM  │  加载 Bootloader                             │
│   └────┬─────┘                                              │
│        ▼                                                    │
│   ┌──────────┐                                              │
│   │Bootloader│  加载 Linux Kernel                           │
│   └────┬─────┘                                              │
│        ▼                                                    │
│   ┌──────────┐                                              │
│   │  Kernel  │  启动 init 进程 (PID=1)                       │
│   └────┬─────┘                                              │
│        ▼                                                    │
│   ┌──────────┐                                              │
│   │   init   │  解析 init.rc，启动 Zygote                    │
│   └────┬─────┘                                              │
│        ▼                                                    │
│   ┌──────────┐                                              │
│   │  Zygote  │  预加载资源，启动 SystemServer                 │
│   └────┬─────┘                                              │
│        ▼                                                    │
│   ┌──────────────┐                                          │
│   │ SystemServer │  启动各种系统服务 (AMS, WMS, PMS...)       │
│   └──────┬───────┘                                          │
│          ▼                                                  │
│   ┌──────────┐                                              │
│   │ Launcher │  显示桌面                                     │
│   └──────────┘                                              │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 2. 核心原理

### 2.1 init 进程

init 是 Android 系统的第一个用户空间进程（PID=1），负责：
- 创建文件系统目录
- 挂载分区
- 设置 SELinux
- 解析并执行 init.rc 脚本
- 启动关键守护进程

```cpp
// system/core/init/main.cpp
int main(int argc, char** argv) {
    // 第一阶段：挂载文件系统
    if (argc == 1 || strcmp(argv[1], "selinux_setup") == 0) {
        return SetupSelinux(argv);
    }
    
    // 第二阶段：初始化属性服务
    if (strcmp(argv[1], "second_stage") == 0) {
        return SecondStageMain(argc, argv);
    }
    
    return FirstStageMain(argc, argv);
}

// 第二阶段主函数
int SecondStageMain(int argc, char** argv) {
    // 初始化属性服务
    PropertyInit();
    
    // 启动属性服务
    StartPropertyService(&property_fd);
    
    // 解析 init.rc
    LoadBootScripts(am, sm);
    
    // 进入事件循环
    while (true) {
        // 处理子进程退出
        // 处理属性变化
        // 执行 Action
    }
}
```

### 2.2 Zygote 进程

Zygote 是 Android 应用进程的孵化器，所有应用进程都是由 Zygote fork 出来的。

#### Zygote 启动流程

```cpp
// frameworks/base/cmds/app_process/app_main.cpp
int main(int argc, char* const argv[]) {
    AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv));
    
    // 解析参数
    bool zygote = false;
    bool startSystemServer = false;
    
    while (i < argc) {
        const char* arg = argv[i++];
        if (strcmp(arg, "--zygote") == 0) {
            zygote = true;
        } else if (strcmp(arg, "--start-system-server") == 0) {
            startSystemServer = true;
        }
    }
    
    if (zygote) {
        // 启动 Zygote
        runtime.start("com.android.internal.os.ZygoteInit", args, zygote);
    }
}
```

#### ZygoteInit.java

```java
// frameworks/base/core/java/com/android/internal/os/ZygoteInit.java
public class ZygoteInit {
    
    public static void main(String[] argv) {
        ZygoteServer zygoteServer = null;
        
        try {
            // 1. 预加载资源
            preload(bootTimingsTraceLog);
            
            // 2. 创建 ZygoteServer
            zygoteServer = new ZygoteServer(isPrimaryZygote);
            
            // 3. 启动 SystemServer
            if (startSystemServer) {
                Runnable r = forkSystemServer(abiList, zygoteSocketName, zygoteServer);
                if (r != null) {
                    r.run();
                    return;
                }
            }
            
            // 4. 进入循环，等待 fork 请求
            caller = zygoteServer.runSelectLoop(abiList);
        } finally {
            if (zygoteServer != null) {
                zygoteServer.closeServerSocket();
            }
        }
        
        if (caller != null) {
            caller.run();
        }
    }
    
    // 预加载资源
    static void preload(TimingsTraceLog bootTimingsTraceLog) {
        // 预加载类
        preloadClasses();
        
        // 预加载资源
        preloadResources();
        
        // 预加载 OpenGL
        preloadOpenGL();
        
        // 预加载共享库
        preloadSharedLibraries();
        
        // 预加载文本资源
        preloadTextResources();
    }
    
    // fork SystemServer
    private static Runnable forkSystemServer(String abiList, String socketName,
            ZygoteServer zygoteServer) {
        // SystemServer 参数
        String[] args = {
            "--setuid=1000",
            "--setgid=1000",
            "--setgroups=1001,1002,1003,...",
            "--capabilities=" + capabilities + "," + capabilities,
            "--nice-name=system_server",
            "--runtime-args",
            "--target-sdk-version=" + VMRuntime.SDK_VERSION_CUR_DEVELOPMENT,
            "com.android.server.SystemServer",
        };
        
        ZygoteArguments parsedArgs = new ZygoteArguments(args);
        
        // fork 子进程
        int pid = Zygote.forkSystemServer(
                parsedArgs.mUid, parsedArgs.mGid,
                parsedArgs.mGids,
                parsedArgs.mRuntimeFlags,
                null,
                parsedArgs.mPermittedCapabilities,
                parsedArgs.mEffectiveCapabilities);
        
        if (pid == 0) {
            // 子进程（SystemServer）
            zygoteServer.closeServerSocket();
            return handleSystemServerProcess(parsedArgs);
        }
        
        return null;
    }
}
```

### 2.3 SystemServer 进程

SystemServer 是 Android 系统服务的宿主进程，负责启动和管理各种系统服务。

```java
// frameworks/base/services/java/com/android/server/SystemServer.java
public final class SystemServer {
    
    public static void main(String[] args) {
        new SystemServer().run();
    }
    
    private void run() {
        try {
            // 1. 设置系统属性
            SystemProperties.set("persist.sys.dalvik.vm.lib.2", 
                    VMRuntime.getRuntime().vmLibrary());
            
            // 2. 创建主线程 Looper
            Looper.prepareMainLooper();
            
            // 3. 加载 native 库
            System.loadLibrary("android_servers");
            
            // 4. 创建 SystemServiceManager
            mSystemServiceManager = new SystemServiceManager(mSystemContext);
            
            // 5. 启动各种服务
            startBootstrapServices();  // 引导服务
            startCoreServices();       // 核心服务
            startOtherServices();      // 其他服务
            
        } finally {
            // 6. 进入消息循环
            Looper.loop();
        }
    }
    
    // 启动引导服务
    private void startBootstrapServices() {
        // Installer
        Installer installer = mSystemServiceManager.startService(Installer.class);
        
        // ActivityTaskManagerService
        ActivityTaskManagerService atm = mSystemServiceManager.startService(
                ActivityTaskManagerService.Lifecycle.class).getService();
        
        // ActivityManagerService
        mActivityManagerService = ActivityManagerService.Lifecycle.startService(
                mSystemServiceManager, atm);
        
        // PowerManagerService
        mPowerManagerService = mSystemServiceManager.startService(
                PowerManagerService.class);
        
        // PackageManagerService
        mPackageManagerService = PackageManagerService.main(mSystemContext,
                installer, domainVerificationService,
                mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF);
        
        // ...
    }
    
    // 启动核心服务
    private void startCoreServices() {
        // BatteryService
        mSystemServiceManager.startService(BatteryService.class);
        
        // UsageStatsService
        mSystemServiceManager.startService(UsageStatsService.class);
        
        // WebViewUpdateService
        mWebViewUpdateService = mSystemServiceManager.startService(
                WebViewUpdateService.class);
    }
    
    // 启动其他服务
    private void startOtherServices() {
        // WindowManagerService
        wm = WindowManagerService.main(context, inputManager, ...);
        ServiceManager.addService(Context.WINDOW_SERVICE, wm);
        
        // InputManagerService
        inputManager = new InputManagerService(context);
        ServiceManager.addService(Context.INPUT_SERVICE, inputManager);
        
        // AlarmManagerService
        mSystemServiceManager.startService(AlarmManagerService.class);
        
        // ...
        
        // 系统准备就绪
        mActivityManagerService.systemReady(() -> {
            // 启动 SystemUI
            startSystemUi(context, windowManagerF);
            
            // 启动 Launcher
            // ...
        });
    }
}
```

### 2.4 App 进程启动

当用户点击应用图标时，AMS 会请求 Zygote fork 一个新进程。

```java
// frameworks/base/core/java/android/app/ActivityThread.java
public static void main(String[] args) {
    // 1. 准备主线程 Looper
    Looper.prepareMainLooper();
    
    // 2. 创建 ActivityThread
    ActivityThread thread = new ActivityThread();
    
    // 3. attach 到 AMS
    thread.attach(false, startSeq);
    
    // 4. 获取主线程 Handler
    if (sMainThreadHandler == null) {
        sMainThreadHandler = thread.getHandler();
    }
    
    // 5. 进入消息循环
    Looper.loop();
    
    throw new RuntimeException("Main thread loop unexpectedly exited");
}

private void attach(boolean system, long startSeq) {
    sCurrentActivityThread = this;
    mSystemThread = system;
    
    if (!system) {
        // 应用进程
        final IActivityManager mgr = ActivityManager.getService();
        try {
            // 通知 AMS 进程已启动
            mgr.attachApplication(mAppThread, startSeq);
        } catch (RemoteException ex) {
            throw ex.rethrowFromSystemServer();
        }
    }
}
```

#### Application 创建流程

```java
// ActivityThread.java
private void handleBindApplication(AppBindData data) {
    // 1. 创建 LoadedApk
    data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);
    
    // 2. 创建 ContextImpl
    final ContextImpl appContext = ContextImpl.createAppContext(this, data.info);
    
    // 3. 创建 Instrumentation
    mInstrumentation = new Instrumentation();
    mInstrumentation.basicInit(this);
    
    // 4. 创建 Application
    Application app = data.info.makeApplication(data.restrictedBackupMode, null);
    mInitialApplication = app;
    
    // 5. 安装 ContentProvider
    if (!data.restrictedBackupMode) {
        if (!ArrayUtils.isEmpty(data.providers)) {
            installContentProviders(app, data.providers);
        }
    }
    
    // 6. 调用 Application.onCreate()
    mInstrumentation.callApplicationOnCreate(app);
}
```

## 3. 关键源码解析

### 3.1 Zygote fork 流程

```java
// Zygote.java
static int forkAndSpecialize(int uid, int gid, int[] gids, int runtimeFlags,
        int[][] rlimits, int mountExternal, String seInfo, String niceName,
        int[] fdsToClose, int[] fdsToIgnore, boolean startChildZygote,
        String instructionSet, String appDataDir, boolean isTopApp,
        String[] pkgDataInfoList, String[] allowlistedDataInfoList,
        boolean bindMountAppDataDirs, boolean bindMountAppStorageDirs) {
    
    // 预 fork 处理
    ZygoteHooks.preFork();
    
    // Native fork
    int pid = nativeForkAndSpecialize(uid, gid, gids, runtimeFlags, rlimits,
            mountExternal, seInfo, niceName, fdsToClose, fdsToIgnore,
            startChildZygote, instructionSet, appDataDir, isTopApp,
            pkgDataInfoList, allowlistedDataInfoList,
            bindMountAppDataDirs, bindMountAppStorageDirs);
    
    // 后 fork 处理
    if (pid == 0) {
        // 子进程
        ZygoteHooks.postForkChild(runtimeFlags, isSystemServer, isChildZygote,
                instructionSet);
    } else {
        // 父进程
        ZygoteHooks.postForkCommon();
    }
    
    return pid;
}
```

### 3.2 系统服务注册

```java
// ServiceManager.java
public static void addService(String name, IBinder service) {
    addService(name, service, false, IServiceManager.DUMP_FLAG_PRIORITY_DEFAULT);
}

public static void addService(String name, IBinder service, boolean allowIsolated,
        int dumpPriority) {
    try {
        getIServiceManager().addService(name, service, allowIsolated, dumpPriority);
    } catch (RemoteException e) {
        Log.e(TAG, "error in addService", e);
    }
}

// 获取服务
public static IBinder getService(String name) {
    try {
        IBinder service = sCache.get(name);
        if (service != null) {
            return service;
        } else {
            return Binder.allowBlocking(rawGetService(name));
        }
    } catch (RemoteException e) {
        Log.e(TAG, "error in getService", e);
    }
    return null;
}
```

## 4. 实战应用

### 4.1 启动优化相关

```kotlin
// 利用系统启动流程进行优化

// 1. ContentProvider 会在 Application.onCreate 之前执行
// 可以利用这一点进行早期初始化
class EarlyInitProvider : ContentProvider() {
    override fun onCreate(): Boolean {
        // 在 Application.onCreate 之前执行
        EarlyInit.init(context!!)
        return true
    }
    // ...
}

// 2. 利用 IdleHandler 延迟初始化
class MyApplication : Application() {
    override fun onCreate() {
        super.onCreate()
        
        // 主线程空闲时执行
        Looper.myQueue().addIdleHandler {
            // 延迟初始化
            initNonCriticalComponents()
            false
        }
    }
}
```

## 5. 常见面试题

### 问题1：Android 系统启动流程是怎样的？

**答案要点**：
1. **BootROM**：加载 Bootloader
2. **Bootloader**：加载 Linux Kernel
3. **Kernel**：启动 init 进程（PID=1）
4. **init**：解析 init.rc，启动 Zygote
5. **Zygote**：预加载资源，启动 SystemServer
6. **SystemServer**：启动系统服务（AMS、WMS、PMS 等）
7. **Launcher**：显示桌面

### 问题2：Zygote 的作用是什么？为什么需要 Zygote？

**答案要点**：
- **作用**：所有应用进程的孵化器，通过 fork 创建应用进程
- **为什么需要**：
  1. 预加载公共资源（类、资源、OpenGL），fork 后子进程共享
  2. 加快应用启动速度
  3. 节省内存（Copy-On-Write）

### 问题3：SystemServer 启动了哪些重要服务？

**答案要点**：
- **引导服务**：AMS、PMS、PowerManagerService
- **核心服务**：BatteryService、UsageStatsService
- **其他服务**：WMS、InputManagerService、AlarmManagerService、NetworkManagementService 等

### 问题4：App 进程是如何启动的？

**答案要点**：
1. AMS 通过 Socket 请求 Zygote fork 新进程
2. Zygote fork 子进程
3. 子进程执行 ActivityThread.main()
4. 创建主线程 Looper
5. attach 到 AMS
6. 创建 Application
7. 安装 ContentProvider
8. 调用 Application.onCreate()

### 问题5：为什么 ContentProvider 在 Application.onCreate() 之前执行？

**答案要点**：
- 在 handleBindApplication() 中，installContentProviders() 在 callApplicationOnCreate() 之前调用
- 设计原因：ContentProvider 可能被其他组件依赖，需要先初始化
- 影响：ContentProvider 的 onCreate() 会影响启动速度
